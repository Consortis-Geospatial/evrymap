/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ol/AssertionError.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/AssertionError.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError = (function (Error) {
  function AssertionError(code) {
    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__["VERSION"].split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path +
    '/doc/errors/#' + code + ' for details.';

    Error.call(this, message);

    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */
    this.code = code;

    /**
     * @type {string}
     */
    this.name = 'AssertionError';

    // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
    this.message = message;
  }

  if ( Error ) AssertionError.__proto__ = Error;
  AssertionError.prototype = Object.create( Error && Error.prototype );
  AssertionError.prototype.constructor = AssertionError;

  return AssertionError;
}(Error));

/* harmony default export */ __webpack_exports__["default"] = (AssertionError);

//# sourceMappingURL=AssertionError.js.map

/***/ }),

/***/ "./node_modules/ol/Collection.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Collection.js ***!
  \***************************************/
/*! exports provided: CollectionEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollectionEvent", function() { return CollectionEvent; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/Collection
 */






/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */
var CollectionEvent = (function (Event) {
  function CollectionEvent(type, opt_element) {
    Event.call(this, type);

    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */
    this.element = opt_element;

  }

  if ( Event ) CollectionEvent.__proto__ = Event;
  CollectionEvent.prototype = Object.create( Event && Event.prototype );
  CollectionEvent.prototype.constructor = CollectionEvent;

  return CollectionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @template T
 * @api
 */
var Collection = (function (BaseObject) {
  function Collection(opt_array, opt_options) {
    var this$1 = this;


    BaseObject.call(this);

    var options = opt_options || {};

    /**
     * @private
     * @type {boolean}
     */
    this.unique_ = !!options.unique;

    /**
     * @private
     * @type {!Array.<T>}
     */
    this.array_ = opt_array ? opt_array : [];

    if (this.unique_) {
      for (var i = 0, ii = this.array_.length; i < ii; ++i) {
        this$1.assertUnique_(this$1.array_[i], i);
      }
    }

    this.updateLength_();

  }

  if ( BaseObject ) Collection.__proto__ = BaseObject;
  Collection.prototype = Object.create( BaseObject && BaseObject.prototype );
  Collection.prototype.constructor = Collection;

  /**
   * Remove all elements from the collection.
   * @api
   */
  Collection.prototype.clear = function clear () {
    var this$1 = this;

    while (this.getLength() > 0) {
      this$1.pop();
    }
  };

  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array.<T>} arr Array.
   * @return {module:ol/Collection.<T>} This collection.
   * @api
   */
  Collection.prototype.extend = function extend (arr) {
    var this$1 = this;

    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this$1.push(arr[i]);
    }
    return this;
  };

  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array.<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  Collection.prototype.forEach = function forEach (f) {
    var array = this.array_;
    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };

  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array.<T>} Array.
   * @api
   */
  Collection.prototype.getArray = function getArray () {
    return this.array_;
  };

  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  Collection.prototype.item = function item (index) {
    return this.array_[index];
  };

  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  Collection.prototype.getLength = function getLength () {
    return /** @type {number} */ (this.get(Property.LENGTH));
  };

  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.insertAt = function insertAt (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
  };

  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  Collection.prototype.pop = function pop () {
    return this.removeAt(this.getLength() - 1);
  };

  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  Collection.prototype.push = function push (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };

  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  Collection.prototype.remove = function remove (elem) {
    var this$1 = this;

    var arr = this.array_;
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this$1.removeAt(i);
      }
    }
    return undefined;
  };

  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  Collection.prototype.removeAt = function removeAt (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
    return prev;
  };

  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  Collection.prototype.setAt = function setAt (index, elem) {
    var this$1 = this;

    var n = this.getLength();
    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE, prev));
      this.dispatchEvent(
        new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD, elem));
    } else {
      for (var j = n; j < index; ++j) {
        this$1.insertAt(j, undefined);
      }
      this.insertAt(index, elem);
    }
  };

  /**
   * @private
   */
  Collection.prototype.updateLength_ = function updateLength_ () {
    this.set(Property.LENGTH, this.array_.length);
  };

  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */
  Collection.prototype.assertUnique_ = function assertUnique_ (elem, opt_except) {
    var this$1 = this;

    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this$1.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](58);
      }
    }
  };

  return Collection;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Collection);

//# sourceMappingURL=Collection.js.map

/***/ }),

/***/ "./node_modules/ol/CollectionEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/CollectionEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection~CollectionEvent#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection~CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
});

//# sourceMappingURL=CollectionEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/**
 * @module ol/Disposable
 */


/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable = function Disposable () {};

Disposable.prototype.dispose = function dispose () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
Disposable.prototype.disposed_ = false;

/**
 * Extension point for disposable objects.
 * @protected
 */
Disposable.prototype.disposeInternal = _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];
/* harmony default export */ __webpack_exports__["default"] = (Disposable);

//# sourceMappingURL=Disposable.js.map

/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/*! exports provided: createStyleFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStyleFunction", function() { return createStyleFunction; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _geom_Geometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geom/Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/Feature
 */







/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 */
var Feature = (function (BaseObject) {
  function Feature(opt_geometryOrProperties) {

    BaseObject.call(this);

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
     */
    this.style_ = null;

    /**
     * @private
     * @type {module:ol/style/Style~StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.geometryChangeKey_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);

    if (opt_geometryOrProperties !== undefined) {
      if (opt_geometryOrProperties instanceof _geom_Geometry_js__WEBPACK_IMPORTED_MODULE_4__["default"] ||
          !opt_geometryOrProperties) {
        var geometry = opt_geometryOrProperties;
        this.setGeometry(geometry);
      } else {
        /** @type {Object.<string, *>} */
        var properties = opt_geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  if ( BaseObject ) Feature.__proto__ = BaseObject;
  Feature.prototype = Object.create( BaseObject && BaseObject.prototype );
  Feature.prototype.constructor = Feature;

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {module:ol/Feature} The clone.
   * @api
   */
  Feature.prototype.clone = function clone () {
    var clone = new Feature(this.getProperties());
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    var style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  };

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {module:ol/geom/Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  Feature.prototype.getGeometry = function getGeometry () {
    return (
      /** @type {module:ol/geom/Geometry|undefined} */ (this.get(this.geometryName_))
    );
  };

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  Feature.prototype.getId = function getId () {
    return this.id_;
  };

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  Feature.prototype.getGeometryName = function getGeometryName () {
    return this.geometryName_;
  };

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} The feature style.
   * @api
   */
  Feature.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
   * Get the feature's style function.
   * @return {module:ol/style/Style~StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  Feature.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChange_ = function handleGeometryChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_ () {
    if (this.geometryChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"])(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {module:ol/geom/Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  Feature.prototype.setGeometry = function setGeometry (geometry) {
    this.set(this.geometryName_, geometry);
  };

  /**
   * Set the style for the feature.  This can be a single style object, an array
   * of styles, or a function that takes a resolution and returns an array of
   * styles. If it is `null` the feature has no style (a `null` style).
   * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} style Style for this feature.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setStyle = function setStyle (style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  };

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~Event#event:change
   */
  Feature.prototype.setId = function setId (id) {
    this.id_ = id;
    this.changed();
  };

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  Feature.prototype.setGeometryName = function setGeometryName (name) {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.geometryName_ = name;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(this.geometryName_),
      this.handleGeometryChanged_, this);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of module:ol/style/Style or single style objects wrapped
 * in a new feature style function.
 * @param {module:ol/style/Style~StyleFunction|!Array.<module:ol/style/Style>|!module:ol/style/Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {module:ol/style/Style~StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array.<module:ol/style/Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(obj instanceof _style_Style_js__WEBPACK_IMPORTED_MODULE_5__["default"],
        41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`
      styles = [obj];
    }
    return function() {
      return styles;
    };
  }
}
/* harmony default export */ __webpack_exports__["default"] = (Feature);

//# sourceMappingURL=Feature.js.map

/***/ }),

/***/ "./node_modules/ol/ImageBase.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageBase.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageBase
 */



/**
 * @abstract
 */
var ImageBase = (function (EventTarget) {
  function ImageBase(extent, resolution, pixelRatio, state) {

    EventTarget.call(this);

    /**
     * @protected
     * @type {module:ol/extent~Extent}
     */
    this.extent = extent;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.resolution = resolution;

    /**
     * @protected
     * @type {module:ol/ImageState}
     */
    this.state = state;

  }

  if ( EventTarget ) ImageBase.__proto__ = EventTarget;
  ImageBase.prototype = Object.create( EventTarget && EventTarget.prototype );
  ImageBase.prototype.constructor = ImageBase;

  /**
   * @protected
   */
  ImageBase.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  };

  /**
   * @return {module:ol/extent~Extent} Extent.
   */
  ImageBase.prototype.getExtent = function getExtent () {
    return this.extent;
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */
  ImageBase.prototype.getImage = function getImage () {};

  /**
   * @return {number} PixelRatio.
   */
  ImageBase.prototype.getPixelRatio = function getPixelRatio () {
    return this.pixelRatio_;
  };

  /**
   * @return {number} Resolution.
   */
  ImageBase.prototype.getResolution = function getResolution () {
    return /** @type {number} */ (this.resolution);
  };

  /**
   * @return {module:ol/ImageState} State.
   */
  ImageBase.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * Load not yet loaded URI.
   * @abstract
   */
  ImageBase.prototype.load = function load () {};

  return ImageBase;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageBase);

//# sourceMappingURL=ImageBase.js.map

/***/ }),

/***/ "./node_modules/ol/ImageCanvas.js":
/*!****************************************!*\
  !*** ./node_modules/ol/ImageCanvas.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageState.js */ "./node_modules/ol/ImageState.js");
/**
 * @module ol/ImageCanvas
 */




/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error))} Loader
 */


var ImageCanvas = (function (ImageBase) {
  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {

    var state = opt_loader !== undefined ? _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE : _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;

    ImageBase.call(this, extent, resolution, pixelRatio, state);

    /**
     * Optional canvas loader function.
     * @type {?module:ol/ImageCanvas~Loader}
     * @private
     */
    this.loader_ = opt_loader !== undefined ? opt_loader : null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {Error}
     */
    this.error_ = null;

  }

  if ( ImageBase ) ImageCanvas.__proto__ = ImageBase;
  ImageCanvas.prototype = Object.create( ImageBase && ImageBase.prototype );
  ImageCanvas.prototype.constructor = ImageCanvas;

  /**
   * Get any error associated with asynchronous rendering.
   * @return {Error} Any error that occurred during rendering.
   */
  ImageCanvas.prototype.getError = function getError () {
    return this.error_;
  };

  /**
   * Handle async drawing complete.
   * @param {Error} err Any error during drawing.
   * @private
   */
  ImageCanvas.prototype.handleLoad_ = function handleLoad_ (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    } else {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ImageCanvas.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };

  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  ImageCanvas.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvas);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/ImageState.js":
/*!***************************************!*\
  !*** ./node_modules/ol/ImageState.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
});

//# sourceMappingURL=ImageState.js.map

/***/ }),

/***/ "./node_modules/ol/ImageTile.js":
/*!**************************************!*\
  !*** ./node_modules/ol/ImageTile.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/ImageTile
 */






/**
 * @typedef {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord,
 * module:ol/TileState, string, ?string, module:ol/Tile~LoadFunction)} TileClass
 * @api
 */

var ImageTile = (function (Tile) {
  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

    Tile.call(this, tileCoord, state, opt_options);

    /**
     * @private
     * @type {?string}
     */
    this.crossOrigin_ = crossOrigin;

    /**
     * Image URI
     *
     * @private
     * @type {string}
     */
    this.src_ = src;

    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.imageListenerKeys_ = null;

    /**
     * @private
     * @type {module:ol/Tile~LoadFunction}
     */
    this.tileLoadFunction_ = tileLoadFunction;

  }

  if ( Tile ) ImageTile.__proto__ = Tile;
  ImageTile.prototype = Object.create( Tile && Tile.prototype );
  ImageTile.prototype.constructor = ImageTile;

  /**
   * @inheritDoc
   */
  ImageTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.unlistenImage_();
      this.image_ = getBlankImage();
    }
    if (this.interimTile) {
      this.interimTile.dispose();
    }
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT;
    this.changed();
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  ImageTile.prototype.getImage = function getImage () {
    return this.image_;
  };

  /**
   * @inheritDoc
   */
  ImageTile.prototype.getKey = function getKey () {
    return this.src_;
  };

  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  ImageTile.prototype.handleImageError_ = function handleImageError_ () {
    this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };

  /**
   * Tracks successful image load.
   *
   * @private
   */
  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {
    if (this.image_.naturalWidth && this.image_.naturalHeight) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
    } else {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  };

  /**
   * @inheritDoc
   * @api
   */
  ImageTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING;
      this.changed();
      this.imageListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].ERROR,
          this.handleImageError_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listenOnce"])(this.image_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].LOAD,
          this.handleImageLoad_, this)
      ];
      this.tileLoadFunction_(this, this.src_);
    }
  };

  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {
    this.imageListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.imageListenerKeys_ = null;
  };

  return ImageTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
function getBlankImage() {
  var ctx = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

/* harmony default export */ __webpack_exports__["default"] = (ImageTile);

//# sourceMappingURL=ImageTile.js.map

/***/ }),

/***/ "./node_modules/ol/Kinetic.js":
/*!************************************!*\
  !*** ./node_modules/ol/Kinetic.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic = function Kinetic(decay, minVelocity, delay) {

  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;

  /**
   * @private
   * @type {number}
   */
  this.minVelocity_ = minVelocity;

  /**
   * @private
   * @type {number}
   */
  this.delay_ = delay;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.points_ = [];

  /**
   * @private
   * @type {number}
   */
  this.angle_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.initialVelocity_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
Kinetic.prototype.begin = function begin () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 */
Kinetic.prototype.update = function update (x, y) {
  this.points_.push(x, y, Date.now());
};

/**
 * @return {boolean} Whether we should do kinetic animation.
 */
Kinetic.prototype.end = function end () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  }

  // get the first point which still falls into the delay time
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values
  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};

/**
 * @return {number} Total distance travelled (pixels).
 */
Kinetic.prototype.getDistance = function getDistance () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};

/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */
Kinetic.prototype.getAngle = function getAngle () {
  return this.angle_;
};

/* harmony default export */ __webpack_exports__["default"] = (Kinetic);

//# sourceMappingURL=Kinetic.js.map

/***/ }),

/***/ "./node_modules/ol/LayerType.js":
/*!**************************************!*\
  !*** ./node_modules/ol/LayerType.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/LayerType
 */

/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
});

//# sourceMappingURL=LayerType.js.map

/***/ }),

/***/ "./node_modules/ol/Map.js":
/*!********************************!*\
  !*** ./node_modules/ol/Map.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PluggableMap.js */ "./node_modules/ol/PluggableMap.js");
/* harmony import */ var _control_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./control/util.js */ "./node_modules/ol/control/util.js");
/* harmony import */ var _interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction.js */ "./node_modules/ol/interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/canvas/ImageLayer.js */ "./node_modules/ol/renderer/canvas/ImageLayer.js");
/* harmony import */ var _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/canvas/Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer/canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./renderer/canvas/VectorLayer.js */ "./node_modules/ol/renderer/canvas/VectorLayer.js");
/* harmony import */ var _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer/canvas/VectorTileLayer.js */ "./node_modules/ol/renderer/canvas/VectorTileLayer.js");
/**
 * @module ol/Map
 */










/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires module:ol/MapBrowserEvent~MapBrowserEvent
 * @fires module:ol/MapEvent~MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @api
 */
var Map = (function (PluggableMap) {
  function Map(options) {
    options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);
    if (!options.controls) {
      options.controls = Object(_control_util_js__WEBPACK_IMPORTED_MODULE_1__["defaults"])();
    }
    if (!options.interactions) {
      options.interactions = Object(_interaction_js__WEBPACK_IMPORTED_MODULE_2__["defaults"])();
    }

    PluggableMap.call(this, options);
  }

  if ( PluggableMap ) Map.__proto__ = PluggableMap;
  Map.prototype = Object.create( PluggableMap && PluggableMap.prototype );
  Map.prototype.constructor = Map;

  Map.prototype.createRenderer = function createRenderer () {
    var renderer = new _renderer_canvas_Map_js__WEBPACK_IMPORTED_MODULE_5__["default"](this);
    renderer.registerLayerRenderers([
      _renderer_canvas_ImageLayer_js__WEBPACK_IMPORTED_MODULE_4__["default"],
      _renderer_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_6__["default"],
      _renderer_canvas_VectorLayer_js__WEBPACK_IMPORTED_MODULE_7__["default"],
      _renderer_canvas_VectorTileLayer_js__WEBPACK_IMPORTED_MODULE_8__["default"]
    ]);
    return renderer;
  };

  return Map;
}(_PluggableMap_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Map);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEvent.js":
/*!********************************************!*\
  !*** ./node_modules/ol/MapBrowserEvent.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 */
var MapBrowserEvent = (function (MapEvent) {
  function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {

    MapEvent.call(this, type, map, opt_frameState);

    /**
     * The original browser event.
     * @const
     * @type {Event}
     * @api
     */
    this.originalEvent = browserEvent;

    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {module:ol/pixel~Pixel}
     * @api
     */
    this.pixel = map.getEventPixel(browserEvent);

    /**
     * The coordinate in view projection corresponding to the original browser event.
     * @type {module:ol/coordinate~Coordinate}
     * @api
     */
    this.coordinate = map.getCoordinateFromPixel(this.pixel);

    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */
    this.dragging = opt_dragging !== undefined ? opt_dragging : false;

  }

  if ( MapEvent ) MapBrowserEvent.__proto__ = MapEvent;
  MapBrowserEvent.prototype = Object.create( MapEvent && MapEvent.prototype );
  MapBrowserEvent.prototype.constructor = MapBrowserEvent;

  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.preventDefault = function preventDefault () {
    MapEvent.prototype.preventDefault.call(this);
    this.originalEvent.preventDefault();
  };

  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @override
   * @api
   */
  MapBrowserEvent.prototype.stopPropagation = function stopPropagation () {
    MapEvent.prototype.stopPropagation.call(this);
    this.originalEvent.stopPropagation();
  };

  return MapBrowserEvent;
}(_MapEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEvent);

//# sourceMappingURL=MapBrowserEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventHandler.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventHandler.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./pointer/PointerEventHandler.js */ "./node_modules/ol/pointer/PointerEventHandler.js");
/**
 * @module ol/MapBrowserEventHandler
 */








var MapBrowserEventHandler = (function (EventTarget) {
  function MapBrowserEventHandler(map, moveTolerance) {

    EventTarget.call(this);

    /**
     * This is the element that we will listen to the real events on.
     * @type {module:ol/PluggableMap}
     * @private
     */
    this.map_ = map;

    /**
     * @type {number}
     * @private
     */
    this.clickTimeoutId_ = 0;

    /**
     * @type {boolean}
     * @private
     */
    this.dragging_ = false;

    /**
     * @type {!Array.<module:ol/events~EventsKey>}
     * @private
     */
    this.dragListenerKeys_ = [];

    /**
     * @type {number}
     * @private
     */
    this.moveTolerance_ = moveTolerance ?
      moveTolerance * _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"] : _has_js__WEBPACK_IMPORTED_MODULE_0__["DEVICE_PIXEL_RATIO"];

    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {module:ol/pointer/PointerEvent}
     * @private
     */
    this.down_ = null;

    var element = this.map_.getViewport();

    /**
     * @type {number}
     * @private
     */
    this.activePointers_ = 0;

    /**
     * @type {!Object.<number, boolean>}
     * @private
     */
    this.trackedTouches_ = {};

    /**
     * Event handler which generates pointer events for
     * the viewport element.
     *
     * @type {module:ol/pointer/PointerEventHandler}
     * @private
     */
    this.pointerEventHandler_ = new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](element);

    /**
     * Event handler which generates pointer events for
     * the document (used when dragging).
     *
     * @type {module:ol/pointer/PointerEventHandler}
     * @private
     */
    this.documentPointerEventHandler_ = null;

    /**
     * @type {?module:ol/events~EventsKey}
     * @private
     */
    this.pointerdownListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      this.handlePointerDown_, this);

    /**
     * @type {?module:ol/events~EventsKey}
     * @private
     */
    this.relayedListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
      _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERMOVE,
      this.relayEvent_, this);

  }

  if ( EventTarget ) MapBrowserEventHandler.__proto__ = EventTarget;
  MapBrowserEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_ (pointerEvent) {
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== 0) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = 0;
      newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(function() {
        this.clickTimeoutId_ = 0;
        var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };

  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_ (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP ||
        event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }
    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.stopPropagation() or event.preventDefault().
    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
  };

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_ (pointerEvent) {
    return pointerEvent.button === 0;
  };

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_ (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    this.down_ = pointerEvent;

    if (this.dragListenerKeys_.length === 0) {
      /* Set up a pointer event handler on the `document`,
       * which is required when the pointer is moved outside
       * the viewport when dragging.
       */
      this.documentPointerEventHandler_ =
          new _pointer_PointerEventHandler_js__WEBPACK_IMPORTED_MODULE_6__["default"](document);

      this.dragListenerKeys_.push(
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE,
          this.handlePointerMove_, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.documentPointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP,
          this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.pointerEventHandler_,
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERCANCEL,
          this.handlePointerUp_, this)
      );
    }
  };

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_ (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG, this.map_, pointerEvent,
        this.dragging_);
      this.dispatchEvent(newEvent);
    }

    // Some native android browser triggers mousemove events during small period
    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
    // https://code.google.com/p/android/issues/detail?id=19827
    // ex: Galaxy Tab P3110 + Android 4.1.1
    pointerEvent.preventDefault();
  };

  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserPointerEvent matches the PointerEvent type.
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_ (pointerEvent) {
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"](
      pointerEvent.type, this.map_, pointerEvent, dragging));
  };

  /**
   * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_ (pointerEvent) {
    return this.dragging_ ||
        Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||
        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };

  /**
   * @inheritDoc
   */
  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal () {
    if (this.relayedListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    if (this.pointerdownListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.dragListenerKeys_.length = 0;

    if (this.documentPointerEventHandler_) {
      this.documentPointerEventHandler_.dispose();
      this.documentPointerEventHandler_ = null;
    }
    if (this.pointerEventHandler_) {
      this.pointerEventHandler_.dispose();
      this.pointerEventHandler_ = null;
    }
    EventTarget.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MapBrowserEventHandler);

//# sourceMappingURL=MapBrowserEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserEventType.js":
/*!************************************************!*\
  !*** ./node_modules/ol/MapBrowserEventType.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/MapBrowserEventType
 */


/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=MapBrowserEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapBrowserPointerEvent.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/MapBrowserPointerEvent.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/**
 * @module ol/MapBrowserPointerEvent
 */


var MapBrowserPointerEvent = (function (MapBrowserEvent) {
  function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {

    MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

    /**
     * @const
     * @type {module:ol/pointer/PointerEvent}
     */
    this.pointerEvent = pointerEvent;

  }

  if ( MapBrowserEvent ) MapBrowserPointerEvent.__proto__ = MapBrowserEvent;
  MapBrowserPointerEvent.prototype = Object.create( MapBrowserEvent && MapBrowserEvent.prototype );
  MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;

  return MapBrowserPointerEvent;
}(_MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapBrowserPointerEvent);

//# sourceMappingURL=MapBrowserPointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEvent.js":
/*!*************************************!*\
  !*** ./node_modules/ol/MapEvent.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */
var MapEvent = (function (Event) {
  function MapEvent(type, map, opt_frameState) {

    Event.call(this, type);

    /**
     * The map where the event occurred.
     * @type {module:ol/PluggableMap}
     * @api
     */
    this.map = map;

    /**
     * The frame state at the time of the event.
     * @type {?module:ol/PluggableMap~FrameState}
     * @api
     */
    this.frameState = opt_frameState !== undefined ? opt_frameState : null;

  }

  if ( Event ) MapEvent.__proto__ = Event;
  MapEvent.prototype = Object.create( Event && Event.prototype );
  MapEvent.prototype.constructor = MapEvent;

  return MapEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MapEvent);

//# sourceMappingURL=MapEvent.js.map

/***/ }),

/***/ "./node_modules/ol/MapEventType.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/MapEventType.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'

});

//# sourceMappingURL=MapEventType.js.map

/***/ }),

/***/ "./node_modules/ol/MapProperty.js":
/*!****************************************!*\
  !*** ./node_modules/ol/MapProperty.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
});

//# sourceMappingURL=MapProperty.js.map

/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/*! exports provided: getChangeEventType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChangeEventType", function() { return getChangeEventType; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */







/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
  */
var ObjectEvent = (function (Event) {
  function ObjectEvent(type, key, oldValue) {
    Event.call(this, type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;

  }

  if ( Event ) ObjectEvent.__proto__ = Event;
  ObjectEvent.prototype = Object.create( Event && Event.prototype );
  ObjectEvent.prototype.constructor = ObjectEvent;

  return ObjectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires module:ol/Object~ObjectEvent
 * @api
 */
var BaseObject = (function (Observable) {
  function BaseObject(opt_values) {
    Observable.call(this);

    // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);

    /**
     * @private
     * @type {!Object.<string, *>}
     */
    this.values_ = {};

    if (opt_values !== undefined) {
      this.setProperties(opt_values);
    }
  }

  if ( Observable ) BaseObject.__proto__ = Observable;
  BaseObject.prototype = Object.create( Observable && Observable.prototype );
  BaseObject.prototype.constructor = BaseObject;

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  BaseObject.prototype.get = function get (key) {
    var value;
    if (this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  };

  /**
   * Get a list of object property names.
   * @return {Array.<string>} List of property names.
   * @api
   */
  BaseObject.prototype.getKeys = function getKeys () {
    return Object.keys(this.values_);
  };

  /**
   * Get an object of all property names and values.
   * @return {Object.<string, *>} Object.
   * @api
   */
  BaseObject.prototype.getProperties = function getProperties () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])({}, this.values_);
  };

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  BaseObject.prototype.notify = function notify (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.set = function set (key, value, opt_silent) {
    if (opt_silent) {
      this.values_[key] = value;
    } else {
      var oldValue = this.values_[key];
      this.values_[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object.<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */
  BaseObject.prototype.setProperties = function setProperties (values, opt_silent) {
    var this$1 = this;

    for (var key in values) {
      this$1.set(key, values[key], opt_silent);
    }
  };

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */
  BaseObject.prototype.unset = function unset (key, opt_silent) {
    if (key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];
      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @type {Object.<string, string>}
 */
var changeEventTypeCache = {};


/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ?
    changeEventTypeCache[key] :
    (changeEventTypeCache[key] = 'change:' + key);
}


/* harmony default export */ __webpack_exports__["default"] = (BaseObject);

//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object~ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
});

//# sourceMappingURL=ObjectEventType.js.map

/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/*! exports provided: unByKey, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unByKey", function() { return unByKey; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Observable
 */




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires module:ol/events/Event~Event
 * @api
 */
var Observable = (function (EventTarget) {
  function Observable() {

    EventTarget.call(this);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;

  }

  if ( EventTarget ) Observable.__proto__ = EventTarget;
  Observable.prototype = Object.create( EventTarget && EventTarget.prototype );
  Observable.prototype.constructor = Observable;

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  Observable.prototype.changed = function changed () {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE);
  };

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  Observable.prototype.getRevision = function getRevision () {
    return this.revision_;
  };

  /**
   * Listen for a certain type of event.
   * @param {string|Array.<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.on = function on (type, listener) {
    var this$1 = this;

    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this$1, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Listen once for a certain type of event.
   * @param {string|Array.<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */
  Observable.prototype.once = function once (type, listener) {
    var this$1 = this;

    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);
      for (var i = 0; i < len; ++i) {
        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this$1, type[i], listener);
      }
      return keys;
    } else {
      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listenOnce"])(this, /** @type {string} */ (type), listener);
    }
  };

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array.<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */
  Observable.prototype.un = function un (type, listener) {
    var this$1 = this;

    if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this$1, type[i], listener);
      }
      return;
    } else {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this, /** @type {string} */ (type), listener);
    }
  };

  return Observable;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(key[i]);
    }
  } else {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(/** @type {module:ol/events~EventsKey} */ (key));
  }
}


/* harmony default export */ __webpack_exports__["default"] = (Observable);

//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "./node_modules/ol/PluggableMap.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/PluggableMap.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MapBrowserEvent.js */ "./node_modules/ol/MapBrowserEvent.js");
/* harmony import */ var _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MapBrowserEventHandler.js */ "./node_modules/ol/MapBrowserEventHandler.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MapEvent.js */ "./node_modules/ol/MapEvent.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _MapProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MapProperty.js */ "./node_modules/ol/MapProperty.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _TileQueue_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TileQueue.js */ "./node_modules/ol/TileQueue.js");
/* harmony import */ var _View_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./View.js */ "./node_modules/ol/View.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _layer_Group_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./layer/Group.js */ "./node_modules/ol/layer/Group.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/PluggableMap
 */




























/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {module:ol/View~State} viewState The state of the current view.
 * @property {boolean} animate
 * @property {module:ol/transform~Transform} coordinateToPixelTransform
 * @property {null|module:ol/extent~Extent} extent
 * @property {module:ol/coordinate~Coordinate} focus
 * @property {number} index
 * @property {Object.<number, module:ol/layer/Layer~State>} layerStates
 * @property {Array.<module:ol/layer/Layer~State>} layerStatesArray
 * @property {module:ol/transform~Transform} pixelToCoordinateTransform
 * @property {Array.<module:ol/PluggableMap~PostRenderFunction>} postRenderFunctions
 * @property {module:ol/size~Size} size
 * @property {!Object.<string, boolean>} skippedFeatureUids
 * @property {module:ol/TileQueue} tileQueue
 * @property {Object.<string, Object.<string, module:ol/TileRange>>} usedTiles
 * @property {Array.<number>} viewHints
 * @property {!Object.<string, Object.<string, boolean>>} wantedTiles
 */


/**
 * @typedef {function(module:ol/PluggableMap, ?module:ol/PluggableMap~FrameState): boolean} PostRenderFunction
 */


/**
 * @typedef {Object} AtPixelOptions
 * @property {((function(module:ol/layer/Layer): boolean)|undefined)} layerFilter Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
 * inside the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @typedef {Object} MapOptionsInternal
 * @property {module:ol/Collection.<module:ol/control/Control>} [controls]
 * @property {module:ol/Collection.<module:ol/interaction/Interaction>} [interactions]
 * @property {HTMLElement|Document} keyboardEventTarget
 * @property {module:ol/Collection.<module:ol/Overlay>} overlays
 * @property {Object.<string, *>} values
 */


/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {module:ol/Collection.<module:ol/control/Control>|Array.<module:ol/control/Control>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/util~defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {module:ol/Collection.<module:ol/interaction/Interaction>|Array.<module:ol/interaction/Interaction>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction~defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles
 * will be loaded during animations. This may improve the user experience, but
 * can also make animations stutter on devices with slow memory.
 * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,
 * tiles will be loaded while interacting with the map. This may improve the
 * user experience, but can also make map panning and zooming choppy on devices
 * with slow memory.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {module:ol/Collection.<module:ol/Overlay>|Array.<module:ol/Overlay>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered.
 * @property {module:ol/View} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */


/**
 * @fires module:ol/MapBrowserEvent~MapBrowserEvent
 * @fires module:ol/MapEvent~MapEvent
 * @fires module:ol/render/Event~RenderEvent#postcompose
 * @fires module:ol/render/Event~RenderEvent#precompose
 * @api
 */
var PluggableMap = (function (BaseObject) {
  function PluggableMap(options) {
    var this$1 = this;


    BaseObject.call(this);

    var optionsInternal = createOptionsInternal(options);

    /**
     * @type {number}
     * @private
     */
    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileAnimating_ =
        options.loadTilesWhileAnimating !== undefined ?
          options.loadTilesWhileAnimating : false;

    /**
     * @type {boolean}
     * @private
     */
    this.loadTilesWhileInteracting_ =
        options.loadTilesWhileInteracting !== undefined ?
          options.loadTilesWhileInteracting : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = options.pixelRatio !== undefined ?
      options.pixelRatio : _has_js__WEBPACK_IMPORTED_MODULE_21__["DEVICE_PIXEL_RATIO"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.animationDelayKey_;

    /**
     * @private
     */
    this.animationDelay_ = function() {
      this.animationDelayKey_ = undefined;
      this.renderFrame_.call(this, Date.now());
    }.bind(this);

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.coordinateToPixelTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_25__["create"])();

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.pixelToCoordinateTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_25__["create"])();

    /**
     * @private
     * @type {number}
     */
    this.frameIndex_ = 0;

    /**
     * @private
     * @type {?module:ol/PluggableMap~FrameState}
     */
    this.frameState_ = null;

    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.previousExtent_ = null;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.viewPropertyListenerKey_ = null;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.viewChangeListenerKey_ = null;

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.layerGroupPropertyListenerKeys_ = null;

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.viewport_ = document.createElement('DIV');
    this.viewport_.className = 'ol-viewport' + (_has_js__WEBPACK_IMPORTED_MODULE_21__["TOUCH"] ? ' ol-touch' : '');
    this.viewport_.style.position = 'relative';
    this.viewport_.style.overflow = 'hidden';
    this.viewport_.style.width = '100%';
    this.viewport_.style.height = '100%';
    // prevent page zoom on IE >= 10 browsers
    this.viewport_.style.msTouchAction = 'none';
    this.viewport_.style.touchAction = 'none';

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainer_ = document.createElement('DIV');
    this.overlayContainer_.className = 'ol-overlaycontainer';
    this.viewport_.appendChild(this.overlayContainer_);

    /**
     * @private
     * @type {!HTMLElement}
     */
    this.overlayContainerStopEvent_ = document.createElement('DIV');
    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
    var overlayEvents = [
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].CLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].DBLCLICK,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].TOUCHSTART,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].MSPOINTERDOWN,
      _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINTERDOWN,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL,
      _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL
    ];
    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this$1.overlayContainerStopEvent_, overlayEvents[i], _events_Event_js__WEBPACK_IMPORTED_MODULE_17__["stopPropagation"]);
    }
    this.viewport_.appendChild(this.overlayContainerStopEvent_);

    /**
     * @private
     * @type {module:ol/MapBrowserEventHandler}
     */
    this.mapBrowserEventHandler_ = new _MapBrowserEventHandler_js__WEBPACK_IMPORTED_MODULE_4__["default"](this, options.moveTolerance);
    for (var key in _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this$1.mapBrowserEventHandler_, _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_5__["default"][key],
        this$1.handleMapBrowserEvent, this$1);
    }

    /**
     * @private
     * @type {HTMLElement|Document}
     */
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.keyHandlerKeys_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);

    /**
     * @type {module:ol/Collection.<module:ol/control/Control>}
     * @protected
     */
    this.controls = optionsInternal.controls || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {module:ol/Collection.<module:ol/interaction/Interaction>}
     * @protected
     */
    this.interactions = optionsInternal.interactions || new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();

    /**
     * @type {module:ol/Collection.<module:ol/Overlay>}
     * @private
     */
    this.overlays_ = optionsInternal.overlays;

    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object.<string, module:ol/Overlay>}
     */
    this.overlayIdIndex_ = {};

    /**
     * @type {module:ol/renderer/Map}
     * @private
     */
    this.renderer_ = this.createRenderer();

    /**
     * @type {function(Event)|undefined}
     * @private
     */
    this.handleResize_;

    /**
     * @private
     * @type {module:ol/coordinate~Coordinate}
     */
    this.focus_ = null;

    /**
     * @private
     * @type {!Array.<module:ol/PluggableMap~PostRenderFunction>}
     */
    this.postRenderFunctions_ = [];

    /**
     * @private
     * @type {module:ol/TileQueue}
     */
    this.tileQueue_ = new _TileQueue_js__WEBPACK_IMPORTED_MODULE_11__["default"](
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this));

    /**
     * Uids of features to skip at rendering time.
     * @type {Object.<string, boolean>}
     * @private
     */
    this.skippedFeatureUids_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(
      this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_9__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP),
      this.handleLayerGroupChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_9__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW),
      this.handleViewChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_9__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE),
      this.handleSizeChanged_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_9__["getChangeEventType"])(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET),
      this.handleTargetChanged_, this);

    // setProperties will trigger the rendering of the map if the map
    // is "defined" already.
    this.setProperties(optionsInternal.values);

    this.controls.forEach(
      /**
       * @param {module:ol/control/Control} control Control.
       * @this {module:ol/PluggableMap}
       */
      (function(control) {
        control.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.controls, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.interactions.forEach(
      /**
       * @param {module:ol/interaction/Interaction} interaction Interaction.
       * @this {module:ol/PluggableMap}
       */
      (function(interaction) {
        interaction.setMap(this);
      }).bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(this);
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.interactions, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        event.element.setMap(null);
      }, this);

    this.overlays_.forEach(this.addOverlayInternal_.bind(this));

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        this.addOverlayInternal_(/** @type {module:ol/Overlay} */ (event.element));
      }, this);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(this.overlays_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      /**
       * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
       */
      function(event) {
        var overlay = /** @type {module:ol/Overlay} */ (event.element);
        var id = overlay.getId();
        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }, this);

  }

  if ( BaseObject ) PluggableMap.__proto__ = BaseObject;
  PluggableMap.prototype = Object.create( BaseObject && BaseObject.prototype );
  PluggableMap.prototype.constructor = PluggableMap;

  PluggableMap.prototype.createRenderer = function createRenderer () {
    throw new Error('Use a map type that has a createRenderer method');
  };

  /**
   * Add the given control to the map.
   * @param {module:ol/control/Control} control Control.
   * @api
   */
  PluggableMap.prototype.addControl = function addControl (control) {
    this.getControls().push(control);
  };

  /**
   * Add the given interaction to the map.
   * @param {module:ol/interaction/Interaction} interaction Interaction to add.
   * @api
   */
  PluggableMap.prototype.addInteraction = function addInteraction (interaction) {
    this.getInteractions().push(interaction);
  };

  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {module:ol/layer/Base} layer Layer.
   * @api
   */
  PluggableMap.prototype.addLayer = function addLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };

  /**
   * Add the given overlay to the map.
   * @param {module:ol/Overlay} overlay Overlay.
   * @api
   */
  PluggableMap.prototype.addOverlay = function addOverlay (overlay) {
    this.getOverlays().push(overlay);
  };

  /**
   * This deals with map's overlay collection changes.
   * @param {module:ol/Overlay} overlay Overlay.
   * @private
   */
  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_ (overlay) {
    var id = overlay.getId();
    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  };

  /**
   *
   * @inheritDoc
   */
  PluggableMap.prototype.disposeInternal = function disposeInternal () {
    this.mapBrowserEventHandler_.dispose();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].CONTEXTMENU, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].WHEEL, this.handleBrowserEvent, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlisten"])(this.viewport_, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].MOUSEWHEEL, this.handleBrowserEvent, this);
    if (this.handleResize_ !== undefined) {
      removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
      this.animationDelayKey_ = undefined;
    }
    this.setTarget(null);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {module:ol/pixel~Pixel} pixel Pixel.
   * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),
   *     module:ol/layer/Layer): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature feature} or
   *     {@link module:ol/render/Feature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = opt_options.layerFilter !== undefined ?
      opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_20__["TRUE"];
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, callback, null,
      layerFilter, null);
  };

  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {module:ol/pixel~Pixel} pixel Pixel.
   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
   * @return {Array.<module:ol/Feature|module:ol/render/Feature>} The detected features or
   * `null` if none were found.
   * @api
   */
  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel (pixel, opt_options) {
    var features = null;
    this.forEachFeatureAtPixel(pixel, function(feature) {
      if (!features) {
        features = [];
      }
      features.push(feature);
    }, opt_options);
    return features;
  };

  /**
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {module:ol/pixel~Pixel} pixel Pixel.
   * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:ol/layer/Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */
  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }
    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    var layerFilter = options.layerFilter || _functions_js__WEBPACK_IMPORTED_MODULE_20__["TRUE"];
    return this.renderer_.forEachLayerAtPixel(
      pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);
  };

  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {module:ol/pixel~Pixel} pixel Pixel.
   * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @template U
   * @api
   */
  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel (pixel, opt_options) {
    if (!this.frameState_) {
      return false;
    }
    var coordinate = this.getCoordinateFromPixel(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions_js__WEBPACK_IMPORTED_MODULE_20__["TRUE"];
    var hitTolerance = opt_options.hitTolerance !== undefined ?
      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate, this.frameState_, hitTolerance, layerFilter, null);
  };

  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {Event} event Event.
   * @return {module:ol/coordinate~Coordinate} Coordinate.
   * @api
   */
  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };

  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {Event} event Event.
   * @return {module:ol/pixel~Pixel} Pixel.
   * @api
   */
  PluggableMap.prototype.getEventPixel = function getEventPixel (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
    return [
      eventPosition.clientX - viewportPosition.left,
      eventPosition.clientY - viewportPosition.top
    ];
  };

  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.getTarget = function getTarget () {
    return /** @type {HTMLElement|string|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET));
  };

  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  PluggableMap.prototype.getTargetElement = function getTargetElement () {
    var target = this.getTarget();
    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };

  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {module:ol/pixel~Pixel} pixel Pixel position in the map viewport.
   * @return {module:ol/coordinate~Coordinate} The coordinate for the pixel position.
   * @api
   */
  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel (pixel) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_25__["apply"])(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };

  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {module:ol/Collection.<module:ol/control/Control>} Controls.
   * @api
   */
  PluggableMap.prototype.getControls = function getControls () {
    return this.controls;
  };

  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {module:ol/Collection.<module:ol/Overlay>} Overlays.
   * @api
   */
  PluggableMap.prototype.getOverlays = function getOverlays () {
    return this.overlays_;
  };

  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {module:ol/Overlay} Overlay.
   * @api
   */
  PluggableMap.prototype.getOverlayById = function getOverlayById (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };

  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {module:ol/Collection.<module:ol/interaction/Interaction>} Interactions.
   * @api
   */
  PluggableMap.prototype.getInteractions = function getInteractions () {
    return this.interactions;
  };

  /**
   * Get the layergroup associated with this map.
   * @return {module:ol/layer/Group} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getLayerGroup = function getLayerGroup () {
    return (
      /** @type {module:ol/layer/Group} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP))
    );
  };

  /**
   * Get the collection of layers associated with this map.
   * @return {!module:ol/Collection.<module:ol/layer/Base>} Layers.
   * @api
   */
  PluggableMap.prototype.getLayers = function getLayers () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };

  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {module:ol/coordinate~Coordinate} coordinate A map coordinate.
   * @return {module:ol/pixel~Pixel} A pixel position in the map viewport.
   * @api
   */
  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate (coordinate) {
    var frameState = this.frameState_;
    if (!frameState) {
      return null;
    } else {
      return Object(_transform_js__WEBPACK_IMPORTED_MODULE_25__["apply"])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };

  /**
   * Get the map renderer.
   * @return {module:ol/renderer/Map} Renderer
   */
  PluggableMap.prototype.getRenderer = function getRenderer () {
    return this.renderer_;
  };

  /**
   * Get the size of this map.
   * @return {module:ol/size~Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.getSize = function getSize () {
    return (
      /** @type {module:ol/size~Size|undefined} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE))
    );
  };

  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {module:ol/View} The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.getView = function getView () {
    return (
      /** @type {module:ol/View} */ (this.get(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW))
    );
  };

  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  PluggableMap.prototype.getViewport = function getViewport () {
    return this.viewport_;
  };

  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer () {
    return this.overlayContainer_;
  };

  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent () {
    return this.overlayContainerStopEvent_;
  };

  /**
   * @param {module:ol/Tile} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {module:ol/coordinate~Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  PluggableMap.prototype.getTilePriority = function getTilePriority (tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    var frameState = this.frameState_;
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_24__["DROP"];
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
      return _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_24__["DROP"];
    }
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels
    // between the center of the tile and the focus.  The factor of 65536 means
    // that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    var deltaX = tileCenter[0] - frameState.focus[0];
    var deltaY = tileCenter[1] - frameState.focus[1];
    return 65536 * Math.log(tileResolution) +
        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  };

  /**
   * @param {Event} browserEvent Browser event.
   * @param {string=} opt_type Type.
   */
  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };

  /**
   * @param {module:ol/MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }
    this.focus_ = mapBrowserEvent.coordinate;
    mapBrowserEvent.frameState = this.frameState_;
    var interactionsArray = this.getInteractions().getArray();
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];
        if (!interaction.getActive()) {
          continue;
        }
        var cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont) {
          break;
        }
      }
    }
  };

  /**
   * @protected
   */
  PluggableMap.prototype.handlePostRender = function handlePostRender () {
    var this$1 = this;


    var frameState = this.frameState_;

    // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.
    var tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;
      if (frameState) {
        var hints = frameState.viewHints;
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_13__["default"].ANIMATING]) {
          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
          maxNewLoads = 2;
        }
        if (hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_13__["default"].INTERACTING]) {
          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
          maxNewLoads = 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    var postRenderFunctions = this.postRenderFunctions_;
    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this$1, frameState);
    }
    postRenderFunctions.length = 0;
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_ () {
    var this$1 = this;

    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.

    var targetElement;
    if (this.getTarget()) {
      targetElement = this.getTargetElement();
    }

    if (this.keyHandlerKeys_) {
      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
        Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlistenByKey"])(this$1.keyHandlerKeys_[i]);
      }
      this.keyHandlerKeys_ = null;
    }

    if (!targetElement) {
      this.renderer_.removeLayerRenderers();
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_15__["removeNode"])(this.viewport_);
      if (this.handleResize_ !== undefined) {
        removeEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
        this.handleResize_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      var keyboardEventTarget = !this.keyboardEventTarget_ ?
        targetElement : this.keyboardEventTarget_;
      this.keyHandlerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].KEYDOWN, this.handleBrowserEvent, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(keyboardEventTarget, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].KEYPRESS, this.handleBrowserEvent, this)
      ];

      if (!this.handleResize_) {
        this.handleResize_ = this.updateSize.bind(this);
        addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].RESIZE, this.handleResize_, false);
      }
    }

    this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleTileChange_ = function handleTileChange_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_ () {
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_ () {
    if (this.viewPropertyListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlistenByKey"])(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlistenByKey"])(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    var view = this.getView();
    if (view) {
      this.viewport_.setAttribute('data-view', Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(view));
      this.viewPropertyListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(
        view, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].PROPERTYCHANGE,
        this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(
        view, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].CHANGE,
        this.handleViewPropertyChanged_, this);
    }
    this.render();
  };

  /**
   * @private
   */
  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_ () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_16__["unlistenByKey"]);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    var layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.layerGroupPropertyListenerKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(
          layerGroup, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].PROPERTYCHANGE,
          this.render, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_16__["listen"])(
          layerGroup, _events_EventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].CHANGE,
          this.render, this)
      ];
    }
    this.render();
  };

  /**
   * @return {boolean} Is rendered.
   */
  PluggableMap.prototype.isRendered = function isRendered () {
    return !!this.frameState_;
  };

  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  PluggableMap.prototype.renderSync = function renderSync () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  };

  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  PluggableMap.prototype.render = function render () {
    if (this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };

  /**
   * Remove the given control from the map.
   * @param {module:ol/control/Control} control Control.
   * @return {module:ol/control/Control|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  PluggableMap.prototype.removeControl = function removeControl (control) {
    return this.getControls().remove(control);
  };

  /**
   * Remove the given interaction from the map.
   * @param {module:ol/interaction/Interaction} interaction Interaction to remove.
   * @return {module:ol/interaction/Interaction|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  PluggableMap.prototype.removeInteraction = function removeInteraction (interaction) {
    return this.getInteractions().remove(interaction);
  };

  /**
   * Removes the given layer from the map.
   * @param {module:ol/layer/Base} layer Layer.
   * @return {module:ol/layer/Base|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  PluggableMap.prototype.removeLayer = function removeLayer (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };

  /**
   * Remove the given overlay from the map.
   * @param {module:ol/Overlay} overlay Overlay.
   * @return {module:ol/Overlay|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  PluggableMap.prototype.removeOverlay = function removeOverlay (overlay) {
    return this.getOverlays().remove(overlay);
  };

  /**
   * @param {number} time Time.
   * @private
   */
  PluggableMap.prototype.renderFrame_ = function renderFrame_ (time) {
    var viewState;

    var size = this.getSize();
    var view = this.getView();
    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["createEmpty"])();
    var previousFrameState = this.frameState_;
    /** @type {?module:ol/PluggableMap~FrameState} */
    var frameState = null;
    if (size !== undefined && Object(_size_js__WEBPACK_IMPORTED_MODULE_23__["hasArea"])(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
      var layerStates = {};
      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
        layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layerStatesArray[i].layer)] = layerStatesArray[i];
      }
      viewState = view.getState();
      var focus = this.focus_;
      if (!focus) {
        focus = viewState.center;
        var pixelResolution = viewState.resolution / this.pixelRatio_;
        focus[0] = Math.round(focus[0] / pixelResolution) * pixelResolution;
        focus[1] = Math.round(focus[1] / pixelResolution) * pixelResolution;
      }
      frameState = /** @type {module:ol/PluggableMap~FrameState} */ ({
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        extent: extent,
        focus: focus,
        index: this.frameIndex_++,
        layerStates: layerStates,
        layerStatesArray: layerStatesArray,
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        skippedFeatureUids: this.skippedFeatureUids_,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {}
      });
    }

    if (frameState) {
      frameState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["getForViewAndSize"])(viewState.center,
        viewState.resolution, viewState.rotation, frameState.size, extent);
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ ||
                    (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["isEmpty"])(this.previousExtent_) &&
                    !Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["equals"])(frameState.extent, this.previousExtent_));
        if (moveStart) {
          this.dispatchEvent(
            new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVESTART, this, previousFrameState));
          this.previousExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["createOrUpdateEmpty"])(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_13__["default"].ANIMATING] &&
          !frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_13__["default"].INTERACTING] &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["equals"])(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].MOVEEND, this, frameState));
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_19__["clone"])(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent_js__WEBPACK_IMPORTED_MODULE_6__["default"](_MapEventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POSTRENDER, this, frameState));

    setTimeout(this.handlePostRender.bind(this), 0);

  };

  /**
   * Sets the layergroup of this map.
   * @param {module:ol/layer/Group} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setLayerGroup = function setLayerGroup (layerGroup) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP, layerGroup);
  };

  /**
   * Set the size of this map.
   * @param {module:ol/size~Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  PluggableMap.prototype.setSize = function setSize (size) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].SIZE, size);
  };

  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string|undefined} target The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  PluggableMap.prototype.setTarget = function setTarget (target) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET, target);
  };

  /**
   * Set the view for this map.
   * @param {module:ol/View} view The view that controls this map.
   * @observable
   * @api
   */
  PluggableMap.prototype.setView = function setView (view) {
    this.set(_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW, view);
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   */
  PluggableMap.prototype.skipFeature = function skipFeature (feature) {
    var featureUid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
    this.skippedFeatureUids_[featureUid] = true;
    this.render();
  };

  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  PluggableMap.prototype.updateSize = function updateSize () {
    var targetElement = this.getTargetElement();

    if (!targetElement) {
      this.setSize(undefined);
    } else {
      var computedStyle = getComputedStyle(targetElement);
      this.setSize([
        targetElement.offsetWidth -
            parseFloat(computedStyle['borderLeftWidth']) -
            parseFloat(computedStyle['paddingLeft']) -
            parseFloat(computedStyle['paddingRight']) -
            parseFloat(computedStyle['borderRightWidth']),
        targetElement.offsetHeight -
            parseFloat(computedStyle['borderTopWidth']) -
            parseFloat(computedStyle['paddingTop']) -
            parseFloat(computedStyle['paddingBottom']) -
            parseFloat(computedStyle['borderBottomWidth'])
      ]);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   */
  PluggableMap.prototype.unskipFeature = function unskipFeature (feature) {
    var featureUid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
    delete this.skippedFeatureUids_[featureUid];
    this.render();
  };

  return PluggableMap;
}(_Object_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {MapOptions} options Map options.
 * @return {module:ol/PluggableMap~MapOptionsInternal} Internal map options.
 */
function createOptionsInternal(options) {

  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?
      document.getElementById(options.keyboardEventTarget) :
      options.keyboardEventTarget;
  }

  /**
   * @type {Object.<string, *>}
   */
  var values = {};

  var layerGroup = (options.layers instanceof _layer_Group_js__WEBPACK_IMPORTED_MODULE_22__["default"]) ?
    options.layers : new _layer_Group_js__WEBPACK_IMPORTED_MODULE_22__["default"]({layers: options.layers});
  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].LAYERGROUP] = layerGroup;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].TARGET] = options.target;

  values[_MapProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].VIEW] = options.view !== undefined ?
    options.view : new _View_js__WEBPACK_IMPORTED_MODULE_12__["default"]();

  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.controls.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_14__["assert"])(options.controls instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"],
        47); // Expected `controls` to be an array or an `module:ol/Collection~Collection`
      controls = options.controls;
    }
  }

  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.interactions.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_14__["assert"])(options.interactions instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"],
        48); // Expected `interactions` to be an array or an `module:ol/Collection~Collection`
      interactions = options.interactions;
    }
  }

  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.overlays.slice());
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_14__["assert"])(options.overlays instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"],
        49); // Expected `overlays` to be an array or an `module:ol/Collection~Collection`
      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };

}
/* harmony default export */ __webpack_exports__["default"] = (PluggableMap);

//# sourceMappingURL=PluggableMap.js.map

/***/ }),

/***/ "./node_modules/ol/Tile.js":
/*!*********************************!*\
  !*** ./node_modules/ol/Tile.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/Tile
 */






/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments.
 *
 * @typedef {function(module:ol/Tile, string)} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(module:ol/tilecoord~TileCoord, number,
 *           module:ol/proj/Projection): (string|undefined)} UrlFunction
 * @api
 */


/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */


/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
  */
var Tile = (function (EventTarget) {
  function Tile(tileCoord, state, opt_options) {
    EventTarget.call(this);

    var options = opt_options ? opt_options : {};

    /**
     * @type {module:ol/tilecoord~TileCoord}
     */
    this.tileCoord = tileCoord;

    /**
     * @protected
     * @type {module:ol/TileState}
     */
    this.state = state;

    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {module:ol/Tile}
     */
    this.interimTile = null;

    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */
    this.key = '';

    /**
     * The duration for the opacity transition.
     * @type {number}
     */
    this.transition_ = options.transition === undefined ? 250 : options.transition;

    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object.<number, number>}
     */
    this.transitionStarts_ = {};

  }

  if ( EventTarget ) Tile.__proto__ = EventTarget;
  Tile.prototype = Object.create( EventTarget && EventTarget.prototype );
  Tile.prototype.constructor = Tile;

  /**
   * @protected
   */
  Tile.prototype.changed = function changed () {
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE);
  };

  /**
   * @return {string} Key.
   */
  Tile.prototype.getKey = function getKey () {
    return this.key + '/' + this.tileCoord;
  };

  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!module:ol/Tile} Best tile for rendering.
   */
  Tile.prototype.getInterimTile = function getInterimTile () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }
    var tile = this.interimTile;

    // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)
    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        return tile;
      }
      tile = tile.interimTile;
    } while (tile);

    // we can not find a better tile
    return this;
  };

  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  Tile.prototype.refreshInterimChain = function refreshInterimChain () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev = this;

    do {
      if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }
      tile = prev.interimTile;
    } while (tile);
  };

  /**
   * Get the tile coordinate for this tile.
   * @return {module:ol/tilecoord~TileCoord} The tile coordinate.
   * @api
   */
  Tile.prototype.getTileCoord = function getTileCoord () {
    return this.tileCoord;
  };

  /**
   * @return {module:ol/TileState} State.
   */
  Tile.prototype.getState = function getState () {
    return this.state;
  };

  /**
   * @param {module:ol/TileState} state State.
   */
  Tile.prototype.setState = function setState (state) {
    this.state = state;
    this.changed();
  };

  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  Tile.prototype.load = function load () {};

  /**
   * Get the alpha value for rendering.
   * @param {number} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  Tile.prototype.getAlpha = function getAlpha (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + (1000 / 60); // avoid rendering at 0
    if (delta >= this.transition_) {
      return 1;
    }
    return Object(_easing_js__WEBPACK_IMPORTED_MODULE_1__["easeIn"])(delta / this.transition_);
  };

  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {number} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  Tile.prototype.inTransition = function inTransition (id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  };

  /**
   * Mark a transition as complete.
   * @param {number} id An id for the renderer.
   */
  Tile.prototype.endTransition = function endTransition (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Tile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/TileCache.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileCache.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/TileCache
 */



var TileCache = (function (LRUCache) {
  function TileCache(opt_highWaterMark) {

    LRUCache.call(this, opt_highWaterMark);

  }

  if ( LRUCache ) TileCache.__proto__ = LRUCache;
  TileCache.prototype = Object.create( LRUCache && LRUCache.prototype );
  TileCache.prototype.constructor = TileCache;

  /**
   * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
   */
  TileCache.prototype.expireCache = function expireCache (usedTiles) {
    var this$1 = this;

    while (this.canExpireCache()) {
      var tile = this$1.peekLast();
      var zKey = tile.tileCoord[0].toString();
      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
        break;
      } else {
        this$1.pop().dispose();
      }
    }
  };

  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {
    if (this.getCount() === 0) {
      return;
    }
    var key = this.peekFirstKey();
    var tileCoord = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["fromKey"])(key);
    var z = tileCoord[0];
    this.forEach(function(tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove(Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_1__["getKey"])(tile.tileCoord));
        tile.dispose();
      }
    }, this);
  };

  return TileCache;
}(_structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileCache);

//# sourceMappingURL=TileCache.js.map

/***/ }),

/***/ "./node_modules/ol/TileQueue.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileQueue.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structs/PriorityQueue.js */ "./node_modules/ol/structs/PriorityQueue.js");
/**
 * @module ol/TileQueue
 */






/**
 * @typedef {function(module:ol/Tile, string, module:ol/coordinate~Coordinate, number): number} PriorityFunction
 */


var TileQueue = (function (PriorityQueue) {
  function TileQueue(tilePriorityFunction, tileChangeCallback) {

    PriorityQueue.call(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      this, function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (/** @type {module:ol/Tile} */ (element[0]).getKey());
      });

    /**
     * @private
     * @type {function(): ?}
     */
    this.tileChangeCallback_ = tileChangeCallback;

    /**
     * @private
     * @type {number}
     */
    this.tilesLoading_ = 0;

    /**
     * @private
     * @type {!Object.<string,boolean>}
     */
    this.tilesLoadingKeys_ = {};

  }

  if ( PriorityQueue ) TileQueue.__proto__ = PriorityQueue;
  TileQueue.prototype = Object.create( PriorityQueue && PriorityQueue.prototype );
  TileQueue.prototype.constructor = TileQueue;

  /**
   * @inheritDoc
   */
  TileQueue.prototype.enqueue = function enqueue (element) {
    var added = PriorityQueue.prototype.enqueue.call(this, element);
    if (added) {
      var tile = element[0];
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
    }
    return added;
  };

  /**
   * @return {number} Number of tiles loading.
   */
  TileQueue.prototype.getTilesLoading = function getTilesLoading () {
    return this.tilesLoading_;
  };

  /**
   * @param {module:ol/events/Event} event Event.
   * @protected
   */
  TileQueue.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {module:ol/Tile} */ (event.target);
    var state = tile.getState();
    if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].LOADED || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERROR ||
        state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY || state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlisten"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE, this.handleTileChange, this);
      var tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  };

  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  TileQueue.prototype.loadMoreTiles = function loadMoreTiles (maxTotalLoading, maxNewLoads) {
    var this$1 = this;

    var newLoads = 0;
    var abortedTiles = false;
    var state, tile, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&
           this.getCount() > 0) {
      tile = /** @type {module:ol/Tile} */ (this$1.dequeue()[0]);
      tileKey = tile.getKey();
      state = tile.getState();
      if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABORT) {
        abortedTiles = true;
      } else if (state === _TileState_js__WEBPACK_IMPORTED_MODULE_0__["default"].IDLE && !(tileKey in this$1.tilesLoadingKeys_)) {
        this$1.tilesLoadingKeys_[tileKey] = true;
        ++this$1.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
    if (newLoads === 0 && abortedTiles) {
      // Do not stop the render loop when all wanted tiles were aborted due to
      // a small, saturated tile cache.
      this.tileChangeCallback_();
    }
  };

  return TileQueue;
}(_structs_PriorityQueue_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (TileQueue);

//# sourceMappingURL=TileQueue.js.map

/***/ }),

/***/ "./node_modules/ol/TileRange.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileRange.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange = function TileRange(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;

};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
TileRange.prototype.contains = function contains (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
TileRange.prototype.containsTileRange = function containsTileRange (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&
     this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
TileRange.prototype.containsXY = function containsXY (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
TileRange.prototype.equals = function equals (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY &&
     this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {module:ol/TileRange} tileRange Tile range.
 */
TileRange.prototype.extend = function extend (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
* @return {number} Height.
*/
TileRange.prototype.getHeight = function getHeight () {
  return this.maxY - this.minY + 1;
};

/**
* @return {module:ol/size~Size} Size.
*/
TileRange.prototype.getSize = function getSize () {
  return [this.getWidth(), this.getHeight()];
};

/**
* @return {number} Width.
*/
TileRange.prototype.getWidth = function getWidth () {
  return this.maxX - this.minX + 1;
};

/**
* @param {module:ol/TileRange} tileRange Tile range.
* @return {boolean} Intersects.
*/
TileRange.prototype.intersects = function intersects (tileRange) {
  return this.minX <= tileRange.maxX &&
     this.maxX >= tileRange.minX &&
     this.minY <= tileRange.maxY &&
     this.maxY >= tileRange.minY;
};


/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/TileRange=} tileRange TileRange.
 * @return {module:ol/TileRange} Tile range.
 */
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}


/* harmony default export */ __webpack_exports__["default"] = (TileRange);

//# sourceMappingURL=TileRange.js.map

/***/ }),

/***/ "./node_modules/ol/TileState.js":
/*!**************************************!*\
  !*** ./node_modules/ol/TileState.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
});

//# sourceMappingURL=TileState.js.map

/***/ }),

/***/ "./node_modules/ol/View.js":
/*!*********************************!*\
  !*** ./node_modules/ol/View.js ***!
  \*********************************/
/*! exports provided: createCenterConstraint, createResolutionConstraint, createRotationConstraint, isNoopAnimation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCenterConstraint", function() { return createCenterConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResolutionConstraint", function() { return createResolutionConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRotationConstraint", function() { return createRotationConstraint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNoopAnimation", function() { return isNoopAnimation; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./centerconstraint.js */ "./node_modules/ol/centerconstraint.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolutionconstraint.js */ "./node_modules/ol/resolutionconstraint.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ViewProperty.js */ "./node_modules/ol/ViewProperty.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/View
 */























/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {module:ol/coordinate~Coordinate} [sourceCenter]
 * @property {module:ol/coordinate~Coordinate} [targetCenter]
 * @property {number} [sourceResolution]
 * @property {number} [targetResolution]
 * @property {number} [sourceRotation]
 * @property {number} [targetRotation]
 * @property {module:ol/coordinate~Coordinate} [anchor]
 * @property {number} start
 * @property {number} duration
 * @property {boolean} complete
 * @property {function(number):number} easing
 * @property {function(boolean)} callback
 */


/**
 * @typedef {Object} Constraints
 * @property {module:ol/centerconstraint~Type} center
 * @property {module:ol/resolutionconstraint~Type} resolution
 * @property {module:ol/rotationconstraint~Type} rotation
 */


/**
 * @typedef {Object} FitOptions
 * @property {module:ol/size~Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array.<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [constrainResolution=true] Constrain the resolution.
 * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get
 * the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean)} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */


/**
 * @typedef {Object} ViewOptions
 * @property {module:ol/coordinate~Coordinate} [center] The initial center for
 * the view. The coordinate system for the center is specified with the
 * `projection` option. Layer sources will not be fetched if this is not set,
 * but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {module:ol/extent~Extent} [extent] The extent that constrains the
 * center, in other words, center cannot be set outside this extent.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array.<number>} [resolutions] Resolutions to determine the
 * resolution constraint. If set the `maxResolution`, `minResolution`,
 * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view. The initial
 * resolution is determined using the {@link #constrainResolution} method.
 * @property {number} [zoomFactor=2] The zoom factor used to determine the
 * resolution constraint.
 */


/**
 * @typedef {Object} AnimationOptions
 * @property {module:ol/coordinate~Coordinate|undefined} center The center of the view at the end of
 * the animation.
 * @property {number|undefined} zoom The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number|undefined} resolution The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number|undefined} rotation The rotation of the view at the end of
 * the animation.
 * @property {module:ol/coordinate~Coordinate|undefined} anchor Optional anchor to remained fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */


/**
 * @typedef {Object} State
 * @property {module:ol/coordinate~Coordinate} center
 * @property {module:ol/proj/Projection} projection
 * @property {number} resolution
 * @property {number} rotation
 * @property {number} zoom
 */


/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;


/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But a View object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
  * @api
 */
var View = (function (BaseObject) {
  function View(opt_options) {
    BaseObject.call(this);

    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_18__["assign"])({}, opt_options);

    /**
     * @private
     * @type {Array.<number>}
     */
    this.hints_ = [0, 0];

    /**
     * @private
     * @type {Array.<Array.<module:ol/View~Animation>>}
     */
    this.animations_ = [];

    /**
     * @private
     * @type {number|undefined}
     */
    this.updateAnimationKey_;

    this.updateAnimations_ = this.updateAnimations_.bind(this);

    /**
     * @private
     * @const
     * @type {module:ol/proj/Projection}
     */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__["createProjection"])(options.projection, 'EPSG:3857');

    this.applyOptions_(options);
  }

  if ( BaseObject ) View.__proto__ = BaseObject;
  View.prototype = Object.create( BaseObject && BaseObject.prototype );
  View.prototype.constructor = View;

  /**
   * Set up the view with the given options.
   * @param {module:ol/View~ViewOptions} options View options.
   */
  View.prototype.applyOptions_ = function applyOptions_ (options) {

    /**
     * @type {Object.<string, *>}
     */
    var properties = {};
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER] = options.center !== undefined ?
      options.center : null;

    var resolutionConstraintInfo = createResolutionConstraint(options);

    /**
     * @private
     * @type {number}
     */
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;

    /**
     * @private
     * @type {number}
     */
    this.minResolution_ = resolutionConstraintInfo.minResolution;

    /**
     * @private
     * @type {number}
     */
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

    /**
     * @private
     * @type {Array.<number>|undefined}
     */
    this.resolutions_ = options.resolutions;

    /**
     * @private
     * @type {number}
     */
    this.minZoom_ = resolutionConstraintInfo.minZoom;

    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);

    /**
     * @private
     * @type {module:ol/View~Constraints}
     */
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };

    if (options.resolution !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = options.resolution;
    } else if (options.zoom !== undefined) {
      properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = this.constrainResolution(
        this.maxResolution_, options.zoom - this.minZoom_);

      if (this.resolutions_) { // in case map zoom is out of min/max zoom range
        properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION] = Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["clamp"])(
          Number(this.getResolution() || properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION]),
          this.minResolution_, this.maxResolution_);
      }
    }
    properties[_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION] = options.rotation !== undefined ? options.rotation : 0;
    this.setProperties(properties);

    /**
     * @private
     * @type {module:ol/View~ViewOptions}
     */
    this.options_ = options;

  };

  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {module:ol/View~ViewOptions} newOptions New options to be applied.
   * @return {module:ol/View~ViewOptions} New options updated with the current view state.
   */
  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_ (newOptions) {
    var options = Object(_obj_js__WEBPACK_IMPORTED_MODULE_18__["assign"])({}, this.options_);

    // preserve resolution (or zoom)
    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }

    // preserve center
    options.center = this.getCenter();

    // preserve rotation
    options.rotation = this.getRotation();

    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_18__["assign"])({}, options, newOptions);
  };

  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(module:ol/View~AnimationOptions|function(boolean))} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  View.prototype.animate = function animate (var_args) {
    var arguments$1 = arguments;
    var this$1 = this;

    var animationCount = arguments.length;
    var callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    if (!this.isDef()) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[animationCount - 1];
      if (state.center) {
        this.setCenter(state.center);
      }
      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      }
      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }
      if (callback) {
        setTimeout(function() {
          callback(true);
        }, 0);
      }
      return;
    }
    var start = Date.now();
    var center = this.getCenter().slice();
    var resolution = this.getResolution();
    var rotation = this.getRotation();
    var series = [];
    for (var i = 0; i < animationCount; ++i) {
      var options = /** @type {module:ol/View~AnimationOptions} */ (arguments$1[i]);

      var animation = /** @type {module:ol/View~Animation} */ ({
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing_js__WEBPACK_IMPORTED_MODULE_12__["inAndOut"]
      });

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center;
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this$1.constrainResolution(
          this$1.maxResolution_, options.zoom - this$1.minZoom_, 0);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["modulo"])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }

      animation.callback = callback;

      // check if animation is a no-op
      if (isNoopAnimation(animation)) {
        animation.complete = true;
        // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, 1);
    this.updateAnimations_();
  };

  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  View.prototype.getAnimating = function getAnimating () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING] > 0;
  };

  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  View.prototype.getInteracting = function getInteracting () {
    return this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].INTERACTING] > 0;
  };

  /**
   * Cancel any ongoing animations.
   * @api
   */
  View.prototype.cancelAnimations = function cancelAnimations () {
    var this$1 = this;

    this.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -this.hints_[_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING]);
    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this$1.animations_[i];
      if (series[0].callback) {
        series[0].callback(false);
      }
    }
    this.animations_.length = 0;
  };

  /**
   * Update all animations.
   */
  View.prototype.updateAnimations_ = function updateAnimations_ () {
    var this$1 = this;

    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }
    if (!this.getAnimating()) {
      return;
    }
    var now = Date.now();
    var more = false;
    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this$1.animations_[i];
      var seriesComplete = true;
      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];
        if (animation.complete) {
          continue;
        }
        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        var progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this$1.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, [x, y]);
        }
        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ?
            animation.targetResolution :
            animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            this$1.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this$1.calculateCenterZoom(resolution, animation.anchor));
          }
          this$1.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
        }
        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ?
            Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["modulo"])(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :
            animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            this$1.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER,
              this$1.calculateCenterRotate(rotation, animation.anchor));
          }
          this$1.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
        }
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this$1.animations_[i] = null;
        this$1.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_7__["default"].ANIMATING, -1);
        var callback = series[0].callback;
        if (callback) {
          setTimeout(function() {
            callback(true);
          }, 0);
        }
      }
    }
    // prune completed series
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
    }
  };

  /**
   * @param {number} rotation Target rotation.
   * @param {module:ol/coordinate~Coordinate} anchor Rotation anchor.
   * @return {module:ol/coordinate~Coordinate|undefined} Center for rotation and anchor.
   */
  View.prototype.calculateCenterRotate = function calculateCenterRotate (rotation, anchor) {
    var center;
    var currentCenter = this.getCenter();
    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["rotate"])(center, rotation - this.getRotation());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["add"])(center, anchor);
    }
    return center;
  };

  /**
   * @param {number} resolution Target resolution.
   * @param {module:ol/coordinate~Coordinate} anchor Zoom anchor.
   * @return {module:ol/coordinate~Coordinate|undefined} Center for resolution and anchor.
   */
  View.prototype.calculateCenterZoom = function calculateCenterZoom (resolution, anchor) {
    var center;
    var currentCenter = this.getCenter();
    var currentResolution = this.getResolution();
    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  };

  /**
   * @private
   * @return {module:ol/size~Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_ () {
    var size = [100, 100];
    var selector = '.ol-viewport[data-view="' + Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(this) + '"]';
    var element = document.querySelector(selector);
    if (element) {
      var metrics = getComputedStyle(element);
      size[0] = parseInt(metrics.width, 10);
      size[1] = parseInt(metrics.height, 10);
    }
    return size;
  };

  /**
   * Get the constrained center of this view.
   * @param {module:ol/coordinate~Coordinate|undefined} center Center.
   * @return {module:ol/coordinate~Coordinate|undefined} Constrained center.
   * @api
   */
  View.prototype.constrainCenter = function constrainCenter (center) {
    return this.constraints_.center(center);
  };

  /**
   * Get the constrained resolution of this view.
   * @param {number|undefined} resolution Resolution.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @param {number=} opt_direction Direction. Default is `0`.
   * @return {number|undefined} Constrained resolution.
   * @api
   */
  View.prototype.constrainResolution = function constrainResolution (resolution, opt_delta, opt_direction) {
    var delta = opt_delta || 0;
    var direction = opt_direction || 0;
    return this.constraints_.resolution(resolution, delta, direction);
  };

  /**
   * Get the constrained rotation of this view.
   * @param {number|undefined} rotation Rotation.
   * @param {number=} opt_delta Delta. Default is `0`.
   * @return {number|undefined} Constrained rotation.
   * @api
   */
  View.prototype.constrainRotation = function constrainRotation (rotation, opt_delta) {
    var delta = opt_delta || 0;
    return this.constraints_.rotation(rotation, delta);
  };

  /**
   * Get the view center.
   * @return {module:ol/coordinate~Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  View.prototype.getCenter = function getCenter () {
    return (
      /** @type {module:ol/coordinate~Coordinate|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER))
    );
  };

  /**
   * @return {module:ol/View~Constraints} Constraints.
   */
  View.prototype.getConstraints = function getConstraints () {
    return this.constraints_;
  };

  /**
   * @param {Array.<number>=} opt_hints Destination array.
   * @return {Array.<number>} Hint.
   */
  View.prototype.getHints = function getHints (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };

  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {module:ol/size~Size=} opt_size Box pixel size. If not provided, the size of the
   * first map that uses this view will be used.
   * @return {module:ol/extent~Extent} Extent.
   * @api
   */
  View.prototype.calculateExtent = function calculateExtent (opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var center = /** @type {!module:ol/coordinate~Coordinate} */ (this.getCenter());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(center, 1); // The view center is not defined
    var resolution = /** @type {!number} */ (this.getResolution());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(resolution !== undefined, 2); // The view resolution is not defined
    var rotation = /** @type {!number} */ (this.getRotation());
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(rotation !== undefined, 3); // The view rotation is not defined

    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getForViewAndSize"])(center, resolution, rotation, size);
  };

  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  View.prototype.getMaxResolution = function getMaxResolution () {
    return this.maxResolution_;
  };

  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  View.prototype.getMinResolution = function getMinResolution () {
    return this.minResolution_;
  };

  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  View.prototype.getMaxZoom = function getMaxZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
  };

  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  View.prototype.setMaxZoom = function setMaxZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
  };

  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  View.prototype.getMinZoom = function getMinZoom () {
    return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
  };

  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  View.prototype.setMinZoom = function setMinZoom (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
  };

  /**
   * Get the view projection.
   * @return {module:ol/proj/Projection} The projection of the view.
   * @api
   */
  View.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.getResolution = function getResolution () {
    return /** @type {number|undefined} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION));
  };

  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array.<number>|undefined} The resolutions of the view.
   * @api
   */
  View.prototype.getResolutions = function getResolutions () {
    return this.resolutions_;
  };

  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {module:ol/extent~Extent} extent Extent.
   * @param {module:ol/size~Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  View.prototype.getResolutionForExtent = function getResolutionForExtent (extent, opt_size) {
    var size = opt_size || this.getSizeFromViewport_();
    var xResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent) / size[0];
    var yResolution = Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };

  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Resolution for value function.
   */
  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      });
  };

  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.getRotation = function getRotation () {
    return /** @type {number} */ (this.get(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION));
  };

  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Value for resolution function.
   */
  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.maxResolution_;
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        var value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;
        return value;
      });
  };

  /**
   * @return {module:ol/View~State} View state.
   */
  View.prototype.getState = function getState () {
    var center = /** @type {module:ol/coordinate~Coordinate} */ (this.getCenter());
    var projection = this.getProjection();
    var resolution = /** @type {number} */ (this.getResolution());
    var rotation = this.getRotation();
    return (
      /** @type {module:ol/View~State} */ ({
        center: center.slice(),
        projection: projection !== undefined ? projection : null,
        resolution: resolution,
        rotation: rotation,
        zoom: this.getZoom()
      })
    );
  };

  /**
   * Get the current zoom level.  If you configured your view with a resolutions
   * array (this is rare), this method may return non-integer zoom levels (so
   * the zoom level is not safe to use as an index into a resolutions array).
   * @return {number|undefined} Zoom.
   * @api
   */
  View.prototype.getZoom = function getZoom () {
    var zoom;
    var resolution = this.getResolution();
    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  };

  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  View.prototype.getZoomForResolution = function getZoomForResolution (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;
    if (this.resolutions_) {
      var nearest = Object(_array_js__WEBPACK_IMPORTED_MODULE_9__["linearFindNearest"])(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };

  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  View.prototype.getResolutionForZoom = function getResolutionForZoom (zoom) {
    return /** @type {number} */ (this.constrainResolution(
      this.maxResolution_, zoom - this.minZoom_, 0));
  };

  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {module:ol/geom/SimpleGeometry|module:ol/extent~Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {module:ol/View~FitOptions=} opt_options Options.
   * @api
   */
  View.prototype.fit = function fit (geometryOrExtent, opt_options) {
    var options = opt_options || {};
    var size = options.size;
    if (!size) {
      size = this.getSizeFromViewport_();
    }
    /** @type {module:ol/geom/SimpleGeometry} */
    var geometry;
    if (!(geometryOrExtent instanceof _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_16__["default"])) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(Array.isArray(geometryOrExtent),
        24); // Invalid extent or geometry provided as `geometry`
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_10__["assert"])(!Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(geometryOrExtent),
        25); // Cannot fit empty extent provided as `geometry`
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
    } else if (geometryOrExtent.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_14__["default"].CIRCLE) {
      geometryOrExtent = geometryOrExtent.getExtent();
      geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_15__["fromExtent"])(geometryOrExtent);
      geometry.rotate(this.getRotation(), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getCenter"])(geometryOrExtent));
    } else {
      geometry = geometryOrExtent;
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var constrainResolution = options.constrainResolution !== undefined ?
      options.constrainResolution : true;
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;
    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.constrainResolution(
        this.maxResolution_, options.maxZoom - this.minZoom_, 0);
    } else {
      minResolution = 0;
    }
    var coords = geometry.getFlatCoordinates();

    // calculate rotated extent
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    var stride = geometry.getStride();
    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }

    // calculate resolution
    var resolution = this.getResolutionForExtent(
      [minRotX, minRotY, maxRotX, maxRotY],
      [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution :
      Math.max(resolution, minResolution);
    if (constrainResolution) {
      var constrainedResolution = this.constrainResolution(resolution, 0, 0);
      if (!nearest && constrainedResolution < resolution) {
        constrainedResolution = this.constrainResolution(
          constrainedResolution, -1, 0);
      }
      resolution = constrainedResolution;
    }

    // calculate center
    sinAngle = -sinAngle; // go back to original rotation
    var centerRotX = (minRotX + maxRotX) / 2;
    var centerRotY = (minRotY + maxRotY) / 2;
    centerRotX += (padding[1] - padding[3]) / 2 * resolution;
    centerRotY += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
    var center = [centerX, centerY];
    var callback = options.callback ? options.callback : _functions_js__WEBPACK_IMPORTED_MODULE_2__["UNDEFINED"];

    if (options.duration !== undefined) {
      this.animate({
        resolution: resolution,
        center: center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.setResolution(resolution);
      this.setCenter(center);
      setTimeout(callback.bind(undefined, true), 0);
    }
  };

  /**
   * Center on coordinate and view position.
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @param {module:ol/size~Size} size Box pixel size.
   * @param {module:ol/pixel~Pixel} position Position on the view to center on.
   * @api
   */
  View.prototype.centerOn = function centerOn (coordinate, size, position) {
    // calculate rotated position
    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    var resolution = this.getResolution();
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;

    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;

    this.setCenter([centerX, centerY]);
  };

  /**
   * @return {boolean} Is defined.
   */
  View.prototype.isDef = function isDef () {
    return !!this.getCenter() && this.getResolution() !== undefined;
  };

  /**
   * Rotate the view around a given coordinate.
   * @param {number} rotation New rotation value for the view.
   * @param {module:ol/coordinate~Coordinate=} opt_anchor The rotation center.
   * @api
   */
  View.prototype.rotate = function rotate (rotation, opt_anchor) {
    if (opt_anchor !== undefined) {
      var center = this.calculateCenterRotate(rotation, opt_anchor);
      this.setCenter(center);
    }
    this.setRotation(rotation);
  };

  /**
   * Set the center of the current view.
   * @param {module:ol/coordinate~Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  View.prototype.setCenter = function setCenter (center) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].CENTER, center);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * @param {module:ol/ViewHint} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  View.prototype.setHint = function setHint (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };

  /**
   * Set the resolution for this view.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  View.prototype.setResolution = function setResolution (resolution) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].RESOLUTION, resolution);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Set the rotation for this view.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  View.prototype.setRotation = function setRotation (rotation) {
    this.set(_ViewProperty_js__WEBPACK_IMPORTED_MODULE_8__["default"].ROTATION, rotation);
    if (this.getAnimating()) {
      this.cancelAnimations();
    }
  };

  /**
   * Zoom to a specific zoom level.
   * @param {number} zoom Zoom level.
   * @api
   */
  View.prototype.setZoom = function setZoom (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };

  return View;
}(_Object_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {module:ol/View~ViewOptions} options View options.
 * @return {module:ol/centerconstraint~Type} The constraint.
 */
function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    return Object(_centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["createExtent"])(options.extent);
  } else {
    return _centerconstraint_js__WEBPACK_IMPORTED_MODULE_3__["none"];
  }
}


/**
 * @param {module:ol/View~ViewOptions} options View options.
 * @return {{constraint: module:ol/resolutionconstraint~Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */
function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;

  var minZoom = options.minZoom !== undefined ?
    options.minZoom : DEFAULT_MIN_ZOOM;

  var maxZoom = options.maxZoom !== undefined ?
    options.maxZoom : defaultMaxZoom;

  var zoomFactor = options.zoomFactor !== undefined ?
    options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ?
      resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToResolutions"])(
      resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_19__["createProjection"])(options.projection, 'EPSG:3857');
    var extent = projection.getExtent();
    var size = !extent ?
      // use an extent that can fit the whole world if need be
      360 * _proj_js__WEBPACK_IMPORTED_MODULE_19__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_20__["default"].DEGREES] /
            projection.getMetersPerUnit() :
      Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getWidth"])(extent), Object(_extent_js__WEBPACK_IMPORTED_MODULE_13__["getHeight"])(extent));

    var defaultMaxResolution = size / _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] / Math.pow(
      defaultZoomFactor, DEFAULT_MIN_ZOOM);

    var defaultMinResolution = defaultMaxResolution / Math.pow(
      defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    resolutionConstraint = Object(_resolutionconstraint_js__WEBPACK_IMPORTED_MODULE_5__["createSnapToPower"])(
      zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return {constraint: resolutionConstraint, maxResolution: maxResolution,
    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};
}


/**
 * @param {module:ol/View~ViewOptions} options View options.
 * @return {module:ol/rotationconstraint~Type} Rotation constraint.
 */
function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ?
    options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToZero"])();
    } else if (constrainRotation === false) {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    } else if (typeof constrainRotation === 'number') {
      return Object(_rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["createSnapToN"])(constrainRotation);
    } else {
      return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["none"];
    }
  } else {
    return _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_6__["disable"];
  }
}


/**
 * Determine if an animation involves no view change.
 * @param {module:ol/View~Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_11__["equals"])(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}

/* harmony default export */ __webpack_exports__["default"] = (View);

//# sourceMappingURL=View.js.map

/***/ }),

/***/ "./node_modules/ol/ViewHint.js":
/*!*************************************!*\
  !*** ./node_modules/ol/ViewHint.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ANIMATING: 0,
  INTERACTING: 1
});

//# sourceMappingURL=ViewHint.js.map

/***/ }),

/***/ "./node_modules/ol/ViewProperty.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/ViewProperty.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
});

//# sourceMappingURL=ViewProperty.js.map

/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/*! exports provided: binarySearch, numberSafeCompareFunction, includes, linearFindNearest, reverseSubArray, extend, remove, find, equals, stableSort, findIndex, isSorted */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearch", function() { return binarySearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberSafeCompareFunction", function() { return numberSafeCompareFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearFindNearest", function() { return linearFindNearest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverseSubArray", function() { return reverseSubArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stableSort", function() { return stableSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSorted", function() { return isSorted; });
/**
 * @module ol/array
 */


/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) { /* Too low. */
      low = mid + 1;

    } else { /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}


/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}


/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}


/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
}


/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}


/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {!Array.<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}


/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}


/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */
function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
}


/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}


/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */
function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}


/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
function findIndex(arr, func) {
  var index;
  var found = !arr.every(function(el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}


/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}

//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssertionError.js */ "./node_modules/ol/AssertionError.js");
/**
 * @module ol/asserts
 */


/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__["default"](errorCode);
  }
}

//# sourceMappingURL=asserts.js.map

/***/ }),

/***/ "./node_modules/ol/centerconstraint.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/centerconstraint.js ***!
  \*********************************************/
/*! exports provided: createExtent, none */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent", function() { return createExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/centerconstraint
 */



/**
 * @typedef {function((module:ol/coordinate~Coordinate|undefined)): (module:ol/coordinate~Coordinate|undefined)} Type
 */


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/centerconstraint~Type} The constraint.
 */
function createExtent(extent) {
  return (
    /**
     * @param {module:ol/coordinate~Coordinate=} center Center.
     * @return {module:ol/coordinate~Coordinate|undefined} Center.
     */
    function(center) {
      if (center) {
        return [
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[0], extent[0], extent[2]),
          Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["clamp"])(center[1], extent[1], extent[3])
        ];
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {module:ol/coordinate~Coordinate=} center Center.
 * @return {module:ol/coordinate~Coordinate|undefined} Center.
 */
function none(center) {
  return center;
}

//# sourceMappingURL=centerconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/color.js":
/*!**********************************!*\
  !*** ./node_modules/ol/color.js ***!
  \**********************************/
/*! exports provided: asString, fromString, asArray, normalize, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asString", function() { return asString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asArray", function() { return asArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/color
 */




/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array.<number>} Color
 * @api
 */


/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;


/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
var NAMED_COLOR_RE_ = /^([a-z]*)$/i;


/**
 * Return the color as an rgba string.
 * @param {module:ol/color~Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;
  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}


/**
 * @param {string} s String.
 * @return {module:ol/color~Color} Color.
 */
var fromString = (
  function() {

    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.

    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;

    /**
     * @type {Object.<string, module:ol/color~Color>}
     */
    var cache = {};

    /**
     * @type {number}
     */
    var cacheSize = 0;

    return (
      /**
       * @param {string} s String.
       * @return {module:ol/color~Color} Color.
       */
      function(s) {
        var color;
        if (cache.hasOwnProperty(s)) {
          color = cache[s];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            var i = 0;
            for (var key in cache) {
              if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
              }
            }
          }
          color = fromStringInternal_(s);
          cache[s] = color;
          ++cacheSize;
        }
        return color;
      }
    );

  })();

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {module:ol/color~Color|string} color Color.
 * @return {module:ol/color~Color} Color.
 * @api
 */
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(/** @type {string} */ (color));
  }
}

/**
 * @param {string} s String.
 * @private
 * @return {module:ol/color~Color} Color.
 */
function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) { // hex
    var n = s.length - 1; // number of hex digits
    var d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) { // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) { // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 14); // Invalid color
  }
  return (
    /** @type {module:ol/color~Color} */ (color)
  );
}


/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {module:ol/color~Color} color Color.
 * @return {module:ol/color~Color} Clamped color.
 */
function normalize(color) {
  color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[0] + 0.5) | 0, 0, 255);
  color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[1] + 0.5) | 0, 0, 255);
  color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])((color[2] + 0.5) | 0, 0, 255);
  color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(color[3], 0, 1);
  return color;
}


/**
 * @param {module:ol/color~Color} color Color.
 * @return {string} String.
 */
function toString(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = (r + 0.5) | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = (g + 0.5) | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = (b + 0.5) | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}

//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/ol/colorlike.js":
/*!**************************************!*\
  !*** ./node_modules/ol/colorlike.js ***!
  \**************************************/
/*! exports provided: asColorLike, isColorLike */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asColorLike", function() { return asColorLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isColorLike", function() { return isColorLike; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/colorlike
 */



/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */


/**
 * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
 * @return {module:ol/colorlike~ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (isColorLike(color)) {
    return /** @type {string|CanvasPattern|CanvasGradient} */ (color);
  } else {
    return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["toString"])(/** @type {module:ol/color~Color} */ (color));
  }
}


/**
 * @param {?} color The value that is potentially an {@link ol/colorlike~ColorLike}.
 * @return {boolean} The color is an {@link ol/colorlike~ColorLike}.
 */
function isColorLike(color) {
  return (
    typeof color === 'string' ||
    color instanceof CanvasPattern ||
    color instanceof CanvasGradient
  );
}

//# sourceMappingURL=colorlike.js.map

/***/ }),

/***/ "./node_modules/ol/control/Attribution.js":
/*!************************************************!*\
  !*** ./node_modules/ol/control/Attribution.js ***!
  \************************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _control_Control_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../control/Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/**
 * @module ol/control/Attribution
 */









/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible=true] Specify if attributions can
 * be collapsed. If you use an OSM source, should be set to `false` — see
 * {@link https://www.openstreetmap.org/copyright OSM Copyright} —
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {function(module:ol/MapEvent)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */


/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution = (function (Control) {
  function Attribution(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    /**
     * @private
     * @type {HTMLElement}
     */
    this.ulElement_ = document.createElement('UL');

    /**
     * @private
     * @type {boolean}
     */
    this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

    /**
     * @private
     * @type {boolean}
     */
    this.collapsible_ = options.collapsible !== undefined ?
      options.collapsible : true;

    if (!this.collapsible_) {
      this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';

    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.collapseLabel_ = document.createElement('span');
      this.collapseLabel_.textContent = collapseLabel;
    } else {
      this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      this.label_ = document.createElement('span');
      this.label_.textContent = label;
    } else {
      this.label_ = label;
    }


    var activeLabel = (this.collapsible_ && !this.collapsed_) ?
      this.collapseLabel_ : this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_CONTROL"] +
        (this.collapsed_ && this.collapsible_ ? ' ' + _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"] : '') +
        (this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(this.ulElement_);
    element.appendChild(button);

    /**
     * A list of currently rendered resolutions.
     * @type {Array.<string>}
     * @private
     */
    this.renderedAttributions_ = [];

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

  }

  if ( Control ) Attribution.__proto__ = Control;
  Attribution.prototype = Object.create( Control && Control.prototype );
  Attribution.prototype.constructor = Attribution;

  /**
   * Get a list of visible attributions.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @return {Array.<string>} Attributions.
   * @private
   */
  Attribution.prototype.getSourceAttributions_ = function getSourceAttributions_ (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object.<string, boolean>}
     */
    var lookup = {};

    /**
     * A list of visible attributions.
     * @type {Array.<string>}
     */
    var visibleAttributions = [];

    var layerStatesArray = frameState.layerStatesArray;
    var resolution = frameState.viewState.resolution;
    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, resolution)) {
        continue;
      }

      var source = layerState.layer.getSource();
      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();
      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);
      if (!attributions) {
        continue;
      }

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }
    return visibleAttributions;
  };

  /**
   * @private
   * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.
   */
  Attribution.prototype.updateElement_ = function updateElement_ (frameState) {
    var this$1 = this;

    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var attributions = this.getSourceAttributions_(frameState);

    var visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if (Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(attributions, this.renderedAttributions_)) {
      return;
    }

    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeChildren"])(this.ulElement_);

    // append the attributions
    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('LI');
      element.innerHTML = attributions[i];
      this$1.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Attribution.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    this.handleToggle_();
  };

  /**
   * @private
   */
  Attribution.prototype.handleToggle_ = function handleToggle_ () {
    this.element.classList.toggle(_css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_COLLAPSED"]);
    if (this.collapsed_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.collapseLabel_, this.label_);
    } else {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["replaceNode"])(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
  };

  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.getCollapsible = function getCollapsible () {
    return this.collapsible_;
  };

  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  Attribution.prototype.setCollapsible = function setCollapsible (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');
    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };

  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.setCollapsed = function setCollapsed (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  };

  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  Attribution.prototype.getCollapsed = function getCollapsed () {
    return this.collapsed_;
  };

  return Attribution;
}(_control_Control_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Update the attribution element.
 * @param {module:ol/MapEvent} mapEvent Map event.
 * @this {module:ol/control/Attribution}
 * @api
 */
function render(mapEvent) {
  this.updateElement_(mapEvent.frameState);
}


/* harmony default export */ __webpack_exports__["default"] = (Attribution);

//# sourceMappingURL=Attribution.js.map

/***/ }),

/***/ "./node_modules/ol/control/Control.js":
/*!********************************************!*\
  !*** ./node_modules/ol/control/Control.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapEventType.js */ "./node_modules/ol/MapEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/control/Control
 */







/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(module:ol/MapEvent)} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control = (function (BaseObject) {
  function Control(options) {

    BaseObject.call(this);

    /**
     * @protected
     * @type {HTMLElement}
     */
    this.element = options.element ? options.element : null;

    /**
     * @private
     * @type {HTMLElement}
     */
    this.target_ = null;

    /**
     * @private
     * @type {module:ol/PluggableMap}
     */
    this.map_ = null;

    /**
     * @protected
     * @type {!Array.<module:ol/events~EventsKey>}
     */
    this.listenerKeys = [];

    /**
     * @type {function(module:ol/MapEvent)}
     */
    this.render = options.render ? options.render : _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];

    if (options.target) {
      this.setTarget(options.target);
    }

  }

  if ( BaseObject ) Control.__proto__ = BaseObject;
  Control.prototype = Object.create( BaseObject && BaseObject.prototype );
  Control.prototype.constructor = Control;

  /**
   * @inheritDoc
   */
  Control.prototype.disposeInternal = function disposeInternal () {
    Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    BaseObject.prototype.disposeInternal.call(this);
  };

  /**
   * Get the map associated with this control.
   * @return {module:ol/PluggableMap} Map.
   * @api
   */
  Control.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {module:ol/PluggableMap} map Map.
   * @api
   */
  Control.prototype.setMap = function setMap (map) {
    var this$1 = this;

    if (this.map_) {
      Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["removeNode"])(this.element);
    }
    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"])(this$1.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (this.map_) {
      var target = this.target_ ?
        this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"]) {
        this.listenerKeys.push(Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(map,
          _MapEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POSTRENDER, this.render, this));
      }
      map.render();
    }
  };

  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  Control.prototype.setTarget = function setTarget (target) {
    this.target_ = typeof target === 'string' ?
      document.getElementById(target) :
      target;
  };

  return Control;
}(_Object_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Control);

//# sourceMappingURL=Control.js.map

/***/ }),

/***/ "./node_modules/ol/control/Rotate.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/control/Rotate.js ***!
  \*******************************************/
/*! exports provided: render, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _control_Control_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../control/Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/control/Rotate
 */







/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(module:ol/MapEvent)} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function()} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate = (function (Control) {
  function Rotate(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      render: options.render || render,
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-rotate';

    var label = options.label !== undefined ? options.label : '\u21E7';

    /**
     * @type {HTMLElement}
     * @private
     */
    this.label_ = null;

    if (typeof label === 'string') {
      this.label_ = document.createElement('span');
      this.label_.className = 'ol-compass';
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add('ol-compass');
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(this.label_);

    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(button, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CLICK, this.handleClick_, this);

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(button);

    this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @type {boolean}
     * @private
     */
    this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    if (this.autoHide_) {
      this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
    }

  }

  if ( Control ) Rotate.__proto__ = Control;
  Rotate.prototype = Object.create( Control && Control.prototype );
  Rotate.prototype.constructor = Rotate;

  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Rotate.prototype.handleClick_ = function handleClick_ (event) {
    event.preventDefault();
    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };

  /**
   * @private
   */
  Rotate.prototype.resetNorth_ = function resetNorth_ () {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    if (view.getRotation() !== undefined) {
      if (this.duration_ > 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
        });
      } else {
        view.setRotation(0);
      }
    }
  };

  return Rotate;
}(_control_Control_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Update the rotate control element.
 * @param {module:ol/MapEvent} mapEvent Map event.
 * @this {module:ol/control/Rotate}
 * @api
 */
function render(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';
    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      if (!contains && rotation === 0) {
        this.element.classList.add(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css_js__WEBPACK_IMPORTED_MODULE_1__["CLASS_HIDDEN"]);
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (Rotate);

//# sourceMappingURL=Rotate.js.map

/***/ }),

/***/ "./node_modules/ol/control/Zoom.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/Zoom.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _control_Control_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../control/Control.js */ "./node_modules/ol/control/Control.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/**
 * @module ol/control/Zoom
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */


/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom = (function (Control) {
  function Zoom(opt_options) {

    var options = opt_options ? opt_options : {};

    Control.call(this, {
      element: document.createElement('div'),
      target: options.target
    });

    var className = options.className !== undefined ? options.className : 'ol-zoom';

    var delta = options.delta !== undefined ? options.delta : 1;

    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

    var zoomInTipLabel = options.zoomInTipLabel !== undefined ?
      options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?
      options.zoomOutTipLabel : 'Zoom out';

    var inElement = document.createElement('button');
    inElement.className = className + '-in';
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(inElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, delta));

    var outElement = document.createElement('button');
    outElement.className = className + '-out';
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(outElement, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CLICK, this.handleClick_.bind(this, -delta));

    var cssClasses = className + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_UNSELECTABLE"] + ' ' + _css_js__WEBPACK_IMPORTED_MODULE_3__["CLASS_CONTROL"];
    var element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);

    /**
     * @type {number}
     * @private
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Control ) Zoom.__proto__ = Control;
  Zoom.prototype = Object.create( Control && Control.prototype );
  Zoom.prototype.constructor = Zoom;

  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  Zoom.prototype.handleClick_ = function handleClick_ (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };

  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  Zoom.prototype.zoomByDelta_ = function zoomByDelta_ (delta) {
    var map = this.getMap();
    var view = map.getView();
    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }
    var currentResolution = view.getResolution();
    if (currentResolution) {
      var newResolution = view.constrainResolution(currentResolution, delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          resolution: newResolution,
          duration: this.duration_,
          easing: _easing_js__WEBPACK_IMPORTED_MODULE_4__["easeOut"]
        });
      } else {
        view.setResolution(newResolution);
      }
    }
  };

  return Zoom;
}(_control_Control_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Zoom);

//# sourceMappingURL=Zoom.js.map

/***/ }),

/***/ "./node_modules/ol/control/util.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/control/util.js ***!
  \*****************************************/
/*! exports provided: defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Attribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Attribution.js */ "./node_modules/ol/control/Attribution.js");
/* harmony import */ var _Rotate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rotate.js */ "./node_modules/ol/control/Rotate.js");
/* harmony import */ var _Zoom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Zoom.js */ "./node_modules/ol/control/Zoom.js");
/**
 * @module ol/control/util
 */






/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {module:ol/control/Attribution~Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {module:ol/control/Rotate~Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {module:ol/control/Zoom~Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */


/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {module:ol/control/util~DefaultsOptions=} opt_options
 * Defaults options.
 * @return {module:ol/Collection.<module:ol/control/Control>}
 * Controls.
 * @function module:ol/control.defaults
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var controls = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _Zoom_js__WEBPACK_IMPORTED_MODULE_3__["default"](options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _Rotate_js__WEBPACK_IMPORTED_MODULE_2__["default"](options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ?
    options.attribution : true;
  if (attributionControl) {
    controls.push(new _Attribution_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.attributionOptions));
  }

  return controls;
}

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/*! exports provided: add, closestOnCircle, closestOnSegment, createStringXY, degreesToStringHDMS, format, equals, rotate, scale, squaredDistance, distance, squaredDistanceToSegment, toStringHDMS, toStringXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnCircle", function() { return closestOnCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestOnSegment", function() { return closestOnSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStringXY", function() { return createStringXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesToStringHDMS", function() { return degreesToStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "format", function() { return format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistanceToSegment", function() { return squaredDistanceToSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringHDMS", function() { return toStringHDMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toStringXY", function() { return toStringXY; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array.<number>} Coordinate
 * @api
 */


/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((module:ol/coordinate~Coordinate|undefined)): string} CoordinateFormat
 * @api
 */


/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/coordinate~Coordinate} delta Delta.
 * @return {module:ol/coordinate~Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
}


/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
 * @param {module:ol/geom/Circle} circle The circle.
 * @return {module:ol/coordinate~Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];

  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);

  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;

  return [x, y];
}


/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
 * @param {Array.<module:ol/coordinate~Coordinate>} segment The two coordinates
 * of the segment.
 * @return {module:ol/coordinate~Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = (dx === 0 && dy === 0) ? 0 :
    ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}


/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {module:ol/coordinate~Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {module:ol/coordinate~CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}


/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["modulo"])(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - (deg * 3600) - (min * 60);
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(min, 2) + '\u2032 ' +
    Object(_string_js__WEBPACK_IMPORTED_MODULE_1__["padNumber"])(sec, 2, dflPrecision) + '\u2033' +
    (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}


/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
      .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}


/**
 * @param {module:ol/coordinate~Coordinate} coordinate1 First coordinate.
 * @param {module:ol/coordinate~Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}


/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}


/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}


/**
 * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.
 * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}


/**
 * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.
 * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}


/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate of the point.
 * @param {Array.<module:ol/coordinate~Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate,
    closestOnSegment(coordinate, segment));
}


/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' +
        degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}


/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}

//# sourceMappingURL=coordinate.js.map

/***/ }),

/***/ "./node_modules/ol/css.js":
/*!********************************!*\
  !*** ./node_modules/ol/css.js ***!
  \********************************/
/*! exports provided: CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, getFontFamilies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_HIDDEN", function() { return CLASS_HIDDEN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_SELECTABLE", function() { return CLASS_SELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSELECTABLE", function() { return CLASS_UNSELECTABLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_UNSUPPORTED", function() { return CLASS_UNSUPPORTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_CONTROL", function() { return CLASS_CONTROL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLASS_COLLAPSED", function() { return CLASS_COLLAPSED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFontFamilies", function() { return getFontFamilies; });
/**
 * @module ol/css
 */


/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';


/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
var CLASS_SELECTABLE = 'ol-selectable';


/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSELECTABLE = 'ol-unselectable';


/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
var CLASS_UNSUPPORTED = 'ol-unsupported';


/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
var CLASS_CONTROL = 'ol-control';


/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */
var CLASS_COLLAPSED = 'ol-collapsed';


/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object.<string>} The font families (or null if the input spec is invalid).
 */
var getFontFamilies = (function() {
  var style;
  var cache = {};
  return function(font) {
    if (!style) {
      style = document.createElement('div').style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
})();

//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/ol/dom.js":
/*!********************************!*\
  !*** ./node_modules/ol/dom.js ***!
  \********************************/
/*! exports provided: createCanvasContext2D, outerWidth, outerHeight, replaceNode, removeNode, removeChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvasContext2D", function() { return createCanvasContext2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerWidth", function() { return outerWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerHeight", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replaceNode", function() { return replaceNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeNode", function() { return removeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/**
 * @module ol/dom
 */


/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height) {
  var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
}


/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */
function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
}


/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */
function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
}

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}

/**
 * @param {Node} node The node to remove the children from.
 */
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}

//# sourceMappingURL=dom.js.map

/***/ }),

/***/ "./node_modules/ol/easing.js":
/*!***********************************!*\
  !*** ./node_modules/ol/easing.js ***!
  \***********************************/
/*! exports provided: easeIn, easeOut, inAndOut, linear, upAndDown */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inAndOut", function() { return inAndOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upAndDown", function() { return upAndDown; });
/**
 * @module ol/easing
 */


/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}


/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeOut(t) {
  return 1 - easeIn(1 - t);
}


/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}


/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function linear(t) {
  return t;
}


/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}

//# sourceMappingURL=easing.js.map

/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/*! exports provided: bindListener, findListener, getListeners, listen, listenOnce, unlisten, unlistenByKey, unlistenAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindListener", function() { return bindListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findListener", function() { return findListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getListeners", function() { return getListeners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listen", function() { return listen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "listenOnce", function() { return listenOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlisten", function() { return unlisten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenByKey", function() { return unlistenByKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unlistenAll", function() { return unlistenAll; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */



/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {Object} [bindTo]
 * @property {module:ol/events~ListenerFunction} [boundListener]
 * @property {boolean} callOnce
 * @property {number} [deleteIndex]
 * @property {module:ol/events~ListenerFunction} listener
 * @property {EventTarget|module:ol/events/EventTarget} target
 * @property {string} type
 * @api
 */


/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function(module:ol/events/Event)|function(module:ol/events/Event): boolean} ListenerFunction
 * @api
 */


/**
 * @param {module:ol/events~EventsKey} listenerObj Listener object.
 * @return {module:ol/events~ListenerFunction} Bound listener.
 */
function bindListener(listenerObj) {
  var boundListener = function(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
}


/**
 * Finds the matching {@link module:ol/events~EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!module:ol/events~EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link module:ol/events~unlistenByKey}.
 * @return {module:ol/events~EventsKey|undefined} The matching listener object.
 */
function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener &&
        listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
}


/**
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<module:ol/events~EventsKey>|undefined} Listeners.
 */
function getListeners(target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
}


/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @return {!Object.<string, Array.<module:ol/events~EventsKey>>} Map of
 *     listeners by event type.
 */
function getListenerMap(target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
}


/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 * @param {string} type Type.
 */
function removeListeners(target, type) {
  var listeners = getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
}


/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {module:ol/events~EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  var listenerMap = getListenerMap(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = findListener(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {module:ol/events~EventsKey} */ ({
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    });
    target.addEventListener(type, bindListener(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
}


/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {module:ol/events~EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}


/**
 * Unregisters an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link module:ol/events~listen} call.
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {module:ol/events~ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
function unlisten(target, type, listener, opt_this) {
  var listeners = getListeners(target, type);
  if (listeners) {
    var listenerObj = findListener(listeners, listener, opt_this, true);
    if (listenerObj) {
      unlistenByKey(listenerObj);
    }
  }
}


/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {module:ol/events~EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        removeListeners(key.target, key.type);
      }
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["clear"])(key);
  }
}


/**
 * Unregisters all event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
 */
function unlistenAll(target) {
  var listenerMap = getListenerMap(target);
  for (var type in listenerMap) {
    removeListeners(target, type);
  }
}

//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/*! exports provided: stopPropagation, preventDefault, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopPropagation", function() { return stopPropagation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preventDefault", function() { return preventDefault; });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/EventTarget~EventTarget}.
 */
var Event = function Event(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.preventDefault = function preventDefault () {
  this.propagationStopped = true;
};

/**
 * Stop event propagation.
 * @function
 * @api
 */
Event.prototype.stopPropagation = function stopPropagation () {
  this.propagationStopped = true;
};


/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}


/**
 * @param {Event|module:ol/events/Event} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ __webpack_exports__["default"] = (Event);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/events/EventTarget.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/events/EventTarget.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/events/EventTarget
 */






/**
 * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike
 */


/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var EventTarget = (function (Disposable) {
  function EventTarget() {

    Disposable.call(this);

    /**
     * @private
     * @type {!Object.<string, number>}
     */
    this.pendingRemovals_ = {};

    /**
     * @private
     * @type {!Object.<string, number>}
     */
    this.dispatching_ = {};

    /**
     * @private
     * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}
     */
    this.listeners_ = {};

  }

  if ( Disposable ) EventTarget.__proto__ = Disposable;
  EventTarget.prototype = Object.create( Disposable && Disposable.prototype );
  EventTarget.prototype.constructor = EventTarget;

  /**
   * @param {string} type Type.
   * @param {module:ol/events~ListenerFunction} listener Listener.
   */
  EventTarget.prototype.addEventListener = function addEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (!listeners) {
      listeners = this.listeners_[type] = [];
    }
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
  };

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {{type: string,
   *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|
   *     module:ol/events/Event|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @function
   * @api
   */
  EventTarget.prototype.dispatchEvent = function dispatchEvent (event) {
    var this$1 = this;

    var evt = typeof event === 'string' ? new _events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"](event) : event;
    var type = evt.type;
    evt.target = this;
    var listeners = this.listeners_[type];
    var propagate;
    if (listeners) {
      if (!(type in this.dispatching_)) {
        this.dispatching_[type] = 0;
        this.pendingRemovals_[type] = 0;
      }
      ++this.dispatching_[type];
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if (listeners[i].call(this$1, evt) === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      --this.dispatching_[type];
      if (this.dispatching_[type] === 0) {
        var pendingRemovals = this.pendingRemovals_[type];
        delete this.pendingRemovals_[type];
        while (pendingRemovals--) {
          this$1.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__["UNDEFINED"]);
        }
        delete this.dispatching_[type];
      }
      return propagate;
    }
  };

  /**
   * @inheritDoc
   */
  EventTarget.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenAll"])(this);
  };

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array.<module:ol/events~ListenerFunction>} Listeners.
   */
  EventTarget.prototype.getListeners = function getListeners (type) {
    return this.listeners_[type];
  };

  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this EventTarget has any listeners.
   * @return {boolean} Has listeners.
   */
  EventTarget.prototype.hasListener = function hasListener (opt_type) {
    return opt_type ?
      opt_type in this.listeners_ :
      Object.keys(this.listeners_).length > 0;
  };

  /**
   * @param {string} type Type.
   * @param {module:ol/events~ListenerFunction} listener Listener.
   */
  EventTarget.prototype.removeEventListener = function removeEventListener (type, listener) {
    var listeners = this.listeners_[type];
    if (listeners) {
      var index = listeners.indexOf(listener);
      if (type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__["UNDEFINED"];
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  };

  return EventTarget;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (EventTarget);

//# sourceMappingURL=EventTarget.js.map

/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/events/KeyCode.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/events/KeyCode.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});

//# sourceMappingURL=KeyCode.js.map

/***/ }),

/***/ "./node_modules/ol/events/condition.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/condition.js ***!
  \*********************************************/
/*! exports provided: altKeyOnly, altShiftKeysOnly, focus, always, click, mouseActionButton, never, pointerMove, singleClick, doubleClick, noModifierKeys, platformModifierKeyOnly, shiftKeyOnly, targetNotEditable, mouseOnly, primaryAction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altKeyOnly", function() { return altKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "altShiftKeysOnly", function() { return altShiftKeysOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "focus", function() { return focus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "always", function() { return always; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseActionButton", function() { return mouseActionButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "never", function() { return never; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointerMove", function() { return pointerMove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "singleClick", function() { return singleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "doubleClick", function() { return doubleClick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noModifierKeys", function() { return noModifierKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platformModifierKeyOnly", function() { return platformModifierKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shiftKeyOnly", function() { return shiftKeyOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetNotEditable", function() { return targetNotEditable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mouseOnly", function() { return mouseOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "primaryAction", function() { return primaryAction; });
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/**
 * @module ol/events/condition
 */






/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, module:ol/MapBrowserEvent): boolean} Condition
 */


/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
var altKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
var altShiftKeysOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return (
    originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {module:ol/MapBrowserEvent} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */
var focus = function(event) {
  return event.target.getTargetElement() === document.activeElement;
};


/**
 * Return always true.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */
var always = _functions_js__WEBPACK_IMPORTED_MODULE_2__["TRUE"];


/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CLICK;
};


/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
var mouseActionButton = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 &&
      !(_has_js__WEBPACK_IMPORTED_MODULE_3__["WEBKIT"] && _has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] && originalEvent.ctrlKey);
};


/**
 * Return always false.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */
var never = _functions_js__WEBPACK_IMPORTED_MODULE_2__["FALSE"];


/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};


/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].SINGLECLICK;
};


/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK;
};


/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
var noModifierKeys = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      !originalEvent.shiftKey);
};


/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
var platformModifierKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey &&
    (_has_js__WEBPACK_IMPORTED_MODULE_3__["MAC"] ? originalEvent.metaKey : originalEvent.ctrlKey) &&
    !originalEvent.shiftKey;
};


/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
var shiftKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return (
    !originalEvent.altKey &&
      !(originalEvent.metaKey || originalEvent.ctrlKey) &&
      originalEvent.shiftKey);
};


/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
var targetNotEditable = function(mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return (
    tagName !== 'INPUT' &&
      tagName !== 'SELECT' &&
      tagName !== 'TEXTAREA');
};


/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
var mouseOnly = function(mapBrowserEvent) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return (
    /** @type {module:ol/MapBrowserEvent} */ (mapBrowserEvent).pointerEvent.pointerType == 'mouse'
  );
};


/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See http://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
var primaryAction = function(mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

//# sourceMappingURL=condition.js.map

/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/*! exports provided: boundingExtent, buffer, clone, closestSquaredDistanceXY, containsCoordinate, containsExtent, containsXY, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, createOrUpdateFromCoordinate, createOrUpdateFromCoordinates, createOrUpdateFromFlatCoordinates, createOrUpdateFromRings, equals, extend, extendCoordinate, extendCoordinates, extendFlatCoordinates, extendRings, extendXY, forEachCorner, getArea, getBottomLeft, getBottomRight, getCenter, getCorner, getEnlargedArea, getForViewAndSize, getHeight, getIntersectionArea, getIntersection, getMargin, getSize, getTopLeft, getTopRight, getWidth, intersects, isEmpty, returnOrUpdate, scaleFromCenter, intersectsSegment, applyTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */





/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array.<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @private
 * @return {module:ol/extent~Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}


/**
 * Return extent increased by the provided value.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [
      extent[0] - value,
      extent[1] - value,
      extent[2] + value,
      extent[3] + value
    ];
  }
}


/**
 * Creates a clone of an extent.
 *
 * @param {module:ol/extent~Extent} extent Extent to clone.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} The clone.
 */
function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}


/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
      extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}


/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}


/**
 * Get the relationship between a coordinate and extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
 * @return {module:ol/extent/Relationship} The relationship (bitwise compare with
 *     module:ol/extent/Relationship~Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING;
  }
  return relationship;
}


/**
 * Create an empty extent.
 * @return {module:ol/extent~Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}


/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}


/**
 * Create a new empty extent or make the provided one empty.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(
    Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}


/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}


/**
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}


/**
 * Determine if two extents are equivalent.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
      extent1[1] == extent2[1] && extent1[3] == extent2[3];
}


/**
 * Modify an extent to include another extent.
 * @param {module:ol/extent~Extent} extent1 The extent to be modified.
 * @param {module:ol/extent~Extent} extent2 The extent that will be included in the first.
 * @return {module:ol/extent~Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} rings Rings.
 * @return {module:ol/extent~Extent} Extent.
 */
function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}


/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(this:T, module:ol/coordinate~Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
function forEachCorner(extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}


/**
 * Get the size of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  var area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}


/**
 * Get the bottom left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}


/**
 * Get the bottom right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}


/**
 * Get the center coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}


/**
 * Get a corner coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent/Corner} corner Corner.
 * @return {module:ol/coordinate~Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  var coordinate;
  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__["default"].TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(false, 13); // Invalid corner
  }
  return (
    /** @type {!module:ol/coordinate~Coordinate} */ (coordinate)
  );
}


/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}


/**
 * @param {module:ol/coordinate~Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {module:ol/size~Size} size Size.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(
    Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),
    opt_extent);
}


/**
 * Get the height of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}


/**
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}


/**
 * Get the intersection of two extents.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent 2.
 * @param {module:ol/extent~Extent=} opt_extent Optional extent to populate with intersection.
 * @return {module:ol/extent~Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}


/**
 * Get the size (width, height) of an extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @return {module:ol/size~Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}


/**
 * Get the top left coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}


/**
 * Get the top right coordinate of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {module:ol/coordinate~Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}


/**
 * Get the width of an extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}


/**
 * Determine if one extent intersects another.
 * @param {module:ol/extent~Extent} extent1 Extent 1.
 * @param {module:ol/extent~Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] &&
      extent1[2] >= extent2[0] &&
      extent1[1] <= extent2[3] &&
      extent1[3] >= extent2[1];
}


/**
 * Determine if an extent is empty.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}


/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {module:ol/extent~Extent} extent The extent.
 * @param {module:ol/coordinate~Coordinate} start Segment start coordinate.
 * @param {module:ol/coordinate~Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);
  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING ||
      endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - ((endY - maxY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT)) {
      // potentially intersects right
      y = endY - ((endX - maxX) * slope);
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].BELOW)) {
      // potentially intersects bottom
      x = endX - ((endY - minY) / slope);
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) &&
        !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT)) {
      // potentially intersects left
      y = endY - ((endX - minX) * slope);
      intersects = y >= minY && y <= maxY;
    }

  }
  return intersects;
}


/**
 * Apply a transform function to the extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {module:ol/proj~TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, opt_extent) {
  var coordinates = [
    extent[0], extent[1],
    extent[0], extent[3],
    extent[2], extent[1],
    extent[2], extent[3]
  ];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _boundingExtentXYs(xs, ys, opt_extent);
}

//# sourceMappingURL=extent.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Corner.js":
/*!******************************************!*\
  !*** ./node_modules/ol/extent/Corner.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
});

//# sourceMappingURL=Corner.js.map

/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
});

//# sourceMappingURL=Relationship.js.map

/***/ }),

/***/ "./node_modules/ol/featureloader.js":
/*!******************************************!*\
  !*** ./node_modules/ol/featureloader.js ***!
  \******************************************/
/*! exports provided: loadFeaturesXhr, xhr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFeaturesXhr", function() { return loadFeaturesXhr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhr", function() { return xhr; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format/FormatType.js */ "./node_modules/ol/format/FormatType.js");
/**
 * @module ol/featureloader
 */




/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel) and an
 * {@link module:ol/proj/Projection} for the projection  as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:module:ol/source/Vector, module:ol/extent~Extent, number,
 *                    module:ol/proj/Projection)} FeatureLoader
 * @api
 */


/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(module:ol/extent~Extent, number, module:ol/proj/Projection): string} FeatureUrlFunction
 * @api
 */


/**
 * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.
 * @param {module:ol/format/Feature} format Feature format.
 * @param {function(this:module:ol/VectorTile, Array.<module:ol/Feature>, module:ol/proj/Projection, module:ol/extent~Extent)|function(this:module:ol/source/Vector, Array.<module:ol/Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:module:ol/VectorTile)|function(this:module:ol/source/Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {module:ol/featureloader~FeatureLoader} The feature loader.
 */
function loadFeaturesXhr(url, format, success, failure) {
  return (
    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {module:ol/proj/Projection} projection Projection.
     * @this {module:ol/source/Vector|module:ol/VectorTile}
     */
    function(extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET',
        typeof url === 'function' ? url(extent, resolution, projection) : url,
        true);
      if (format.getType() == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].JSON || type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TEXT) {
            source = xhr.responseText;
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].XML) {
            source = xhr.responseXML;
            if (!source) {
              source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            }
          } else if (type == _format_FormatType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */ (xhr.response);
          }
          if (source) {
            success.call(this, format.readFeatures(source,
              {featureProjection: projection}),
            format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function() {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
}


/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.
 * @param {module:ol/format/Feature} format Feature format.
 * @return {module:ol/featureloader~FeatureLoader} The feature loader.
 * @api
 */
function xhr(url, format) {
  return loadFeaturesXhr(url, format,
    /**
     * @param {Array.<module:ol/Feature>} features The loaded features.
     * @param {module:ol/proj/Projection} dataProjection Data
     * projection.
     * @this {module:ol/source/Vector}
     */
    function(features, dataProjection) {
      this.addFeatures(features);
    }, /* FIXME handle error */ _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"]);
}

//# sourceMappingURL=featureloader.js.map

/***/ }),

/***/ "./node_modules/ol/format/FormatType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/format/FormatType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
});

//# sourceMappingURL=FormatType.js.map

/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/*! exports provided: TRUE, FALSE, UNDEFINED */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRUE", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FALSE", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNDEFINED", function() { return UNDEFINED; });
/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @returns {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
function UNDEFINED() {}

//# sourceMappingURL=functions.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Circle.js":
/*!****************************************!*\
  !*** ./node_modules/ol/geom/Circle.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/**
 * @module ol/geom/Circle
 */





/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle = (function (SimpleGeometry) {
  function Circle(center, opt_radius, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout !== undefined && opt_radius === undefined) {
      this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;
      this.setCenterAndRadius(center, radius, opt_layout);
    }
  }

  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;
  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Circle.prototype.constructor = Circle;

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/Circle} Clone.
   * @override
   * @api
   */
  Circle.prototype.clone = function clone () {
    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;
    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;
        for (var i$1 = 2; i$1 < this.stride; ++i$1) {
          closestPoint[i$1] = flatCoordinates[i$1];
        }
      }
      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.containsXY = function containsXY (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };

  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {module:ol/coordinate~Coordinate} Center.
   * @api
   */
  Circle.prototype.getCenter = function getCenter () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.computeExtent = function computeExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdate"])(
      flatCoordinates[0] - radius, flatCoordinates[1] - radius,
      flatCoordinates[0] + radius, flatCoordinates[1] + radius,
      extent);
  };

  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  Circle.prototype.getRadius = function getRadius () {
    return Math.sqrt(this.getRadiusSquared_());
  };

  /**
   * @private
   * @return {number} Radius squared.
   */
  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE;
  };

  /**
   * @inheritDoc
   * @api
   */
  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {
    var circleExtent = this.getExtent();
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }
      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent, this.intersectsCoordinate, this);
    }
    return false;

  };

  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {module:ol/coordinate~Coordinate} center Center.
   * @api
   */
  Circle.prototype.setCenter = function setCenter (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;
    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }
    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };

  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!module:ol/coordinate~Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @api
   */
  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array.<number>} */
    var flatCoordinates = this.flatCoordinates;
    var offset = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  };

  /**
   * @inheritDoc
   */
  Circle.prototype.getCoordinates = function getCoordinates () {};

  /**
   * @inheritDoc
   */
  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  Circle.prototype.setRadius = function setRadius (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };

  return Circle;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {module:ol/geom/Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */
Circle.prototype.transform;
/* harmony default export */ __webpack_exports__["default"] = (Circle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/geom/Geometry
 */









/**
 * @type {module:ol/transform~Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["create"])();


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
var Geometry = (function (BaseObject) {
  function Geometry() {

    BaseObject.call(this);

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {Object.<string, module:ol/geom/Geometry>}
     */
    this.simplifiedGeometryCache = {};

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

  }

  if ( BaseObject ) Geometry.__proto__ = BaseObject;
  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );
  Geometry.prototype.constructor = Geometry;

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!module:ol/geom/Geometry} Clone.
   */
  Geometry.prototype.clone = function clone () {};

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {module:ol/coordinate~Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {};

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {module:ol/coordinate~Coordinate} point Point.
   * @param {module:ol/coordinate~Coordinate=} opt_closestPoint Closest point.
   * @return {module:ol/coordinate~Coordinate} Closest point.
   * @api
   */
  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };

  /**
   * @abstract
   * @param {module:ol/extent~Extent} extent Extent.
   * @protected
   * @return {module:ol/extent~Extent} extent Extent.
   */
  Geometry.prototype.computeExtent = function computeExtent (extent) {};

  /**
   * Get the extent of the geometry.
   * @param {module:ol/extent~Extent=} opt_extent Extent.
   * @return {module:ol/extent~Extent} extent Extent.
   * @api
   */
  Geometry.prototype.getExtent = function getExtent (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      this.extent_ = this.computeExtent(this.extent_);
      this.extentRevision_ = this.getRevision();
    }
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["returnOrUpdate"])(this.extent_, opt_extent);
  };

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {module:ol/coordinate~Coordinate} anchor The rotation center.
   * @api
   */
  Geometry.prototype.rotate = function rotate (angle, anchor) {};

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
   *     sx).
   * @param {module:ol/coordinate~Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {};

  /**
   * Translate the geometry. This modifies the geometry coordinates in place.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  Geometry.prototype.translate = function translate (deltaX, deltaY) {};

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the the {@link
   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
   * Douglas Peucker} algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @function
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {module:ol/geom/Geometry} A new, simplified version of the original
   *     geometry.
   * @api
   */
  Geometry.prototype.simplify = function simplify (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {module:ol/geom/Geometry} Simplified geometry.
   */
  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {};

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {module:ol/geom/GeometryType} Geometry type.
   */
  Geometry.prototype.getType = function getType () {};

  /**
   * Apply a transform function to each coordinate of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {module:ol/proj~TransformFunction} transformFn Transform.
   */
  Geometry.prototype.applyTransform = function applyTransform (transformFn) {};

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {module:ol/extent~Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {};

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   */
  Geometry.prototype.translate = function translate (deltaX, deltaY) {};

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {module:ol/geom/Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  Geometry.prototype.transform = function transform (source, destination) {
    source = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(source);
    var transformFn = source.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__["default"].TILE_PIXELS ?
      function(inCoordinates, outCoordinates, stride) {
        var pixelExtent = source.getExtent();
        var projectedExtent = source.getWorldExtent();
        var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(pixelExtent);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__["compose"])(tmpTransform,
          projectedExtent[0], projectedExtent[3],
          scale, -scale, 0,
          0, 0);
        Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(inCoordinates, 0, inCoordinates.length, stride,
          tmpTransform, outCoordinates);
        return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(source, destination)(inCoordinates, outCoordinates, stride);
      } :
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(source, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
Geometry.prototype.containsXY = _functions_js__WEBPACK_IMPORTED_MODULE_2__["FALSE"];


/* harmony default export */ __webpack_exports__["default"] = (Geometry);

//# sourceMappingURL=Geometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryLayout.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/GeometryLayout.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
});

//# sourceMappingURL=GeometryLayout.js.map

/***/ }),

/***/ "./node_modules/ol/geom/GeometryType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/GeometryType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
});

//# sourceMappingURL=GeometryType.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LineString.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LineString.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LineString
 */














/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString = (function (SimpleGeometry) {
  function LineString(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {module:ol/coordinate~Coordinate}
     */
    this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, coordinates);
    } else {
      this.setCoordinates(coordinates, opt_layout);
    }

  }

  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;
  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LineString.prototype.constructor = LineString;

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @api
   */
  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, coordinate);
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/LineString} Clone.
   * @override
   * @api
   */
  LineString.prototype.clone = function clone () {
    return new LineString(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {
    return Object(_geom_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__["forEach"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @return {module:ol/coordinate~Coordinate} Coordinate.
   * @api
   */
  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {
    if (this.layout != _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
        this.layout != _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["lineStringCoordinateAtM"])(this.flatCoordinates, 0,
      this.flatCoordinates.length, this.stride, m, extrapolate);
  };

  /**
   * Return the coordinates of the linestring.
   * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
   * @override
   * @api
   */
  LineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {module:ol/coordinate~Coordinate=} opt_dest Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {module:ol/coordinate~Coordinate} Coordinate of the interpolated point.
   * @api
   */
  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {
    return Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__["interpolatePoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      fraction, opt_dest);
  };

  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  LineString.prototype.getLength = function getLength () {
    return Object(_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_10__["lineStringLength"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @return {Array.<number>} Flat midpoint.
   */
  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }
    return this.flatMidpoint_;
  };

  /**
   * @inheritDoc
   */
  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__["intersectsLineString"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      extent);
  };

  /**
   * Set the coordinates of the linestring.
   * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LineString);

//# sourceMappingURL=LineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/LinearRing
 */










/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing = (function (SimpleGeometry) {
  function LinearRing(coordinates, opt_layout) {

    SimpleGeometry.call(this);

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, coordinates);
    } else {
      this.setCoordinates(coordinates, opt_layout);
    }

  }

  if ( SimpleGeometry ) LinearRing.__proto__ = SimpleGeometry;
  LinearRing.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  LinearRing.prototype.constructor = LinearRing;

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/LinearRing} Clone.
   * @override
   * @api
   */
  LinearRing.prototype.clone = function clone () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["maxSquaredDelta"])(
        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__["assignClosestPoint"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  LinearRing.prototype.getArea = function getArea () {
    return Object(_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_4__["linearRing"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the coordinates of the linear ring.
   * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
   * @override
   * @api
   */
  LinearRing.prototype.getCoordinates = function getCoordinates () {
    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__["douglasPeucker"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
      squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_1__["default"].XY);
  };

  /**
   * @inheritDoc
   * @api
   */
  LinearRing.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].LINEAR_RING;
  };

  /**
   * @inheritDoc
   */
  LinearRing.prototype.intersectsExtent = function intersectsExtent (extent) {};

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  LinearRing.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LinearRing);

//# sourceMappingURL=LinearRing.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiLineString.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/MultiLineString.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiLineString
 */













/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString = (function (SimpleGeometry) {
  function MultiLineString(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array.<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      this.setCoordinates(coordinates, opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, coordinates);
      this.ends_ = opt_ends;
    } else {
      var layout = this.getLayout();
      var flatCoordinates = [];
      var ends = [];
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        var lineString = coordinates[i];
        if (i === 0) {
          layout = lineString.getLayout();
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      this.setFlatCoordinates(layout, flatCoordinates);
      this.ends_ = ends;
    }

  }

  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;
  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiLineString.prototype.constructor = MultiLineString;

  /**
   * Append the passed linestring to the multilinestring.
   * @param {module:ol/geom/LineString} lineString LineString.
   * @api
   */
  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/MultiLineString} Clone.
   * @override
   * @api
   */
  MultiLineString.prototype.clone = function clone () {
    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
   * @return {module:ol/coordinate~Coordinate} Coordinate.
   * @api
   */
  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {
    if ((this.layout != _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM &&
         this.layout != _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYZM) ||
        this.flatCoordinates.length === 0) {
      return null;
    }
    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["lineStringsCoordinateAtM"])(this.flatCoordinates, 0,
      this.ends_, this.stride, m, extrapolate, interpolate);
  };

  /**
   * Return the coordinates of the multilinestring.
   * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.
   * @override
   * @api
   */
  MultiLineString.prototype.getCoordinates = function getCoordinates () {
    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__["inflateCoordinatesArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array.<number>} Ends.
   */
  MultiLineString.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {module:ol/geom/LineString} LineString.
   * @api
   */
  MultiLineString.prototype.getLineString = function getLineString (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linestrings of this multilinestring.
   * @return {Array.<module:ol/geom/LineString>} LineStrings.
   * @api
   */
  MultiLineString.prototype.getLineStrings = function getLineStrings () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array.<module:ol/geom/LineString>} */
    var lineStrings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }
    return lineStrings;
  };

  /**
   * @return {Array.<number>} Flat midpoints.
   */
  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = Object(_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__["interpolatePoint"])(
        flatCoordinates, offset, end, stride, 0.5);
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(midpoints, midpoint);
      offset = end;
    }
    return midpoints;
  };

  /**
   * @inheritDoc
   */
  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__["douglasPeuckerArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__["intersectsLineStringArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiLineString);

//# sourceMappingURL=MultiLineString.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/MultiPoint.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/MultiPoint
 */









/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint = (function (SimpleGeometry) {
  function MultiPoint(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    if (opt_layout && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(opt_layout, coordinates);
    } else {
      this.setCoordinates(coordinates, opt_layout);
    }
  }

  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;
  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPoint.prototype.constructor = MultiPoint;

  /**
   * Append the passed point to this multipoint.
   * @param {module:ol/geom/Point} point Point.
   * @api
   */
  MultiPoint.prototype.appendPoint = function appendPoint (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, point.getFlatCoordinates());
    }
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/MultiPoint} Clone.
   * @override
   * @api
   */
  MultiPoint.prototype.clone = function clone () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    return multiPoint;
  };

  /**
   * @inheritDoc
   */
  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(
        x, y, flatCoordinates[i], flatCoordinates[i + 1]);
      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  };

  /**
   * Return the coordinates of the multipoint.
   * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
   * @override
   * @api
   */
  MultiPoint.prototype.getCoordinates = function getCoordinates () {
    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__["inflateCoordinates"])(
      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };

  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {module:ol/geom/Point} Point.
   * @api
   */
  MultiPoint.prototype.getPoint = function getPoint (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.flatCoordinates.slice(
      index * this.stride, (index + 1) * this.stride), this.layout);
  };

  /**
   * Return the points of this multipoint.
   * @return {Array.<module:ol/geom/Point>} Points.
   * @api
   */
  MultiPoint.prototype.getPoints = function getPoints () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array.<module:ol/geom/Point>} */
    var points = [];
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _geom_Point_js__WEBPACK_IMPORTED_MODULE_3__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].MULTI_POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;
    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsXY"])(extent, x, y)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Set the coordinates of the multipoint.
   * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__["deflateCoordinates"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPoint);

//# sourceMappingURL=MultiPoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/MultiPolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/MultiPolygon.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiPolygon
 */


















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon = (function (SimpleGeometry) {
  function MultiPolygon(coordinates, opt_layout, opt_endss) {

    SimpleGeometry.call(this);

    /**
     * @type {Array.<Array.<number>>}
     * @private
     */
    this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = this.getLayout();
      var flatCoordinates = [];
      var endss = [];
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        var polygon = coordinates[i];
        if (i === 0) {
          layout = polygon.getLayout();
        }
        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }
      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }
    if (opt_layout !== undefined && opt_endss) {
      this.setFlatCoordinates(opt_layout, coordinates);
      this.endss_ = opt_endss;
    } else {
      this.setCoordinates(coordinates, opt_layout);
    }

  }

  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;
  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  MultiPolygon.prototype.constructor = MultiPolygon;

  /**
   * Append the passed polygon to this multipolygon.
   * @param {module:ol/geom/Polygon} polygon Polygon.
   * @api
   */
  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {
    /** @type {Array.<number>} */
    var ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }
    this.endss_.push(ends);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/MultiPolygon} Clone.
   * @override
   * @api
   */
  MultiPolygon.prototype.clone = function clone () {
    var this$1 = this;

    var len = this.endss_.length;
    var newEndss = new Array(len);
    for (var i = 0; i < len; ++i) {
      newEndss[i] = this$1.endss_[i].slice();
    }

    return new MultiPolygon(
      this.flatCoordinates.slice(), this.layout, newEndss);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["multiArrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestMultiArrayPoint"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingssContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };

  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  MultiPolygon.prototype.getArea = function getArea () {
    return Object(_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_7__["linearRingss"])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinates.
   * @override
   * @api
   */
  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
        flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateMultiCoordinatesArray"])(
      flatCoordinates, 0, this.endss_, this.stride);
  };

  /**
   * @return {Array.<Array.<number>>} Endss.
   */
  MultiPolygon.prototype.getEndss = function getEndss () {
    return this.endss_;
  };

  /**
   * @return {Array.<number>} Flat interior points.
   */
  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = Object(_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_8__["linearRingss"])(
        this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = Object(_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointsOfMultiArray"])(
        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
        flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return this.flatInteriorPoints_;
  };

  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
   * @return {module:ol/geom/MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {
    return new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.getFlatInteriorPoints().slice(), _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * @return {Array.<number>} Oriented flat coordinates.
   */
  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingsAreOriented"])(
        flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRingsArray"])(
              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeMultiArray"])(
      this.flatCoordinates, 0, this.endss_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEndss);
  };

  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {module:ol/geom/Polygon} Polygon.
   * @api
   */
  MultiPolygon.prototype.getPolygon = function getPolygon (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    var offset;
    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }
    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }
    return new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.flatCoordinates.slice(offset, end), this.layout, ends);
  };

  /**
   * Return the polygons of this multipolygon.
   * @return {Array.<module:ol/geom/Polygon>} Polygons.
   * @api
   */
  MultiPolygon.prototype.getPolygons = function getPolygons () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];
      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }
      var polygon = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }
    return polygons;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingMultiArray"])(
      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };

  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateMultiCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ?
        0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  };

  return MultiPolygon;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (MultiPolygon);

//# sourceMappingURL=MultiPolygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */






/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point = (function (SimpleGeometry) {
  function Point(coordinates, opt_layout) {
    SimpleGeometry.call(this);
    this.setCoordinates(coordinates, opt_layout);
  }

  if ( SimpleGeometry ) Point.__proto__ = SimpleGeometry;
  Point.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Point.prototype.constructor = Point;

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/Point} Clone.
   * @override
   * @api
   */
  Point.prototype.clone = function clone () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    return point;
  };

  /**
   * @inheritDoc
   */
  Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__["squaredDistance"])(x, y, flatCoordinates[0], flatCoordinates[1]);
    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };

  /**
   * Return the coordinate of the point.
   * @return {module:ol/coordinate~Coordinate} Coordinates.
   * @override
   * @api
   */
  Point.prototype.getCoordinates = function getCoordinates () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };

  /**
   * @inheritDoc
   */
  Point.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromCoordinate"])(this.flatCoordinates, extent);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT;
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsXY"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };

  /**
   * @inheritDoc
   * @api
   */
  Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__["deflateCoordinate"])(
      this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Point);

//# sourceMappingURL=Point.js.map

/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/*! exports provided: default, circular, fromExtent, fromCircle, makeRegular */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circular", function() { return circular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromExtent", function() { return fromExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromCircle", function() { return fromCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeRegular", function() { return makeRegular; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Polygon
 */



















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon = (function (SimpleGeometry) {
  function Polygon(coordinates, opt_layout, opt_ends) {

    SimpleGeometry.call(this);

    /**
     * @type {Array.<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {module:ol/coordinate~Coordinate}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      this.setFlatCoordinates(opt_layout, coordinates);
      this.ends_ = opt_ends;
    } else {
      this.setCoordinates(coordinates, opt_layout);
    }

  }

  if ( SimpleGeometry ) Polygon.__proto__ = SimpleGeometry;
  Polygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );
  Polygon.prototype.constructor = Polygon;

  /**
   * Append the passed linear ring to this polygon.
   * @param {module:ol/geom/LinearRing} linearRing Linear ring.
   * @api
   */
  Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };

  /**
   * Make a complete copy of the geometry.
   * @return {!module:ol/geom/Polygon} Clone.
   * @override
   * @api
   */
  Polygon.prototype.clone = function clone () {
    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["arrayMaxSquaredDelta"])(
        this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }
    return Object(_geom_flat_closest_js__WEBPACK_IMPORTED_MODULE_9__["assignClosestArrayPoint"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.containsXY = function containsXY (x, y) {
    return Object(_geom_flat_contains_js__WEBPACK_IMPORTED_MODULE_10__["linearRingsContainsXY"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  Polygon.prototype.getArea = function getArea () {
    return Object(_geom_flat_area_js__WEBPACK_IMPORTED_MODULE_8__["linearRings"])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.
   * @override
   * @api
   */
  Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {
    var flatCoordinates;
    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
        flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return Object(_geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_12__["inflateCoordinatesArray"])(
      flatCoordinates, 0, this.ends_, this.stride);
  };

  /**
   * @return {Array.<number>} Ends.
   */
  Polygon.prototype.getEnds = function getEnds () {
    return this.ends_;
  };

  /**
   * @return {Array.<number>} Interior point.
   */
  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
      this.flatInteriorPoint_ = Object(_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_13__["getInteriorPointOfArray"])(
        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,
        flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return this.flatInteriorPoint_;
  };

  /**
   * Return an interior point of the polygon.
   * @return {module:ol/geom/Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  Polygon.prototype.getInteriorPoint = function getInteriorPoint () {
    return new _geom_Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](this.getFlatInteriorPoint(), _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XYM);
  };

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  Polygon.prototype.getLinearRingCount = function getLinearRingCount () {
    return this.ends_.length;
  };

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {module:ol/geom/LinearRing} Linear ring.
   * @api
   */
  Polygon.prototype.getLinearRing = function getLinearRing (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.flatCoordinates.slice(
      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };

  /**
   * Return the linear rings of the polygon.
   * @return {Array.<module:ol/geom/LinearRing>} Linear rings.
   * @api
   */
  Polygon.prototype.getLinearRings = function getLinearRings () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_4__["default"](flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  };

  /**
   * @return {Array.<number>} Oriented flat coordinates.
   */
  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;
      if (Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["linearRingIsOriented"])(
        flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length =
            Object(_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_15__["orientLinearRings"])(
              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }
      this.orientedRevision_ = this.getRevision();
    }
    return this.orientedFlatCoordinates_;
  };

  /**
   * @inheritDoc
   */
  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_16__["quantizeArray"])(
      this.flatCoordinates, 0, this.ends_, this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, simplifiedEnds);
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.getType = function getType () {
    return _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON;
  };

  /**
   * @inheritDoc
   * @api
   */
  Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {
    return Object(_geom_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_14__["intersectsLinearRingArray"])(
      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };

  /**
   * Set the coordinates of the polygon.
   * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   * @override
   * @api
   */
  Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = Object(_geom_flat_deflate_js__WEBPACK_IMPORTED_MODULE_11__["deflateCoordinatesArray"])(
      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (Polygon);


/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {module:ol/coordinate~Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {module:ol/geom/Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array.<number>} */
  var flatCoordinates = [];
  for (var i = 0; i < n; ++i) {
    Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["extend"])(flatCoordinates, Object(_sphere_js__WEBPACK_IMPORTED_MODULE_7__["offset"])(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {module:ol/extent~Extent} extent The extent.
 * @return {module:ol/geom/Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates =
      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__["default"].XY, [flatCoordinates.length]);
}


/**
 * Create a regular polygon from a circle.
 * @param {module:ol/geom/Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {module:ol/geom/Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}


/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {module:ol/geom/Polygon} polygon Polygon geometry.
 * @param {module:ol/coordinate~Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */
function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (Object(_math_js__WEBPACK_IMPORTED_MODULE_17__["modulo"])(i, sides) * 2 * Math.PI / sides);
    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));
    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));
  }
  polygon.changed();
}

//# sourceMappingURL=Polygon.js.map

/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/*! exports provided: getStrideForLayout, transformGeom2D, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStrideForLayout", function() { return getStrideForLayout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformGeom2D", function() { return transformGeom2D; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/GeometryLayout.js */ "./node_modules/ol/geom/GeometryLayout.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/geom/SimpleGeometry
 */







/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry = (function (Geometry) {
  function SimpleGeometry() {

    Geometry.call(this);

    /**
     * @protected
     * @type {module:ol/geom/GeometryLayout}
     */
    this.layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.flatCoordinates = null;

  }

  if ( Geometry ) SimpleGeometry.__proto__ = Geometry;
  SimpleGeometry.prototype = Object.create( Geometry && Geometry.prototype );
  SimpleGeometry.prototype.constructor = SimpleGeometry;

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates,
      0, this.flatCoordinates.length, this.stride, extent);
  };

  /**
   * @abstract
   * @return {Array} Coordinates.
   */
  SimpleGeometry.prototype.getCoordinates = function getCoordinates () {};

  /**
   * Return the first coordinate of the geometry.
   * @return {module:ol/coordinate~Coordinate} First coordinate.
   * @api
   */
  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {
    return this.flatCoordinates.slice(0, this.stride);
  };

  /**
   * @return {Array.<number>} Flat coordinates.
   */
  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {
    return this.flatCoordinates;
  };

  /**
   * Return the last coordinate of the geometry.
   * @return {module:ol/coordinate~Coordinate} Last point.
   * @api
   */
  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };

  /**
   * Return the {@link module:ol/geom/GeometryLayout~GeometryLayout layout} of the geometry.
   * @return {module:ol/geom/GeometryLayout} Layout.
   * @api
   */
  SimpleGeometry.prototype.getLayout = function getLayout () {
    return this.layout;
  };

  /**
   * @inheritDoc
   */
  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
    if (this.simplifiedGeometryRevision != this.getRevision()) {
      Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__["clear"])(this.simplifiedGeometryCache);
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (squaredTolerance < 0 ||
        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
      return this;
    }
    var key = squaredTolerance.toString();
    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
      return this.simplifiedGeometryCache[key];
    } else {
      var simplifiedGeometry =
          this.getSimplifiedGeometryInternal(squaredTolerance);
      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        this.simplifiedGeometryCache[key] = simplifiedGeometry;
        return simplifiedGeometry;
      } else {
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
    }
  };

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {module:ol/geom/SimpleGeometry} Simplified geometry.
   * @protected
   */
  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
    return this;
  };

  /**
   * @return {number} Stride.
   */
  SimpleGeometry.prototype.getStride = function getStride () {
    return this.stride;
  };

  /**
   * @param {module:ol/geom/GeometryLayout} layout Layout.
   * @param {Array.<number>} flatCoordinates Flat coordinates.
    */
  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };

  /**
   * @abstract
   * @param {!Array} coordinates Coordinates.
   * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
   */
  SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

  /**
   * @param {module:ol/geom/GeometryLayout|undefined} layout Layout.
   * @param {Array} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {
    var this$1 = this;

    /** @type {number} */
    var stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this$1.layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
          this$1.stride = 2;
          return;
        } else {
          coordinates = /** @type {Array} */ (coordinates[0]);
        }
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.applyTransform = function applyTransform (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.rotate = function rotate$1 (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.scale = function scale$1 (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;
    if (sy === undefined) {
      sy = sx;
    }
    var anchor = opt_anchor;
    if (!anchor) {
      anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());
    }
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["scale"])(
        flatCoordinates, 0, flatCoordinates.length,
        stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      var stride = this.getStride();
      Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["translate"])(
        flatCoordinates, 0, flatCoordinates.length, stride,
        deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_geom_Geometry_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {number} stride Stride.
 * @return {module:ol/geom/GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  var layout;
  if (stride == 2) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY;
  } else if (stride == 3) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ;
  } else if (stride == 4) {
    layout = _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM;
  }
  return (
    /** @type {module:ol/geom/GeometryLayout} */ (layout)
  );
}


/**
 * @param {module:ol/geom/GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  var stride;
  if (layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XY) {
    stride = 2;
  } else if (layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZ || layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYM) {
    stride = 3;
  } else if (layout == _geom_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__["default"].XYZM) {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}


/**
 * @inheritDoc
 */
SimpleGeometry.prototype.containsXY = _functions_js__WEBPACK_IMPORTED_MODULE_0__["FALSE"];


/**
 * @param {module:ol/geom/SimpleGeometry} simpleGeometry Simple geometry.
 * @param {module:ol/transform~Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__["transform2D"])(
      flatCoordinates, 0, flatCoordinates.length, stride,
      transform, opt_dest);
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SimpleGeometry);

//# sourceMappingURL=SimpleGeometry.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/*! exports provided: linearRing, linearRings, linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRing", function() { return linearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRings", function() { return linearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/**
 * @module ol/geom/flat/area
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}

//# sourceMappingURL=area.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/*! exports provided: linearRingss */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingss", function() { return linearRingss; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/center
 */



/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array.<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromFlatCoordinates"])(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}

//# sourceMappingURL=center.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/*! exports provided: maxSquaredDelta, arrayMaxSquaredDelta, multiArrayMaxSquaredDelta, assignClosestPoint, assignClosestArrayPoint, assignClosestMultiArrayPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maxSquaredDelta", function() { return maxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMaxSquaredDelta", function() { return arrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiArrayMaxSquaredDelta", function() { return multiArrayMaxSquaredDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestPoint", function() { return assignClosestPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestArrayPoint", function() { return assignClosestArrayPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignClosestMultiArrayPoint", function() { return assignClosestMultiArrayPoint; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */



/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (var i$1 = 0; i$1 < stride; ++i$1) {
    closestPoint[i$1] = flatCoordinates[offset + i$1];
  }
  closestPoint.length = stride;
}


/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(
      flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(
      flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(flatCoordinates, offset, end,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(
      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max(
        ((Math.sqrt(squaredDistance) -
            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(flatCoordinates, offset, ends,
  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates, offset, end, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(flatCoordinates, offset,
  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
  opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates, offset, ends, stride,
      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}

//# sourceMappingURL=closest.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/*! exports provided: linearRingContainsExtent, linearRingContainsXY, linearRingsContainsXY, linearRingssContainsXY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsExtent", function() { return linearRingContainsExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingContainsXY", function() { return linearRingContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsContainsXY", function() { return linearRingsContainsXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingssContainsXY", function() { return linearRingssContainsXY; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */



/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent,
    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
  return !outside;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {
        wn++;
      }
    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/*! exports provided: deflateCoordinate, deflateCoordinates, deflateCoordinatesArray, deflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinate", function() { return deflateCoordinate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinates", function() { return deflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateCoordinatesArray", function() { return deflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deflateMultiCoordinatesArray", function() { return deflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/deflate
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(
      flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(
      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}

//# sourceMappingURL=deflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/*! exports provided: inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinates", function() { return inflateCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateCoordinatesArray", function() { return inflateCoordinatesArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateMultiCoordinatesArray", function() { return inflateMultiCoordinatesArray; });
/**
 * @module ol/geom/flat/inflate
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<module:ol/coordinate~Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<module:ol/coordinate~Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(
      flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}

//# sourceMappingURL=inflate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/*! exports provided: getInteriorPointOfArray, getInteriorPointsOfMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointOfArray", function() { return getInteriorPointOfArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInteriorPointsOfMultiArray", function() { return getInteriorPointsOfMultiArray; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */




/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset,
  ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array.<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingsContainsXY"])(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates,
      offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}

//# sourceMappingURL=interiorpoint.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/*! exports provided: interpolatePoint, lineStringCoordinateAtM, lineStringsCoordinateAtM */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolatePoint", function() { return interpolatePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringCoordinateAtM", function() { return lineStringCoordinateAtM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringsCoordinateAtM", function() { return lineStringsCoordinateAtM; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/interpolate
 */




/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] +
        fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] +
        fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["binarySearch"])(cumulativeLengths, target);
    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) /
          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(
        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 */
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = (lo + hi) >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push(Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["lerp"])(flatCoordinates[(lo - 1) * stride + i],
      flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 */
function lineStringsCoordinateAtM(
  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
}

//# sourceMappingURL=interpolate.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/*! exports provided: intersectsLineString, intersectsLineStringArray, intersectsLinearRing, intersectsLinearRingArray, intersectsLinearRingMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineString", function() { return intersectsLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLineStringArray", function() { return intersectsLineStringArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRing", function() { return intersectsLinearRing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingArray", function() { return intersectsLinearRingArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsLinearRingMultiArray", function() { return intersectsLinearRingMultiArray; });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/**
 * @module ol/geom/flat/intersectsextent
 */





/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendFlatCoordinates"])(
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])(), flatCoordinates, offset, end, stride);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, coordinatesExtent)) {
    return false;
  }
  if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsExtent"])(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] &&
      coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] &&
      coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return Object(_flat_segments_js__WEBPACK_IMPORTED_MODULE_2__["forEach"])(flatCoordinates, offset, end, stride,
    /**
     * @param {module:ol/coordinate~Coordinate} point1 Start point.
     * @param {module:ol/coordinate~Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersectsSegment"])(extent, point1, point2);
    });
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(
      flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(
    flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsXY"])(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(
    flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (Object(_flat_contains_js__WEBPACK_IMPORTED_MODULE_1__["linearRingContainsExtent"])(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }
  return true;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (intersectsLinearRingArray(
      flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}

//# sourceMappingURL=intersectsextent.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/*! exports provided: lineStringLength, linearRingLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineStringLength", function() { return lineStringLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingLength", function() { return linearRingLength; });
/**
 * @module ol/geom/flat/length
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}

//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/*! exports provided: linearRingIsClockwise, linearRingIsOriented, linearRingsAreOriented, orientLinearRings, orientLinearRingsArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsClockwise", function() { return linearRingIsClockwise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingIsOriented", function() { return linearRingIsOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearRingsAreOriented", function() { return linearRingsAreOriented; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRings", function() { return orientLinearRings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orientLinearRingsArray", function() { return orientLinearRingsArray; });
/* harmony import */ var _flat_reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flat/reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */



/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}


/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    if (!linearRingIsOriented(
      flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(
      flatCoordinates, offset, end, stride);
    var reverse = i === 0 ?
      (right && isClockwise) || (!right && !isClockwise) :
      (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      Object(_flat_reverse_js__WEBPACK_IMPORTED_MODULE_0__["coordinates"])(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}


/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
}

//# sourceMappingURL=orient.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/*! exports provided: coordinates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinates", function() { return coordinates; });
/**
 * @module ol/geom/flat/reverse
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}

//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/*! exports provided: forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/**
 * @module ol/geom/flat/segments
 */


/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; (offset + stride) < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
}

//# sourceMappingURL=segments.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/*! exports provided: simplifyLineString, douglasPeucker, douglasPeuckerArray, douglasPeuckerMultiArray, radialDistance, snap, quantize, quantizeArray, quantizeMultiArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplifyLineString", function() { return simplifyLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeucker", function() { return douglasPeucker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerArray", function() { return douglasPeuckerArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "douglasPeuckerMultiArray", function() { return douglasPeuckerMultiArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radialDistance", function() { return radialDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeArray", function() { return quantizeArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantizeMultiArray", function() { return quantizeMultiArray; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end,
  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?
    opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end,
      stride, squaredTolerance,
      simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates, offset, end, stride, squaredTolerance,
    simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array.<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array.<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredSegmentDistance"])(
        x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (var i$1 = 0; i$1 < n; ++i$1) {
    if (markers[i$1]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + i$1 * stride + 1];
    }
  }
  return simplifiedOffset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(flatCoordinates, offset,
  ends, stride, squaredTolerance, simplifiedFlatCoordinates,
  simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates, offset, end, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates, offset, endss, stride, squaredTolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates, offset, ends, stride, squaredTolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(flatCoordinates, offset, end,
  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
          flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["squaredDistance"])(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}


/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}


/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(flatCoordinates, offset, end, stride,
  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if ((dx1 * dy2 == dy1 * dx2) &&
        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates, offset, ends, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates, offset, end, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates, offset, endss, stride,
  tolerance,
  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates, offset, ends, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

//# sourceMappingURL=simplify.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/straightchunk.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/straightchunk.js ***!
  \****************************************************/
/*! exports provided: matchingChunk */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchingChunk", function() { return matchingChunk; });
/**
 * @module ol/geom/flat/straightchunk
 */


/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array.<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}

//# sourceMappingURL=straightchunk.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/textpath.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/textpath.js ***!
  \***********************************************/
/*! exports provided: drawTextOnPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawTextOnPath", function() { return drawTextOnPath; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/textpath
 */



/**
 * @param {Array.<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(
  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = [];

  // Keep text upright
  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];

  var numChars = text.length;

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;
  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;
    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    var interpolate = segmentPos / segmentLength;
    var x = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(x1, x2, interpolate);
    var y = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["lerp"])(y1, y2, interpolate);
    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }
      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];
      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }
      previousAngle = angle;
    }
    startM += charLength;
  }
  return result;
}

//# sourceMappingURL=textpath.js.map

/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/*! exports provided: transform2D, rotate, scale, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform2D", function() { return transform2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * @module ol/geom/flat/transform
 */


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {module:ol/transform~Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/*! exports provided: FIREFOX, SAFARI, WEBKIT, MAC, DEVICE_PIXEL_RATIO, CANVAS_LINE_DASH, GEOLOCATION, TOUCH, POINTER, MSPOINTER, WEBGL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FIREFOX", function() { return FIREFOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SAFARI", function() { return SAFARI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBKIT", function() { return WEBKIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAC", function() { return MAC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEVICE_PIXEL_RATIO", function() { return DEVICE_PIXEL_RATIO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CANVAS_LINE_DASH", function() { return CANVAS_LINE_DASH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOLOCATION", function() { return GEOLOCATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER", function() { return POINTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MSPOINTER", function() { return MSPOINTER; });
/* harmony import */ var _webgl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl.js */ "./node_modules/ol/webgl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WEBGL", function() { return _webgl_js__WEBPACK_IMPORTED_MODULE_0__["HAS"]; });

/**
 * @module ol/has
 */

var ua = typeof navigator !== 'undefined' ?
  navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
var FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
var MAC = ua.indexOf('macintosh') !== -1;


/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;


/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
var CANVAS_LINE_DASH = function() {
  var has = false;
  try {
    has = !!document.createElement('CANVAS').getContext('2d').setLineDash;
  } catch (e) {
    // pass
  }
  return has;
}();


/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
var GEOLOCATION = 'geolocation' in navigator;


/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
var TOUCH = 'ontouchstart' in window;


/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
var POINTER = 'PointerEvent' in window;


/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
var MSPOINTER = !!(navigator.msPointerEnabled);




//# sourceMappingURL=has.js.map

/***/ }),

/***/ "./node_modules/ol/interaction.js":
/*!****************************************!*\
  !*** ./node_modules/ol/interaction.js ***!
  \****************************************/
/*! exports provided: DoubleClickZoom, DragAndDrop, DragBox, DragPan, DragRotate, DragRotateAndZoom, DragZoom, Draw, Extent, Interaction, KeyboardPan, KeyboardZoom, Modify, MouseWheelZoom, PinchRotate, PinchZoom, Pointer, Select, Snap, Translate, defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaults", function() { return defaults; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Kinetic.js */ "./node_modules/ol/Kinetic.js");
/* harmony import */ var _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interaction/DoubleClickZoom.js */ "./node_modules/ol/interaction/DoubleClickZoom.js");
/* harmony import */ var _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interaction/DragPan.js */ "./node_modules/ol/interaction/DragPan.js");
/* harmony import */ var _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./interaction/DragRotate.js */ "./node_modules/ol/interaction/DragRotate.js");
/* harmony import */ var _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./interaction/DragZoom.js */ "./node_modules/ol/interaction/DragZoom.js");
/* harmony import */ var _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./interaction/KeyboardPan.js */ "./node_modules/ol/interaction/KeyboardPan.js");
/* harmony import */ var _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./interaction/KeyboardZoom.js */ "./node_modules/ol/interaction/KeyboardZoom.js");
/* harmony import */ var _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./interaction/MouseWheelZoom.js */ "./node_modules/ol/interaction/MouseWheelZoom.js");
/* harmony import */ var _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./interaction/PinchRotate.js */ "./node_modules/ol/interaction/PinchRotate.js");
/* harmony import */ var _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./interaction/PinchZoom.js */ "./node_modules/ol/interaction/PinchZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DoubleClickZoom", function() { return _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./interaction/DragAndDrop.js */ "./node_modules/ol/interaction/DragAndDrop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragAndDrop", function() { return _interaction_DragAndDrop_js__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./interaction/DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragBox", function() { return _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragPan", function() { return _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotate", function() { return _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./interaction/DragRotateAndZoom.js */ "./node_modules/ol/interaction/DragRotateAndZoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragRotateAndZoom", function() { return _interaction_DragRotateAndZoom_js__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DragZoom", function() { return _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./interaction/Draw.js */ "./node_modules/ol/interaction/Draw.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Draw", function() { return _interaction_Draw_js__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./interaction/Extent.js */ "./node_modules/ol/interaction/Extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Extent", function() { return _interaction_Extent_js__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interaction", function() { return _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardPan", function() { return _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeyboardZoom", function() { return _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./interaction/Modify.js */ "./node_modules/ol/interaction/Modify.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modify", function() { return _interaction_Modify_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MouseWheelZoom", function() { return _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchRotate", function() { return _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PinchZoom", function() { return _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Pointer", function() { return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _interaction_Select_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./interaction/Select.js */ "./node_modules/ol/interaction/Select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Select", function() { return _interaction_Select_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./interaction/Snap.js */ "./node_modules/ol/interaction/Snap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Snap", function() { return _interaction_Snap_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./interaction/Translate.js */ "./node_modules/ol/interaction/Translate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Translate", function() { return _interaction_Translate_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/**
 * @module ol/interaction
 */


































/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the wheel/trackpad or pinch gesture ends.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or
 * mousewheel zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */


/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. The default set of
 * interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {module:ol/interaction/Interaction~DefaultsOptions=} opt_options
 * Defaults options.
 * @return {module:ol/Collection.<module:ol/interaction/Interaction>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {

  var options = opt_options ? opt_options : {};

  var interactions = new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

  var kinetic = new _Kinetic_js__WEBPACK_IMPORTED_MODULE_1__["default"](-0.005, 0.05, 100);

  var altShiftDragRotate = options.altShiftDragRotate !== undefined ?
    options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new _interaction_DragRotate_js__WEBPACK_IMPORTED_MODULE_4__["default"]());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ?
    options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new _interaction_DoubleClickZoom_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new _interaction_DragPan_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :
    true;
  if (pinchRotate) {
    interactions.push(new _interaction_PinchRotate_js__WEBPACK_IMPORTED_MODULE_9__["default"]());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new _interaction_PinchZoom_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _interaction_KeyboardPan_js__WEBPACK_IMPORTED_MODULE_6__["default"]());
    interactions.push(new _interaction_KeyboardZoom_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ?
    options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new _interaction_MouseWheelZoom_js__WEBPACK_IMPORTED_MODULE_8__["default"]({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ?
    options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new _interaction_DragZoom_js__WEBPACK_IMPORTED_MODULE_5__["default"]({
      duration: options.zoomDuration
    }));
  }

  return interactions;

}

//# sourceMappingURL=interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DoubleClickZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/interaction/DoubleClickZoom.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/DoubleClickZoom
 */




/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */


/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom = (function (Interaction) {
  function DoubleClickZoom(opt_options) {
    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( Interaction ) DoubleClickZoom.__proto__ = Interaction;
  DoubleClickZoom.prototype = Object.create( Interaction && Interaction.prototype );
  DoubleClickZoom.prototype.constructor = DoubleClickZoom;

  return DoubleClickZoom;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/DoubleClickZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;
  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_1__["zoomByDelta"])(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (DoubleClickZoom);

//# sourceMappingURL=DoubleClickZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragAndDrop.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/DragAndDrop.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data









/**
 * @typedef {Object} Options
 * @property {Array.<function(new: module:ol/format/Feature)>} [formatConstructors] Format constructors.
 * @property {module:ol/source/Vector} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {module:ol/proj~ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {Element} [target] The element that is used as the drop target, default is the viewport element.
 */


/**
 * @enum {string}
 */
var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event module:ol/interaction/DragAndDrop~DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */
var DragAndDropEvent = (function (Event) {
  function DragAndDropEvent(type, file, opt_features, opt_projection) {

    Event.call(this, type);

    /**
     * The features parsed from dropped data.
     * @type {Array.<module:ol/Feature>|undefined}
     * @api
     */
    this.features = opt_features;

    /**
     * The dropped file.
     * @type {File}
     * @api
     */
    this.file = file;

    /**
     * The feature projection.
     * @type {module:ol/proj/Projection|undefined}
     * @api
     */
    this.projection = opt_projection;

  }

  if ( Event ) DragAndDropEvent.__proto__ = Event;
  DragAndDropEvent.prototype = Object.create( Event && Event.prototype );
  DragAndDropEvent.prototype.constructor = DragAndDropEvent;

  return DragAndDropEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 * @api
 *
 * @fires module:ol/interaction/DragAndDrop~DragAndDropEvent
 */
var DragAndDrop = (function (Interaction) {
  function DragAndDrop(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(this, {
      handleEvent: _functions_js__WEBPACK_IMPORTED_MODULE_0__["TRUE"]
    });

    /**
     * @private
     * @type {Array.<function(new: module:ol/format/Feature)>}
     */
    this.formatConstructors_ = options.formatConstructors ?
      options.formatConstructors : [];

    /**
     * @private
     * @type {module:ol/proj/Projection}
     */
    this.projection_ = options.projection ?
      Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(options.projection) : null;

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.dropListenKeys_ = null;

    /**
     * @private
     * @type {module:ol/source/Vector}
     */
    this.source_ = options.source || null;

    /**
     * @private
     * @type {Element}
     */
    this.target = options.target ? options.target : null;

  }

  if ( Interaction ) DragAndDrop.__proto__ = Interaction;
  DragAndDrop.prototype = Object.create( Interaction && Interaction.prototype );
  DragAndDrop.prototype.constructor = DragAndDrop;

  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */
  DragAndDrop.prototype.handleResult_ = function handleResult_ (file, event) {
    var this$1 = this;

    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;
    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var formatConstructors = this.formatConstructors_;
    var features = [];
    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      /**
       * Avoid "cannot instantiate abstract class" error.
       * @type {Function}
       */
      var formatConstructor = formatConstructors[i];
      /**
       * @type {module:ol/format/Feature}
       */
      var format = new formatConstructor();
      features = this$1.tryReadFeatures_(format, result, {
        featureProjection: projection
      });
      if (features && features.length > 0) {
        break;
      }
    }
    if (this.source_) {
      this.source_.clear();
      this.source_.addFeatures(features);
    }
    this.dispatchEvent(
      new DragAndDropEvent(
        DragAndDropEventType.ADD_FEATURES, file,
        features, projection));
  };

  /**
   * @private
   */
  DragAndDrop.prototype.registerListeners_ = function registerListeners_ () {
    var map = this.getMap();
    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleDrop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGENTER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DRAGOVER, handleStop, this),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_1__["listen"])(dropArea, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DROP, handleStop, this)
      ];
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setActive = function setActive (active) {
    Interaction.prototype.setActive.call(this, active);
    if (active) {
      this.registerListeners_();
    } else {
      this.unregisterListeners_();
    }
  };

  /**
   * @inheritDoc
   */
  DragAndDrop.prototype.setMap = function setMap (map) {
    this.unregisterListeners_();
    Interaction.prototype.setMap.call(this, map);
    if (this.getActive()) {
      this.registerListeners_();
    }
  };

  /**
   * @param {module:ol/format/Feature} format Format.
   * @param {string} text Text.
   * @param {module:ol/format/Feature~ReadOptions} options Read options.
   * @private
   * @return {Array.<module:ol/Feature>} Features.
   */
  DragAndDrop.prototype.tryReadFeatures_ = function tryReadFeatures_ (format, text, options) {
    try {
      return format.readFeatures(text, options);
    } catch (e) {
      return null;
    }
  };

  /**
   * @private
   */
  DragAndDrop.prototype.unregisterListeners_ = function unregisterListeners_ () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_1__["unlistenByKey"]);
      this.dropListenKeys_ = null;
    }
  };

  return DragAndDrop;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {DragEvent} event Event.
 * @this {module:ol/interaction/DragAndDrop}
 */
function handleDrop(event) {
  var this$1 = this;

  var files = event.dataTransfer.files;
  for (var i = 0, ii = files.length; i < ii; ++i) {
    var file = files.item(i);
    var reader = new FileReader();
    reader.addEventListener(_events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOAD, this$1.handleResult_.bind(this$1, file));
    reader.readAsText(file);
  }
}


/**
 * @param {DragEvent} event Event.
 */
function handleStop(event) {
  event.stopPropagation();
  event.preventDefault();
  event.dataTransfer.dropEffect = 'copy';
}


/* harmony default export */ __webpack_exports__["default"] = (DragAndDrop);

//# sourceMappingURL=DragAndDrop.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragBox.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragBox.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _render_Box_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/Box.js */ "./node_modules/ol/render/Box.js");
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box







/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, module:ol/MapBrowserEvent, module:ol/pixel~Pixel, module:ol/pixel~Pixel):boolean} EndCondition
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~always}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {module:ol/interaction/DragBox~EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)} onBoxEnd Code to execute just
 * before `boxend` is fired.
 */


/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event module:ol/interaction/DragBox~DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event module:ol/interaction/DragBox~DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event module:ol/interaction/DragBox~DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */
var DragBoxEvent = (function (Event) {
  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * The coordinate of the drag event.
     * @const
     * @type {module:ol/coordinate~Coordinate}
     * @api
     */
    this.coordinate = coordinate;

    /**
     * @const
     * @type {module:ol/MapBrowserEvent}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) DragBoxEvent.__proto__ = Event;
  DragBoxEvent.prototype = Object.create( Event && Event.prototype );
  DragBoxEvent.prototype.constructor = DragBoxEvent;

  return DragBoxEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @fires module:ol/interaction/DragBox~DragBoxEvent
 * @api
 */
var DragBox = (function (PointerInteraction) {
  function DragBox(opt_options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent
    });

    var options = opt_options ? opt_options : {};

    /**
    * @type {module:ol/render/Box}
    * @private
    */
    this.box_ = new _render_Box_js__WEBPACK_IMPORTED_MODULE_4__["default"](options.className || 'ol-dragbox');

    /**
    * @type {number}
    * @private
    */
    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    /**
     * Function to execute just before `onboxend` is fired
     * @type {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)}
     * @private
     */
    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : _functions_js__WEBPACK_IMPORTED_MODULE_2__["UNDEFINED"];

    /**
    * @type {module:ol/pixel~Pixel}
    * @private
    */
    this.startPixel_ = null;

    /**
    * @private
    * @type {module:ol/events/condition~Condition}
    */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
    * @private
    * @type {module:ol/interaction/DragBox~EndCondition}
    */
    this.boxEndCondition_ = options.boxEndCondition ?
      options.boxEndCondition : defaultBoxEndCondition;
  }

  if ( PointerInteraction ) DragBox.__proto__ = PointerInteraction;
  DragBox.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragBox.prototype.constructor = DragBox;

  /**
  * Returns geometry of last drawn box.
  * @return {module:ol/geom/Polygon} Geometry.
  * @api
  */
  DragBox.prototype.getGeometry = function getGeometry () {
    return this.box_.getGeometry();
  };

  return DragBox;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {module:ol/pixel~Pixel} startPixel The starting pixel of the box.
 * @param {module:ol/pixel~Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {module:ol/interaction/DragBox}
 */
function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/DragBox}
 */
function handleDragEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
    return;
  }

  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

  this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,
    mapBrowserEvent.coordinate, mapBrowserEvent));
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/DragBox}
 */
function handleUpEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
    return true;
  }

  this.box_.setMap(null);

  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd_(mapBrowserEvent);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,
      mapBrowserEvent.coordinate, mapBrowserEvent));
  }
  return false;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/DragBox}
 */
function handleDownEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseOnly"])(mapBrowserEvent)) {
    return false;
  }

  if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_1__["mouseActionButton"])(mapBrowserEvent) &&
      this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,
      mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
}


/* harmony default export */ __webpack_exports__["default"] = (DragBox);

//# sourceMappingURL=DragBox.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragPan.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/DragPan.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragPan
 */








/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~noModifierKeys}.
 * @property {module:ol/Kinetic} [kinetic] Kinetic inertia to apply to the pan.
 */


/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan = (function (PointerInteraction) {
  function DragPan(opt_options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_4__["FALSE"]
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {module:ol/Kinetic|undefined}
     */
    this.kinetic_ = options.kinetic;

    /**
     * @type {module:ol/pixel~Pixel}
     */
    this.lastCentroid = null;

    /**
     * @type {number}
     */
    this.lastPointersCount_;

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"];

    /**
     * @private
     * @type {boolean}
     */
    this.noKinetic_ = false;

  }

  if ( PointerInteraction ) DragPan.__proto__ = PointerInteraction;
  DragPan.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragPan.prototype.constructor = DragPan;

  return DragPan;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/DragPan}
 */
function handleDragEvent(mapBrowserEvent) {
  var targetPointers = this.targetPointers;
  var centroid = Object(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["centroid"])(targetPointers);
  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }
    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var center = [deltaX, deltaY];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(center, view.getResolution());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["rotate"])(center, view.getRotation());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["add"])(center, view.getCenter());
      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else if (this.kinetic_) {
    // reset so we don't overestimate the kinetic energy after
    // after one finger down, tiny drag, second finger down
    this.kinetic_.begin();
  }
  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/DragPan}
 */
function handleUpEvent(mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center = /** @type {!module:ol/coordinate~Coordinate} */ (view.getCenter());
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([
        centerpx[0] - distance * Math.cos(angle),
        centerpx[1] - distance * Math.sin(angle)
      ]);
      view.animate({
        center: view.constrainCenter(dest),
        duration: 500,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]
      });
    }
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/DragPan}
 */
function handleDownEvent(mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;
    if (!this.handlingDownUpSequence) {
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    // stop any current animation
    if (view.getAnimating()) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    // No kinetic as soon as more than one pointer on the screen is
    // detected. This is to prevent nasty pans after pinch.
    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
}


/* harmony default export */ __webpack_exports__["default"] = (DragPan);

//# sourceMappingURL=DragPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotate.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotate.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotate
 */








/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate = (function (PointerInteraction) {
  function DragRotate(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_3__["FALSE"]
    });

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["altShiftKeysOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) DragRotate.__proto__ = PointerInteraction;
  DragRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotate.prototype.constructor = DragRotate;

  return DragRotate;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/DragRotate}
 */
function handleDragEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"]) {
    return;
  }
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta =
      Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var rotation = view.getRotation();
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotateWithoutConstraints"])(view, rotation - delta);
  }
  this.lastAngle_ = theta;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/DragRotate}
 */
function handleUpEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
  var rotation = view.getRotation();
  Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["rotate"])(view, rotation, undefined, this.duration_);
  return false;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/DragRotate}
 */
function handleDownEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return false;
  }

  if (Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseActionButton"])(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (DragRotate);

//# sourceMappingURL=DragRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragRotateAndZoom.js":
/*!**********************************************************!*\
  !*** ./node_modules/ol/interaction/DragRotateAndZoom.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/DragRotateAndZoom
 */







/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */


/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
var DragRotateAndZoom = (function (PointerInteraction) {
  function DragRotateAndZoom(opt_options) {

    var options = opt_options ? opt_options : {};

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent
    });

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_2__["shiftKeyOnly"];

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastMagnitude_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

  }

  if ( PointerInteraction ) DragRotateAndZoom.__proto__ = PointerInteraction;
  DragRotateAndZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  DragRotateAndZoom.prototype.constructor = DragRotateAndZoom;

  return DragRotateAndZoom;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/DragRotateAndZoom}
 */
function handleDragEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var deltaX = offset[0] - size[0] / 2;
  var deltaY = size[1] / 2 - offset[1];
  var theta = Math.atan2(deltaY, deltaX);
  var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  var view = map.getView();
  if (view.getConstraints().rotation !== _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_0__["disable"] && this.lastAngle_ !== undefined) {
    var angleDelta = theta - this.lastAngle_;
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotateWithoutConstraints"])(view, view.getRotation() - angleDelta);
  }
  this.lastAngle_ = theta;
  if (this.lastMagnitude_ !== undefined) {
    var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoomWithoutConstraints"])(view, resolution);
  }
  if (this.lastMagnitude_ !== undefined) {
    this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
  }
  this.lastMagnitude_ = magnitude;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/DragRotateAndZoom}
 */
function handleUpEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, -1);
  var direction = this.lastScaleDelta_ - 1;
  Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["rotate"])(view, view.getRotation());
  Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["zoom"])(view, view.getResolution(), undefined, this.duration_, direction);
  this.lastScaleDelta_ = 0;
  return false;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/DragRotateAndZoom}
 */
function handleDownEvent(mapBrowserEvent) {
  if (!Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_2__["mouseOnly"])(mapBrowserEvent)) {
    return false;
  }

  if (this.condition_(mapBrowserEvent)) {
    mapBrowserEvent.map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_1__["default"].INTERACTING, 1);
    this.lastAngle_ = undefined;
    this.lastMagnitude_ = undefined;
    return true;
  } else {
    return false;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (DragRotateAndZoom);

//# sourceMappingURL=DragRotateAndZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/DragZoom.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/DragZoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/DragBox.js */ "./node_modules/ol/interaction/DragBox.js");
/**
 * @module ol/interaction/DragZoom
 */






/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom = (function (DragBox) {
  function DragZoom(opt_options) {
    var options = opt_options ? opt_options : {};

    var condition = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["shiftKeyOnly"];

    DragBox.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      onBoxEnd: onBoxEnd
    });

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 200;

    /**
     * @private
     * @type {boolean}
     */
    this.out_ = options.out !== undefined ? options.out : false;
  }

  if ( DragBox ) DragZoom.__proto__ = DragBox;
  DragZoom.prototype = Object.create( DragBox && DragBox.prototype );
  DragZoom.prototype.constructor = DragZoom;

  return DragZoom;
}(_interaction_DragBox_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @this {module:ol/interaction/DragZoom}
 */
function onBoxEnd() {
  var map = this.getMap();
  var view = /** @type {!module:ol/View} */ (map.getView());
  var size = /** @type {!module:ol/size~Size} */ (map.getSize());
  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdateFromCoordinates"])([
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getBottomLeft"])(extent)),
      map.getPixelFromCoordinate(Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getTopRight"])(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["scaleFromCenter"])(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.constrainResolution(
    view.getResolutionForExtent(extent, size));

  var center = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCenter"])(extent);
  center = view.constrainCenter(center);

  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing_js__WEBPACK_IMPORTED_MODULE_0__["easeOut"]
  });
}


/* harmony default export */ __webpack_exports__["default"] = (DragZoom);

//# sourceMappingURL=DragZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Draw.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Draw.js ***!
  \*********************************************/
/*! exports provided: handleEvent, createRegularPolygon, createBox, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleEvent", function() { return handleEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRegularPolygon", function() { return createRegularPolygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBox", function() { return createBox; });
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom/Circle.js */ "./node_modules/ol/geom/Circle.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/MultiLineString.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom/MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom/MultiPolygon.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../pointer/MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _interaction_Property_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../interaction/Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Draw
 */



























/**
 * @typedef {Object} Options
 * @property {module:ol/geom/GeometryType} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {module:ol/Collection.<module:ol/Feature>} [features]
 * Destination collection for the drawn features.
 * @property {module:ol/source/Vector} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {module:ol/events/condition~Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
 * Style for sketch features.
 * @property {module:ol/interaction/Draw~GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {module:ol/events/condition~Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * Function that takes an array of coordinates and an optional existing geometry as
 * arguments, and returns a geometry. The optional existing geometry is the
 * geometry that is returned when the function is called without a second
 * argument.
 * @typedef {function(!Array.<module:ol/coordinate~Coordinate>, module:ol/geom/SimpleGeometry=):
 *     module:ol/geom/SimpleGeometry} GeometryFunction
 */


/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};


/**
 * @enum {string}
 */
var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event module:ol/interaction/Draw~DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',
  /**
   * Triggered upon feature draw end
   * @event module:ol/interaction/Draw~DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */
var DrawEvent = (function (Event) {
  function DrawEvent(type, feature) {

    Event.call(this, type);

    /**
     * The feature being drawn.
     * @type {module:ol/Feature}
     * @api
     */
    this.feature = feature;

  }

  if ( Event ) DrawEvent.__proto__ = Event;
  DrawEvent.prototype = Object.create( Event && Event.prototype );
  DrawEvent.prototype.constructor = DrawEvent;

  return DrawEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires module:ol/interaction/Draw~DrawEvent
 * @api
 */
var Draw = (function (PointerInteraction) {
  function Draw(options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleEvent: handleEvent,
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_10__["FALSE"]
    });

    /**
     * @type {boolean}
     * @private
     */
    this.shouldHandle_ = false;

    /**
     * @type {module:ol/pixel~Pixel}
     * @private
     */
    this.downPx_ = null;

    /**
     * @type {number|undefined}
     * @private
     */
    this.downTimeout_;

    /**
     * @type {number|undefined}
     * @private
     */
    this.lastDragTime_;

    /**
     * @type {boolean}
     * @private
     */
    this.freehand_ = false;

    /**
     * Target source for drawn features.
     * @type {module:ol/source/Vector}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * Target collection for drawn features.
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */
    this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

    /**
     * Geometry type.
     * @type {module:ol/geom/GeometryType}
     * @private
     */
    this.type_ = /** @type {module:ol/geom/GeometryType} */ (options.type);

    /**
     * Drawing mode (derived from geometry type.
     * @type {module:ol/interaction/Draw~Mode}
     * @private
     */
    this.mode_ = getMode(this.type_);

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */
    this.stopClick_ = !!options.stopClick;

    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */
    this.minPoints_ = options.minPoints ?
      options.minPoints :
      (this.mode_ === Mode.POLYGON ? 3 : 2);

    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */
    this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;

    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions_js__WEBPACK_IMPORTED_MODULE_10__["TRUE"];

    var geometryFunction = options.geometryFunction;
    if (!geometryFunction) {
      if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
        /**
         * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates
         *     The coordinates.
         * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.
         * @return {module:ol/geom/SimpleGeometry} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var circle = opt_geometry ? /** @type {module:ol/geom/Circle} */ (opt_geometry) :
            new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"]([NaN, NaN]);
          var squaredLength = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(
            coordinates[0], coordinates[1]);
          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));
          return circle;
        };
      } else {
        var Constructor;
        var mode = this.mode_;
        if (mode === Mode.POINT) {
          Constructor = _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"];
        } else if (mode === Mode.LINE_STRING) {
          Constructor = _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"];
        } else if (mode === Mode.POLYGON) {
          Constructor = _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"];
        }
        /**
         * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates
         *     The coordinates.
         * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.
         * @return {module:ol/geom/SimpleGeometry} A geometry.
         */
        geometryFunction = function(coordinates, opt_geometry) {
          var geometry = opt_geometry;
          if (geometry) {
            if (mode === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor(coordinates);
          }
          return geometry;
        };
      }
    }

    /**
     * @type {module:ol/interaction/Draw~GeometryFunction}
     * @private
     */
    this.geometryFunction_ = geometryFunction;

    /**
     * @type {number}
     * @private
     */
    this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {module:ol/coordinate~Coordinate}
     * @private
     */
    this.finishCoordinate_ = null;

    /**
     * Sketch feature.
     * @type {module:ol/Feature}
     * @private
     */
    this.sketchFeature_ = null;

    /**
     * Sketch point.
     * @type {module:ol/Feature}
     * @private
     */
    this.sketchPoint_ = null;

    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>}
     * @private
     */
    this.sketchCoords_ = null;

    /**
     * Sketch line. Used when drawing polygon.
     * @type {module:ol/Feature}
     * @private
     */
    this.sketchLine_ = null;

    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {Array.<module:ol/coordinate~Coordinate>}
     * @private
     */
    this.sketchLineCoords_ = null;

    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */
    this.squaredClickTolerance_ = options.clickTolerance ?
      options.clickTolerance * options.clickTolerance : 36;

    /**
     * Draw overlay where our sketch features are drawn.
     * @type {module:ol/layer/Vector}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_22__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_23__["default"]({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileInteracting: true
    });

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */
    this.geometryName_ = options.geometryName;

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["noModifierKeys"];

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.freehandCondition_;
    if (options.freehand) {
      this.freehandCondition_ = _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["always"];
    } else {
      this.freehandCondition_ = options.freehandCondition ?
        options.freehandCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_8__["shiftKeyOnly"];
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_4__["getChangeEventType"])(_interaction_Property_js__WEBPACK_IMPORTED_MODULE_21__["default"].ACTIVE),
      this.updateState_, this);

  }

  if ( PointerInteraction ) Draw.__proto__ = PointerInteraction;
  Draw.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Draw.prototype.constructor = Draw;

  /**
   * @inheritDoc
   */
  Draw.prototype.setMap = function setMap (map) {
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_();
  };

  /**
   * Handle move events.
   * @param {module:ol/MapBrowserEvent} event A move event.
   * @return {boolean} Pass the event to other interactions.
   * @private
   */
  Draw.prototype.handlePointerMove_ = function handlePointerMove_ (event) {
    if (this.downPx_ &&
        ((!this.freehand_ && this.shouldHandle_) ||
        (this.freehand_ && !this.shouldHandle_))) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ?
        squaredDistance > this.squaredClickTolerance_ :
        squaredDistance <= this.squaredClickTolerance_;
      if (!this.shouldHandle_) {
        return true;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event);
    } else {
      this.createOrUpdateSketchPoint_(event);
    }
    return true;
  };

  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {module:ol/MapBrowserEvent} event Event.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  Draw.prototype.atFinish_ = function atFinish_ (event) {
    var this$1 = this;

    var at = false;
    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      if (this.mode_ === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (this.mode_ === Mode.POLYGON) {
        potentiallyDone = this.sketchCoords_[0].length >
            this.minPoints_;
        potentiallyFinishCoordinates = [this.sketchCoords_[0][0],
          this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];
      }
      if (potentiallyDone) {
        var map = event.map;
        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var pixel = event.pixel;
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this$1.freehand_ ? 1 : this$1.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
          if (at) {
            this$1.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }
    return at;
  };

  /**
   * @param {module:ol/MapBrowserEvent} event Event.
   * @private
   */
  Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_ (event) {
    var coordinates = event.coordinate.slice();
    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_18__["default"](coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinates);
    }
  };

  /**
   * Start the drawing.
   * @param {module:ol/MapBrowserEvent} event Event.
   * @private
   */
  Draw.prototype.startDrawing_ = function startDrawing_ (event) {
    var start = event.coordinate;
    this.finishCoordinate_ = start;
    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }
    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.sketchLineCoords_));
    }
    var geometry = this.geometryFunction_(this.sketchCoords_);
    this.sketchFeature_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }
    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Modify the drawing.
   * @param {module:ol/MapBrowserEvent} event Event.
   * @private
   */
  Draw.prototype.modifyDrawing_ = function modifyDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
    var coordinates, last;
    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = this.sketchCoords_[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(event)) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(/** @type {!Array.<module:ol/coordinate~Coordinate>} */ (this.sketchCoords_), geometry);
    if (this.sketchPoint_) {
      var sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());
      sketchPointGeom.setCoordinates(coordinate);
    }
    var sketchLineGeom;
    if (geometry instanceof _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"] &&
        this.mode_ !== Mode.POLYGON) {
      if (!this.sketchLine_) {
        this.sketchLine_ = new _Feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
      }
      var ring = geometry.getLinearRing(0);
      sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
      if (!sketchLineGeom) {
        sketchLineGeom = new _geom_LineString_js__WEBPACK_IMPORTED_MODULE_13__["default"](ring.getFlatCoordinates(), ring.getLayout());
        this.sketchLine_.setGeometry(sketchLineGeom);
      } else {
        sketchLineGeom.setFlatCoordinates(
          ring.getLayout(), ring.getFlatCoordinates());
        sketchLineGeom.changed();
      }
    } else if (this.sketchLineCoords_) {
      sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
    this.updateSketchFeatures_();
  };

  /**
   * Add a new coordinate to the drawing.
   * @param {module:ol/MapBrowserEvent} event Event.
   * @private
   */
  Draw.prototype.addToDrawing_ = function addToDrawing_ (event) {
    var coordinate = event.coordinate;
    var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
    var done;
    var coordinates;
    if (this.mode_ === Mode.LINE_STRING) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates = this.sketchCoords_;
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = this.sketchCoords_[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry);
    }
    this.updateSketchFeatures_();
    if (done) {
      this.finishDrawing();
    }
  };

  /**
   * Remove last point of the feature currently being drawn.
   * @api
   */
  Draw.prototype.removeLastPoint = function removeLastPoint () {
    if (!this.sketchFeature_) {
      return;
    }
    var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
    var coordinates, sketchLineGeom;
    if (this.mode_ === Mode.LINE_STRING) {
      coordinates = this.sketchCoords_;
      coordinates.splice(-2, 1);
      this.geometryFunction_(coordinates, geometry);
      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
      }
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates = this.sketchCoords_[0];
      coordinates.splice(-2, 1);
      sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry);
    }

    if (coordinates.length === 0) {
      this.finishCoordinate_ = null;
    }

    this.updateSketchFeatures_();
  };

  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */
  Draw.prototype.finishDrawing = function finishDrawing () {
    var sketchFeature = this.abortDrawing_();
    if (!sketchFeature) {
      return;
    }
    var coordinates = this.sketchCoords_;
    var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (sketchFeature.getGeometry());
    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring
      coordinates[0].pop();
      this.geometryFunction_(coordinates, geometry);
      coordinates = geometry.getCoordinates();
    }

    // cast multi-part geometries
    if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
      sketchFeature.setGeometry(new _geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_15__["default"]([coordinates]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_14__["default"]([coordinates]));
    } else if (this.type_ === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
      sketchFeature.setGeometry(new _geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_16__["default"]([coordinates]));
    }

    // First dispatch event to allow full set up of feature
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

    // Then insert feature
    if (this.features_) {
      this.features_.push(sketchFeature);
    }
    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };

  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {module:ol/Feature} The sketch feature (or null if none).
   * @private
   */
  Draw.prototype.abortDrawing_ = function abortDrawing_ () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    if (sketchFeature) {
      this.sketchFeature_ = null;
      this.sketchPoint_ = null;
      this.sketchLine_ = null;
      this.overlay_.getSource().clear(true);
    }
    return sketchFeature;
  };

  /**
   * Extend an existing geometry by adding additional points. This only works
   * on features with `LineString` geometries, where the interaction will
   * extend lines by adding points to the end of the coordinates array.
   * @param {!module:ol/Feature} feature Feature to be extended.
   * @api
   */
  Draw.prototype.extend = function extend (feature) {
    var geometry = feature.getGeometry();
    var lineString = /** @type {module:ol/geom/LineString} */ (geometry);
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };

  /**
   * Redraw the sketch features.
   * @private
   */
  Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_ () {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }
    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };

  /**
   * @private
   */
  Draw.prototype.updateState_ = function updateState_ () {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      this.abortDrawing_();
    }
    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_20__["default"]));


/**
 * @return {module:ol/style/Style~StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_24__["createEditingStyle"])();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually
 * draw or finish the drawing.
 * @param {module:ol/MapBrowserEvent} event Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/Draw}
 * @api
 */
function handleEvent(event) {
  if (event.originalEvent.type === _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CONTEXTMENU) {
    // Avoid context menu for long taps when drawing on mobile
    event.preventDefault();
  }
  this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
  var move = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
  var pass = true;
  if (this.lastDragTime_ && event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG) {
    var now = Date.now();
    if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
      this.downPx_ = event.pixel;
      this.shouldHandle_ = !this.freehand_;
      move = true;
    } else {
      this.lastDragTime_ = undefined;
    }
    if (this.shouldHandle_ && this.downTimeout_) {
      clearTimeout(this.downTimeout_);
      this.downTimeout_ = undefined;
    }
  }
  if (this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG &&
      this.sketchFeature_ !== null) {
    this.addToDrawing_(event);
    pass = false;
  } else if (this.freehand_ &&
      event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDOWN) {
    pass = false;
  } else if (move) {
    pass = event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE;
    if (pass && this.freehand_) {
      pass = this.handlePointerMove_(event);
    } else if (event.pointerEvent.pointerType == _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_17__["POINTER_TYPE"] ||
        (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERDRAG && !this.downTimeout_)) {
      this.handlePointerMove_(event);
    }
  } else if (event.type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].DBLCLICK) {
    pass = false;
  }

  return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_20__["handleEvent"].call(this, event) && pass;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} event Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/Draw}
 */
function handleDownEvent(event) {
  this.shouldHandle_ = !this.freehand_;

  if (this.freehand_) {
    this.downPx_ = event.pixel;
    if (!this.finishCoordinate_) {
      this.startDrawing_(event);
    }
    return true;
  } else if (this.condition_(event)) {
    this.lastDragTime_ = Date.now();
    this.downTimeout_ = setTimeout(function() {
      this.handlePointerMove_(new _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].POINTERMOVE, event.map, event.pointerEvent, event.frameState));
    }.bind(this), this.dragVertexDelay_);
    this.downPx_ = event.pixel;
    return true;
  } else {
    return false;
  }
}


/**
 * @param {module:ol/MapBrowserPointerEvent} event Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/Draw}
 */
function handleUpEvent(event) {
  var pass = true;

  if (this.downTimeout_) {
    clearTimeout(this.downTimeout_);
    this.downTimeout_ = undefined;
  }

  this.handlePointerMove_(event);

  var circleMode = this.mode_ === Mode.CIRCLE;

  if (this.shouldHandle_) {
    if (!this.finishCoordinate_) {
      this.startDrawing_(event);
      if (this.mode_ === Mode.POINT) {
        this.finishDrawing();
      }
    } else if (this.freehand_ || circleMode) {
      this.finishDrawing();
    } else if (this.atFinish_(event)) {
      if (this.finishCondition_(event)) {
        this.finishDrawing();
      }
    } else {
      this.addToDrawing_(event);
    }
    pass = false;
  } else if (this.freehand_) {
    this.finishCoordinate_ = null;
    this.abortDrawing_();
  }
  if (!pass && this.stopClick_) {
    event.stopPropagation();
  }
  return pass;
}


/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of an
 * `module:ol/geom/Circle~Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon. Default is
 *     32.
 * @param {number=} opt_angle Angle of the first point in radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a
 *     polygon.
 * @api
 */
function createRegularPolygon(opt_sides, opt_angle) {
  return function(coordinates, opt_geometry) {
    var center = coordinates[0];
    var end = coordinates[1];
    var radius = Math.sqrt(
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_5__["squaredDistance"])(center, end));
    var geometry = opt_geometry ? /** @type {module:ol/geom/Polygon} */ (opt_geometry) :
      Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["fromCircle"])(new _geom_Circle_js__WEBPACK_IMPORTED_MODULE_11__["default"](center), opt_sides);
    var angle = opt_angle ? opt_angle :
      Math.atan((end[1] - center[1]) / (end[0] - center[0]));
    Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["makeRegular"])(geometry, center, radius, angle);
    return geometry;
  };
}


/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {module:ol/interaction/Draw~GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */
function createBox() {
  return (
    function(coordinates, opt_geometry) {
      var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["boundingExtent"])(coordinates);
      var boxCoordinates = [[
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopRight"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getTopLeft"])(extent),
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["getBottomLeft"])(extent)
      ]];
      var geometry = opt_geometry;
      if (geometry) {
        geometry.setCoordinates(boxCoordinates);
      } else {
        geometry = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_19__["default"](boxCoordinates);
      }
      return geometry;
    }
  );
}


/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {module:ol/geom/GeometryType} type Geometry type.
 * @return {module:ol/interaction/Draw~Mode} Drawing mode.
 */
function getMode(type) {
  var mode;
  if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POINT ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POINT) {
    mode = Mode.POINT;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].LINE_STRING ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_LINE_STRING) {
    mode = Mode.LINE_STRING;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].POLYGON ||
      type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].MULTI_POLYGON) {
    mode = Mode.POLYGON;
  } else if (type === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_12__["default"].CIRCLE) {
    mode = Mode.CIRCLE;
  }
  return (
    /** @type {!module:ol/interaction/Draw~Mode} */ (mode)
  );
}


/* harmony default export */ __webpack_exports__["default"] = (Draw);

//# sourceMappingURL=Draw.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Extent.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Extent.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Extent
 */















/**
 * @typedef {Object} Options
 * @property {module:ol/extent~Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */


/**
 * @enum {string}
 */
var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event module:ol/interaction/Extent~ExtentEventType#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */
var ExtentInteractionEvent = (function (Event) {
  function ExtentInteractionEvent(extent) {
    Event.call(this, ExtentEventType.EXTENTCHANGED);

    /**
     * The current extent.
     * @type {module:ol/extent~Extent}
     * @api
     */
    this.extent = extent;
  }

  if ( Event ) ExtentInteractionEvent.__proto__ = Event;
  ExtentInteractionEvent.prototype = Object.create( Event && Event.prototype );
  ExtentInteractionEvent.prototype.constructor = ExtentInteractionEvent;

  return ExtentInteractionEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires module:ol/interaction/Extent~Event
 * @api
 */
var ExtentInteraction = (function (PointerInteraction) {
  function ExtentInteraction(opt_options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleEvent: handleEvent,
      handleUpEvent: handleUpEvent
    });

    var options = opt_options || {};

    /**
     * Extent of the drawn box
     * @type {module:ol/extent~Extent}
     * @private
     */
    this.extent_ = null;

    /**
     * Handler for pointer move events
     * @type {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null}
     * @private
     */
    this.pointerHandler_ = null;

    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Feature for displaying the visible extent
     * @type {module:ol/Feature}
     * @private
     */
    this.extentFeature_ = null;

    /**
     * Feature for displaying the visible pointer
     * @type {module:ol/Feature}
     * @private
     */
    this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }

    /**
     * Layer for the extentFeature
     * @type {module:ol/layer/Vector}
     * @private
     */
    this.extentOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * Layer for the vertexFeature
     * @type {module:ol/layer/Vector}
     * @private
     */
    this.vertexOverlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_10__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      this.setExtent(opt_options.extent);
    }
  }

  if ( PointerInteraction ) ExtentInteraction.__proto__ = PointerInteraction;
  ExtentInteraction.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  ExtentInteraction.prototype.constructor = ExtentInteraction;

  /**
   * @param {module:ol/pixel~Pixel} pixel cursor location
   * @param {module:ol/PluggableMap} map map
   * @returns {module:ol/coordinate~Coordinate|null} snapped vertex on extent
   * @private
   */
  ExtentInteraction.prototype.snapToVertex_ = function snapToVertex_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistanceToSegment"])(pixelCoordinate, a) -
          Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistanceToSegment"])(pixelCoordinate, b);
    };
    var extent = this.getExtent();
    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];

      var vertex = (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["closestOnSegment"])(pixelCoordinate,
        closestSegment));
      var vertexPixel = map.getPixelFromCoordinate(vertex);

      //if the distance is within tolerance, snap to the segment
      if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(vertexPixel, pixel1);
        var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ?
            closestSegment[1] : closestSegment[0];
        }
        return vertex;
      }
    }
    return null;
  };

  /**
   * @param {module:ol/MapBrowserEvent} mapBrowserEvent pointer move event
   * @private
   */
  ExtentInteraction.prototype.handlePointerMove_ = function handlePointerMove_ (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;

    var vertex = this.snapToVertex_(pixel, map);
    if (!vertex) {
      vertex = map.getCoordinateFromPixel(pixel);
    }
    this.createOrUpdatePointerFeature_(vertex);
  };

  /**
   * @param {module:ol/extent~Extent} extent extent
   * @returns {module:ol/Feature} extent as featrue
   * @private
   */
  ExtentInteraction.prototype.createOrUpdateExtentFeature_ = function createOrUpdateExtentFeature_ (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"]({});
      } else {
        extentFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["fromExtent"])(extent));
      }
      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry(Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_8__["fromExtent"])(extent));
      }
    }
    return extentFeature;
  };

  /**
   * @param {module:ol/coordinate~Coordinate} vertex location of feature
   * @returns {module:ol/Feature} vertex as feature
   * @private
   */
  ExtentInteraction.prototype.createOrUpdatePointerFeature_ = function createOrUpdatePointerFeature_ (vertex) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_0__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_7__["default"](vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(vertex);
    }
    return vertexFeature;
  };

  /**
   * @inheritDoc
   */
  ExtentInteraction.prototype.setMap = function setMap (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {module:ol/extent~Extent} Drawn extent in the view projection.
   * @api
   */
  ExtentInteraction.prototype.getExtent = function getExtent () {
    return this.extent_;
  };

  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {module:ol/extent~Extent} extent Extent
   * @api
   */
  ExtentInteraction.prototype.setExtent = function setExtent (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentInteractionEvent(this.extent_));
  };

  return ExtentInteraction;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_9__["default"]));

/**
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Event.
 * @return {boolean} Propagate event?
 * @this {module:ol/interaction/Extent~Extent}
 */
function handleEvent(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"])) {
    return true;
  }
  //display pointer (if not dragging)
  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE && !this.handlingDownUpSequence) {
    this.handlePointerMove_(mapBrowserEvent);
  }
  //call pointer to determine up/down/drag
  _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_9__["handleEvent"].call(this, mapBrowserEvent);
  //return false to stop propagation
  return false;
}

/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Event handled?
 * @this {module:ol/interaction/Extent~Extent}
 */
function handleDownEvent(mapBrowserEvent) {
  var pixel = mapBrowserEvent.pixel;
  var map = mapBrowserEvent.map;

  var extent = this.getExtent();
  var vertex = this.snapToVertex_(pixel, map);

  //find the extent corner opposite the passed corner
  var getOpposingPoint = function(point) {
    var x_ = null;
    var y_ = null;
    if (point[0] == extent[0]) {
      x_ = extent[2];
    } else if (point[0] == extent[2]) {
      x_ = extent[0];
    }
    if (point[1] == extent[1]) {
      y_ = extent[3];
    } else if (point[1] == extent[3]) {
      y_ = extent[1];
    }
    if (x_ !== null && y_ !== null) {
      return [x_, y_];
    }
    return null;
  };
  if (vertex && extent) {
    var x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;
    var y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;

    //snap to point
    if (x !== null && y !== null) {
      this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
    //snap to edge
    } else if (x !== null) {
      this.pointerHandler_ = getEdgeHandler(
        getOpposingPoint([x, extent[1]]),
        getOpposingPoint([x, extent[3]])
      );
    } else if (y !== null) {
      this.pointerHandler_ = getEdgeHandler(
        getOpposingPoint([extent[0], y]),
        getOpposingPoint([extent[2], y])
      );
    }
  //no snap - new bbox
  } else {
    vertex = map.getCoordinateFromPixel(pixel);
    this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
    this.pointerHandler_ = getPointHandler(vertex);
  }
  return true; //event handled; start downup sequence
}

/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Event handled?
 * @this {module:ol/interaction/Extent~Extent}
 */
function handleDragEvent(mapBrowserEvent) {
  if (this.pointerHandler_) {
    var pixelCoordinate = mapBrowserEvent.coordinate;
    this.setExtent(this.pointerHandler_(pixelCoordinate));
    this.createOrUpdatePointerFeature_(pixelCoordinate);
  }
  return true;
}

/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/Extent~Extent}
 */
function handleUpEvent(mapBrowserEvent) {
  this.pointerHandler_ = null;
  //If bbox is zero area, set to null;
  var extent = this.getExtent();
  if (!extent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(extent) === 0) {
    this.setExtent(null);
  }
  return false; //Stop handling downup sequence
}

/**
 * Returns the default style for the drawn bbox
 *
 * @return {module:ol/style/Style~StyleFunction} Default Extent style
 */
function getDefaultExtentStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_12__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON];
  };
}

/**
 * Returns the default style for the pointer
 *
 * @return {module:ol/style/Style~StyleFunction} Default pointer style
 */
function getDefaultPointerStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_12__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINT];
  };
}

/**
 * @param {module:ol/coordinate~Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent} event handler
 */
function getPointHandler(fixedPoint) {
  return function(point) {
    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])([fixedPoint, point]);
  };
}

/**
 * @param {module:ol/coordinate~Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {module:ol/coordinate~Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null} event handler
 */
function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function(point) {
      return Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["boundingExtent"])([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}

/**
 * @param {module:ol/extent~Extent} extent extent
 * @returns {Array<Array<module:ol/coordinate~Coordinate>>} extent line segments
 */
function getSegments(extent) {
  return [
    [[extent[0], extent[1]], [extent[0], extent[3]]],
    [[extent[0], extent[3]], [extent[2], extent[3]]],
    [[extent[2], extent[3]], [extent[2], extent[1]]],
    [[extent[2], extent[1]], [extent[0], extent[1]]]
  ];
}


/* harmony default export */ __webpack_exports__["default"] = (ExtentInteraction);

//# sourceMappingURL=Extent.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Interaction.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/Interaction.js ***!
  \****************************************************/
/*! exports provided: pan, rotate, rotateWithoutConstraints, zoom, zoomByDelta, zoomWithoutConstraints, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pan", function() { return pan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateWithoutConstraints", function() { return rotateWithoutConstraints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomByDelta", function() { return zoomByDelta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomWithoutConstraints", function() { return zoomWithoutConstraints; });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _interaction_Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interaction/Property.js */ "./node_modules/ol/interaction/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/Interaction
 */






/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(module:ol/MapBrowserEvent):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return).
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction = (function (BaseObject) {
  function Interaction(options) {
    BaseObject.call(this);

    /**
     * @private
     * @type {module:ol/PluggableMap}
     */
    this.map_ = null;

    this.setActive(true);

    /**
     * @type {function(module:ol/MapBrowserEvent):boolean}
     */
    this.handleEvent = options.handleEvent;

  }

  if ( BaseObject ) Interaction.__proto__ = BaseObject;
  Interaction.prototype = Object.create( BaseObject && BaseObject.prototype );
  Interaction.prototype.constructor = Interaction;

  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  Interaction.prototype.getActive = function getActive () {
    return /** @type {boolean} */ (this.get(_interaction_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE));
  };

  /**
   * Get the map associated with this interaction.
   * @return {module:ol/PluggableMap} Map.
   * @api
   */
  Interaction.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  Interaction.prototype.setActive = function setActive (active) {
    this.set(_interaction_Property_js__WEBPACK_IMPORTED_MODULE_2__["default"].ACTIVE, active);
  };

  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {module:ol/PluggableMap} map Map.
   */
  Interaction.prototype.setMap = function setMap (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * @param {module:ol/View} view View.
 * @param {module:ol/coordinate~Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */
function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter(
      [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["linear"],
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
}


/**
 * @param {module:ol/View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotate(view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
}


/**
 * @param {module:ol/View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
}


/**
 * @param {module:ol/View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */
function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {module:ol/View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(
      resolution,
      view.getMinResolution() || resolutions[resolutions.length - 1],
      view.getMaxResolution() || resolutions[0]);
  }

  // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);

    opt_anchor = [
      (resolution * currentCenter[0] - currentResolution * center[0]) /
          (resolution - currentResolution),
      (resolution * currentCenter[1] - currentResolution * center[1]) /
          (resolution - currentResolution)
    ];
  }

  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
}


/**
 * @param {module:ol/View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter &&
        resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_1__["easeOut"]
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Interaction);

//# sourceMappingURL=Interaction.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardPan.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardPan.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/KeyCode.js */ "./node_modules/ol/events/KeyCode.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardPan
 */







/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~noModifierKeys} and
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */


/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan = (function (Interaction) {
  function KeyboardPan(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options || {};

    /**
     * @private
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["noModifierKeys"])(mapBrowserEvent) &&
        Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_3__["targetNotEditable"])(mapBrowserEvent);
    };

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition !== undefined ?
      options.condition : this.defaultCondition_;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

    /**
     * @private
     * @type {number}
     */
    this.pixelDelta_ = options.pixelDelta !== undefined ?
      options.pixelDelta : 128;

  }

  if ( Interaction ) KeyboardPan.__proto__ = Interaction;
  KeyboardPan.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardPan.prototype.constructor = KeyboardPan;

  return KeyboardPan;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/KeyboardPan}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) &&
        (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT ||
        keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0, deltaY = 0;
      if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _events_KeyCode_js__WEBPACK_IMPORTED_MODULE_2__["default"].RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }
      var delta = [deltaX, deltaY];
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_0__["rotate"])(delta, view.getRotation());
      Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_4__["pan"])(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardPan);

//# sourceMappingURL=KeyboardPan.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/KeyboardZoom.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/interaction/KeyboardZoom.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/**
 * @module ol/interaction/KeyboardZoom
 */





/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */


/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link moudle:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom = (function (Interaction) {
  function KeyboardZoom(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["targetNotEditable"];

    /**
     * @private
     * @type {number}
     */
    this.delta_ = options.delta ? options.delta : 1;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 100;

  }

  if ( Interaction ) KeyboardZoom.__proto__ = Interaction;
  KeyboardZoom.prototype = Object.create( Interaction && Interaction.prototype );
  KeyboardZoom.prototype.constructor = KeyboardZoom;

  return KeyboardZoom;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/KeyboardZoom}
 */
function handleEvent(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYDOWN ||
      mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__["default"].KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) &&
        (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;
      var view = map.getView();
      Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomByDelta"])(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
}

/* harmony default export */ __webpack_exports__["default"] = (KeyboardZoom);

//# sourceMappingURL=KeyboardZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Modify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Modify.js ***!
  \***********************************************/
/*! exports provided: ModifyEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModifyEvent", function() { return ModifyEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Point_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom/Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Modify
 */























/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;

/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CIRCUMFERENCE_INDEX = 1;


/**
 * @enum {string}
 */
var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};


/**
 * @typedef {Object} SegmentData
 * @property {Array.<number>} [depth]
 * @property {module:ol/Feature} feature
 * @property {module:ol/geom/SimpleGeometry} geometry
 * @property {number} index
 * @property {Array.<module:ol/extent~Extent>} segment
 * @property {Array.<module:ol/interaction/Modify~SegmentData>} [featureSegments]
 */


/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition~primaryAction}.
 * @property {module:ol/events/condition~Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition~singleClick} with
 * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
 * @property {module:ol/events/condition~Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex can be added to the sketch
 * features. Default is {@link module:ol/events/condition~always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
 * Style used for the features being modified. By default the default edit
 * style is used (see {@link module:ol/style}).
 * @property {module:ol/source/Vector} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the features option.
 * @property {module:ol/Collection.<module:ol/Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the source option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */
var ModifyEvent = (function (Event) {
  function ModifyEvent(type, features, mapBrowserPointerEvent) {
    Event.call(this, type);

    /**
     * The features being modified.
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @api
     */
    this.features = features;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {module:ol/MapBrowserEvent}
     * @api
     */
    this.mapBrowserEvent = mapBrowserPointerEvent;

  }

  if ( Event ) ModifyEvent.__proto__ = Event;
  ModifyEvent.prototype = Object.create( Event && Event.prototype );
  ModifyEvent.prototype.constructor = ModifyEvent;

  return ModifyEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires module:ol/interaction/Modify~ModifyEvent
 * @api
 */
var Modify = (function (PointerInteraction) {
  function Modify(options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleEvent: handleEvent,
      handleUpEvent: handleUpEvent
    });

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["primaryAction"];


    /**
     * @private
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */
    this.defaultDeleteCondition_ = function(mapBrowserEvent) {
      return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_11__["altKeyOnly"])(mapBrowserEvent) && Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_11__["singleClick"])(mapBrowserEvent);
    };

    /**
     * @type {module:ol/events/condition~Condition}
     * @private
     */
    this.deleteCondition_ = options.deleteCondition ?
      options.deleteCondition : this.defaultDeleteCondition_;

    /**
     * @type {module:ol/events/condition~Condition}
     * @private
     */
    this.insertVertexCondition_ = options.insertVertexCondition ?
      options.insertVertexCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_11__["always"];

    /**
     * Editing vertex.
     * @type {module:ol/Feature}
     * @private
     */
    this.vertexFeature_ = null;

    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object.<string, boolean>}
     * @private
     */
    this.vertexSegments_ = null;

    /**
     * @type {module:ol/pixel~Pixel}
     * @private
     */
    this.lastPixel_ = [0, 0];

    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */
    this.ignoreNextSingleClick_ = false;

    /**
     * @type {boolean}
     * @private
     */
    this.modified_ = false;

    /**
     * Segment RTree for each layer
     * @type {module:ol/structs/RBush.<module:ol/interaction/Modify~SegmentData>}
     * @private
     */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_19__["default"]();

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {boolean}
     * @private
     */
    this.snappedToVertex_ = false;

    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */
    this.changingFeature_ = false;

    /**
     * @type {Array}
     * @private
     */
    this.dragSegments_ = [];

    /**
     * Draw overlay where sketch features are drawn.
     * @type {module:ol/layer/Vector}
     * @private
     */
    this.overlay_ = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_16__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_17__["default"]({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @const
     * @private
     * @type {!Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}
     */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'Circle': this.writeCircleGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_
    };


    /**
     * @type {module:ol/source/Vector}
     * @private
     */
    this.source_ = null;

    var features;
    if (options.source) {
      this.source_ = options.source;
      features = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](this.source_.getFeatures());
      Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].ADDFEATURE,
        this.handleSourceAdd_, this);
      Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_18__["default"].REMOVEFEATURE,
        this.handleSourceRemove_, this);
    } else {
      features = options.features;
    }
    if (!features) {
      throw new Error('The modify interaction requires features or a source');
    }

    /**
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @private
     */
    this.features_ = features;

    this.features_.forEach(this.addFeature_.bind(this));
    Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
      this.handleFeatureAdd_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
      this.handleFeatureRemove_, this);

    /**
     * @type {module:ol/MapBrowserPointerEvent}
     * @private
     */
    this.lastPointerEvent_ = null;

  }

  if ( PointerInteraction ) Modify.__proto__ = PointerInteraction;
  Modify.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Modify.prototype.constructor = Modify;

  /**
   * @param {module:ol/Feature} feature Feature.
   * @private
   */
  Modify.prototype.addFeature_ = function addFeature_ (feature) {
    var geometry = feature.getGeometry();
    if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {
      this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);
    }
    var map = this.getMap();
    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {module:ol/MapBrowserPointerEvent} evt Map browser event
   * @private
   */
  Modify.prototype.willModifyFeatures_ = function willModifyFeatures_ (evt) {
    if (!this.modified_) {
      this.modified_ = true;
      this.dispatchEvent(new ModifyEvent(
        ModifyEventType.MODIFYSTART, this.features_, evt));
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeature_ = function removeFeature_ (feature) {
    this.removeFeatureSegmentData_(feature);
    // Remove the vertex feature if the collection of canditate features
    // is empty.
    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    Object(_events_js__WEBPACK_IMPORTED_MODULE_8__["unlisten"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_10__["default"].CHANGE,
      this.handleFeatureChange_, this);
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   * @private
   */
  Modify.prototype.removeFeatureSegmentData_ = function removeFeatureSegmentData_ (feature) {
    var rBush = this.rBush_;
    var /** @type {Array.<module:ol/interaction/Modify~SegmentData>} */ nodesToRemove = [];
    rBush.forEach(
      /**
       * @param {module:ol/interaction/Modify~SegmentData} node RTree node.
       */
      function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      rBush.remove(nodesToRemove[i]);
    }
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setActive = function setActive (active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
    PointerInteraction.prototype.setActive.call(this, active);
  };

  /**
   * @inheritDoc
   */
  Modify.prototype.setMap = function setMap (map) {
    this.overlay_.setMap(map);
    PointerInteraction.prototype.setMap.call(this, map);
  };

  /**
   * @param {module:ol/source/Vector~VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceAdd_ = function handleSourceAdd_ (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };

  /**
   * @param {module:ol/source/Vector~VectorSourceEvent} event Event.
   * @private
   */
  Modify.prototype.handleSourceRemove_ = function handleSourceRemove_ (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    this.addFeature_(/** @type {module:ol/Feature} */ (evt.element));
  };

  /**
   * @param {module:ol/events/Event} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    if (!this.changingFeature_) {
      var feature = /** @type {module:ol/Feature} */ (evt.target);
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Modify.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature = /** @type {module:ol/Feature} */ (evt.element);
    this.removeFeature_(feature);
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/Point} geometry Geometry.
   * @private
   */
  Modify.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiPoint} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var this$1 = this;

    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      });
      this$1.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/LineString} geometry Geometry.
   * @private
   */
  Modify.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var this$1 = this;

    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      });
      this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiLineString} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var this$1 = this;

    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/Polygon} geometry Geometry.
   * @private
   */
  Modify.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var this$1 = this;

    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        });
        this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiPolygon} geometry Geometry.
   * @private
   */
  Modify.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var this$1 = this;

    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          });
          this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {module:ol/Feature} feature Feature.
   * @param {module:ol/geom/Circle} geometry Geometry.
   * @private
   */
  Modify.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var coordinates = geometry.getCenter();
    var centerSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    });
    var circumferenceSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    });
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
    this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/GeometryCollection} geometry Geometry.
   * @private
   */
  Modify.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var this$1 = this;

    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      this$1.SEGMENT_WRITERS_[geometries[i].getType()].call(this$1, feature, geometries[i]);
    }
  };

  /**
   * @param {module:ol/coordinate~Coordinate} coordinates Coordinates.
   * @return {module:ol/Feature} Vertex feature.
   * @private
   */
  Modify.prototype.createOrUpdateVertexFeature_ = function createOrUpdateVertexFeature_ (coordinates) {
    var vertexFeature = this.vertexFeature_;
    if (!vertexFeature) {
      vertexFeature = new _Feature_js__WEBPACK_IMPORTED_MODULE_3__["default"](new _geom_Point_js__WEBPACK_IMPORTED_MODULE_14__["default"](coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
      geometry.setCoordinates(coordinates);
    }
    return vertexFeature;
  };

  /**
   * @param {module:ol/MapBrowserEvent} evt Event.
   * @private
   */
  Modify.prototype.handlePointerMove_ = function handlePointerMove_ (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map);
  };

  /**
   * @param {module:ol/pixel~Pixel} pixel Pixel
   * @param {module:ol/PluggableMap} map Map.
   * @private
   */
  Modify.prototype.handlePointerAtPixel_ = function handlePointerAtPixel_ (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixel(pixel);
    var sortByDistance = function(a, b) {
      return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -
          pointDistanceToSegmentDataSquared(pixelCoordinate, b);
    };

    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["buffer"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["createOrUpdateFromCoordinate"])(pixelCoordinate),
      map.getView().getResolution() * this.pixelTolerance_);

    var rBush = this.rBush_;
    var nodes = rBush.getInExtent(box);
    if (nodes.length > 0) {
      nodes.sort(sortByDistance);
      var node = nodes[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["distance"])(pixel, vertexPixel);
      if (dist <= this.pixelTolerance_) {
        var vertexSegments = {};

        if (node.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE &&
        node.index === CIRCLE_CIRCUMFERENCE_INDEX) {

          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(vertexPixel, pixel1);
          var squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;
          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }
          this.createOrUpdateVertexFeature_(vertex);
          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;
            if ((Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(closestSegment[0], segment[0]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(closestSegment[1], segment[1]) ||
                (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(closestSegment[0], segment[1]) &&
                Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(closestSegment[1], segment[0])))) {
              vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment)] = true;
            } else {
              break;
            }
          }
        }

        vertexSegments[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(closestSegment)] = true;
        this.vertexSegments_ = vertexSegments;
        return;
      }
    }
    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };

  /**
   * @param {module:ol/interaction/Modify~SegmentData} segmentData Segment data.
   * @param {module:ol/coordinate~Coordinate} vertex Vertex.
   * @private
   */
  Modify.prototype.insertVertex_ = function insertVertex_ (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = /** @type {number} */ (segmentData.index);
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;
      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    var newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(newSegmentData.segment),
      newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);

    var newSegmentData2 = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    });
    rTree.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };

  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  Modify.prototype.removePoint = function removePoint () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt);
      this.removeVertex_();
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
      this.modified_ = false;
      return true;
    }
    return false;
  };

  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  Modify.prototype.removeVertex_ = function removeVertex_ () {
    var this$1 = this;

    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;
    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentData.feature);
      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }
      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }
      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }

    }
    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;
      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }
      if (newIndex < 0) {
        newIndex = 0;
      }
      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;
      switch (geometry.getType()) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_POLYGON:
          component = component[segmentData.depth[1]];
          /* falls through */
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POLYGON:
          component = component[segmentData.depth[0]];
          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }
            component.splice(index, 1);
            deleted = true;
            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }
          break;
        default:
          // pass
      }

      if (deleted) {
        this$1.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];
        if (left !== undefined) {
          this$1.rBush_.remove(left);
          segments.push(left.segment[0]);
        }
        if (right !== undefined) {
          this$1.rBush_.remove(right);
          segments.push(right.segment[1]);
        }
        if (left !== undefined && right !== undefined) {
          var newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          });
          this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(newSegmentData.segment),
            newSegmentData);
        }
        this$1.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
        if (this$1.vertexFeature_) {
          this$1.overlay_.getSource().removeFeature(this$1.vertexFeature_);
          this$1.vertexFeature_ = null;
        }
        dragSegments.length = 0;
      }

    }
    return deleted;
  };

  /**
   * @param {module:ol/geom/SimpleGeometry} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  Modify.prototype.setGeometryCoordinates_ = function setGeometryCoordinates_ (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };

  /**
   * @param {module:ol/geom/SimpleGeometry} geometry Geometry.
   * @param {number} index Index.
   * @param {Array.<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  Modify.prototype.updateSegmentIndices_ = function updateSegmentIndices_ (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry &&
          (depth === undefined || segmentDataMatch.depth === undefined ||
          Object(_array_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(segmentDataMatch.depth, depth)) &&
          segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_15__["default"]));


/**
 * @param {module:ol/interaction/Modify~SegmentData} a The first segment data.
 * @param {module:ol/interaction/Modify~SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */
function compareIndexes(a, b) {
  return a.index - b.index;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} evt Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/Modify}
 */
function handleDownEvent(evt) {
  var this$1 = this;

  if (!this.condition_(evt)) {
    return false;
  }
  this.handlePointerAtPixel_(evt.pixel, evt.map);
  var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);
  this.dragSegments_.length = 0;
  this.modified_ = false;
  var vertexFeature = this.vertexFeature_;
  if (vertexFeature) {
    var insertVertices = [];
    var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
    var vertex = geometry.getCoordinates();
    var vertexExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])([vertex]);
    var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
    var componentSegments = {};
    segmentDataMatches.sort(compareIndexes);
    for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
      var segmentDataMatch = segmentDataMatches[i];
      var segment = segmentDataMatch.segment;
      var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segmentDataMatch.feature);
      var depth = segmentDataMatch.depth;
      if (depth) {
        uid += '-' + depth.join('-'); // separate feature components
      }
      if (!componentSegments[uid]) {
        componentSegments[uid] = new Array(2);
      }
      if (segmentDataMatch.geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE &&
      segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {

        var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);
        if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(closestVertex, vertex) && !componentSegments[uid][0]) {
          this$1.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
        }
      } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(segment[0], vertex) &&
          !componentSegments[uid][0]) {
        this$1.dragSegments_.push([segmentDataMatch, 0]);
        componentSegments[uid][0] = segmentDataMatch;
      } else if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(segment[1], vertex) &&
          !componentSegments[uid][1]) {

        // prevent dragging closed linestrings by the connecting node
        if ((segmentDataMatch.geometry.getType() ===
            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINE_STRING ||
            segmentDataMatch.geometry.getType() ===
            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_LINE_STRING) &&
            componentSegments[uid][0] &&
            componentSegments[uid][0].index === 0) {
          continue;
        }

        this$1.dragSegments_.push([segmentDataMatch, 1]);
        componentSegments[uid][1] = segmentDataMatch;
      } else if (this$1.insertVertexCondition_(evt) && Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(segment) in this$1.vertexSegments_ &&
          (!componentSegments[uid][0] && !componentSegments[uid][1])) {
        insertVertices.push([segmentDataMatch, vertex]);
      }
    }
    if (insertVertices.length) {
      this.willModifyFeatures_(evt);
    }
    for (var j = insertVertices.length - 1; j >= 0; --j) {
      this$1.insertVertex_.apply(this$1, insertVertices[j]);
    }
  }
  return !!this.vertexFeature_;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} evt Event.
 * @this {module:ol/interaction/Modify}
 */
function handleDragEvent(evt) {
  var this$1 = this;

  this.ignoreNextSingleClick_ = false;
  this.willModifyFeatures_(evt);

  var vertex = evt.coordinate;
  for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
    var dragSegment = this$1.dragSegments_[i];
    var segmentData = dragSegment[0];
    var depth = segmentData.depth;
    var geometry = segmentData.geometry;
    var coordinates = (void 0);
    var segment = segmentData.segment;
    var index = dragSegment[1];

    while (vertex.length < geometry.getStride()) {
      vertex.push(segment[index][vertex.length]);
    }

    switch (geometry.getType()) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINT:
        coordinates = vertex;
        segment[0] = segment[1] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_POINT:
        coordinates = geometry.getCoordinates();
        coordinates[segmentData.index] = vertex;
        segment[0] = segment[1] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE:
        segment[0] = segment[1] = vertex;
        if (segmentData.index === CIRCLE_CENTER_INDEX) {
          this$1.changingFeature_ = true;
          geometry.setCenter(vertex);
          this$1.changingFeature_ = false;
        } else { // We're dragging the circle's circumference:
          this$1.changingFeature_ = true;
          geometry.setRadius(Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["distance"])(geometry.getCenter(), vertex));
          this$1.changingFeature_ = false;
        }
        break;
      default:
        // pass
    }

    if (coordinates) {
      this$1.setGeometryCoordinates_(geometry, coordinates);
    }
  }
  this.createOrUpdateVertexFeature_(vertex);
}


/**
 * @param {module:ol/MapBrowserPointerEvent} evt Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/Modify}
 */
function handleUpEvent(evt) {
  var this$1 = this;

  for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
    var segmentData = this$1.dragSegments_[i][0];
    var geometry = segmentData.geometry;
    if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE) {
      // Update a circle object in the R* bush:
      var coordinates = geometry.getCenter();
      var centerSegmentData = segmentData.featureSegments[0];
      var circumferenceSegmentData = segmentData.featureSegments[1];
      centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;
      circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;
      this$1.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["createOrUpdateFromCoordinate"])(coordinates), centerSegmentData);
      this$1.rBush_.update(geometry.getExtent(), circumferenceSegmentData);
    } else {
      this$1.rBush_.update(Object(_extent_js__WEBPACK_IMPORTED_MODULE_12__["boundingExtent"])(segmentData.segment), segmentData);
    }
  }
  if (this.modified_) {
    this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
    this.modified_ = false;
  }
  return false;
}


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the
 * geometry.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/Modify}
 */
function handleEvent(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_5__["default"])) {
    return true;
  }
  this.lastPointerEvent_ = mapBrowserEvent;

  var handled;
  if (!mapBrowserEvent.map.getView().getInteracting() &&
      mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].POINTERMOVE &&
      !this.handlingDownUpSequence) {
    this.handlePointerMove_(mapBrowserEvent);
  }
  if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
    if (mapBrowserEvent.type != _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK || !this.ignoreNextSingleClick_) {
      handled = this.removePoint();
    } else {
      handled = true;
    }
  }

  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].SINGLECLICK) {
    this.ignoreNextSingleClick_ = false;
  }

  return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_15__["handleEvent"].call(this, mapBrowserEvent) && !handled;
}


/**
 * Returns the distance from a point to a line segment.
 *
 * @param {module:ol/coordinate~Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @return {number} The square of the distance between a point and a line segment.
 */
function pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE) {
    var circleGeometry = /** @type {module:ol/geom/Circle} */ (geometry);

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var distanceToCenterSquared =
            Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistance"])(circleGeometry.getCenter(), pointCoordinates);
      var distanceToCircumference =
            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["squaredDistanceToSegment"])(pointCoordinates, segmentData.segment);
}

/**
 * Returns the point closest to a given line segment.
 *
 * @param {module:ol/coordinate~Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @return {module:ol/coordinate~Coordinate} The point closest to the specified line segment.
 */
function closestOnSegmentData(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].CIRCLE &&
  segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    return geometry.getClosestPoint(pointCoordinates);
  }
  return Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_7__["closestOnSegment"])(pointCoordinates, segmentData.segment);
}


/**
 * @return {module:ol/style/Style~StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var style = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_20__["createEditingStyle"])();
  return function(feature, resolution) {
    return style[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_13__["default"].POINT];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Modify);

//# sourceMappingURL=Modify.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/MouseWheelZoom.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/interaction/MouseWheelZoom.js ***!
  \*******************************************************/
/*! exports provided: Mode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mode", function() { return Mode; });
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../easing.js */ "./node_modules/ol/easing.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/interaction/MouseWheelZoom
 */









/**
 * Maximum mouse wheel delta.
 * @type {number}
 */
var MAX_DELTA = 1;


/**
 * @enum {string}
 */
var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};


/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~always}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [constrainResolution=false] When using a trackpad or
 * magic mouse, zoom to the closest integer zoom level after the scroll gesture
 * ends.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */
var MouseWheelZoom = (function (Interaction) {
  function MouseWheelZoom(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options || {};

    /**
     * @private
     * @type {number}
     */
    this.delta_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

    /**
     * @private
     * @type {number}
     */
    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

    /**
     * @private
     * @type {boolean}
     */
    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__["always"];

    /**
     * @private
     * @type {?module:ol/coordinate~Coordinate}
     */
    this.lastAnchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.startTime_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.timeoutId_ = undefined;

    /**
     * @private
     * @type {module:ol/interaction/MouseWheelZoom~Mode|undefined}
     */
    this.mode_ = undefined;

    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */
    this.trackpadEventGap_ = 400;

    /**
     * @type {number|undefined}
     */
    this.trackpadTimeoutId_ = undefined;

    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */
    this.trackpadDeltaPerZoom_ = 300;

    /**
     * The zoom factor by which scroll zooming is allowed to exceed the limits.
     * @private
     * @type {number}
     */
    this.trackpadZoomBuffer_ = 1.5;

  }

  if ( Interaction ) MouseWheelZoom.__proto__ = Interaction;
  MouseWheelZoom.prototype = Object.create( Interaction && Interaction.prototype );
  MouseWheelZoom.prototype.constructor = MouseWheelZoom;

  /**
   * @private
   */
  MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_ () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
  };

  /**
   * @private
   * @param {module:ol/PluggableMap} map Map.
   */
  MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_ (map) {
    var view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    var maxDelta = MAX_DELTA;
    var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(this.delta_, -maxDelta, maxDelta);
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["zoomByDelta"])(view, -delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.delta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };

  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor (useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {module:ol/interaction/MouseWheelZoom}
 */
function handleEvent(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var type = mapBrowserEvent.type;
  if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL && type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
    return true;
  }

  mapBrowserEvent.preventDefault();

  var map = mapBrowserEvent.map;
  var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);

  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  }

  // Delta normalisation inspired by
  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
  var delta;
  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].WHEEL) {
    delta = wheelEvent.deltaY;
    if (_has_js__WEBPACK_IMPORTED_MODULE_4__["FIREFOX"] &&
        wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= _has_js__WEBPACK_IMPORTED_MODULE_4__["DEVICE_PIXEL_RATIO"];
    }
    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOUSEWHEEL) {
    delta = -wheelEvent.wheelDeltaY;
    if (_has_js__WEBPACK_IMPORTED_MODULE_4__["SAFARI"]) {
      delta /= 3;
    }
  }

  if (delta === 0) {
    return false;
  }

  var now = Date.now();

  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }

  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ?
      Mode.TRACKPAD :
      Mode.WHEEL;
  }

  if (this.mode_ === Mode.TRACKPAD) {
    var view = map.getView();
    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;
    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else if (resolution > maxResolution) {
      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
      rebound = -1;
    }
    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }
    view.setResolution(resolution);

    if (rebound === 0 && this.constrainResolution_) {
      view.animate({
        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
        anchor: this.lastAnchor_,
        duration: this.duration_
      });
    }

    if (rebound > 0) {
      view.animate({
        resolution: minResolution,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
        anchor: this.lastAnchor_,
        duration: 500
      });
    } else if (rebound < 0) {
      view.animate({
        resolution: maxResolution,
        easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],
        anchor: this.lastAnchor_,
        duration: 500
      });
    }
    this.startTime_ = now;
    return false;
  }

  this.delta_ += delta;

  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

  return false;
}


/* harmony default export */ __webpack_exports__["default"] = (MouseWheelZoom);

//# sourceMappingURL=MouseWheelZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchRotate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/interaction/PinchRotate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../rotationconstraint.js */ "./node_modules/ol/rotationconstraint.js");
/**
 * @module ol/interaction/PinchRotate
 */







/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */


/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate = (function (PointerInteraction) {
  function PinchRotate(opt_options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"]
    });

    var options = opt_options || {};

    /**
     * @private
     * @type {module:ol/coordinate~Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastAngle_ = undefined;

    /**
     * @private
     * @type {boolean}
     */
    this.rotating_ = false;

    /**
     * @private
     * @type {number}
     */
    this.rotationDelta_ = 0.0;

    /**
     * @private
     * @type {number}
     */
    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 250;

  }

  if ( PointerInteraction ) PinchRotate.__proto__ = PointerInteraction;
  PinchRotate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchRotate.prototype.constructor = PinchRotate;

  return PinchRotate;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/PinchRotate}
 */
function handleDragEvent(mapBrowserEvent) {
  var rotationDelta = 0.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];

  // angle between touches
  var angle = Math.atan2(
    touch1.clientY - touch0.clientY,
    touch1.clientX - touch0.clientX);

  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;
    if (!this.rotating_ &&
        Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }
    rotationDelta = delta;
  }
  this.lastAngle_ = angle;

  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === _rotationconstraint_js__WEBPACK_IMPORTED_MODULE_4__["disable"]) {
    return;
  }

  // rotate anchor point.
  // FIXME: should be the intersection point between the lines:
  //     touch0,touch1 and previousTouch0,previousTouch1
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = Object(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // rotate
  if (this.rotating_) {
    var rotation = view.getRotation();
    map.render();
    Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotateWithoutConstraints"])(view, rotation + rotationDelta, this.anchor_);
  }
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/PinchRotate}
 */
function handleUpEvent(mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
    if (this.rotating_) {
      var rotation = view.getRotation();
      Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["rotate"])(view, rotation, this.anchor_, this.duration_);
    }
    return false;
  } else {
    return true;
  }
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/PinchRotate}
 */
function handleDownEvent(mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (PinchRotate);

//# sourceMappingURL=PinchRotate.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/PinchZoom.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/PinchZoom.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/**
 * @module ol/interaction/PinchZoom
 */






/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 * @property {boolean} [constrainResolution=false] Zoom to the closest integer
 * zoom level after the pinch gesture ends.
 */


/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom = (function (PointerInteraction) {
  function PinchZoom(opt_options) {

    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_1__["FALSE"]
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {boolean}
     */
    this.constrainResolution_ = options.constrainResolution || false;

    /**
     * @private
     * @type {module:ol/coordinate~Coordinate}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {number}
     */
    this.duration_ = options.duration !== undefined ? options.duration : 400;

    /**
     * @private
     * @type {number|undefined}
     */
    this.lastDistance_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.lastScaleDelta_ = 1;

  }

  if ( PointerInteraction ) PinchZoom.__proto__ = PointerInteraction;
  PinchZoom.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  PinchZoom.prototype.constructor = PinchZoom;

  return PinchZoom;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/PinchZoom}
 */
function handleDragEvent(mapBrowserEvent) {
  var scaleDelta = 1.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY;

  // distance between touches
  var distance = Math.sqrt(dx * dx + dy * dy);

  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }
  this.lastDistance_ = distance;


  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;
  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else if (newResolution < minResolution) {
    scaleDelta = minResolution / resolution;
    newResolution = minResolution;
  }

  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  }

  // scale anchor point.
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = Object(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_3__["centroid"])(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // scale, bypass the resolution constraint
  map.render();
  Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoomWithoutConstraints"])(view, newResolution, this.anchor_);
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/PinchZoom}
 */
function handleUpEvent(mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, -1);
    var resolution = view.getResolution();
    if (this.constrainResolution_ ||
        resolution < view.getMinResolution() ||
        resolution > view.getMaxResolution()) {
      // Zoom to final resolution, with an animation, and provide a
      // direction not to zoom out/in if user was pinching in/out.
      // Direction is > 0 if pinching out, and < 0 if pinching in.
      var direction = this.lastScaleDelta_ - 1;
      Object(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_2__["zoom"])(view, resolution, this.anchor_, this.duration_, direction);
    }
    return false;
  } else {
    return true;
  }
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/PinchZoom}
 */
function handleDownEvent(mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
}

/* harmony default export */ __webpack_exports__["default"] = (PinchZoom);

//# sourceMappingURL=PinchZoom.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Pointer.js":
/*!************************************************!*\
  !*** ./node_modules/ol/interaction/Pointer.js ***!
  \************************************************/
/*! exports provided: centroid, handleEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centroid", function() { return centroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleEvent", function() { return handleEvent; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MapBrowserEventType.js */ "./node_modules/ol/MapBrowserEventType.js");
/* harmony import */ var _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MapBrowserPointerEvent.js */ "./node_modules/ol/MapBrowserPointerEvent.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/interaction/Pointer
 */







/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/Pointer}
 */
var handleDragEvent = _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {module:ol/interaction/Pointer}
 */
var handleUpEvent = _functions_js__WEBPACK_IMPORTED_MODULE_0__["FALSE"];


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {module:ol/interaction/Pointer}
 */
var handleDownEvent = _functions_js__WEBPACK_IMPORTED_MODULE_0__["FALSE"];


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {module:ol/interaction/Pointer}
 */
var handleMoveEvent = _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];


/**
 * @typedef {Object} Options
 * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {(function(module:ol/MapBrowserPointerEvent))} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {(function(module:ol/MapBrowserEvent):boolean)} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {(function(module:ol/MapBrowserPointerEvent))} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events,
 * also during a drag sequence (so during a drag sequence both the
 * `handleDragEvent` function and this function are called).
 * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} stopDown
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */


/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction = (function (Interaction) {
  function PointerInteraction(opt_options) {

    var options = opt_options ? opt_options : {};

    Interaction.call(this, {
      handleEvent: options.handleEvent || handleEvent
    });

    /**
     * @type {function(module:ol/MapBrowserPointerEvent):boolean}
     * @private
     */
    this.handleDownEvent_ = options.handleDownEvent ?
      options.handleDownEvent : handleDownEvent;

    /**
     * @type {function(module:ol/MapBrowserPointerEvent)}
     * @private
     */
    this.handleDragEvent_ = options.handleDragEvent ?
      options.handleDragEvent : handleDragEvent;

    /**
     * @type {function(module:ol/MapBrowserPointerEvent)}
     * @private
     */
    this.handleMoveEvent_ = options.handleMoveEvent ?
      options.handleMoveEvent : handleMoveEvent;

    /**
     * @type {function(module:ol/MapBrowserPointerEvent):boolean}
     * @private
     */
    this.handleUpEvent_ = options.handleUpEvent ?
      options.handleUpEvent : handleUpEvent;

    /**
     * @type {boolean}
     * @protected
     */
    this.handlingDownUpSequence = false;

    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @type {function(boolean):boolean}
     * @protected
     */
    this.stopDown = options.stopDown ? options.stopDown : stopDown;

    /**
     * @type {!Object.<string, module:ol/pointer/PointerEvent>}
     * @private
     */
    this.trackedPointers_ = {};

    /**
     * @type {Array.<module:ol/pointer/PointerEvent>}
     * @protected
     */
    this.targetPointers = [];

  }

  if ( Interaction ) PointerInteraction.__proto__ = Interaction;
  PointerInteraction.prototype = Object.create( Interaction && Interaction.prototype );
  PointerInteraction.prototype.constructor = PointerInteraction;

  /**
   * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
   * @private
   */
  PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_ (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event = mapBrowserEvent.pointerEvent;

      var id = event.pointerId.toString();
      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type ==
          _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
        this.trackedPointers_[id] = event;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event;
      }
      this.targetPointers = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["getValues"])(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @param {Array.<module:ol/pointer/PointerEvent>} pointerEvents List of events.
 * @return {module:ol/pixel~Pixel} Centroid pixel.
 */
function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
}


/**
 * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */
function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG ||
    type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP;
}


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/Pointer}
 * @api
 */
function handleEvent(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _MapBrowserPointerEvent_js__WEBPACK_IMPORTED_MODULE_2__["default"])) {
    return true;
  }

  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);
  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERUP) {
      var handledUp = this.handleUpEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
    }
  } else {
    if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.stopDown(handled);
    } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINTERMOVE) {
      this.handleMoveEvent_(mapBrowserEvent);
    }
  }
  return !stopEvent;
}


/* harmony default export */ __webpack_exports__["default"] = (PointerInteraction);

/**
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the `down` event be stopped?
 */
function stopDown(handled) {
  return handled;
}

//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Property.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/interaction/Property.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  ACTIVE: 'active'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Select.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/interaction/Select.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/condition.js */ "./node_modules/ol/events/condition.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../interaction/Interaction.js */ "./node_modules/ol/interaction/Interaction.js");
/* harmony import */ var _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Vector.js */ "./node_modules/ol/layer/Vector.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/interaction/Select
 */















/**
 * @enum {string}
 */
var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};


/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function((module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer):
 *     boolean} FilterFunction
 */


/**
 * @typedef {Object} Options
 * @property {module:ol/events/condition~Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {module:ol/events/condition~Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}).
 * @property {module:ol/events/condition~Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {module:ol/events/condition~Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {module:ol/Collection.<module:ol/Feature>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {module:ol/interaction/Select~FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection
 * overlay.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features. This only
 * works for the canvas renderer and not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */
var SelectEvent = (function (Event) {
  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    Event.call(this, type);

    /**
     * Selected features array.
     * @type {Array.<module:ol/Feature>}
     * @api
     */
    this.selected = selected;

    /**
     * Deselected features array.
     * @type {Array.<module:ol/Feature>}
     * @api
     */
    this.deselected = deselected;

    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {module:ol/MapBrowserEvent}
     * @api
     */
    this.mapBrowserEvent = mapBrowserEvent;

  }

  if ( Event ) SelectEvent.__proto__ = Event;
  SelectEvent.prototype = Object.create( Event && Event.prototype );
  SelectEvent.prototype.constructor = SelectEvent;

  return SelectEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @fires SelectEvent
 * @api
 */
var Select = (function (Interaction) {
  function Select(opt_options) {

    Interaction.call(this, {
      handleEvent: handleEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["singleClick"];

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.addCondition_ = options.addCondition ? options.addCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.removeCondition_ = options.removeCondition ? options.removeCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["never"];

    /**
     * @private
     * @type {module:ol/events/condition~Condition}
     */
    this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _events_condition_js__WEBPACK_IMPORTED_MODULE_5__["shiftKeyOnly"];

    /**
     * @private
     * @type {boolean}
     */
    this.multi_ = options.multi ? options.multi : false;

    /**
     * @private
     * @type {module:ol/interaction/Select~FilterFunction}
     */
    this.filter_ = options.filter ? options.filter : _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    var featureOverlay = new _layer_Vector_js__WEBPACK_IMPORTED_MODULE_9__["default"]({
      source: new _source_Vector_js__WEBPACK_IMPORTED_MODULE_11__["default"]({
        useSpatialIndex: false,
        features: options.features,
        wrapX: options.wrapX
      }),
      style: options.style ? options.style :
        getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    /**
     * @private
     * @type {module:ol/layer/Vector}
     */
    this.featureOverlay_ = featureOverlay;

    /** @type {function(module:ol/layer/Layer): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_6__["TRUE"];
    }

    /**
     * @private
     * @type {function(module:ol/layer/Layer): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object.<number, module:ol/layer/Layer>}
     */
    this.featureLayerAssociation_ = {};

    var features = this.featureOverlay_.getSource().getFeaturesCollection();
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].ADD,
      this.addFeature_, this);
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(features, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].REMOVE,
      this.removeFeature_, this);

  }

  if ( Interaction ) Select.__proto__ = Interaction;
  Select.prototype = Object.create( Interaction && Interaction.prototype );
  Select.prototype.constructor = Select;

  /**
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   * @param {module:ol/layer/Layer} layer Layer.
   * @private
   */
  Select.prototype.addFeatureLayerAssociation_ = function addFeatureLayerAssociation_ (feature, layer) {
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    this.featureLayerAssociation_[key] = layer;
  };

  /**
   * Get the selected features.
   * @return {module:ol/Collection.<module:ol/Feature>} Features collection.
   * @api
   */
  Select.prototype.getFeatures = function getFeatures () {
    return this.featureOverlay_.getSource().getFeaturesCollection();
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Select.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
   * the (last) selected feature. Note that this will not work with any
   * programmatic method like pushing features to
   * {@link module:ol/interaction/Select~Select#getFeatures collection}.
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature
   * @return {module:ol/layer/Vector} Layer.
   * @api
   */
  Select.prototype.getLayer = function getLayer (feature) {
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    return (
      /** @type {module:ol/layer/Vector} */ (this.featureLayerAssociation_[key])
    );
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Select.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {module:ol/PluggableMap} map Map.
   * @override
   * @api
   */
  Select.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var selectedFeatures =
        this.featureOverlay_.getSource().getFeaturesCollection();
    if (currentMap) {
      selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));
    }
    Interaction.prototype.setMap.call(this, map);
    this.featureOverlay_.setMap(map);
    if (map) {
      selectedFeatures.forEach(map.skipFeature.bind(map));
    }
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.addFeature_ = function addFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.skipFeature(/** @type {module:ol/Feature} */ (evt.element));
    }
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Select.prototype.removeFeature_ = function removeFeature_ (evt) {
    var map = this.getMap();
    if (map) {
      map.unskipFeature(/** @type {module:ol/Feature} */ (evt.element));
    }
  };

  /**
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   * @private
   */
  Select.prototype.removeFeatureLayerAssociation_ = function removeFeatureLayerAssociation_ (feature) {
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    delete this.featureLayerAssociation_[key];
  };

  return Select;
}(_interaction_Interaction_js__WEBPACK_IMPORTED_MODULE_8__["default"]));


/**
 * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {module:ol/interaction/Select}
 */
function handleEvent(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.featureOverlay_.getSource().getFeaturesCollection();
  var deselected = [];
  var selected = [];
  if (set) {
    // Replace the currently selected feature(s) with the feature(s) at the
    // pixel, or clear the selected feature(s) if there is no feature at
    // the pixel.
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
         * @param {module:ol/layer/Layer} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            selected.push(feature);
            this.addFeatureLayerAssociation_(feature, layer);
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);
      if (index > -1) {
        // feature is already selected
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }
    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    // Modify the currently selected feature(s).
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      (
        /**
         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
         * @param {module:ol/layer/Layer} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        function(feature, layer) {
          if (this.filter_(feature, layer)) {
            if ((add || toggle) && !Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              selected.push(feature);
              this.addFeatureLayerAssociation_(feature, layer);
            } else if ((remove || toggle) && Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["includes"])(features.getArray(), feature)) {
              deselected.push(feature);
              this.removeFeatureLayerAssociation_(feature);
            }
            return !this.multi_;
          }
        }).bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
    for (var j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }
    features.extend(selected);
  }
  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(
      new SelectEvent(SelectEventType.SELECT,
        selected, deselected, mapBrowserEvent));
  }
  return Object(_events_condition_js__WEBPACK_IMPORTED_MODULE_5__["pointerMove"])(mapBrowserEvent);
}


/**
 * @return {module:ol/style/Style~StyleFunction} Styles.
 */
function getDefaultStyleFunction() {
  var styles = Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_12__["createEditingStyle"])();
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].POLYGON], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);
  Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["extend"])(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].GEOMETRY_COLLECTION], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_7__["default"].LINE_STRING]);

  return function(feature, resolution) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
}


/* harmony default export */ __webpack_exports__["default"] = (Select);

//# sourceMappingURL=Select.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Snap.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/interaction/Snap.js ***!
  \*********************************************/
/*! exports provided: handleEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleEvent", function() { return handleEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_Vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../source/Vector.js */ "./node_modules/ol/source/Vector.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/interaction/Snap
 */

















/**
 * @typedef {Object} Result
 * @property {boolean} snapped
 * @property {module:ol/coordinate~Coordinate|null} vertex
 * @property {module:ol/pixel~Pixel|null} vertexPixel
 */


/**
 * @typedef {Object} SegmentData
 * @property {module:ol/Feature} feature
 * @property {Array.<module:ol/coordinate~Coordinate>} segment
 */


/**
 * @typedef {Object} Options
 * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided
 */


/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     var snap = new Snap({
 *       source: source
 *     });
 *
 * @api
 */
var Snap = (function (PointerInteraction) {
  function Snap(opt_options) {

    PointerInteraction.call(this, {
      handleEvent: handleEvent,
      handleDownEvent: _functions_js__WEBPACK_IMPORTED_MODULE_7__["TRUE"],
      handleUpEvent: handleUpEvent,
      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_7__["FALSE"]
    });

    var options = opt_options ? opt_options : {};

    /**
     * @type {module:ol/source/Vector}
     * @private
     */
    this.source_ = options.source ? options.source : null;

    /**
     * @private
     * @type {boolean}
     */
    this.vertex_ = options.vertex !== undefined ? options.vertex : true;

    /**
     * @private
     * @type {boolean}
     */
    this.edge_ = options.edge !== undefined ? options.edge : true;

    /**
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @private
     */
    this.features_ = options.features ? options.features : null;

    /**
     * @type {Array.<module:ol/events~EventsKey>}
     * @private
     */
    this.featuresListenerKeys_ = [];

    /**
     * @type {Object.<number, module:ol/events~EventsKey>}
     * @private
     */
    this.featureChangeListenerKeys_ = {};

    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object.<number, module:ol/extent~Extent>}
     * @private
     */
    this.indexedFeaturesExtents_ = {};

    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object.<number, module:ol/Feature>}
     * @private
     */
    this.pendingFeatures_ = {};

    /**
     * Used for distance sorting in sortByDistance_
     * @type {module:ol/coordinate~Coordinate}
     * @private
     */
    this.pixelCoordinate_ = null;

    /**
     * @type {number}
     * @private
     */
    this.pixelTolerance_ = options.pixelTolerance !== undefined ?
      options.pixelTolerance : 10;

    /**
     * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}
     * @private
     */
    this.sortByDistance_ = sortByDistance.bind(this);


    /**
    * Segment RTree for each layer
    * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}
    * @private
    */
    this.rBush_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_14__["default"]();


    /**
    * @const
    * @private
    * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}
    */
    this.SEGMENT_WRITERS_ = {
      'Point': this.writePointGeometry_,
      'LineString': this.writeLineStringGeometry_,
      'LinearRing': this.writeLineStringGeometry_,
      'Polygon': this.writePolygonGeometry_,
      'MultiPoint': this.writeMultiPointGeometry_,
      'MultiLineString': this.writeMultiLineStringGeometry_,
      'MultiPolygon': this.writeMultiPolygonGeometry_,
      'GeometryCollection': this.writeGeometryCollectionGeometry_,
      'Circle': this.writeCircleGeometry_
    };
  }

  if ( PointerInteraction ) Snap.__proto__ = PointerInteraction;
  Snap.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Snap.prototype.constructor = Snap;

  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {module:ol/Feature} feature Feature.
   * @param {boolean=} opt_listen Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  Snap.prototype.addFeature = function addFeature (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var geometry = feature.getGeometry();
    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])());
        segmentWriter.call(this, feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(
        feature,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE,
        this.handleFeatureChange_, this);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_ (feature) {
    this.addFeature(feature);
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   * @private
   */
  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_ (feature) {
    this.removeFeature(feature);
  };

  /**
   * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.
   * @private
   */
  Snap.prototype.getFeatures_ = function getFeatures_ () {
    var features;
    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }
    return (
      /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */ (features)
    );
  };

  /**
   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
    var feature;
    if (evt instanceof _source_Vector_js__WEBPACK_IMPORTED_MODULE_12__["VectorSourceEvent"]) {
      feature = evt.feature;
    } else if (evt instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["CollectionEvent"]) {
      feature = evt.element;
    }
    this.addFeature(/** @type {module:ol/Feature} */ (feature));
  };

  /**
   * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
    var feature;
    if (evt instanceof _source_Vector_js__WEBPACK_IMPORTED_MODULE_12__["VectorSourceEvent"]) {
      feature = evt.feature;
    } else if (evt instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["CollectionEvent"]) {
      feature = evt.element;
    }
    this.removeFeature(/** @type {module:ol/Feature} */ (feature));
  };

  /**
   * @param {module:ol/events/Event} evt Event.
   * @private
   */
  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
    var feature = /** @type {module:ol/Feature} */ (evt.target);
    if (this.handlingDownUpSequence) {
      var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };

  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {module:ol/Feature} feature Feature
   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  Snap.prototype.removeFeature = function removeFeature (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];
    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove = [];
      rBush.forEachInExtent(extent, function(node) {
        if (feature === node.feature) {
          nodesToRemove.push(node);
        }
      });
      for (var i = nodesToRemove.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove[i]);
      }
    }

    if (unregister) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"])(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };

  /**
   * @inheritDoc
   */
  Snap.prototype.setMap = function setMap (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features = this.getFeatures_();

    if (currentMap) {
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlistenByKey"]);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }
    PointerInteraction.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.features_, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
            this.handleFeatureRemove_, this)
        );
      } else if (this.source_) {
        keys.push(
          Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].ADDFEATURE,
            this.handleFeatureAdd_, this),
          Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(this.source_, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_13__["default"].REMOVEFEATURE,
            this.handleFeatureRemove_, this)
        );
      }
      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };

  /**
   * @param {module:ol/pixel~Pixel} pixel Pixel
   * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate
   * @param {module:ol/PluggableMap} map Map.
   * @return {module:ol/interaction/Snap~Result} Snap result
   */
  Snap.prototype.snapTo = function snapTo (pixel, pixelCoordinate, map) {

    var lowerLeft = map.getCoordinateFromPixel(
      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel(
      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])([lowerLeft, upperRight]);

    var segments = this.rBush_.getInExtent(box);

    // If snapping on vertices only, don't consider circles
    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function(segment) {
        return segment.feature.getGeometry().getType() !==
            _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CIRCLE;
      });
    }

    var snappedToVertex = false;
    var snapped = false;
    var vertex = null;
    var vertexPixel = null;
    var dist, pixel1, pixel2, squaredDist1, squaredDist2;
    if (segments.length > 0) {
      this.pixelCoordinate_ = pixelCoordinate;
      segments.sort(this.sortByDistance_);
      var closestSegment = segments[0].segment;
      var isCircle = segments[0].feature.getGeometry().getType() ===
          _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CIRCLE;
      if (this.vertex_ && !this.edge_) {
        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(pixel, pixel1);
        squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(pixel, pixel2);
        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        snappedToVertex = dist <= this.pixelTolerance_;
        if (snappedToVertex) {
          snapped = true;
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          vertexPixel = map.getPixelFromCoordinate(vertex);
        }
      } else if (this.edge_) {
        if (isCircle) {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["closestOnCircle"])(pixelCoordinate,
            /** @type {module:ol/geom/Circle} */ (segments[0].feature.getGeometry()));
        } else {
          vertex = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["closestOnSegment"])(pixelCoordinate, closestSegment);
        }
        vertexPixel = map.getPixelFromCoordinate(vertex);
        if (Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["distance"])(pixel, vertexPixel) <= this.pixelTolerance_) {
          snapped = true;
          if (this.vertex_ && !isCircle) {
            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            squaredDist1 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(vertexPixel, pixel1);
            squaredDist2 = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistance"])(vertexPixel, pixel2);
            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            snappedToVertex = dist <= this.pixelTolerance_;
            if (snappedToVertex) {
              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              vertexPixel = map.getPixelFromCoordinate(vertex);
            }
          }
        }
      }
      if (snapped) {
        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
      }
    }
    return (
      /** @type {module:ol/interaction/Snap~Result} */ ({
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      })
    );
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @private
   */
  Snap.prototype.updateFeature_ = function updateFeature_ (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/Circle} geometry Geometry.
   * @private
   */
  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
    var this$1 = this;

    var polygon = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_9__["fromCircle"])(geometry);
    var coordinates = polygon.getCoordinates()[0];
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/GeometryCollection} geometry Geometry.
   * @private
   */
  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
    var this$1 = this;

    var geometries = geometry.getGeometriesArray();
    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this$1.SEGMENT_WRITERS_[geometries[i].getType()];
      if (segmentWriter) {
        segmentWriter.call(this$1, feature, geometries[i]);
      }
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/LineString} geometry Geometry.
   * @private
   */
  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
    var this$1 = this;

    var coordinates = geometry.getCoordinates();
    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
        feature: feature,
        segment: segment
      });
      this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segment), segmentData);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiLineString} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
    var this$1 = this;

    var lines = geometry.getCoordinates();
    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiPoint} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
    var this$1 = this;

    var points = geometry.getCoordinates();
    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
        feature: feature,
        segment: [coordinates, coordinates]
      });
      this$1.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/MultiPolygon} geometry Geometry.
   * @private
   */
  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
    var this$1 = this;

    var polygons = geometry.getCoordinates();
    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];
      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
            feature: feature,
            segment: segment
          });
          this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segment), segmentData);
        }
      }
    }
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/Point} geometry Geometry.
   * @private
   */
  Snap.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
      feature: feature,
      segment: [coordinates, coordinates]
    });
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };

  /**
   * @param {module:ol/Feature} feature Feature
   * @param {module:ol/geom/Polygon} geometry Geometry.
   * @private
   */
  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
    var this$1 = this;

    var rings = geometry.getCoordinates();
    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
          feature: feature,
          segment: segment
        });
        this$1.rBush_.insert(Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["boundingExtent"])(segment), segmentData);
      }
    }
  };

  return Snap;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_10__["default"]));


/**
 * Handle all pointer events events.
 * @param {module:ol/MapBrowserEvent} evt A move event.
 * @return {boolean} Pass the event to other interactions.
 * @this {module:ol/interaction/Snap}
 */
function handleEvent(evt) {
  var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
  if (result.snapped) {
    evt.coordinate = result.vertex.slice(0, 2);
    evt.pixel = result.vertexPixel;
  }
  return _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_10__["handleEvent"].call(this, evt);
}


/**
 * @param {module:ol/MapBrowserPointerEvent} evt Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/Snap}
 */
function handleUpEvent(evt) {
  var featuresToUpdate = Object(_obj_js__WEBPACK_IMPORTED_MODULE_11__["getValues"])(this.pendingFeatures_);
  if (featuresToUpdate.length) {
    featuresToUpdate.forEach(this.updateFeature_.bind(this));
    this.pendingFeatures_ = {};
  }
  return false;
}


/**
 * Sort segments by distance, helper function
 * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.
 * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.
 * @return {number} The difference in distance.
 * @this {module:ol/interaction/Snap}
 */
function sortByDistance(a, b) {
  var deltaA = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistanceToSegment"])(this.pixelCoordinate_, a.segment);
  var deltaB = Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_3__["squaredDistanceToSegment"])(this.pixelCoordinate_, b.segment);
  return deltaA - deltaB;
}

/* harmony default export */ __webpack_exports__["default"] = (Snap);

//# sourceMappingURL=Snap.js.map

/***/ }),

/***/ "./node_modules/ol/interaction/Translate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/interaction/Translate.js ***!
  \**************************************************/
/*! exports provided: TranslateEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TranslateEvent", function() { return TranslateEvent; });
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../interaction/Pointer.js */ "./node_modules/ol/interaction/Pointer.js");
/* harmony import */ var _interaction_Property_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../interaction/Property.js */ "./node_modules/ol/interaction/Property.js");
/**
 * @module ol/interaction/Translate
 */










/**
 * @enum {string}
 */
var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',
  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',
  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};


/**
 * @typedef {Object} Options
 * @property {module:ol/Collection.<module:ol/Feature>} [features] Only features contained in this collection will be able to be translated. If
 * not specified, all features on the map will be able to be translated.
 * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features. This only works for the canvas renderer and
 * not for WebGL.
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */
var TranslateEvent = (function (Event) {
  function TranslateEvent(type, features, coordinate) {

    Event.call(this, type);

    /**
     * The features being translated.
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @api
     */
    this.features = features;

    /**
     * The coordinate of the drag event.
     * @const
     * @type {module:ol/coordinate~Coordinate}
     * @api
     */
    this.coordinate = coordinate;

  }

  if ( Event ) TranslateEvent.__proto__ = Event;
  TranslateEvent.prototype = Object.create( Event && Event.prototype );
  TranslateEvent.prototype.constructor = TranslateEvent;

  return TranslateEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @classdesc
 * Interaction for translating (moving) features.
 *
 * @fires module:ol/interaction/Translate~TranslateEvent
 * @api
 */
var Translate = (function (PointerInteraction) {
  function Translate(opt_options) {
    PointerInteraction.call(this, {
      handleDownEvent: handleDownEvent,
      handleDragEvent: handleDragEvent,
      handleMoveEvent: handleMoveEvent,
      handleUpEvent: handleUpEvent
    });

    var options = opt_options ? opt_options : {};

    /**
     * The last position we translated to.
     * @type {module:ol/coordinate~Coordinate}
     * @private
     */
    this.lastCoordinate_ = null;


    /**
     * @type {module:ol/Collection.<module:ol/Feature>}
     * @private
     */
    this.features_ = options.features !== undefined ? options.features : null;

    /** @type {function(module:ol/layer/Layer): boolean} */
    var layerFilter;
    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers = options.layers;
        layerFilter = function(layer) {
          return Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(layers, layer);
        };
      }
    } else {
      layerFilter = _functions_js__WEBPACK_IMPORTED_MODULE_4__["TRUE"];
    }

    /**
     * @private
     * @type {function(module:ol/layer/Layer): boolean}
     */
    this.layerFilter_ = layerFilter;

    /**
     * @private
     * @type {number}
     */
    this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

    /**
     * @type {module:ol/Feature}
     * @private
     */
    this.lastFeature_ = null;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_1__["getChangeEventType"])(_interaction_Property_js__WEBPACK_IMPORTED_MODULE_7__["default"].ACTIVE),
      this.handleActiveChanged_, this);

  }

  if ( PointerInteraction ) Translate.__proto__ = PointerInteraction;
  Translate.prototype = Object.create( PointerInteraction && PointerInteraction.prototype );
  Translate.prototype.constructor = Translate;

  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {module:ol/pixel~Pixel} pixel Pixel coordinate to test for intersection.
   * @param {module:ol/PluggableMap} map Map to test the intersection on.
   * @return {module:ol/Feature} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */
  Translate.prototype.featuresAtPixel_ = function featuresAtPixel_ (pixel, map) {
    return map.forEachFeatureAtPixel(pixel,
      function(feature) {
        if (!this.features_ || Object(_array_js__WEBPACK_IMPORTED_MODULE_5__["includes"])(this.features_.getArray(), feature)) {
          return feature;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });
  };

  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.getHitTolerance = function getHitTolerance () {
    return this.hitTolerance_;
  };

  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features. This only works for the canvas renderer and
   * not for WebGL.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  Translate.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };

  /**
   * @inheritDoc
   */
  Translate.prototype.setMap = function setMap (map) {
    var oldMap = this.getMap();
    PointerInteraction.prototype.setMap.call(this, map);
    this.updateState_(oldMap);
  };

  /**
   * @private
   */
  Translate.prototype.handleActiveChanged_ = function handleActiveChanged_ () {
    this.updateState_(null);
  };

  /**
   * @param {module:ol/PluggableMap} oldMap Old map.
   * @private
   */
  Translate.prototype.updateState_ = function updateState_ (oldMap) {
    var map = this.getMap();
    var active = this.getActive();
    if (!map || !active) {
      map = map || oldMap;
      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  };

  return Translate;
}(_interaction_Pointer_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/**
 * @param {module:ol/MapBrowserPointerEvent} event Event.
 * @return {boolean} Start drag sequence?
 * @this {module:ol/interaction/Translate}
 */
function handleDownEvent(event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (!this.lastCoordinate_ && this.lastFeature_) {
    this.lastCoordinate_ = event.coordinate;
    handleMoveEvent.call(this, event);

    var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

    this.dispatchEvent(
      new TranslateEvent(
        TranslateEventType.TRANSLATESTART, features,
        event.coordinate));
    return true;
  }
  return false;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} event Event.
 * @return {boolean} Stop drag sequence?
 * @this {module:ol/interaction/Translate}
 */
function handleUpEvent(event) {
  if (this.lastCoordinate_) {
    this.lastCoordinate_ = null;
    handleMoveEvent.call(this, event);

    var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

    this.dispatchEvent(
      new TranslateEvent(
        TranslateEventType.TRANSLATEEND, features,
        event.coordinate));
    return true;
  }
  return false;
}


/**
 * @param {module:ol/MapBrowserPointerEvent} event Event.
 * @this {module:ol/interaction/Translate}
 */
function handleDragEvent(event) {
  if (this.lastCoordinate_) {
    var newCoordinate = event.coordinate;
    var deltaX = newCoordinate[0] - this.lastCoordinate_[0];
    var deltaY = newCoordinate[1] - this.lastCoordinate_[1];

    var features = this.features_ || new _Collection_js__WEBPACK_IMPORTED_MODULE_0__["default"]([this.lastFeature_]);

    features.forEach(function(feature) {
      var geom = feature.getGeometry();
      geom.translate(deltaX, deltaY);
      feature.setGeometry(geom);
    });

    this.lastCoordinate_ = newCoordinate;
    this.dispatchEvent(
      new TranslateEvent(
        TranslateEventType.TRANSLATING, features,
        newCoordinate));
  }
}


/**
 * @param {module:ol/MapBrowserEvent} event Event.
 * @this {module:ol/interaction/Translate}
 */
function handleMoveEvent(event) {
  var elem = event.map.getViewport();

  // Change the cursor to grab/grabbing if hovering any of the features managed
  // by the interaction
  if (this.featuresAtPixel_(event.pixel, event.map)) {
    elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
    elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
  } else {
    elem.classList.remove('ol-grab', 'ol-grabbing');
  }
}


/* harmony default export */ __webpack_exports__["default"] = (Translate);

//# sourceMappingURL=Translate.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Base.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Base.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _layer_Property_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layer/Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Base
 */






/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer = (function (BaseObject) {
  function BaseLayer(options) {

    BaseObject.call(this);

    /**
    * @type {Object.<string, *>}
    */
    var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);
    properties[_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY] =
       options.opacity !== undefined ? options.opacity : 1;
    properties[_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE] =
       options.visible !== undefined ? options.visible : true;
    properties[_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX] =
       options.zIndex !== undefined ? options.zIndex : 0;
    properties[_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION] =
       options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION] =
       options.minResolution !== undefined ? options.minResolution : 0;

    this.setProperties(properties);

    /**
    * @type {module:ol/layer/Layer~State}
    * @private
    */
    this.state_ = /** @type {module:ol/layer/Layer~State} */ ({
      layer: /** @type {module:ol/layer/Layer} */ (this),
      managed: true
    });

    /**
    * The layer type.
    * @type {module:ol/LayerType}
    * @protected;
    */
    this.type;

  }

  if ( BaseObject ) BaseLayer.__proto__ = BaseObject;
  BaseLayer.prototype = Object.create( BaseObject && BaseObject.prototype );
  BaseLayer.prototype.constructor = BaseLayer;

  /**
  * Get the layer type (used when creating a layer renderer).
  * @return {module:ol/LayerType} The layer type.
  */
  BaseLayer.prototype.getType = function getType () {
    return this.type;
  };

  /**
  * @return {module:ol/layer/Layer~State} Layer state.
  */
  BaseLayer.prototype.getLayerState = function getLayerState () {
    this.state_.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["clamp"])(this.getOpacity(), 0, 1);
    this.state_.sourceState = this.getSourceState();
    this.state_.visible = this.getVisible();
    this.state_.extent = this.getExtent();
    this.state_.zIndex = this.getZIndex();
    this.state_.maxResolution = this.getMaxResolution();
    this.state_.minResolution = Math.max(this.getMinResolution(), 0);

    return this.state_;
  };

  /**
  * @abstract
  * @param {Array.<module:ol/layer/Layer>=} opt_array Array of layers (to be
  *     modified in place).
  * @return {Array.<module:ol/layer/Layer>} Array of layers.
  */
  BaseLayer.prototype.getLayersArray = function getLayersArray (opt_array) {};

  /**
  * @abstract
  * @param {Array.<module:ol/layer/Layer~State>=} opt_states Optional list of layer
  *     states (to be modified in place).
  * @return {Array.<module:ol/layer/Layer~State>} List of layer states.
  */
  BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {};

  /**
  * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
  * will be visible regardless of extent.
  * @return {module:ol/extent~Extent|undefined} The layer extent.
  * @observable
  * @api
  */
  BaseLayer.prototype.getExtent = function getExtent () {
    return (
    /** @type {module:ol/extent~Extent|undefined} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT))
    );
  };

  /**
  * Return the maximum resolution of the layer.
  * @return {number} The maximum resolution of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.getMaxResolution = function getMaxResolution () {
    return /** @type {number} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION));
  };

  /**
  * Return the minimum resolution of the layer.
  * @return {number} The minimum resolution of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.getMinResolution = function getMinResolution () {
    return /** @type {number} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION));
  };

  /**
  * Return the opacity of the layer (between 0 and 1).
  * @return {number} The opacity of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.getOpacity = function getOpacity () {
    return /** @type {number} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY));
  };

  /**
  * @abstract
  * @return {module:ol/source/State} Source state.
  */
  BaseLayer.prototype.getSourceState = function getSourceState () {};

  /**
  * Return the visibility of the layer (`true` or `false`).
  * @return {boolean} The visibility of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.getVisible = function getVisible () {
    return /** @type {boolean} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE));
  };

  /**
  * Return the Z-index of the layer, which is used to order layers before
  * rendering. The default Z-index is 0.
  * @return {number} The Z-index of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.getZIndex = function getZIndex () {
    return /** @type {number} */ (this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX));
  };

  /**
  * Set the extent at which the layer is visible.  If `undefined`, the layer
  * will be visible at all extents.
  * @param {module:ol/extent~Extent|undefined} extent The extent of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setExtent = function setExtent (extent) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].EXTENT, extent);
  };

  /**
  * Set the maximum resolution at which the layer is visible.
  * @param {number} maxResolution The maximum resolution of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setMaxResolution = function setMaxResolution (maxResolution) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MAX_RESOLUTION, maxResolution);
  };

  /**
  * Set the minimum resolution at which the layer is visible.
  * @param {number} minResolution The minimum resolution of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setMinResolution = function setMinResolution (minResolution) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].MIN_RESOLUTION, minResolution);
  };

  /**
  * Set the opacity of the layer, allowed values range from 0 to 1.
  * @param {number} opacity The opacity of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setOpacity = function setOpacity (opacity) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPACITY, opacity);
  };

  /**
  * Set the visibility of the layer (`true` or `false`).
  * @param {boolean} visible The visibility of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setVisible = function setVisible (visible) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].VISIBLE, visible);
  };

  /**
  * Set Z-index of the layer, which is used to order layers before rendering.
  * The default Z-index is 0.
  * @param {number} zindex The z-index of the layer.
  * @observable
  * @api
  */
  BaseLayer.prototype.setZIndex = function setZIndex (zindex) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_1__["default"].Z_INDEX, zindex);
  };

  return BaseLayer;
}(_Object_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (BaseLayer);

//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Group.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Group.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_Base_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../layer/Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Group
 */














/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {(Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>)} [layers] Child layers.
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};


/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */
var LayerGroup = (function (BaseLayer) {
  function LayerGroup(opt_options) {

    var options = opt_options || {};
    var baseOptions = /** @type {module:ol/layer/Group~Options} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["assign"])({}, options));
    delete baseOptions.layers;

    var layers = options.layers;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.layersListenerKeys_ = [];

    /**
     * @private
     * @type {Object.<string, Array.<module:ol/events~EventsKey>>}
     */
    this.listenerKeys_ = {};

    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(Property.LAYERS),
      this.handleLayersChanged_, this);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](layers.slice(), {unique: true});
      } else {
        Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(layers instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"],
          43); // Expected `layers` to be an array or a `Collection`
        layers = layers;
      }
    } else {
      layers = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](undefined, {unique: true});
    }

    this.setLayers(layers);

  }

  if ( BaseLayer ) LayerGroup.__proto__ = BaseLayer;
  LayerGroup.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  LayerGroup.prototype.constructor = LayerGroup;

  /**
   * @private
   */
  LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_ () {
    this.changed();
  };

  /**
   * @param {module:ol/events/Event} event Event.
   * @private
   */
  LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_ () {
    var this$1 = this;

    this.layersListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    this.layersListenerKeys_.length = 0;

    var layers = this.getLayers();
    this.layersListenerKeys_.push(
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD, this.handleLayersAdd_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layers, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE, this.handleLayersRemove_, this)
    );

    for (var id in this$1.listenerKeys_) {
      this$1.listenerKeys_[id].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    }
    Object(_obj_js__WEBPACK_IMPORTED_MODULE_10__["clear"])(this.listenerKeys_);

    var layersArray = layers.getArray();
    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this$1.listenerKeys_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer).toString()] = [
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this$1.handleLayerChange_, this$1),
        Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this$1.handleLayerChange_, this$1)
      ];
    }

    this.changed();
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_ (collectionEvent) {
    var layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer).toString();
    this.listenerKeys_[key] = [
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].PROPERTYCHANGE, this.handleLayerChange_, this),
      Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(layer, _events_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].CHANGE, this.handleLayerChange_, this)
    ];
    this.changed();
  };

  /**
   * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */
  LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_ (collectionEvent) {
    var layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);
    var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer).toString();
    this.listenerKeys_[key].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    delete this.listenerKeys_[key];
    this.changed();
  };

  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!module:ol/Collection.<module:ol/layer/Base>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.getLayers = function getLayers () {
    return (
      /** @type {!module:ol/Collection.<module:ol/layer/Base>} */ (this.get(Property.LAYERS))
    );
  };

  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!module:ol/Collection.<module:ol/layer/Base>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */
  LayerGroup.prototype.setLayers = function setLayers (layers) {
    this.set(Property.LAYERS, layers);
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];

    var pos = states.length;

    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });

    var ownLayerState = this.getLayerState();
    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(
        layerState.minResolution, ownLayerState.minResolution);
      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_8__["getIntersection"])(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };

  /**
   * @inheritDoc
   */
  LayerGroup.prototype.getSourceState = function getSourceState () {
    return _source_State_js__WEBPACK_IMPORTED_MODULE_11__["default"].READY;
  };

  return LayerGroup;
}(_layer_Base_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (LayerGroup);

//# sourceMappingURL=Group.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/**
 * @module ol/layer/Image
 */




/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {module:ol/source/Image} [source] Source for this layer.
 */


/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @fires module:ol/render/Event~RenderEvent
 * @api
 */
var ImageLayer = (function (Layer) {
  function ImageLayer(opt_options) {
    var options = opt_options ? opt_options : {};
    Layer.call(this, options);

    /**
     * The layer type.
     * @protected
     * @type {module:ol/LayerType}
     */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE;

  }

  if ( Layer ) ImageLayer.__proto__ = Layer;
  ImageLayer.prototype = Object.create( Layer && Layer.prototype );
  ImageLayer.prototype.constructor = ImageLayer;

  return ImageLayer;
}(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Image source} of the image layer.
 * @function
 * @return {module:ol/source/Image} Source.
 * @api
 */
ImageLayer.prototype.getSource;
/* harmony default export */ __webpack_exports__["default"] = (ImageLayer);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Layer.js":
/*!****************************************!*\
  !*** ./node_modules/ol/layer/Layer.js ***!
  \****************************************/
/*! exports provided: visibleAtResolution, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "visibleAtResolution", function() { return visibleAtResolution; });
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _layer_Base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../layer/Base.js */ "./node_modules/ol/layer/Base.js");
/* harmony import */ var _layer_Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../layer/Property.js */ "./node_modules/ol/layer/Property.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/layer/Layer
 */











/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {module:ol/source/Source} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 */


/**
 * @typedef {Object} State
 * @property {module:ol/layer/Layer} layer
 * @property {number} opacity
 * @property {module:ol/source/Source~State} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {module:ol/extent~Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @fires module:ol/render/Event~RenderEvent
 */
var Layer = (function (BaseLayer) {
  function Layer(options) {

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__["assign"])({}, options);
    delete baseOptions.source;

    BaseLayer.call(this, baseOptions);

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.mapPrecomposeKey_ = null;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.mapRenderKey_ = null;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.sourceChangeKey_ = null;

    if (options.map) {
      this.setMap(options.map);
    }

    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this,
      Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__["getChangeEventType"])(_layer_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE),
      this.handleSourcePropertyChange_, this);

    var source = options.source ? options.source : null;
    this.setSource(source);
  }

  if ( BaseLayer ) Layer.__proto__ = BaseLayer;
  Layer.prototype = Object.create( BaseLayer && BaseLayer.prototype );
  Layer.prototype.constructor = Layer;

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayersArray = function getLayersArray (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };

  /**
   * @inheritDoc
   */
  Layer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };

  /**
   * Get the layer source.
   * @return {module:ol/source/Source} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  Layer.prototype.getSource = function getSource () {
    var source = this.get(_layer_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE);
    return (
      /** @type {module:ol/source/Source} */ (source) || null
    );
  };

  /**
    * @inheritDoc
    */
  Layer.prototype.getSourceState = function getSourceState () {
    var source = this.getSource();
    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_8__["default"].UNDEFINED : source.getState();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourceChange_ = function handleSourceChange_ () {
    this.changed();
  };

  /**
   * @private
   */
  Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_ () {
    if (this.sourceChangeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    var source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(source,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, this.handleSourceChange_, this);
    }
    this.changed();
  };

  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {module:ol/PluggableMap} map Map.
   * @api
   */
  Layer.prototype.setMap = function setMap (map) {
    if (this.mapPrecomposeKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlistenByKey"])(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__["default"].PRECOMPOSE, function(evt) {
        var layerState = this.getLayerState();
        layerState.managed = false;
        layerState.zIndex = Infinity;
        evt.frameState.layerStatesArray.push(layerState);
        evt.frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__["getUid"])(this)] = layerState;
      }, this);
      this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE, map.render, map);
      this.changed();
    }
  };

  /**
   * Set the layer source.
   * @param {module:ol/source/Source} source The layer source.
   * @observable
   * @api
   */
  Layer.prototype.setSource = function setSource (source) {
    this.set(_layer_Property_js__WEBPACK_IMPORTED_MODULE_5__["default"].SOURCE, source);
  };

  return Layer;
}(_layer_Base_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {module:ol/layer/Layer~State} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
function visibleAtResolution(layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution &&
      resolution < layerState.maxResolution;
}


/* harmony default export */ __webpack_exports__["default"] = (Layer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Property.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/layer/Property.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
});

//# sourceMappingURL=Property.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Tile.js":
/*!***************************************!*\
  !*** ./node_modules/ol/layer/Tile.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _layer_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/TileProperty.js */ "./node_modules/ol/layer/TileProperty.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/layer/Tile
 */






/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {module:ol/source/Tile} [source] Source for this layer.
 * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer = (function (Layer) {
  function TileLayer(opt_options) {
    var options = opt_options ? opt_options : {};

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    Layer.call(this, baseOptions);

    this.setPreload(options.preload !== undefined ? options.preload : 0);
    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
      options.useInterimTilesOnError : true);

    /**
    * The layer type.
    * @protected
    * @type {module:ol/LayerType}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TILE;

  }

  if ( Layer ) TileLayer.__proto__ = Layer;
  TileLayer.prototype = Object.create( Layer && Layer.prototype );
  TileLayer.prototype.constructor = TileLayer;

  /**
  * Return the level as number to which we will preload tiles up to.
  * @return {number} The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.getPreload = function getPreload () {
    return /** @type {number} */ (this.get(_layer_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD));
  };

  /**
  * Set the level as number to which we will preload tiles up to.
  * @param {number} preload The level to preload tiles up to.
  * @observable
  * @api
  */
  TileLayer.prototype.setPreload = function setPreload (preload) {
    this.set(_layer_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].PRELOAD, preload);
  };

  /**
  * Whether we use interim tiles on error.
  * @return {boolean} Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
    return /** @type {boolean} */ (this.get(_layer_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR));
  };

  /**
  * Set whether we use interim tiles on error.
  * @param {boolean} useInterimTilesOnError Use interim tiles on error.
  * @observable
  * @api
  */
  TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
    this.set(_layer_TileProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"].USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return TileLayer;
}(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Tile tilesource} of the layer.
 * @function
 * @return {module:ol/source/Tile} Source.
 * @api
 */
TileLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (TileLayer);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/layer/TileProperty.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/layer/TileProperty.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
});

//# sourceMappingURL=TileProperty.js.map

/***/ }),

/***/ "./node_modules/ol/layer/Vector.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/layer/Vector.js ***!
  \*****************************************/
/*! exports provided: RenderType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderType", function() { return RenderType; });
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layer/VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Style.js */ "./node_modules/ol/style/Style.js");
/**
 * @module ol/layer/Vector
 */







/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {module:ol/render~OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {module:ol/layer/VectorRenderType|string} [renderMode='vector'] Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but point symbols and
 *    texts are always rotated with the view and pixels are scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering even during
 *    animations, but slower performance.
 * @property {module:ol/source/Vector} [source] Source.
 * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles, and the priority is defined by the z-index of the style. Lower z-index
 * means higher priority.
 * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during animations. This means that no
 * vectors will be shown clipped, but the setting will have a performance impact for large
 * amounts of vector data. When set to `false`, batches will be recreated when no animation
 * is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`
 * is `vector`, feature batches will be recreated during interactions. See also
 * `updateWhileAnimating`.
 */


/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
var RenderType = {
  IMAGE: 'image',
  VECTOR: 'vector'
};


/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var VectorLayer = (function (Layer) {
  function VectorLayer(opt_options) {
    var options = opt_options ?
      opt_options : /** @type {module:ol/layer/Vector~Options} */ ({});

    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["assign"])({}, options);

    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    Layer.call(this, baseOptions);

    /**
    * @private
    * @type {boolean}
    */
    this.declutter_ = options.declutter !== undefined ? options.declutter : false;

    /**
    * @type {number}
    * @private
    */
    this.renderBuffer_ = options.renderBuffer !== undefined ?
      options.renderBuffer : 100;

    /**
    * User provided style.
    * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
    * @private
    */
    this.style_ = null;

    /**
    * Style function for use within the library.
    * @type {module:ol/style/Style~StyleFunction|undefined}
    * @private
    */
    this.styleFunction_ = undefined;

    this.setStyle(options.style);

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?
      options.updateWhileAnimating : false;

    /**
    * @type {boolean}
    * @private
    */
    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?
      options.updateWhileInteracting : false;

    /**
    * @private
    * @type {module:ol/layer/VectorTileRenderType|string}
    */
    this.renderMode_ = options.renderMode || _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR;

    /**
    * The layer type.
    * @protected
    * @type {module:ol/LayerType}
    */
    this.type = _LayerType_js__WEBPACK_IMPORTED_MODULE_0__["default"].VECTOR;

  }

  if ( Layer ) VectorLayer.__proto__ = Layer;
  VectorLayer.prototype = Object.create( Layer && Layer.prototype );
  VectorLayer.prototype.constructor = VectorLayer;

  /**
  * @return {boolean} Declutter.
  */
  VectorLayer.prototype.getDeclutter = function getDeclutter () {
    return this.declutter_;
  };

  /**
  * @param {boolean} declutter Declutter.
  */
  VectorLayer.prototype.setDeclutter = function setDeclutter (declutter) {
    this.declutter_ = declutter;
  };

  /**
  * @return {number|undefined} Render buffer.
  */
  VectorLayer.prototype.getRenderBuffer = function getRenderBuffer () {
    return this.renderBuffer_;
  };

  /**
  * @return {function(module:ol/Feature, module:ol/Feature): number|null|undefined} Render
  *     order.
  */
  VectorLayer.prototype.getRenderOrder = function getRenderOrder () {
    return (
    /** @type {module:ol/render~OrderFunction|null|undefined} */ (this.get(Property.RENDER_ORDER))
    );
  };

  /**
  * Get the style for features.  This returns whatever was passed to the `style`
  * option at construction or to the `setStyle` method.
  * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
  *     Layer style.
  * @api
  */
  VectorLayer.prototype.getStyle = function getStyle () {
    return this.style_;
  };

  /**
  * Get the style function.
  * @return {module:ol/style/Style~StyleFunction|undefined} Layer style function.
  * @api
  */
  VectorLayer.prototype.getStyleFunction = function getStyleFunction () {
    return this.styleFunction_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     animating.
  */
  VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating () {
    return this.updateWhileAnimating_;
  };

  /**
  * @return {boolean} Whether the rendered layer should be updated while
  *     interacting.
  */
  VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting () {
    return this.updateWhileInteracting_;
  };

  /**
  * @param {module:ol/render~OrderFunction|null|undefined} renderOrder
  *     Render order.
  */
  VectorLayer.prototype.setRenderOrder = function setRenderOrder (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };

  /**
  * Set the style for features.  This can be a single style object, an array
  * of styles, or a function that takes a feature and resolution and returns
  * an array of styles. If it is `undefined` the default style is used. If
  * it is `null` the layer has no style (a `null` style), so only features
  * that have their own styles will be rendered in the layer. See
  * {@link module:ol/style} for information on the default style.
  * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction|null|undefined}
  *     style Layer style.
  * @api
  */
  VectorLayer.prototype.setStyle = function setStyle (style) {
    this.style_ = style !== undefined ? style : _style_Style_js__WEBPACK_IMPORTED_MODULE_4__["createDefaultStyle"];
    this.styleFunction_ = style === null ?
      undefined : Object(_style_Style_js__WEBPACK_IMPORTED_MODULE_4__["toFunction"])(this.style_);
    this.changed();
  };

  /**
  * @return {module:ol/layer/VectorRenderType|string} The render mode.
  */
  VectorLayer.prototype.getRenderMode = function getRenderMode () {
    return this.renderMode_;
  };

  return VectorLayer;
}(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.
 * @function
 * @return {module:ol/source/Vector} Source.
 * @api
 */
VectorLayer.prototype.getSource;


/* harmony default export */ __webpack_exports__["default"] = (VectorLayer);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorRenderType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/layer/VectorRenderType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorRenderType
 */

/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/layer/VectorTileRenderType.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/layer/VectorTileRenderType.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
});

//# sourceMappingURL=VectorTileRenderType.js.map

/***/ }),

/***/ "./node_modules/ol/loadingstrategy.js":
/*!********************************************!*\
  !*** ./node_modules/ol/loadingstrategy.js ***!
  \********************************************/
/*! exports provided: all, bbox, tile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return bbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tile", function() { return tile; });
/**
 * @module ol/loadingstrategy
 */


/**
 * Strategy function for loading all features with a single request.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<module:ol/extent~Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}


/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<module:ol/extent~Extent>} Extents.
 * @api
 */
function bbox(extent, resolution) {
  return [extent];
}


/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {function(module:ol/extent~Extent, number): Array.<module:ol/extent~Extent>} Loading strategy.
 * @api
 */
function tile(tileGrid) {
  return (
    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array.<module:ol/extent~Extent>} Extents.
     */
    function(extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array.<module:ol/extent~Extent>} */
      var extents = [];
      /** @type {module:ol/tilecoord~TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
}

//# sourceMappingURL=loadingstrategy.js.map

/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/*! exports provided: clamp, cosh, roundUpToPowerOfTwo, squaredSegmentDistance, squaredDistance, solveLinearSystem, toDegrees, toRadians, modulo, lerp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundUpToPowerOfTwo", function() { return roundUpToPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredSegmentDistance", function() { return squaredSegmentDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/math
 */


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}


/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
var cosh = (function() {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function(x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}());


/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
function roundUpToPowerOfTwo(x) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
}


/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}


/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}


/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}


/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}


/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/*! exports provided: assign, clear, getValues, isEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assign", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getValues", function() { return getValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/**
 * @module ol/obj
 */


/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};


/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}


/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
function getValues(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
}


/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
}

//# sourceMappingURL=obj.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/EventSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/EventSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventSource
 */

var EventSource = function EventSource(dispatcher, mapping) {

  /**
   * @type {module:ol/pointer/PointerEventHandler}
   */
  this.dispatcher = dispatcher;

  /**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */
  this.mapping_ = mapping;
};

/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */
EventSource.prototype.getEvents = function getEvents () {
  return Object.keys(this.mapping_);
};

/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */
EventSource.prototype.getHandlerForEvent = function getHandlerForEvent (eventType) {
  return this.mapping_[eventType];
};

/* harmony default export */ __webpack_exports__["default"] = (EventSource);

//# sourceMappingURL=EventSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/EventType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/pointer/EventType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MouseSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/MouseSource.js ***!
  \************************************************/
/*! exports provided: POINTER_ID, POINTER_TYPE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_ID", function() { return POINTER_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINTER_TYPE", function() { return POINTER_TYPE; });
/* harmony import */ var _pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointer/EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MouseSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @type {number}
 */
var POINTER_ID = 1;


/**
 * @type {string}
 */
var POINTER_TYPE = 'mouse';


/**
 * Radius around touchend that swallows mouse events.
 *
 * @type {number}
 */
var DEDUP_DIST = 25;

/**
 * Handler for `mousedown`.
 *
 * @this {module:ol/pointer/MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousedown(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
}

/**
 * Handler for `mousemove`.
 *
 * @this {module:ol/pointer/MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mousemove(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
}

/**
 * Handler for `mouseup`.
 *
 * @this {module:ol/pointer/MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseup(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
}

/**
 * Handler for `mouseover`.
 *
 * @this {module:ol/pointer/MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseover(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
}

/**
 * Handler for `mouseout`.
 *
 * @this {module:ol/pointer/MouseSource}
 * @param {MouseEvent} inEvent The in event.
 */
function mouseout(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
}


var MouseSource = (function (EventSource) {
  function MouseSource(dispatcher) {
    var mapping = {
      'mousedown': mousedown,
      'mousemove': mousemove,
      'mouseup': mouseup,
      'mouseover': mouseover,
      'mouseout': mouseout
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object.<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {Array.<module:ol/pixel~Pixel>}
     */
    this.lastTouches = [];
  }

  if ( EventSource ) MouseSource.__proto__ = EventSource;
  MouseSource.prototype = Object.create( EventSource && EventSource.prototype );
  MouseSource.prototype.constructor = MouseSource;

  /**
   * Detect if a mouse event was simulated from a touch by
   * checking if previously there was a touch event at the
   * same position.
   *
   * FIXME - Known problem with the native Android browser on
   * Samsung GT-I9100 (Android 4.1.2):
   * In case the page is scrolled, this function does not work
   * correctly when a canvas is used (WebGL or canvas renderer).
   * Mouse listeners on canvas elements (for this browser), create
   * two mouse events: One 'good' and one 'bad' one (on other browsers or
   * when a div is used, there is only one event). For the 'bad' one,
   * clientX/clientY and also pageX/pageY are wrong when the page
   * is scrolled. Because of that, this function can not detect if
   * the events were simulated from a touch event. As result, a
   * pointer event at a wrong position is dispatched, which confuses
   * the map interactions.
   * It is unclear, how one can get the correct position for the event
   * or detect that the positions are invalid.
   *
   * @private
   * @param {MouseEvent} inEvent The in event.
   * @return {boolean} True, if the event was generated by a touch.
   */
  MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_ (inEvent) {
    var lts = this.lastTouches;
    var x = inEvent.clientX;
    var y = inEvent.clientY;
    for (var i = 0, l = lts.length, t = (void 0); i < l && (t = lts[i]); i++) {
      // simulated mouse events will be swallowed near a primary touchend
      var dx = Math.abs(x - t[0]);
      var dy = Math.abs(y - t[1]);
      if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
        return true;
      }
    }
    return false;
  };

  /**
   * Dispatches a `pointercancel` event.
   *
   * @param {Event} inEvent The in event.
   */
  MouseSource.prototype.cancel = function cancel (inEvent) {
    var e = prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.cancel(e, inEvent);
    this.cleanupMouse();
  };

  /**
   * Remove the mouse from the list of active pointers.
   */
  MouseSource.prototype.cleanupMouse = function cleanupMouse () {
    delete this.pointerMap[POINTER_ID.toString()];
  };

  return MouseSource;
}(_pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */
function prepareEvent(inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);

  // forward mouse preventDefault
  var pd = e.preventDefault;
  e.preventDefault = function() {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = POINTER_ID;
  e.isPrimary = true;
  e.pointerType = POINTER_TYPE;

  return e;
}


/* harmony default export */ __webpack_exports__["default"] = (MouseSource);

//# sourceMappingURL=MouseSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/MsSource.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/pointer/MsSource.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointer/EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/MsSource
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @const
 * @type {Array.<string>}
 */
var POINTER_TYPES = [
  '',
  'unavailable',
  'touch',
  'pen',
  'mouse'
];

/**
 * Handler for `msPointerDown`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerDown(inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
}

/**
 * Handler for `msPointerMove`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerMove(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
}

/**
 * Handler for `msPointerUp`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerUp(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msPointerOut`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOut(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
}

/**
 * Handler for `msPointerOver`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerOver(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
}

/**
 * Handler for `msPointerCancel`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msPointerCancel(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
}

/**
 * Handler for `msLostPointerCapture`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msLostPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

/**
 * Handler for `msGotPointerCapture`.
 *
 * @this {module:ol/pointer/MsSource}
 * @param {MSPointerEvent} inEvent The in event.
 */
function msGotPointerCapture(inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
}

var MsSource = (function (EventSource) {
  function MsSource(dispatcher) {
    var mapping = {
      'MSPointerDown': msPointerDown,
      'MSPointerMove': msPointerMove,
      'MSPointerUp': msPointerUp,
      'MSPointerOut': msPointerOut,
      'MSPointerOver': msPointerOver,
      'MSPointerCancel': msPointerCancel,
      'MSGotPointerCapture': msGotPointerCapture,
      'MSLostPointerCapture': msLostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object.<string, MSPointerEvent|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;
  }

  if ( EventSource ) MsSource.__proto__ = EventSource;
  MsSource.prototype = Object.create( EventSource && EventSource.prototype );
  MsSource.prototype.constructor = MsSource;

  /**
   * Creates a copy of the original event that will be used
   * for the fake pointer event.
   *
   * @private
   * @param {MSPointerEvent} inEvent The in event.
   * @return {Object} The copied event.
   */
  MsSource.prototype.prepareEvent_ = function prepareEvent_ (inEvent) {
    var e = inEvent;
    if (typeof inEvent.pointerType === 'number') {
      e = this.dispatcher.cloneEvent(inEvent, inEvent);
      e.pointerType = POINTER_TYPES[inEvent.pointerType];
    }

    return e;
  };

  /**
   * Remove this pointer from the list of active pointers.
   * @param {number} pointerId Pointer identifier.
   */
  MsSource.prototype.cleanup = function cleanup (pointerId) {
    delete this.pointerMap[pointerId.toString()];
  };

  return MsSource;
}(_pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (MsSource);

//# sourceMappingURL=MsSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/NativeSource.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/NativeSource.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointer/EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/**
 * @module ol/pointer/NativeSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



/**
 * Handler for `pointerdown`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerDown(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointermove`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerMove(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerup`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerUp(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerout`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOut(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointerover`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerOver(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `pointercancel`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function pointerCancel(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `lostpointercapture`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function lostPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

/**
 * Handler for `gotpointercapture`.
 *
 * @this {module:ol/pointer/NativeSource}
 * @param {Event} inEvent The in event.
 */
function gotPointerCapture(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
}

var NativeSource = (function (EventSource) {
  function NativeSource(dispatcher) {
    var mapping = {
      'pointerdown': pointerDown,
      'pointermove': pointerMove,
      'pointerup': pointerUp,
      'pointerout': pointerOut,
      'pointerover': pointerOver,
      'pointercancel': pointerCancel,
      'gotpointercapture': gotPointerCapture,
      'lostpointercapture': lostPointerCapture
    };
    EventSource.call(this, dispatcher, mapping);
  }

  if ( EventSource ) NativeSource.__proto__ = EventSource;
  NativeSource.prototype = Object.create( EventSource && EventSource.prototype );
  NativeSource.prototype.constructor = NativeSource;

  return NativeSource;
}(_pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (NativeSource);

//# sourceMappingURL=NativeSource.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEvent.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEvent.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/pointer/PointerEvent
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */
var HAS_BUTTONS = false;


var PointerEvent = (function (Event) {
  function PointerEvent(type, originalEvent, opt_eventDict) {
    Event.call(this, type);

    /**
     * @const
     * @type {Event}
     */
    this.originalEvent = originalEvent;

    var eventDict = opt_eventDict ? opt_eventDict : {};

    /**
     * @type {number}
     */
    this.buttons = this.getButtons_(eventDict);

    /**
     * @type {number}
     */
    this.pressure = this.getPressure_(eventDict, this.buttons);

    // MouseEvent related properties

    /**
     * @type {boolean}
     */
    this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

    /**
     * @type {boolean}
     */
    this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

    /**
     * @type {Object}
     */
    this.view = 'view' in eventDict ? eventDict['view'] : null;

    /**
     * @type {number}
     */
    this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

    /**
     * @type {number}
     */
    this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

    /**
     * @type {number}
     */
    this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

    /**
     * @type {number}
     */
    this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

    /**
     * @type {number}
     */
    this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

    /**
     * @type {boolean}
     */
    this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

    /**
     * @type {boolean}
     */
    this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

    /**
     * @type {boolean}
     */
    this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

    /**
     * @type {boolean}
     */
    this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

    /**
     * @type {number}
     */
    this.button = 'button' in eventDict ? eventDict['button'] : 0;

    /**
     * @type {Node}
     */
    this.relatedTarget = 'relatedTarget' in eventDict ?
      eventDict['relatedTarget'] : null;

    // PointerEvent related properties

    /**
     * @const
     * @type {number}
     */
    this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

    /**
     * @type {number}
     */
    this.width = 'width' in eventDict ? eventDict['width'] : 0;

    /**
     * @type {number}
     */
    this.height = 'height' in eventDict ? eventDict['height'] : 0;

    /**
     * @type {number}
     */
    this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

    /**
     * @type {number}
     */
    this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

    /**
     * @type {string}
     */
    this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

    /**
     * @type {number}
     */
    this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

    /**
     * @type {boolean}
     */
    this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

    // keep the semantics of preventDefault
    if (originalEvent.preventDefault) {
      this.preventDefault = function() {
        originalEvent.preventDefault();
      };
    }
  }

  if ( Event ) PointerEvent.__proto__ = Event;
  PointerEvent.prototype = Object.create( Event && Event.prototype );
  PointerEvent.prototype.constructor = PointerEvent;

  /**
   * @private
   * @param {Object.<string, ?>} eventDict The event dictionary.
   * @return {number} Button indicator.
   */
  PointerEvent.prototype.getButtons_ = function getButtons_ (eventDict) {
    // According to the w3c spec,
    // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
    // MouseEvent.button == 0 can mean either no mouse button depressed, or the
    // left mouse button depressed.
    //
    // As of now, the only way to distinguish between the two states of
    // MouseEvent.button is by using the deprecated MouseEvent.which property, as
    // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
    // no mouse button is held.
    //
    // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
    // but initMouseEvent does not expose an argument with which to set
    // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
    // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
    // of app developers.
    //
    // The only way to propagate the correct state of MouseEvent.which and
    // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
    // is to call initMouseEvent with a buttonArg value of -1.
    //
    // This is fixed with DOM Level 4's use of buttons
    var buttons;
    if (eventDict.buttons || HAS_BUTTONS) {
      buttons = eventDict.buttons;
    } else {
      switch (eventDict.which) {
        case 1: buttons = 1; break;
        case 2: buttons = 4; break;
        case 3: buttons = 2; break;
        default: buttons = 0;
      }
    }
    return buttons;
  };

  /**
   * @private
   * @param {Object.<string, ?>} eventDict The event dictionary.
   * @param {number} buttons Button indicator.
   * @return {number} The pressure.
   */
  PointerEvent.prototype.getPressure_ = function getPressure_ (eventDict, buttons) {
    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;
    if (eventDict.pressure) {
      pressure = eventDict.pressure;
    } else {
      pressure = buttons ? 0.5 : 0;
    }
    return pressure;
  };

  return PointerEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Checks if the `buttons` property is supported.
 */
(function() {
  try {
    var ev = new MouseEvent('click', {buttons: 1});
    HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
    // pass
  }
})();

/* harmony default export */ __webpack_exports__["default"] = (PointerEvent);

//# sourceMappingURL=PointerEvent.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/PointerEventHandler.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/pointer/PointerEventHandler.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointer/EventType.js */ "./node_modules/ol/pointer/EventType.js");
/* harmony import */ var _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../pointer/MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/* harmony import */ var _pointer_MsSource_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../pointer/MsSource.js */ "./node_modules/ol/pointer/MsSource.js");
/* harmony import */ var _pointer_NativeSource_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../pointer/NativeSource.js */ "./node_modules/ol/pointer/NativeSource.js");
/* harmony import */ var _pointer_PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pointer/PointerEvent.js */ "./node_modules/ol/pointer/PointerEvent.js");
/* harmony import */ var _pointer_TouchSource_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pointer/TouchSource.js */ "./node_modules/ol/pointer/TouchSource.js");
/**
 * @module ol/pointer/PointerEventHandler
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.












/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */
var CLONE_PROPS = [
  // MouseEvent
  ['bubbles', false],
  ['cancelable', false],
  ['view', null],
  ['detail', null],
  ['screenX', 0],
  ['screenY', 0],
  ['clientX', 0],
  ['clientY', 0],
  ['ctrlKey', false],
  ['altKey', false],
  ['shiftKey', false],
  ['metaKey', false],
  ['button', 0],
  ['relatedTarget', null],
  // DOM Level 3
  ['buttons', 0],
  // PointerEvent
  ['pointerId', 0],
  ['width', 0],
  ['height', 0],
  ['pressure', 0],
  ['tiltX', 0],
  ['tiltY', 0],
  ['pointerType', ''],
  ['hwTimestamp', 0],
  ['isPrimary', false],
  // event instance
  ['type', ''],
  ['target', null],
  ['currentTarget', null],
  ['which', 0]
];


var PointerEventHandler = (function (EventTarget) {
  function PointerEventHandler(element) {
    EventTarget.call(this);

    /**
     * @const
     * @private
     * @type {Element|HTMLDocument}
     */
    this.element_ = element;

    /**
     * @const
     * @type {!Object.<string, Event|Object>}
     */
    this.pointerMap = {};

    /**
     * @type {Object.<string, function(Event)>}
     * @private
     */
    this.eventMap_ = {};

    /**
     * @type {Array.<module:ol/pointer/EventSource>}
     * @private
     */
    this.eventSourceList_ = [];

    this.registerSources();
  }

  if ( EventTarget ) PointerEventHandler.__proto__ = EventTarget;
  PointerEventHandler.prototype = Object.create( EventTarget && EventTarget.prototype );
  PointerEventHandler.prototype.constructor = PointerEventHandler;

  /**
   * Set up the event sources (mouse, touch and native pointers)
   * that generate pointer events.
   */
  PointerEventHandler.prototype.registerSources = function registerSources () {
    if (_has_js__WEBPACK_IMPORTED_MODULE_2__["POINTER"]) {
      this.registerSource('native', new _pointer_NativeSource_js__WEBPACK_IMPORTED_MODULE_6__["default"](this));
    } else if (_has_js__WEBPACK_IMPORTED_MODULE_2__["MSPOINTER"]) {
      this.registerSource('ms', new _pointer_MsSource_js__WEBPACK_IMPORTED_MODULE_5__["default"](this));
    } else {
      var mouseSource = new _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["default"](this);
      this.registerSource('mouse', mouseSource);

      if (_has_js__WEBPACK_IMPORTED_MODULE_2__["TOUCH"]) {
        this.registerSource('touch', new _pointer_TouchSource_js__WEBPACK_IMPORTED_MODULE_8__["default"](this, mouseSource));
      }
    }

    // register events on the viewport element
    this.register_();
  };

  /**
   * Add a new event source that will generate pointer events.
   *
   * @param {string} name A name for the event source
   * @param {module:ol/pointer/EventSource} source The source event.
   */
  PointerEventHandler.prototype.registerSource = function registerSource (name, source) {
    var s = source;
    var newEvents = s.getEvents();

    if (newEvents) {
      newEvents.forEach(function(e) {
        var handler = s.getHandlerForEvent(e);

        if (handler) {
          this.eventMap_[e] = handler.bind(s);
        }
      }.bind(this));
      this.eventSourceList_.push(s);
    }
  };

  /**
   * Set up the events for all registered event sources.
   * @private
   */
  PointerEventHandler.prototype.register_ = function register_ () {
    var this$1 = this;

    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this$1.eventSourceList_[i];
      this$1.addEvents_(eventSource.getEvents());
    }
  };

  /**
   * Remove all registered events.
   * @private
   */
  PointerEventHandler.prototype.unregister_ = function unregister_ () {
    var this$1 = this;

    var l = this.eventSourceList_.length;
    for (var i = 0; i < l; i++) {
      var eventSource = this$1.eventSourceList_[i];
      this$1.removeEvents_(eventSource.getEvents());
    }
  };

  /**
   * Calls the right handler for a new event.
   * @private
   * @param {Event} inEvent Browser event.
   */
  PointerEventHandler.prototype.eventHandler_ = function eventHandler_ (inEvent) {
    var type = inEvent.type;
    var handler = this.eventMap_[type];
    if (handler) {
      handler(inEvent);
    }
  };

  /**
   * Setup listeners for the given events.
   * @private
   * @param {Array.<string>} events List of events.
   */
  PointerEventHandler.prototype.addEvents_ = function addEvents_ (events) {
    events.forEach(function(eventName) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["listen"])(this.element_, eventName, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Unregister listeners for the given events.
   * @private
   * @param {Array.<string>} events List of events.
   */
  PointerEventHandler.prototype.removeEvents_ = function removeEvents_ (events) {
    events.forEach(function(e) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__["unlisten"])(this.element_, e, this.eventHandler_, this);
    }.bind(this));
  };

  /**
   * Returns a snapshot of inEvent, with writable properties.
   *
   * @param {Event} event Browser event.
   * @param {Event|Touch} inEvent An event that contains
   *    properties to copy.
   * @return {Object} An object containing shallow copies of
   *    `inEvent`'s properties.
   */
  PointerEventHandler.prototype.cloneEvent = function cloneEvent (event, inEvent) {
    var eventCopy = {};
    for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {
      var p = CLONE_PROPS[i][0];
      eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];
    }

    return eventCopy;
  };

  // EVENTS


  /**
   * Triggers a 'pointerdown' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.down = function down (data, event) {
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERDOWN, data, event);
  };

  /**
   * Triggers a 'pointermove' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.move = function move (data, event) {
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERMOVE, data, event);
  };

  /**
   * Triggers a 'pointerup' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.up = function up (data, event) {
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERUP, data, event);
  };

  /**
   * Triggers a 'pointerenter' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enter = function enter (data, event) {
    data.bubbles = false;
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERENTER, data, event);
  };

  /**
   * Triggers a 'pointerleave' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leave = function leave (data, event) {
    data.bubbles = false;
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERLEAVE, data, event);
  };

  /**
   * Triggers a 'pointerover' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.over = function over (data, event) {
    data.bubbles = true;
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROVER, data, event);
  };

  /**
   * Triggers a 'pointerout' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.out = function out (data, event) {
    data.bubbles = true;
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTEROUT, data, event);
  };

  /**
   * Triggers a 'pointercancel' event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.cancel = function cancel (data, event) {
    this.fireEvent(_pointer_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINTERCANCEL, data, event);
  };

  /**
   * Triggers a combination of 'pointerout' and 'pointerleave' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.leaveOut = function leaveOut (data, event) {
    this.out(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.leave(data, event);
    }
  };

  /**
   * Triggers a combination of 'pointerover' and 'pointerevents' events.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.enterOver = function enterOver (data, event) {
    this.over(data, event);
    if (!this.contains_(data.target, data.relatedTarget)) {
      this.enter(data, event);
    }
  };

  /**
   * @private
   * @param {Element} container The container element.
   * @param {Element} contained The contained element.
   * @return {boolean} Returns true if the container element
   *   contains the other element.
   */
  PointerEventHandler.prototype.contains_ = function contains_ (container, contained) {
    if (!container || !contained) {
      return false;
    }
    return container.contains(contained);
  };

  // EVENT CREATION AND TRACKING
  /**
   * Creates a new Event of type `inType`, based on the information in
   * `data`.
   *
   * @param {string} inType A string representing the type of event to create.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   * @return {module:ol/pointer/PointerEvent} A PointerEvent of type `inType`.
   */
  PointerEventHandler.prototype.makeEvent = function makeEvent (inType, data, event) {
    return new _pointer_PointerEvent_js__WEBPACK_IMPORTED_MODULE_7__["default"](inType, event, data);
  };

  /**
   * Make and dispatch an event in one call.
   * @param {string} inType A string representing the type of event.
   * @param {Object} data Pointer event data.
   * @param {Event} event The event.
   */
  PointerEventHandler.prototype.fireEvent = function fireEvent (inType, data, event) {
    var e = this.makeEvent(inType, data, event);
    this.dispatchEvent(e);
  };

  /**
   * Creates a pointer event from a native pointer event
   * and dispatches this event.
   * @param {Event} event A platform event with a target.
   */
  PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent (event) {
    var e = this.makeEvent(event.type, event, event);
    this.dispatchEvent(e);
  };

  /**
   * Wrap a native mouse event into a pointer event.
   * This proxy method is required for the legacy IE support.
   * @param {string} eventType The pointer event type.
   * @param {Event} event The event.
   * @return {module:ol/pointer/PointerEvent} The wrapped event.
   */
  PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent (eventType, event) {
    var pointerEvent = this.makeEvent(
      eventType, _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_4__["default"].prepareEvent(event, this), event);
    return pointerEvent;
  };

  /**
   * @inheritDoc
   */
  PointerEventHandler.prototype.disposeInternal = function disposeInternal () {
    this.unregister_();
    EventTarget.prototype.disposeInternal.call(this);
  };

  return PointerEventHandler;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (PointerEventHandler);

//# sourceMappingURL=PointerEventHandler.js.map

/***/ }),

/***/ "./node_modules/ol/pointer/TouchSource.js":
/*!************************************************!*\
  !*** ./node_modules/ol/pointer/TouchSource.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pointer/EventSource.js */ "./node_modules/ol/pointer/EventSource.js");
/* harmony import */ var _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointer/MouseSource.js */ "./node_modules/ol/pointer/MouseSource.js");
/**
 * @module ol/pointer/TouchSource
 */

// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.






/**
 * @type {number}
 */
var CLICK_COUNT_TIMEOUT = 200;

/**
 * @type {string}
 */
var POINTER_TYPE = 'touch';

/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @this {module:ol/pointer/TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchstart(inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
}

/**
 * Handler for `touchmove`.
 *
 * @this {module:ol/pointer/TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchmove(inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
}

/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {module:ol/pointer/TouchSource}
 * @param {TouchEvent} inEvent The event.
 */
function touchend(inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
}

/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @this {module:ol/pointer/TouchSource}
 * @param {TouchEvent} inEvent The in event.
 */
function touchcancel(inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
}


var TouchSource = (function (EventSource) {
  function TouchSource(dispatcher, mouseSource) {
    var mapping = {
      'touchstart': touchstart,
      'touchmove': touchmove,
      'touchend': touchend,
      'touchcancel': touchcancel
    };
    EventSource.call(this, dispatcher, mapping);

    /**
     * @const
     * @type {!Object.<string, Event|Object>}
     */
    this.pointerMap = dispatcher.pointerMap;

    /**
     * @const
     * @type {module:ol/pointer/MouseSource}
     */
    this.mouseSource = mouseSource;

    /**
     * @private
     * @type {number|undefined}
     */
    this.firstTouchId_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.clickCount_ = 0;

    /**
     * @private
     * @type {number|undefined}
     */
    this.resetId_ = undefined;

    /**
     * Mouse event timeout: This should be long enough to
     * ignore compat mouse events made by touch.
     * @private
     * @type {number}
     */
    this.dedupTimeout_ = 2500;
  }

  if ( EventSource ) TouchSource.__proto__ = EventSource;
  TouchSource.prototype = Object.create( EventSource && EventSource.prototype );
  TouchSource.prototype.constructor = TouchSource;

  /**
   * @private
   * @param {Touch} inTouch The in touch.
   * @return {boolean} True, if this is the primary touch.
   */
  TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_ (inTouch) {
    return this.firstTouchId_ === inTouch.identifier;
  };

  /**
   * Set primary touch if there are no pointers, or the only pointer is the mouse.
   * @param {Touch} inTouch The in touch.
   * @private
   */
  TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_ (inTouch) {
    var count = Object.keys(this.pointerMap).length;
    if (count === 0 || (count === 1 && _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"].toString() in this.pointerMap)) {
      this.firstTouchId_ = inTouch.identifier;
      this.cancelResetClickCount_();
    }
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_ (inPointer) {
    if (inPointer.isPrimary) {
      this.firstTouchId_ = undefined;
      this.resetClickCount_();
    }
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCount_ = function resetClickCount_ () {
    this.resetId_ = setTimeout(
      this.resetClickCountHandler_.bind(this),
      CLICK_COUNT_TIMEOUT);
  };

  /**
   * @private
   */
  TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_ () {
    this.clickCount_ = 0;
    this.resetId_ = undefined;
  };

  /**
   * @private
   */
  TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_ () {
    if (this.resetId_ !== undefined) {
      clearTimeout(this.resetId_);
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent Browser event
   * @param {Touch} inTouch Touch event
   * @return {PointerEvent} A pointer object.
   */
  TouchSource.prototype.touchToPointer_ = function touchToPointer_ (browserEvent, inTouch) {
    var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
    // Spec specifies that pointerId 1 is reserved for Mouse.
    // Touch identifiers can start at 0.
    // Add 2 to the touch identifier for compatibility.
    e.pointerId = inTouch.identifier + 2;
    // TODO: check if this is necessary?
    //e.target = findTarget(e);
    e.bubbles = true;
    e.cancelable = true;
    e.detail = this.clickCount_;
    e.button = 0;
    e.buttons = 1;
    e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
    e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
    e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
    e.isPrimary = this.isPrimaryTouch_(inTouch);
    e.pointerType = POINTER_TYPE;

    // make sure that the properties that are different for
    // each `Touch` object are not copied from the BrowserEvent object
    e.clientX = inTouch.clientX;
    e.clientY = inTouch.clientY;
    e.screenX = inTouch.screenX;
    e.screenY = inTouch.screenY;

    return e;
  };

  /**
   * @private
   * @param {TouchEvent} inEvent Touch event
   * @param {function(TouchEvent, PointerEvent)} inFunction In function.
   */
  TouchSource.prototype.processTouches_ = function processTouches_ (inEvent, inFunction) {
    var this$1 = this;

    var touches = Array.prototype.slice.call(inEvent.changedTouches);
    var count = touches.length;
    function preventDefault() {
      inEvent.preventDefault();
    }
    for (var i = 0; i < count; ++i) {
      var pointer = this$1.touchToPointer_(inEvent, touches[i]);
      // forward touch preventDefaults
      pointer.preventDefault = preventDefault;
      inFunction.call(this$1, inEvent, pointer);
    }
  };

  /**
   * @private
   * @param {TouchList} touchList The touch list.
   * @param {number} searchId Search identifier.
   * @return {boolean} True, if the `Touch` with the given id is in the list.
   */
  TouchSource.prototype.findTouch_ = function findTouch_ (touchList, searchId) {
    var l = touchList.length;
    for (var i = 0; i < l; i++) {
      var touch = touchList[i];
      if (touch.identifier === searchId) {
        return true;
      }
    }
    return false;
  };

  /**
   * In some instances, a touchstart can happen without a touchend. This
   * leaves the pointermap in a broken state.
   * Therefore, on every touchstart, we remove the touches that did not fire a
   * touchend event.
   * To keep state globally consistent, we fire a pointercancel for
   * this "abandoned" touch
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.vacuumTouches_ = function vacuumTouches_ (inEvent) {
    var this$1 = this;

    var touchList = inEvent.touches;
    // pointerMap.getCount() should be < touchList.length here,
    // as the touchstart has not been processed yet.
    var keys = Object.keys(this.pointerMap);
    var count = keys.length;
    if (count >= touchList.length) {
      var d = [];
      for (var i = 0; i < count; ++i) {
        var key = keys[i];
        var value = this$1.pointerMap[key];
        // Never remove pointerId == 1, which is mouse.
        // Touch identifiers are 2 smaller than their pointerId, which is the
        // index in pointermap.
        if (key != _pointer_MouseSource_js__WEBPACK_IMPORTED_MODULE_2__["POINTER_ID"] && !this$1.findTouch_(touchList, key - 2)) {
          d.push(value.out);
        }
      }
      for (var i$1 = 0; i$1 < d.length; ++i$1) {
        this$1.cancelOut_(inEvent, d[i$1]);
      }
    }
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer object.
   */
  TouchSource.prototype.overDown_ = function overDown_ (browserEvent, inPointer) {
    this.pointerMap[inPointer.pointerId] = {
      target: inPointer.target,
      out: inPointer,
      outTarget: inPointer.target
    };
    this.dispatcher.over(inPointer, browserEvent);
    this.dispatcher.enter(inPointer, browserEvent);
    this.dispatcher.down(inPointer, browserEvent);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.moveOverOut_ = function moveOverOut_ (browserEvent, inPointer) {
    var event = inPointer;
    var pointer = this.pointerMap[event.pointerId];
    // a finger drifted off the screen, ignore it
    if (!pointer) {
      return;
    }
    var outEvent = pointer.out;
    var outTarget = pointer.outTarget;
    this.dispatcher.move(event, browserEvent);
    if (outEvent && outTarget !== event.target) {
      outEvent.relatedTarget = event.target;
      event.relatedTarget = outTarget;
      // recover from retargeting by shadow
      outEvent.target = outTarget;
      if (event.target) {
        this.dispatcher.leaveOut(outEvent, browserEvent);
        this.dispatcher.enterOver(event, browserEvent);
      } else {
        // clean up case when finger leaves the screen
        event.target = outTarget;
        event.relatedTarget = null;
        this.cancelOut_(browserEvent, event);
      }
    }
    pointer.out = event;
    pointer.outTarget = event.target;
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent An event.
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.upOut_ = function upOut_ (browserEvent, inPointer) {
    this.dispatcher.up(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {TouchEvent} browserEvent The event.
   * @param {PointerEvent} inPointer The in pointer.
   */
  TouchSource.prototype.cancelOut_ = function cancelOut_ (browserEvent, inPointer) {
    this.dispatcher.cancel(inPointer, browserEvent);
    this.dispatcher.out(inPointer, browserEvent);
    this.dispatcher.leave(inPointer, browserEvent);
    this.cleanUpPointer_(inPointer);
  };

  /**
   * @private
   * @param {PointerEvent} inPointer The inPointer object.
   */
  TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_ (inPointer) {
    delete this.pointerMap[inPointer.pointerId];
    this.removePrimaryPointer_(inPointer);
  };

  /**
   * Prevent synth mouse events from creating pointer events.
   *
   * @private
   * @param {TouchEvent} inEvent The in event.
   */
  TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_ (inEvent) {
    var lts = this.mouseSource.lastTouches;
    var t = inEvent.changedTouches[0];
    // only the primary finger will synth mouse events
    if (this.isPrimaryTouch_(t)) {
      // remember x/y of last touch
      var lt = [t.clientX, t.clientY];
      lts.push(lt);

      setTimeout(function() {
        // remove touch after timeout
        Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["remove"])(lts, lt);
      }, this.dedupTimeout_);
    }
  };

  return TouchSource;
}(_pointer_EventSource_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TouchSource);

//# sourceMappingURL=TouchSource.js.map

/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/*! exports provided: METERS_PER_UNIT, cloneTransform, identityTransform, addProjection, addProjections, get, getPointResolution, addEquivalentProjections, addEquivalentTransforms, clearAllProjections, createProjection, createTransformFromCoordinateTransform, addCoordinateTransforms, fromLonLat, toLonLat, equivalent, getTransformFromProjections, getTransform, transform, transformExtent, transformWithProjections, addCommon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return getPointResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"]; });

/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */











/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {module:ol/proj/Projection|string|undefined} ProjectionLike
 * @api
 */


/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array.<number>, Array.<number>=, number=): Array.<number>} TransformFunction
 * @api
 */





/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
}


/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
}


/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {module:ol/proj/Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["add"](projection.getCode(), projection);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection, projection, cloneTransform);
}


/**
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}


/**
 * Fetches a Projection object for the code specified.
 *
 * @param {module:ol/proj~ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {module:ol/proj/Projection} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  var projection = null;
  if (projectionLike instanceof _proj_Projection_js__WEBPACK_IMPORTED_MODULE_5__["default"]) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["get"](code);
  }
  return projection;
}


/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {module:ol/proj~ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {module:ol/coordinate~Coordinate} point Point to find adjusted resolution at.
 * @param {module:ol/proj/Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES && !opt_units || opt_units == _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
      var vertices = [
        point[0] - resolution / 2, point[1],
        point[0] + resolution / 2, point[1],
        point[0], point[1] - resolution / 2,
        point[0], point[1] + resolution / 2
      ];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = Object(_sphere_js__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ?
        _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["METERS_PER_UNIT"][opt_units] :
        projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}


/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<module:ol/proj/Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(source, destination, cloneTransform);
      }
    });
  });
}


/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<module:ol/proj/Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<module:ol/proj/Projection>} projections2 Projections with equal
 *     meaning.
 * @param {module:ol/proj~TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {module:ol/proj~TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection1, projection2, forwardTransform);
      Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(projection2, projection1, inverseTransform);
    });
  });
}


/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  _proj_projections_js__WEBPACK_IMPORTED_MODULE_7__["clear"]();
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["clear"])();
}


/**
 * @param {module:ol/proj/Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {module:ol/proj/Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {module:ol/proj/Projection} */ (projection)
    );
  }
}


/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} coordTransform Coordinate
 *     transform.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    });
}


/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {module:ol/proj~ProjectionLike} source Source projection.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(module:ol/coordinate~Coordinate): module:ol/coordinate~Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["add"])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}


/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326',
    opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}


/**
 * Transforms a coordinate to longitude/latitude.
 * @param {module:ol/coordinate~Coordinate} coordinate Projected coordinate.
 * @param {module:ol/proj~ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {module:ol/coordinate~Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate,
    opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["modulo"])(lon + 180, 360) - 180;
  }
  return lonLat;
}


/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {module:ol/proj/Projection} projection1 Projection 1.
 * @param {module:ol/proj/Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}


/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} sourceProjection Source Projection object.
 * @param {module:ol/proj/Projection} destinationProjection Destination Projection
 *     object.
 * @return {module:ol/proj~TransformFunction} Transform function.
 */
function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = Object(_proj_transforms_js__WEBPACK_IMPORTED_MODULE_8__["get"])(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}


/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {module:ol/proj~ProjectionLike} source Source.
 * @param {module:ol/proj~ProjectionLike} destination Destination.
 * @return {module:ol/proj~TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}


/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/coordinate~Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}


/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {module:ol/extent~Extent} extent The extent to transform.
 * @param {module:ol/proj~ProjectionLike} source Source projection-like.
 * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
 * @return {module:ol/extent~Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination) {
  var transformFunc = getTransform(source, destination);
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["applyTransform"])(extent, transformFunc);
}


/**
 * Transforms the given point to the destination projection.
 *
 * @param {module:ol/coordinate~Coordinate} point Point.
 * @param {module:ol/proj/Projection} sourceProjection Source projection.
 * @param {module:ol/proj/Projection} destinationProjection Destination projection.
 * @return {module:ol/coordinate~Coordinate} Point.
 */
function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"]);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"]);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_4__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["PROJECTIONS"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["fromEPSG4326"], _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_3__["toEPSG4326"]);
}

addCommon();

//# sourceMappingURL=proj.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */



/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {module:ol/proj/Units|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {module:ol/extent~Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {module:ol/extent~Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, module:ol/coordinate~Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{module:ol/coordinate~Coordinate}` as arguments, and returns
 * the `{number}` resolution at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */


/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection = function Projection(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {module:ol/proj/Units}
   */
  this.units_ = /** @type {module:ol/proj/Units} */ (options.units);

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ?
    options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ?
    options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, module:ol/coordinate~Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {module:ol/tilegrid/TileGrid}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
Projection.prototype.canWrapX = function canWrapX () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
Projection.prototype.getCode = function getCode () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {module:ol/proj/Units} Units.
 * @api
 */
Projection.prototype.getUnits = function getUnits () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
Projection.prototype.getMetersPerUnit = function getMetersPerUnit () {
  return this.metersPerUnit_ || _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__["METERS_PER_UNIT"][this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
Projection.prototype.getWorldExtent = function getWorldExtent () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *   or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *   "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
Projection.prototype.getAxisOrientation = function getAxisOrientation () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
Projection.prototype.isGlobal = function isGlobal () {
  return this.global_;
};

/**
 * Set if the projection is a global projection which spans the whole world
 * @param {boolean} global Whether the projection is global.
 * @api
 */
Projection.prototype.setGlobal = function setGlobal (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {module:ol/tilegrid/TileGrid} The default tile grid.
 */
Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid () {
  return this.defaultTileGrid_;
};

/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid The default tile grid.
 */
Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {module:ol/extent~Extent} extent Extent.
 * @api
 */
Projection.prototype.setExtent = function setExtent (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {module:ol/extent~Extent} worldExtent World extent
 *   [minlon, minlat, maxlon, maxlat].
 * @api
 */
Projection.prototype.setWorldExtent = function setWorldExtent (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
 * for this projection.
 * @param {function(number, module:ol/coordinate~Coordinate):number} func Function
 * @api
 */
Projection.prototype.setGetPointResolution = function setGetPointResolution (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, module:ol/coordinate~Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc () {
  return this.getPointResolutionFunc_;
};

/* harmony default export */ __webpack_exports__["default"] = (Projection);

//# sourceMappingURL=Projection.js.map

/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/*! exports provided: METERS_PER_UNIT, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};


/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<module:ol/proj/Units, number>}
 * @api
 */
var METERS_PER_UNIT = {};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

/* harmony default export */ __webpack_exports__["default"] = (Units);

//# sourceMappingURL=Units.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/*! exports provided: RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, PROJECTIONS, fromEPSG4326, toEPSG4326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HALF_SIZE", function() { return HALF_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORLD_EXTENT", function() { return WORLD_EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEPSG4326", function() { return fromEPSG4326; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toEPSG4326", function() { return toEPSG4326; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg3857
 */





/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * @const
 * @type {number}
 */
var HALF_SIZE = Math.PI * RADIUS;


/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var EXTENT = [
  -HALF_SIZE, -HALF_SIZE,
  HALF_SIZE, HALF_SIZE
];


/**
 * @const
 * @type {module:ol/extent~Extent}
 */
var WORLD_EXTENT = [-180, -85, 180, 85];


/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
var EPSG3857Projection = (function (Projection) {
  function EPSG3857Projection(code) {
    Projection.call(this, {
      code: code,
      units: _proj_Units_js__WEBPACK_IMPORTED_MODULE_2__["default"].METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["cosh"])(point[1] / RADIUS);
      }
    });

  }

  if ( Projection ) EPSG3857Projection.__proto__ = Projection;
  EPSG3857Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG3857Projection.prototype.constructor = EPSG3857Projection;

  return EPSG3857Projection;
}(_proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
  new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];


/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = RADIUS *
        Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
}


/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(
      Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}

//# sourceMappingURL=epsg3857.js.map

/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/*! exports provided: RADIUS, EXTENT, METERS_PER_UNIT, PROJECTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RADIUS", function() { return RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENT", function() { return EXTENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return METERS_PER_UNIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROJECTIONS", function() { return PROJECTIONS; });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/epsg4326
 */




/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;


/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {module:ol/extent~Extent}
 */
var EXTENT = [-180, -90, 180, 90];


/**
 * @const
 * @type {number}
 */
var METERS_PER_UNIT = Math.PI * RADIUS / 180;


/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
var EPSG4326Projection = (function (Projection) {
  function EPSG4326Projection(code, opt_axisOrientation) {
    Projection.call(this, {
      code: code,
      units: _proj_Units_js__WEBPACK_IMPORTED_MODULE_1__["default"].DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });

  }

  if ( Projection ) EPSG4326Projection.__proto__ = Projection;
  EPSG4326Projection.prototype = Object.create( Projection && Projection.prototype );
  EPSG4326Projection.prototype.constructor = EPSG4326Projection;

  return EPSG4326Projection;
}(_proj_Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<module:ol/proj/Projection>}
 */
var PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')
];

//# sourceMappingURL=epsg4326.js.map

/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/*! exports provided: clear, get, add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/**
 * @module ol/proj/projections
 */


/**
 * @type {Object.<string, module:ol/proj/Projection>}
 */
var cache = {};


/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}


/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {module:ol/proj/Projection} The projection (if cached).
 */
function get(code) {
  return cache[code] || null;
}


/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {module:ol/proj/Projection} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}

//# sourceMappingURL=projections.js.map

/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/*! exports provided: clear, add, remove, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */



/**
 * @private
 * @type {!Object.<string, Object.<string, module:ol/proj~TransformFunction>>}
 */
var transforms = {};


/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}


/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {module:ol/proj/Projection} source Source.
 * @param {module:ol/proj/Projection} destination Destination.
 * @param {module:ol/proj~TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}


/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {module:ol/proj/Projection} source Source projection.
 * @param {module:ol/proj/Projection} destination Destination projection.
 * @return {module:ol/proj~TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__["isEmpty"])(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}


/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {module:ol/proj~TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  var transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}

//# sourceMappingURL=transforms.js.map

/***/ }),

/***/ "./node_modules/ol/render/Box.js":
/*!***************************************!*\
  !*** ./node_modules/ol/render/Box.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/**
 * @module ol/render/Box
 */




var RenderBox = (function (Disposable) {
  function RenderBox(className) {
    Disposable.call(this);

    /**
     * @type {module:ol/geom/Polygon}
     * @private
     */
    this.geometry_ = null;

    /**
     * @type {HTMLDivElement}
     * @private
     */
    this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));
    this.element_.style.position = 'absolute';
    this.element_.className = 'ol-box ' + className;

    /**
     * @private
     * @type {module:ol/PluggableMap}
     */
    this.map_ = null;

    /**
     * @private
     * @type {module:ol/pixel~Pixel}
     */
    this.startPixel_ = null;

    /**
     * @private
     * @type {module:ol/pixel~Pixel}
     */
    this.endPixel_ = null;

  }

  if ( Disposable ) RenderBox.__proto__ = Disposable;
  RenderBox.prototype = Object.create( Disposable && Disposable.prototype );
  RenderBox.prototype.constructor = RenderBox;

  /**
   * @inheritDoc
   */
  RenderBox.prototype.disposeInternal = function disposeInternal () {
    this.setMap(null);
  };

  /**
   * @private
   */
  RenderBox.prototype.render_ = function render_ () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };

  /**
   * @param {module:ol/PluggableMap} map Map.
   */
  RenderBox.prototype.setMap = function setMap (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = style.top = style.width = style.height = 'inherit';
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };

  /**
   * @param {module:ol/pixel~Pixel} startPixel Start pixel.
   * @param {module:ol/pixel~Pixel} endPixel End pixel.
   */
  RenderBox.prototype.setPixels = function setPixels (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };

  /**
   * Creates or updates the cached geometry.
   */
  RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
    // close the polygon
    coordinates[4] = coordinates[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_1__["default"]([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };

  /**
   * @return {module:ol/geom/Polygon} Geometry.
   */
  RenderBox.prototype.getGeometry = function getGeometry () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RenderBox);

//# sourceMappingURL=Box.js.map

/***/ }),

/***/ "./node_modules/ol/render/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/render/Event.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/**
 * @module ol/render/Event
 */



var RenderEvent = (function (Event) {
  function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

    Event.call(this, type);

    /**
     * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.
     * @type {module:ol/render/VectorContext|undefined}
     * @api
     */
    this.vectorContext = opt_vectorContext;

    /**
     * An object representing the current render frame state.
     * @type {module:ol/PluggableMap~FrameState|undefined}
     * @api
     */
    this.frameState = opt_frameState;

    /**
     * Canvas context. Only available when a Canvas renderer is used, null
     * otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */
    this.context = opt_context;

    /**
     * WebGL context. Only available when a WebGL renderer is used, null
     * otherwise.
     * @type {module:ol/webgl/Context|null|undefined}
     * @api
     */
    this.glContext = opt_glContext;

  }

  if ( Event ) RenderEvent.__proto__ = Event;
  RenderEvent.prototype = Object.create( Event && Event.prototype );
  RenderEvent.prototype.constructor = RenderEvent;

  return RenderEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (RenderEvent);

//# sourceMappingURL=Event.js.map

/***/ }),

/***/ "./node_modules/ol/render/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/render/EventType.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event module:ol/render/Event~RenderEvent#render
   * @api
   */
  RENDER: 'render'
});

//# sourceMappingURL=EventType.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayGroup.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/render/ReplayGroup.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/ReplayGroup
 */
/**
 * Base class for replay groups.
 */
var ReplayGroup = function ReplayGroup () {};

ReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {};

/**
 * @abstract
 * @return {boolean} Is empty.
 */
ReplayGroup.prototype.isEmpty = function isEmpty () {};

/* harmony default export */ __webpack_exports__["default"] = (ReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/ReplayType.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/render/ReplayType.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/ReplayType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
});

//# sourceMappingURL=ReplayType.js.map

/***/ }),

/***/ "./node_modules/ol/render/VectorContext.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/VectorContext.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext = function VectorContext () {};

VectorContext.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {};

/**
 * Render a geometry.
 *
 * @param {module:ol/geom/Geometry} geometry The geometry to render.
 */
VectorContext.prototype.drawGeometry = function drawGeometry (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {module:ol/style/Style} style The rendering style.
 */
VectorContext.prototype.setStyle = function setStyle (style) {};

/**
 * @param {module:ol/geom/Circle} circleGeometry Circle geometry.
 * @param {module:ol/Feature} feature Feature.
 */
VectorContext.prototype.drawCircle = function drawCircle (circleGeometry, feature) {};

/**
 * @param {module:ol/Feature} feature Feature.
 * @param {module:ol/style/Style} style Style.
 */
VectorContext.prototype.drawFeature = function drawFeature (feature, style) {};

/**
 * @param {module:ol/geom/GeometryCollection} geometryCollectionGeometry Geometry collection.
 * @param {module:ol/Feature} feature Feature.
 */
VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection (geometryCollectionGeometry, feature) {};

/**
 * @param {module:ol/geom/LineString|module:ol/render/Feature} lineStringGeometry Line string geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {};

/**
 * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} multiLineStringGeometry MultiLineString geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {};

/**
 * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} multiPointGeometry MultiPoint geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {};

/**
 * @param {module:ol/geom/MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {};

/**
 * @param {module:ol/geom/Point|module:ol/render/Feature} pointGeometry Point geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawPoint = function drawPoint (pointGeometry, feature) {};

/**
 * @param {module:ol/geom/Polygon|module:ol/render/Feature} polygonGeometry Polygon geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {};

/**
 * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
VectorContext.prototype.drawText = function drawText (geometry, feature) {};

/**
 * @param {module:ol/style/Fill} fillStyle Fill style.
 * @param {module:ol/style/Stroke} strokeStyle Stroke style.
 */
VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {};

/**
 * @param {module:ol/style/Image} imageStyle Image style.
 * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setImageStyle = function setImageStyle (imageStyle, opt_declutterGroup) {};

/**
 * @param {module:ol/style/Text} textStyle Text style.
 * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.
 */
VectorContext.prototype.setTextStyle = function setTextStyle (textStyle, opt_declutterGroup) {};

/* harmony default export */ __webpack_exports__["default"] = (VectorContext);

//# sourceMappingURL=VectorContext.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/canvas.js ***!
  \******************************************/
/*! exports provided: defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, labelCache, checkedFonts, textHeights, checkFont, measureTextHeight, measureTextWidth, rotateAtOffset, resetTransform, drawImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFont", function() { return defaultFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultFillStyle", function() { return defaultFillStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineCap", function() { return defaultLineCap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDash", function() { return defaultLineDash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineDashOffset", function() { return defaultLineDashOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineJoin", function() { return defaultLineJoin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMiterLimit", function() { return defaultMiterLimit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultStrokeStyle", function() { return defaultStrokeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextAlign", function() { return defaultTextAlign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTextBaseline", function() { return defaultTextBaseline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPadding", function() { return defaultPadding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultLineWidth", function() { return defaultLineWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelCache", function() { return labelCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkedFonts", function() { return checkedFonts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textHeights", function() { return textHeights; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFont", function() { return checkFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextHeight", function() { return measureTextHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidth", function() { return measureTextWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAtOffset", function() { return rotateAtOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTransform", function() { return resetTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawImage", function() { return drawImage; });
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../structs/LRUCache.js */ "./node_modules/ol/structs/LRUCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas
 */







/**
 * @typedef {Object} FillState
 * @property {module:ol/colorlike~ColorLike} fillStyle
 */


/**
 * @typedef {Object} FillStrokeState
 * @property {module:ol/colorlike~ColorLike} [currentFillStyle]
 * @property {module:ol/colorlike~ColorLike} [currentStrokeStyle]
 * @property {string} [currentLineCap]
 * @property {Array.<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {string} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {module:ol/colorlike~ColorLike} [fillStyle]
 * @property {module:ol/colorlike~ColorLike} [strokeStyle]
 * @property {string} [lineCap]
 * @property {Array.<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {string} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */


/**
 * @typedef {Object} StrokeState
 * @property {string} lineCap
 * @property {Array.<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {module:ol/colorlike~ColorLike} strokeStyle
 */


/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 */


/**
 * Container for decluttered replay instructions that need to be rendered or
 * omitted together, i.e. when styles render both an image and text, or for the
 * characters that form text along lines. The basic elements of this array are
 * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
 * rendered extent of the group in pixel space. `count` is the number of styles
 * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
 * In addition to these four elements, declutter instruction arrays (i.e. the
 * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
 * @typedef {Array.<*>} DeclutterGroup
 */


/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';


/**
 * @const
 * @type {module:ol/color~Color}
 */
var defaultFillStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultLineCap = 'round';


/**
 * @const
 * @type {Array.<number>}
 */
var defaultLineDash = [];


/**
 * @const
 * @type {number}
 */
var defaultLineDashOffset = 0;


/**
 * @const
 * @type {string}
 */
var defaultLineJoin = 'round';


/**
 * @const
 * @type {number}
 */
var defaultMiterLimit = 10;


/**
 * @const
 * @type {module:ol/color~Color}
 */
var defaultStrokeStyle = [0, 0, 0, 1];


/**
 * @const
 * @type {string}
 */
var defaultTextAlign = 'center';


/**
 * @const
 * @type {string}
 */
var defaultTextBaseline = 'middle';


/**
 * @const
 * @type {Array.<number>}
 */
var defaultPadding = [0, 0, 0, 0];


/**
 * @const
 * @type {number}
 */
var defaultLineWidth = 1;


/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * @type {module:ol/structs/LRUCache.<HTMLCanvasElement>}
 * @api
 */
var labelCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__["default"]();


/**
 * @type {!Object.<string, number>}
 */
var checkedFonts = {};


/**
 * @type {CanvasRenderingContext2D}
 */
var measureContext = null;


/**
 * @type {!Object.<string, number>}
 */
var textHeights = {};


/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
var checkFont = (function() {
  var retries = 60;
  var checked = checkedFonts;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;

  function isAvailable(font) {
    var context = getMeasureContext();
    var available = true;
    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      context.font = size + referenceFont;
      referenceWidth = context.measureText(text).width;
      if (font != referenceFont) {
        context.font = size + font + ',' + referenceFont;
        var width = context.measureText(text).width;
        // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.
        available = available && width != referenceWidth;
      }
    }
    return available;
  }

  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__["clear"])(textHeights);
          // Make sure that loaded fonts are picked up by Safari
          measureContext = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function(fontSpec) {
    var fontFamilies = Object(_css_js__WEBPACK_IMPORTED_MODULE_0__["getFontFamilies"])(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
})();


/**
 * @return {CanvasRenderingContext2D} Measure context.
 */
function getMeasureContext() {
  if (!measureContext) {
    measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);
  }
  return measureContext;
}


/**
 * @param {string} font Font to use for measuring.
 * @return {module:ol/size~Size} Measurement.
 */
var measureTextHeight = (function() {
  var span;
  var heights = textHeights;
  return function(font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
})();


/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
function measureTextWidth(font, text) {
  var measureContext = getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
}


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}


var resetTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_4__["create"])();


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {module:ol/transform~Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */
function drawImage(context,
  transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, resetTransform);
  }
}

//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ImageReplay.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ImageReplay.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../canvas/Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas/Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/ImageReplay
 */



var CanvasImageReplay = (function (CanvasReplay) {
  function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {module:ol/render/canvas~DeclutterGroup}
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.snapToPixel_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

  }

  if ( CanvasReplay ) CanvasImageReplay.__proto__ = CanvasReplay;
  CanvasImageReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasImageReplay.prototype.constructor = CanvasImageReplay;

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} My end.
   */
  CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_ (flatCoordinates, offset, end, stride) {
    return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawPoint = function drawPoint (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.snapToPixel_, this.width_
    ]);
    this.endGeometry(pointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }
    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.drawCoordinates_(
      flatCoordinates, 0, flatCoordinates.length, stride);
    this.instructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_
    ]);
    this.hitDetectionInstructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
      this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
      this.scale_, this.snapToPixel_, this.width_
    ]);
    this.endGeometry(multiPointGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.snapToPixel_ = undefined;
    this.width_ = undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasImageReplay.prototype.setImageStyle = function setImageStyle (imageStyle, declutterGroup) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    var image = imageStyle.getImage(1);
    var origin = imageStyle.getOrigin();
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScale();
    this.snapToPixel_ = imageStyle.getSnapToPixel();
    this.width_ = size[0];
  };

  return CanvasImageReplay;
}(_canvas_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageReplay);

//# sourceMappingURL=ImageReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Immediate.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/render/canvas/Immediate.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?












/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer = (function (VectorContext) {
  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {
    VectorContext.call(this);

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = context;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.extent_ = extent;

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.transform_ = transform;

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = viewRotation;

    /**
     * @private
     * @type {?module:ol/render/canvas~FillState}
     */
    this.contextFillState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~StrokeState}
     */
    this.contextStrokeState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~TextState}
     */
    this.contextTextState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~FillState}
     */
    this.fillState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~StrokeState}
     */
    this.strokeState_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageAnchorY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageHeight_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOpacity_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageOriginY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.imageScale_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.imageSnapToPixel_ = false;

    /**
     * @private
     * @type {number}
     */
    this.imageWidth_ = 0;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean}
     */
    this.textRotateWithView_ = false;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textScale_ = 0;

    /**
     * @private
     * @type {?module:ol/render/canvas~FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?module:ol/render/canvas~TextState}
     */
    this.textState_ = null;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.tmpLocalTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["create"])();

  }

  if ( VectorContext ) CanvasImmediateRenderer.__proto__ = VectorContext;
  CanvasImmediateRenderer.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_ (flatCoordinates, offset, end, stride) {
    var this$1 = this;

    if (!this.image_) {
      return;
    }
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, 2, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }
    var rotation = this.imageRotation_;
    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this$1.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this$1.imageAnchorY_;
      if (this$1.imageSnapToPixel_) {
        x = Math.round(x);
        y = Math.round(y);
      }
      if (rotation !== 0 || this$1.imageScale_ != 1) {
        var centerX = x + this$1.imageAnchorX_;
        var centerY = y + this$1.imageAnchorY_;
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(localTransform,
          centerX, centerY,
          this$1.imageScale_, this$1.imageScale_,
          rotation,
          -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
      }
      context.drawImage(this$1.image_, this$1.imageOriginX_, this$1.imageOriginY_,
        this$1.imageWidth_, this$1.imageHeight_, x, y,
        this$1.imageWidth_, this$1.imageHeight_);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  CanvasImmediateRenderer.prototype.drawText_ = function drawText_ (flatCoordinates, offset, end, stride) {
    var this$1 = this;

    if (!this.textState_ || this.text_ === '') {
      return;
    }
    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }
    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }
    this.setContextTextState_(this.textState_);
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;
    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }
    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this$1.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this$1.textOffsetY_;
      if (rotation !== 0 || this$1.textScale_ != 1) {
        var localTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__["compose"])(this$1.tmpLocalTransform_,
          x, y,
          this$1.textScale_, this$1.textScale_,
          rotation,
          -x, -y);
        context.setTransform.apply(context, localTransform);
      }
      if (this$1.textStrokeState_) {
        context.strokeText(this$1.text_, x, y);
      }
      if (this$1.textFillState_) {
        context.fillText(this$1.text_, x, y);
      }
    }
    if (rotation !== 0 || this.textScale_ != 1) {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_ (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__["transform2D"])(
      flatCoordinates, offset, end, stride, this.transform_,
      this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;
    if (close) {
      length -= 2;
    }
    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }
    if (close) {
      context.closePath();
    }
    return end;
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array.<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_ (flatCoordinates, offset, ends, stride) {
    var this$1 = this;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }
    return offset;
  };

  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {module:ol/geom/Circle} geometry Circle geometry.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawCircle = function drawCircle (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var pixelCoordinates = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__["transformGeom2D"])(
        geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(
        pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {module:ol/style/Style} style The rendering style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.setStyle = function setStyle (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };

  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry The geometry to render.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry (geometry) {
    var type = geometry.getType();
    switch (type) {
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POINT:
        this.drawPoint(/** @type {module:ol/geom/Point} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING:
        this.drawLineString(/** @type {module:ol/geom/LineString} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON:
        this.drawPolygon(/** @type {module:ol/geom/Polygon} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POINT:
        this.drawMultiPoint(/** @type {module:ol/geom/MultiPoint} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_LINE_STRING:
        this.drawMultiLineString(/** @type {module:ol/geom/MultiLineString} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].MULTI_POLYGON:
        this.drawMultiPolygon(/** @type {module:ol/geom/MultiPolygon} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].GEOMETRY_COLLECTION:
        this.drawGeometryCollection(/** @type {module:ol/geom/GeometryCollection} */ (geometry));
        break;
      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE:
        this.drawCircle(/** @type {module:ol/geom/Circle} */ (geometry));
        break;
      default:
    }
  };

  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {module:ol/Feature} feature Feature.
   * @param {module:ol/style/Style} style Style.
   * @override
   * @api
   */
  CanvasImmediateRenderer.prototype.drawFeature = function drawFeature (feature, style) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  };

  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {module:ol/geom/GeometryCollection} geometry Geometry collection.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection (geometry) {
    var this$1 = this;

    var geometries = geometry.getGeometriesArray();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this$1.drawGeometry(geometries[i]);
    }
  };

  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Point geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPoint = function drawPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry MultiPoint geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint (geometry) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();
    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry LineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawLineString = function drawLineString (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), false);
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };

  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry MultiLineString geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString (geometry) {
    var this$1 = this;

    var geometryExtent = geometry.getExtent();
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometryExtent)) {
      return;
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends = geometry.getEnds();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }
      context.stroke();
    }
    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };

  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Polygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon (geometry) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(),
        0, geometry.getEnds(), geometry.getStride());
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };

  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.
   * @override
   */
  CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon (geometry) {
    var this$1 = this;

    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {
      return;
    }
    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }
      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this$1.drawRings_(flatCoordinates, offset, ends, stride);
      }
      if (this.fillState_) {
        context.fill();
      }
      if (this.strokeState_) {
        context.stroke();
      }
    }
    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };

  /**
   * @param {module:ol/render/canvas~FillState} fillState Fill state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_ (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;
    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
      }
    }
  };

  /**
   * @param {module:ol/render/canvas~StrokeState} strokeState Stroke state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_ (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;
    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
      }
      if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"]) {
        if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["equals"])(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = context.lineDashOffset =
              strokeState.lineDashOffset;
        }
      }
      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
      }
      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
      }
      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = context.miterLimit =
            strokeState.miterLimit;
      }
      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = context.strokeStyle =
            strokeState.strokeStyle;
      }
    }
  };

  /**
   * @param {module:ol/render/canvas~TextState} textState Text state.
   * @private
   */
  CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_ (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ?
      textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"];
    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign = textAlign;
      context.textBaseline = textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = context.font = textState.font;
      }
      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign = context.textAlign = textAlign;
      }
      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline = context.textBaseline =
            textState.textBaseline;
      }
    }
  };

  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {module:ol/style/Fill} fillStyle Fill style.
   * @param {module:ol/style/Stroke} strokeStyle Stroke style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(fillStyleColor ?
          fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
      };
    }
    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ?
          strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
        lineDash: strokeStyleLineDash ?
          strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
        lineDashOffset: strokeStyleLineDashOffset ?
          strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
        lineJoin: strokeStyleLineJoin !== undefined ?
          strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?
          strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"]),
        miterLimit: strokeStyleMiterLimit !== undefined ?
          strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
        strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(strokeStyleColor ?
          strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
      };
    }
  };

  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {module:ol/style/Image} imageStyle Image style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageAnchor = imageStyle.getAnchor();
      // FIXME pixel ratio
      var imageImage = imageStyle.getImage(1);
      var imageOrigin = imageStyle.getOrigin();
      var imageSize = imageStyle.getSize();
      this.imageAnchorX_ = imageAnchor[0];
      this.imageAnchorY_ = imageAnchor[1];
      this.imageHeight_ = imageSize[1];
      this.image_ = imageImage;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
      this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
      this.imageWidth_ = imageSize[0];
    }
  };

  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {module:ol/style/Text} textStyle Text style.
   * @override
   */
  CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textFillStyleColor ?
            textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFillStyle"])
        };
      }
      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ?
            textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineCap"],
          lineDash: textStrokeStyleLineDash ?
            textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDash"],
          lineDashOffset: textStrokeStyleLineDashOffset ?
            textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineDashOffset"],
          lineJoin: textStrokeStyleLineJoin !== undefined ?
            textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineJoin"],
          lineWidth: textStrokeStyleWidth !== undefined ?
            textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultLineWidth"],
          miterLimit: textStrokeStyleMiterLimit !== undefined ?
            textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultMiterLimit"],
          strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(textStrokeStyleColor ?
            textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultStrokeStyle"])
        };
      }
      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScale();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ?
          textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultFont"],
        textAlign: textTextAlign !== undefined ?
          textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextAlign"],
        textBaseline: textTextBaseline !== undefined ?
          textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_8__["defaultTextBaseline"]
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ =
          textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;
      this.textOffsetY_ =
          textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?
        textScale : 1);
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasImmediateRenderer);

//# sourceMappingURL=Immediate.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Instruction.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/Instruction.js ***!
  \******************************************************/
/*! exports provided: fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillInstruction", function() { return fillInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "strokeInstruction", function() { return strokeInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beginPathInstruction", function() { return beginPathInstruction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closePathInstruction", function() { return closePathInstruction; });
/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};


/**
 * @type {Array.<Instruction>}
 */
var fillInstruction = [Instruction.FILL];


/**
 * @type {Array.<Instruction>}
 */
var strokeInstruction = [Instruction.STROKE];


/**
 * @type {Array.<Instruction>}
 */
var beginPathInstruction = [Instruction.BEGIN_PATH];


/**
 * @type {Array.<Instruction>}
 */
var closePathInstruction = [Instruction.CLOSE_PATH];


/* harmony default export */ __webpack_exports__["default"] = (Instruction);

//# sourceMappingURL=Instruction.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/LineStringReplay.js":
/*!***********************************************************!*\
  !*** ./node_modules/ol/render/canvas/LineStringReplay.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../canvas/Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../canvas/Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/LineStringReplay
 */



var CanvasLineStringReplay = (function (CanvasReplay) {
  function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasLineStringReplay.__proto__ = CanvasReplay;
  CanvasLineStringReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_ (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(
      flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(lineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {
    var this$1 = this;

    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;
    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }
    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
      state.miterLimit, state.lineDash, state.lineDashOffset
    ], _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this$1.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
    }
    this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    this.endGeometry(multiLineStringGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasLineStringReplay.prototype.finish = function finish () {
    var state = this.state;
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
    }
    this.reverseHitDetectionInstructions();
    this.state = null;
  };

  /**
   * @inheritDoc.
   */
  CanvasLineStringReplay.prototype.applyStroke = function applyStroke (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["strokeInstruction"]);
      state.lastStroke = this.coordinates.length;
    }
    state.lastStroke = 0;
    CanvasReplay.prototype.applyStroke.call(this, state);
    this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_0__["beginPathInstruction"]);
  };

  return CanvasLineStringReplay;
}(_canvas_Replay_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasLineStringReplay);

//# sourceMappingURL=LineStringReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/PolygonReplay.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/render/canvas/PolygonReplay.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../color.js */ "./node_modules/ol/color.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../canvas/Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../canvas/Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/**
 * @module ol/render/canvas/PolygonReplay
 */







var CanvasPolygonReplay = (function (CanvasReplay) {
  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  }

  if ( CanvasReplay ) CanvasPolygonReplay.__proto__ = CanvasReplay;
  CanvasPolygonReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array.<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_ (flatCoordinates, offset, ends, stride) {
    var this$1 = this;

    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle != undefined;
    var numEnds = ends.length;
    this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"]);
    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this$1.coordinates.length;
      var myEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].MOVE_TO_LINE_TO, myBegin, myEnd];
      this$1.instructions.push(moveToLineToInstruction);
      this$1.hitDetectionInstructions.push(moveToLineToInstruction);
      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatCoordinates above).
        this$1.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
        this$1.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["closePathInstruction"]);
      }
      offset = end;
    }
    if (fill) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
      this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (stroke) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    return offset;
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawCircle = function drawCircle (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(circleGeometry);
    this.beginGeometry(circleGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatCoordinates(
      flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE, myBegin];
    this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["beginPathInstruction"], circleInstruction);
    this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    if (state.fillStyle !== undefined) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["fillInstruction"]);
    }
    if (state.strokeStyle !== undefined) {
      this.instructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
      this.hitDetectionInstructions.push(_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["strokeInstruction"]);
    }
    this.endGeometry(circleGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(polygonGeometry);
    this.beginGeometry(polygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
    this.endGeometry(polygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {
    var this$1 = this;

    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }
    this.setFillStrokeStyles_(multiPolygonGeometry);
    this.beginGeometry(multiPolygonGeometry, feature);
    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_FILL_STYLE,
        Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(_canvas_js__WEBPACK_IMPORTED_MODULE_2__["defaultFillStyle"])
      ]);
    }
    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([
        _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_3__["default"].SET_STROKE_STYLE,
        state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
        state.miterLimit, state.lineDash, state.lineDashOffset
      ]);
    }
    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this$1.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }
    this.endGeometry(multiPolygonGeometry, feature);
  };

  /**
   * @inheritDoc
   */
  CanvasPolygonReplay.prototype.finish = function finish () {
    this.reverseHitDetectionInstructions();
    this.state = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    var tolerance = this.tolerance;
    if (tolerance !== 0) {
      var coordinates = this.coordinates;
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Object(_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_1__["snap"])(coordinates[i], tolerance);
      }
    }
  };

  /**
   * @private
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
   */
  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_ (geometry) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill, geometry);
    }
    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonReplay;
}(_canvas_Replay_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasPolygonReplay);

//# sourceMappingURL=PolygonReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/Replay.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/render/canvas/Replay.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../geom/flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _geom_flat_length_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../geom/flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/* harmony import */ var _geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../geom/flat/textpath.js */ "./node_modules/ol/geom/flat/textpath.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../VectorContext.js */ "./node_modules/ol/render/VectorContext.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../canvas/Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/Replay
 */




















/**
 * @type {module:ol/extent~Extent}
 */
var tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createEmpty"])();


/**
 * @type {!module:ol/transform~Transform}
 */
var tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["create"])();


var CanvasReplay = (function (VectorContext) {
  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    VectorContext.call(this);

    /**
     * @type {?}
     */
    this.declutterTree = declutterTree;

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {module:ol/extent~Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;

    /**
     * @protected
     * @type {number}
     */
    this.pixelRatio = pixelRatio;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {boolean}
     */
    this.alignFill_;

    /**
     * @private
     * @type {Array.<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array.<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {Array.<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.coordinates = [];

    /**
     * @private
     * @type {!Object.<number,module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>>}
     */
    this.coordinateCache_ = {};

    /**
     * @private
     * @type {!module:ol/transform~Transform}
     */
    this.renderedTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["create"])();

    /**
     * @protected
     * @type {Array.<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @private
     * @type {Array.<number>}
     */
    this.pixelCoordinates_ = null;

    /**
     * @protected
     * @type {module:ol/render/canvas~FillStrokeState}
     */
    this.state = /** @type {module:ol/render/canvas~FillStrokeState} */ ({});

    /**
     * @private
     * @type {number}
     */
    this.viewRotation_ = 0;

  }

  if ( VectorContext ) CanvasReplay.__proto__ = VectorContext;
  CanvasReplay.prototype = Object.create( VectorContext && VectorContext.prototype );
  CanvasReplay.prototype.constructor = CanvasReplay;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/coordinate~Coordinate} p1 1st point of the background box.
   * @param {module:ol/coordinate~Coordinate} p2 2nd point of the background box.
   * @param {module:ol/coordinate~Coordinate} p3 3rd point of the background box.
   * @param {module:ol/coordinate~Coordinate} p4 4th point of the background box.
   * @param {Array.<*>} fillInstruction Fill instruction.
   * @param {Array.<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_ (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);
    if (fillInstruction) {
      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
      this.fill_(context);
    }
    if (strokeInstruction) {
      this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction));
      context.stroke();
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
   * @param {number} height Height.
   * @param {number} opacity Opacity.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {number} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {number} width Width.
   * @param {Array.<number>} padding Padding.
   * @param {Array.<*>} fillInstruction Fill instruction.
   * @param {Array.<*>} strokeInstruction Stroke instruction.
   */
  CanvasReplay.prototype.replayImage_ = function replayImage_ (
    context,
    x,
    y,
    image,
    anchorX,
    anchorY,
    declutterGroup,
    height,
    opacity,
    originX,
    originY,
    rotation,
    scale,
    snapToPixel,
    width,
    padding,
    fillInstruction,
    strokeInstruction
  ) {
    var fillStroke = fillInstruction || strokeInstruction;
    anchorX *= scale;
    anchorY *= scale;
    x -= anchorX;
    y -= anchorY;

    var w = (width + originX > image.width) ? image.width - originX : width;
    var h = (height + originY > image.height) ? image.height - originY : height;
    var boxW = padding[3] + w * scale + padding[1];
    var boxH = padding[0] + h * scale + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    /** @type {module:ol/coordinate~Coordinate} */
    var p1;
    /** @type {module:ol/coordinate~Coordinate} */
    var p2;
    /** @type {module:ol/coordinate~Coordinate} */
    var p3;
    /** @type {module:ol/coordinate~Coordinate} */
    var p4;
    if (fillStroke || rotation !== 0) {
      p1 = [boxX, boxY];
      p2 = [boxX + boxW, boxY];
      p3 = [boxX + boxW, boxY + boxH];
      p4 = [boxX, boxY + boxH];
    }

    var transform = null;
    if (rotation !== 0) {
      var centerX = x + anchorX;
      var centerY = y + anchorY;
      transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["compose"])(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdateEmpty"])(tmpExtent);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["apply"])(tmpTransform, p1));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["apply"])(tmpTransform, p2));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["apply"])(tmpTransform, p3));
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["extendCoordinate"])(tmpExtent, Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["apply"])(tmpTransform, p4));
    } else {
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
    }
    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;
    var intersects =
        tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&
        tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    if (declutterGroup) {
      if (!intersects && declutterGroup[4] == 1) {
        return;
      }
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["extend"])(declutterGroup, tmpExtent);
      var declutterArgs = intersects ?
        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :
        null;
      if (declutterArgs && fillStroke) {
        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
      }
      declutterGroup.push(declutterArgs);
    } else if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
          /** @type {Array.<*>} */ (fillInstruction),
          /** @type {Array.<*>} */ (strokeInstruction));
      }
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_14__["drawImage"])(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
    }
  };

  /**
   * @protected
   * @param {Array.<number>} dashArray Dash array.
   * @return {Array.<number>} Dash array with pixel ratio applied
   */
  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
      return dash * pixelRatio;
    });
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates (flatCoordinates, offset, end, stride, closed, skipFirst) {
    var this$1 = this;


    var myEnd = this.coordinates.length;
    var extent = this.getBufferedMaxExtent();
    if (skipFirst) {
      offset += stride;
    }
    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var nextCoord = [NaN, NaN];
    var skipped = true;

    var i, lastRel, nextRel;
    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["coordinateRelationship"])(extent, nextCoord);
      if (nextRel !== lastRel) {
        if (skipped) {
          this$1.coordinates[myEnd++] = lastCoord[0];
          this$1.coordinates[myEnd++] = lastCoord[1];
        }
        this$1.coordinates[myEnd++] = nextCoord[0];
        this$1.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else if (nextRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_5__["default"].INTERSECTING) {
        this$1.coordinates[myEnd++] = nextCoord[0];
        this$1.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
      lastCoord[0] = nextCoord[0];
      lastCoord[1] = nextCoord[1];
      lastRel = nextRel;
    }

    // Last coordinate equals first or only one point to append:
    if ((closed && skipped) || i === offset + stride) {
      this.coordinates[myEnd++] = lastCoord[0];
      this.coordinates[myEnd++] = lastCoord[1];
    }
    return myEnd;
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array.<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array.<number>} replayEnds Replay ends.
   * @return {number} Offset.
   */
  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_ (flatCoordinates, offset, ends, stride, replayEnds) {
    var this$1 = this;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var replayEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      replayEnds.push(replayEnd);
      offset = end;
    }
    return offset;
  };

  /**
   * @inheritDoc.
   */
  CanvasReplay.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {
    var this$1 = this;

    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var replayBegin = this.coordinates.length;
    var flatCoordinates, replayEnd, replayEnds, replayEndss;
    var offset;
    if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_POLYGON) {
      geometry = /** @type {module:ol/geom/MultiPolygon} */ (geometry);
      flatCoordinates = geometry.getOrientedFlatCoordinates();
      replayEndss = [];
      var endss = geometry.getEndss();
      offset = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var myEnds = [];
        offset = this$1.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
        replayEndss.push(myEnds);
      }
      this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CUSTOM,
        replayBegin, replayEndss, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateMultiCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_LINE_STRING) {
      replayEnds = [];
      flatCoordinates = (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POLYGON) ?
        /** @type {module:ol/geom/Polygon} */ (geometry).getOrientedFlatCoordinates() :
        geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0,
        /** @type {module:ol/geom/Polygon|module:ol/geom/MultiLineString} */ (geometry).getEnds(),
        stride, replayEnds);
      this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CUSTOM,
        replayBegin, replayEnds, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinatesArray"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].LINE_STRING || type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].MULTI_POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      replayEnd = this.appendFlatCoordinates(
        flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer, _geom_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__["inflateCoordinates"]]);
    } else if (type == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
      replayEnd = this.coordinates.length;
      this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CUSTOM,
        replayBegin, replayEnd, geometry, renderer]);
    }
    this.endGeometry(geometry, feature);
  };

  /**
   * @protected
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   */
  CanvasReplay.prototype.beginGeometry = function beginGeometry (geometry, feature) {
    this.beginGeometryInstruction1_ = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].BEGIN_GEOMETRY, feature, 0];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].BEGIN_GEOMETRY, feature, 0];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasReplay.prototype.fill_ = function fill_ (context) {
    if (this.alignFill_) {
      var origin = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["apply"])(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }
    context.fill();
    if (this.alignFill_) {
      context.setTransform.apply(context, _canvas_js__WEBPACK_IMPORTED_MODULE_14__["resetTransform"]);
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array.<*>} instruction Instruction.
   */
  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_ (context, instruction) {
    context.strokeStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);
    context.lineWidth = /** @type {number} */ (instruction[2]);
    context.lineCap = /** @type {string} */ (instruction[3]);
    context.lineJoin = /** @type {string} */ (instruction[4]);
    context.miterLimit = /** @type {number} */ (instruction[5]);
    if (_has_js__WEBPACK_IMPORTED_MODULE_11__["CANVAS_LINE_DASH"]) {
      context.lineDashOffset = /** @type {number} */ (instruction[7]);
      context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));
    }
  };

  /**
   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   */
  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_ (declutterGroup, feature) {
    var this$1 = this;

    if (declutterGroup && declutterGroup.length > 5) {
      var groupCount = declutterGroup[4];
      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
        /** @type {module:ol/structs/RBush~Entry} */
        var box = {
          minX: /** @type {number} */ (declutterGroup[0]),
          minY: /** @type {number} */ (declutterGroup[1]),
          maxX: /** @type {number} */ (declutterGroup[2]),
          maxY: /** @type {number} */ (declutterGroup[3]),
          value: feature
        };
        if (!this.declutterTree.collides(box)) {
          this.declutterTree.insert(box);
          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
            var declutterData = /** @type {Array} */ (declutterGroup[j]);
            if (declutterData) {
              if (declutterData.length > 11) {
                this$1.replayTextBackground_(declutterData[0],
                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],
                  declutterData[11], declutterData[12]);
              }
              _canvas_js__WEBPACK_IMPORTED_MODULE_14__["drawImage"].apply(undefined, declutterData);
            }
          }
        }
        declutterGroup.length = 5;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdateEmpty"])(declutterGroup);
      }
    }
  };

  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/transform~Transform} transform Transform.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {Array.<*>} instructions Instructions array.
   * @param {function((module:ol/Feature|module:ol/render/Feature)): T|undefined}
   *     featureCallback Feature callback.
   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replay_ = function replay_ (
    context,
    transform,
    skippedFeaturesHash,
    instructions,
    featureCallback,
    opt_hitExtent
  ) {
    var this$1 = this;

    /** @type {Array.<number>} */
    var pixelCoordinates;
    if (this.pixelCoordinates_ && Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_10__["transform2D"])(
        this.coordinates, 0, this.coordinates.length, 2,
        transform, this.pixelCoordinates_);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["setFromArray"])(this.renderedTransform_, transform);
    }
    var skipFeatures = !Object(_obj_js__WEBPACK_IMPORTED_MODULE_12__["isEmpty"])(skippedFeaturesHash);
    var i = 0; // instruction index
    var ii = instructions.length; // end of instructions
    var d = 0; // data index
    var dd; // end of per-instruction data
    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;

    var state = /** @type {module:ol/render~State} */ ({
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    });

    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var /** @type {module:ol/Feature|module:ol/render/Feature} */ feature;
    var x, y;
    while (i < ii) {
      var instruction = instructions[i];
      var type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);
      switch (type) {
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].BEGIN_GEOMETRY:
          feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);
          if ((skipFeatures &&
              skippedFeaturesHash[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString()]) ||
              !feature.getGeometry()) {
            i = /** @type {number} */ (instruction[2]);
          } else if (opt_hitExtent !== undefined && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["intersects"])(
            opt_hitExtent, feature.getGeometry().getExtent())) {
            i = /** @type {number} */ (instruction[2]) + 1;
          } else {
            ++i;
          }
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].BEGIN_PATH:
          if (pendingFill > batchSize) {
            this$1.fill_(context);
            pendingFill = 0;
          }
          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }
          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = prevY = NaN;
          }
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CIRCLE:
          d = /** @type {number} */ (instruction[1]);
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].CUSTOM:
          d = /** @type {number} */ (instruction[1]);
          dd = instruction[2];
          var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (instruction[3]);
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;
          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }
          var coords = coordinateCache[i];
          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }
          renderer(coords, state);
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].DRAW_IMAGE:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              (instruction[3]);
          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          anchorX = /** @type {number} */ (instruction[4]);
          anchorY = /** @type {number} */ (instruction[5]);
          declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[6]);
          var height = /** @type {number} */ (instruction[7]);
          var opacity = /** @type {number} */ (instruction[8]);
          var originX = /** @type {number} */ (instruction[9]);
          var originY = /** @type {number} */ (instruction[10]);
          var rotateWithView = /** @type {boolean} */ (instruction[11]);
          var rotation = /** @type {number} */ (instruction[12]);
          var scale = /** @type {number} */ (instruction[13]);
          var snapToPixel = /** @type {boolean} */ (instruction[14]);
          var width = /** @type {number} */ (instruction[15]);

          var padding = (void 0), backgroundFill = (void 0), backgroundStroke = (void 0);
          if (instruction.length > 16) {
            padding = /** @type {Array.<number>} */ (instruction[16]);
            backgroundFill = /** @type {boolean} */ (instruction[17]);
            backgroundStroke = /** @type {boolean} */ (instruction[18]);
          } else {
            padding = _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultPadding"];
            backgroundFill = backgroundStroke = false;
          }

          if (rotateWithView) {
            rotation += viewRotation;
          }
          for (; d < dd; d += 2) {
            this$1.replayImage_(context,
              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,
              declutterGroup, height, opacity, originX, originY, rotation, scale,
              snapToPixel, width, padding,
              backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,
              backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);
          }
          this$1.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].DRAW_CHARS:
          var begin = /** @type {number} */ (instruction[1]);
          var end = /** @type {number} */ (instruction[2]);
          var baseline = /** @type {number} */ (instruction[3]);
          declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[4]);
          var overflow = /** @type {number} */ (instruction[5]);
          var fillKey = /** @type {string} */ (instruction[6]);
          var maxAngle = /** @type {number} */ (instruction[7]);
          var measure = /** @type {function(string):number} */ (instruction[8]);
          var offsetY = /** @type {number} */ (instruction[9]);
          var strokeKey = /** @type {string} */ (instruction[10]);
          var strokeWidth = /** @type {number} */ (instruction[11]);
          var text = /** @type {string} */ (instruction[12]);
          var textKey = /** @type {string} */ (instruction[13]);
          var textScale = /** @type {number} */ (instruction[14]);

          var pathLength = Object(_geom_flat_length_js__WEBPACK_IMPORTED_MODULE_8__["lineStringLength"])(pixelCoordinates, begin, end, 2);
          var textLength = measure(text);
          if (overflow || textLength <= pathLength) {
            var textAlign = /** @type {module:ol~render} */ (this$1).textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _replay_js__WEBPACK_IMPORTED_MODULE_16__["TEXT_ALIGN"][textAlign];
            var parts = Object(_geom_flat_textpath_js__WEBPACK_IMPORTED_MODULE_9__["drawTextOnPath"])(
              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
            if (parts) {
              var c = (void 0), cc = (void 0), chars = (void 0), label = (void 0), part = (void 0);
              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, '', strokeKey);
                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                  this$1.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultPadding"], null, null);
                }
              }
              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk
                  chars = /** @type {string} */ (part[4]);
                  label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, fillKey, '');
                  anchorX = /** @type {number} */ (part[2]);
                  anchorY = baseline * label.height - offsetY;
                  this$1.replayImage_(context,
                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                    /** @type {number} */ (part[3]), textScale, false, label.width,
                    _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultPadding"], null, null);
                }
              }
            }
          }
          this$1.renderDeclutter_(declutterGroup, feature);
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].END_GEOMETRY:
          if (featureCallback !== undefined) {
            feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);
            var result = featureCallback(feature);
            if (result) {
              return result;
            }
          }
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this$1.fill_(context);
          }
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].MOVE_TO_LINE_TO:
          d = /** @type {number} */ (instruction[1]);
          dd = /** @type {number} */ (instruction[2]);
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = (x + 0.5) | 0;
          roundY = (y + 0.5) | 0;
          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = (x + 0.5) | 0;
            roundY = (y + 0.5) | 0;
            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this$1.alignFill_ = instruction[2];

          if (pendingFill) {
            this$1.fill_(context);
            pendingFill = 0;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
          this$1.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));
          ++i;
          break;
        case _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop
          break;
      }
    }
    if (pendingFill) {
      this.fill_(context);
    }
    if (pendingStroke) {
      context.stroke();
    }
    return undefined;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/transform~Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   */
  CanvasReplay.prototype.replay = function replay (context, transform, viewRotation, skippedFeaturesHash) {
    this.viewRotation_ = viewRotation;
    this.replay_(context, transform,
      skippedFeaturesHash, this.instructions, undefined, undefined);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/transform~Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *     to skip.
   * @param {function((module:ol/Feature|module:ol/render/Feature)): T=} opt_featureCallback
   *     Feature callback.
   * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this
   *     extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplay.prototype.replayHitDetection = function replayHitDetection (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    opt_featureCallback,
    opt_hitExtent
  ) {
    this.viewRotation_ = viewRotation;
    return this.replay_(context, transform, skippedFeaturesHash,
      this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
  };

  /**
   * Reverse the hit detection instructions.
   */
  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions () {
    var this$1 = this;

    var hitDetectionInstructions = this.hitDetectionInstructions;
    // step 1 - reverse array
    hitDetectionInstructions.reverse();
    // step 2 - reverse instructions within geometry blocks
    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;
    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);
      if (type == _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].END_GEOMETRY) {
        begin = i;
      } else if (type == _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].BEGIN_GEOMETRY) {
        instruction[2] = i;
        Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["reverseSubArray"])(this$1.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };

  /**
   * @inheritDoc
   */
  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
    var state = this.state;
    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_3__["asColorLike"])(fillStyleColor ?
        fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultFillStyle"]);
    } else {
      state.fillStyle = undefined;
    }
    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_3__["asColorLike"])(strokeStyleColor ?
        strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultStrokeStyle"]);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ?
        strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultLineCap"];
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ?
        strokeStyleLineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultLineDash"];
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ?
        strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultLineDashOffset"];
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ?
        strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultLineJoin"];
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ?
        strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultLineWidth"];
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ?
        strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_14__["defaultMiterLimit"];

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth;
        // invalidate the buffered max extent cache
        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };

  /**
   * @param {module:ol/render/canvas~FillStrokeState} state State.
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
   * @return {Array.<*>} Fill instruction.
   */
  CanvasReplay.prototype.createFill = function createFill (state, geometry) {
    var fillStyle = state.fillStyle;
    var fillInstruction = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }
    return fillInstruction;
  };

  /**
   * @param {module:ol/render/canvas~FillStrokeState} state State.
   */
  CanvasReplay.prototype.applyStroke = function applyStroke (state) {
    this.instructions.push(this.createStroke(state));
  };

  /**
   * @param {module:ol/render/canvas~FillStrokeState} state State.
   * @return {Array.<*>} Stroke instruction.
   */
  CanvasReplay.prototype.createStroke = function createStroke (state) {
    return [
      _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].SET_STROKE_STYLE,
      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,
      state.lineJoin, state.miterLimit,
      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio
    ];
  };

  /**
   * @param {module:ol/render/canvas~FillStrokeState} state State.
   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState, (module:ol/geom/Geometry|module:ol/render/Feature)):Array.<*>} createFill Create fill.
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
   */
  CanvasReplay.prototype.updateFillStyle = function updateFillStyle (state, createFill, geometry) {
    var fillStyle = state.fillStyle;
    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state, geometry));
      }
      state.currentFillStyle = fillStyle;
    }
  };

  /**
   * @param {module:ol/render/canvas~FillStrokeState} state State.
   * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState)} applyStroke Apply stroke.
   */
  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    if (state.currentStrokeStyle != strokeStyle ||
        state.currentLineCap != lineCap ||
        (lineDash != state.currentLineDash && !Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(state.currentLineDash, lineDash)) ||
        state.currentLineDashOffset != lineDashOffset ||
        state.currentLineJoin != lineJoin ||
        state.currentLineWidth != lineWidth ||
        state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };

  /**
   * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   */
  CanvasReplay.prototype.endGeometry = function endGeometry (geometry, feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_15__["default"].END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };

  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {module:ol/extent~Extent} The buffered rendering extent.
   * @protected
   */
  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["clone"])(this.maxExtent);
      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["buffer"])(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }
    return this.bufferedMaxExtent_;
  };

  return CanvasReplay;
}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_13__["default"]));


/**
 * FIXME empty description for jsdoc
 */
CanvasReplay.prototype.finish = _functions_js__WEBPACK_IMPORTED_MODULE_1__["UNDEFINED"];


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplay);

//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/ReplayGroup.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/render/canvas/ReplayGroup.js ***!
  \******************************************************/
/*! exports provided: getCircleArray, replayDeclutter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCircleArray", function() { return getCircleArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replayDeclutter", function() { return replayDeclutter; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ReplayGroup.js */ "./node_modules/ol/render/ReplayGroup.js");
/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas/Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _canvas_ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas/ImageReplay.js */ "./node_modules/ol/render/canvas/ImageReplay.js");
/* harmony import */ var _canvas_LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../canvas/LineStringReplay.js */ "./node_modules/ol/render/canvas/LineStringReplay.js");
/* harmony import */ var _canvas_PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../canvas/PolygonReplay.js */ "./node_modules/ol/render/canvas/PolygonReplay.js");
/* harmony import */ var _canvas_TextReplay_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../canvas/TextReplay.js */ "./node_modules/ol/render/canvas/TextReplay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/render/canvas/ReplayGroup
 */

















/**
 * @type {Object.<module:ol/render/ReplayType,
 *                function(new: module:ol/render/canvas/Replay, number, module:ol/extent~Extent,
 *                number, number, boolean, Array.<module:ol/render/canvas~DeclutterGroup>)>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _canvas_PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Default': _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_7__["default"],
  'Image': _canvas_ImageReplay_js__WEBPACK_IMPORTED_MODULE_8__["default"],
  'LineString': _canvas_LineStringReplay_js__WEBPACK_IMPORTED_MODULE_9__["default"],
  'Polygon': _canvas_PolygonReplay_js__WEBPACK_IMPORTED_MODULE_10__["default"],
  'Text': _canvas_TextReplay_js__WEBPACK_IMPORTED_MODULE_11__["default"]
};


var CanvasReplayGroup = (function (ReplayGroup) {
  function CanvasReplayGroup(
    tolerance,
    maxExtent,
    resolution,
    pixelRatio,
    overlaps,
    declutterTree,
    opt_renderBuffer
  ) {
    ReplayGroup.call(this);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = declutterTree;

    /**
     * @type {module:ol/render/canvas~DeclutterGroup}
     * @private
     */
    this.declutterGroup_ = null;

    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.maxExtent_ = maxExtent;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = overlaps;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {number|undefined}
     */
    this.renderBuffer_ = opt_renderBuffer;

    /**
     * @private
     * @type {!Object.<string, !Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>}
     */
    this.replaysByZIndex_ = {};

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitDetectionContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.hitDetectionTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["create"])();
  }

  if ( ReplayGroup ) CanvasReplayGroup.__proto__ = ReplayGroup;
  CanvasReplayGroup.prototype = Object.create( ReplayGroup && ReplayGroup.prototype );
  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;

  /**
   * @param {boolean} group Group with previous replay.
   * @return {module:ol/render/canvas~DeclutterGroup} Declutter instruction group.
   */
  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
    var declutter = null;
    if (this.declutterTree_) {
      if (group) {
        declutter = this.declutterGroup_;
        /** @type {number} */ (declutter[4])++;
      } else {
        declutter = this.declutterGroup_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
        declutter.push(1);
      }
    }
    return declutter;
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/transform~Transform} transform Transform.
   */
  CanvasReplayGroup.prototype.clip = function clip (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };

  /**
   * @param {Array.<module:ol/render/ReplayType>} replays Replays.
   * @return {boolean} Has replays of the provided types.
   */
  CanvasReplayGroup.prototype.hasReplays = function hasReplays (replays) {
    var this$1 = this;

    for (var zIndex in this$1.replaysByZIndex_) {
      var candidates = this$1.replaysByZIndex_[zIndex];
      for (var i = 0, ii = replays.length; i < ii; ++i) {
        if (replays[i] in candidates) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * FIXME empty description for jsdoc
   */
  CanvasReplayGroup.prototype.finish = function finish () {
    var this$1 = this;

    for (var zKey in this$1.replaysByZIndex_) {
      var replays = this$1.replaysByZIndex_[zKey];
      for (var replayKey in replays) {
        replays[replayKey].finish();
      }
    }
  };

  /**
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
   * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>} declutterReplays Declutter replays.
   * @return {T|undefined} Callback result.
   * @template T
   */
  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    resolution,
    rotation,
    hitTolerance,
    skippedFeaturesHash,
    callback,
    declutterReplays
  ) {
    var this$1 = this;


    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_13__["compose"])(this.hitDetectionTransform_,
      hitTolerance + 0.5, hitTolerance + 0.5,
      1 / resolution, -1 / resolution,
      -rotation,
      -coordinate[0], -coordinate[1]);
    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else {
      context.clearRect(0, 0, contextSize, contextSize);
    }

    /**
     * @type {module:ol/extent~Extent}
     */
    var hitExtent;
    if (this.renderBuffer_ !== undefined) {
      hitExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["extendCoordinate"])(hitExtent, coordinate);
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["buffer"])(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var mask = getCircleArray(hitTolerance);
    var declutteredFeatures;
    if (this.declutterTree_) {
      declutteredFeatures = this.declutterTree_.all().map(function(entry) {
        return entry.value;
      });
    }

    var replayType;

    /**
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     * @return {?} Callback result.
     */
    function featureCallback(feature) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
      for (var i = 0; i < contextSize; i++) {
        for (var j = 0; j < contextSize; j++) {
          if (mask[i][j]) {
            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
              var result = (void 0);
              if (!(declutteredFeatures && (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) ||
                  declutteredFeatures.indexOf(feature) !== -1) {
                result = callback(feature);
              }
              if (result) {
                return result;
              } else {
                context.clearRect(0, 0, contextSize, contextSize);
                return undefined;
              }
            }
          }
        }
      }
    }

    /** @type {Array.<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    var i, j, replays, replay, result;
    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      replays = this$1.replaysByZIndex_[zIndexKey];
      for (j = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"].length - 1; j >= 0; --j) {
        replayType = _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"][j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = declutterReplays[zIndexKey];
            if (!declutter) {
              declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            result = replay.replayHitDetection(context, transform, rotation,
              skippedFeaturesHash, featureCallback, hitExtent);
            if (result) {
              return result;
            }
          }
        }
      }
    }
    return undefined;
  };

  /**
   * @param {module:ol/transform~Transform} transform Transform.
   * @return {Array.<number>} Clip coordinates.
   */
  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords (transform) {
    var maxExtent = this.maxExtent_;
    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__["transform2D"])(
      flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.replaysByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.replaysByZIndex_[zIndexKey] = replays;
    }
    var replay = replays[replayType];
    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[replayType];
      replay = new Constructor(this.tolerance_, this.maxExtent_,
        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
      replays[replayType] = replay;
    }
    return replay;
  };

  /**
   * @return {Object.<string, Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>} Replays.
   */
  CanvasReplayGroup.prototype.getReplays = function getReplays () {
    return this.replaysByZIndex_;
  };

  /**
   * @inheritDoc
   */
  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1 () {
    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["isEmpty"])(this.replaysByZIndex_);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/transform~Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.
   * @param {Array.<module:ol/render/ReplayType>=} opt_replayTypes Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>=} opt_declutterReplays Declutter replays.
   */
  CanvasReplayGroup.prototype.replay = function replay (
    context,
    transform,
    viewRotation,
    skippedFeaturesHash,
    opt_replayTypes,
    opt_declutterReplays
  ) {
    var this$1 = this;


    /** @type {Array.<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);

    // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning
    context.save();
    this.clip(context, transform);

    var replayTypes = opt_replayTypes ? opt_replayTypes : _replay_js__WEBPACK_IMPORTED_MODULE_12__["ORDER"];
    var i, ii, j, jj, replays, replay;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this$1.replaysByZIndex_[zIndexKey];
      for (j = 0, jj = replayTypes.length; j < jj; ++j) {
        var replayType = replayTypes[j];
        replay = replays[replayType];
        if (replay !== undefined) {
          if (opt_declutterReplays &&
              (replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE || replayType == _ReplayType_js__WEBPACK_IMPORTED_MODULE_6__["default"].TEXT)) {
            var declutter = opt_declutterReplays[zIndexKey];
            if (!declutter) {
              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
            } else {
              declutter.push(replay, transform.slice(0));
            }
          } else {
            replay.replay(context, transform, viewRotation, skippedFeaturesHash);
          }
        }
      }
    }

    context.restore();
  };

  return CanvasReplayGroup;
}(_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 */
var circleArrayCache = {
  0: [[true]]
};


/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 */
function fillCircleArrayRowToMiddle(array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
}


/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 */
function getCircleArray(radius) {
  if (circleArrayCache[radius] !== undefined) {
    return circleArrayCache[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  circleArrayCache[radius] = arr;
  return arr;
}


/**
 * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */
function replayDeclutter(declutterReplays, context, rotation) {
  var zs = Object.keys(declutterReplays).map(Number).sort(_array_js__WEBPACK_IMPORTED_MODULE_0__["numberSafeCompareFunction"]);
  var skippedFeatureUids = {};
  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];
    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids);
    }
  }
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasReplayGroup);

//# sourceMappingURL=ReplayGroup.js.map

/***/ }),

/***/ "./node_modules/ol/render/canvas/TextReplay.js":
/*!*****************************************************!*\
  !*** ./node_modules/ol/render/canvas/TextReplay.js ***!
  \*****************************************************/
/*! exports provided: measureTextWidths, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "measureTextWidths", function() { return measureTextWidths; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geom/flat/straightchunk.js */ "./node_modules/ol/geom/flat/straightchunk.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../canvas/Instruction.js */ "./node_modules/ol/render/canvas/Instruction.js");
/* harmony import */ var _canvas_Replay_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../canvas/Replay.js */ "./node_modules/ol/render/canvas/Replay.js");
/* harmony import */ var _replay_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../style/TextPlacement.js */ "./node_modules/ol/style/TextPlacement.js");
/**
 * @module ol/render/canvas/TextReplay
 */













var CanvasTextReplay = (function (CanvasReplay) {
  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

    /**
     * @private
     * @type {module:ol/render/canvas~DeclutterGroup}
     */
    this.declutterGroup_;

    /**
     * @private
     * @type {Array.<HTMLCanvasElement>}
     */
    this.labels_ = null;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.textRotateWithView_ = undefined;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {?module:ol/render/canvas~FillState}
     */
    this.textFillState_ = null;

    /**
     * @type {!Object.<string, module:ol/render/canvas~FillState>}
     */
    this.fillStates = {};

    /**
     * @private
     * @type {?module:ol/render/canvas~StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @type {!Object.<string, module:ol/render/canvas~StrokeState>}
     */
    this.strokeStates = {};

    /**
     * @private
     * @type {module:ol/render/canvas~TextState}
     */
    this.textState_ = /** @type {module:ol/render/canvas~TextState} */ ({});

    /**
     * @type {!Object.<string, module:ol/render/canvas~TextState>}
     */
    this.textStates = {};

    /**
     * @private
     * @type {string}
     */
    this.textKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.fillKey_ = '';

    /**
     * @private
     * @type {string}
     */
    this.strokeKey_ = '';

    /**
     * @private
     * @type {Object.<string, Object.<string, number>>}
     */
    this.widths_ = {};

    _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].prune();

  }

  if ( CanvasReplay ) CanvasTextReplay.__proto__ = CanvasReplay;
  CanvasTextReplay.prototype = Object.create( CanvasReplay && CanvasReplay.prototype );
  CanvasTextReplay.prototype.constructor = CanvasTextReplay;

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.drawText = function drawText (geometry, feature) {
    var this$1 = this;

    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
      return;
    }

    var begin = this.coordinates.length;

    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var end = 2;
    var stride = 2;
    var i, ii;

    if (textState.placement === _style_TextPlacement_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE) {
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_3__["intersects"])(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }
      var ends;
      flatCoordinates = geometry.getFlatCoordinates();
      stride = geometry.getStride();
      if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON) {
        ends = geometry.getEnds().slice(0, 1);
      } else if (geometryType == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON) {
        var endss = geometry.getEndss();
        ends = [];
        for (i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }
      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd;
      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = Object(_geom_flat_straightchunk_js__WEBPACK_IMPORTED_MODULE_4__["matchingChunk"])(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }
        for (i = flatOffset; i < flatEnd; i += stride) {
          this$1.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }
        end = this$1.coordinates.length;
        flatOffset = ends[o];
        this$1.drawChars_(begin, end, this$1.declutterGroup_);
        begin = end;
      }
      this.endGeometry(geometry, feature);

    } else {
      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
      var width = label.width / this.pixelRatio;
      switch (geometryType) {
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POINT:
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POINT:
          flatCoordinates = geometry.getFlatCoordinates();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].LINE_STRING:
          flatCoordinates = /** @type {module:ol/geom/LineString} */ (geometry).getFlatMidpoint();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CIRCLE:
          flatCoordinates = /** @type {module:ol/geom/Circle} */ (geometry).getCenter();
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_LINE_STRING:
          flatCoordinates = /** @type {module:ol/geom/MultiLineString} */ (geometry).getFlatMidpoints();
          end = flatCoordinates.length;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].POLYGON:
          flatCoordinates = /** @type {module:ol/geom/Polygon} */ (geometry).getFlatInteriorPoint();
          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
            return;
          }
          stride = 3;
          break;
        case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_5__["default"].MULTI_POLYGON:
          var interiorPoints = /** @type {module:ol/geom/MultiPolygon} */ (geometry).getFlatInteriorPoints();
          flatCoordinates = [];
          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (textState.overflow || interiorPoints[i + 2] / this$1.resolution >= width) {
              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
            }
          }
          end = flatCoordinates.length;
          if (end == 0) {
            return;
          }
          break;
        default:
      }
      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill, geometry);
          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));
        }
        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }
      this.beginGeometry(geometry, feature);
      this.drawTextImage_(label, begin, end);
      this.endGeometry(geometry, feature);
    }
  };

  /**
   * @param {string} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {HTMLCanvasElement} Image.
   */
  CanvasTextReplay.prototype.getImage = function getImage (text, textKey, fillKey, strokeKey) {
    var label;
    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;

    if (!_canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].containsKey(key)) {
      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
      var textState = this.textStates[textKey] || this.textState_;
      var pixelRatio = this.pixelRatio;
      var scale = textState.scale * pixelRatio;
      var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

      var lines = text.split('\n');
      var numLines = lines.length;
      var widths = [];
      var width = measureTextWidths(textState.font, lines, widths);
      var lineHeight = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextHeight"])(textState.font);
      var height = lineHeight * numLines;
      var renderWidth = (width + strokeWidth);
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_2__["createCanvasContext2D"])(
        Math.ceil(renderWidth * scale),
        Math.ceil((height + strokeWidth) * scale));
      label = context.canvas;
      _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].set(key, label);
      if (scale != 1) {
        context.scale(scale, scale);
      }
      context.font = textState.font;
      if (strokeKey) {
        context.strokeStyle = strokeState.strokeStyle;
        context.lineWidth = strokeWidth;
        context.lineCap = strokeState.lineCap;
        context.lineJoin = strokeState.lineJoin;
        context.miterLimit = strokeState.miterLimit;
        if (_has_js__WEBPACK_IMPORTED_MODULE_6__["CANVAS_LINE_DASH"] && strokeState.lineDash.length) {
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }
      if (fillKey) {
        context.fillStyle = fillState.fillStyle;
      }
      context.textBaseline = 'middle';
      context.textAlign = 'center';
      var leftRight = (0.5 - align);
      var x = align * label.width / scale + leftRight * strokeWidth;
      var i;
      if (strokeKey) {
        for (i = 0; i < numLines; ++i) {
          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
      if (fillKey) {
        for (i = 0; i < numLines; ++i) {
          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
        }
      }
    }
    return _canvas_js__WEBPACK_IMPORTED_MODULE_7__["labelCache"].get(key);
  };

  /**
   * @private
   * @param {HTMLCanvasElement} label Label.
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_ (label, begin, end) {
    var textState = this.textState_;
    var strokeState = this.textStrokeState_;
    var pixelRatio = this.pixelRatio;
    var align = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"]];
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1, true, label.width,
      textState.padding == _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] ?
        _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"] : textState.padding.map(function(p) {
          return p * pixelRatio;
        }),
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
    this.hitDetectionInstructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_IMAGE, begin, end,
      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
      1 / pixelRatio, true, label.width, textState.padding,
      !!textState.backgroundFill, !!textState.backgroundStroke
    ]);
  };

  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
   */
  CanvasTextReplay.prototype.drawChars_ = function drawChars_ (begin, end, declutterGroup) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;

    var strokeKey = this.strokeKey_;
    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = /** @type {module:ol/render/canvas~StrokeState} */ ({
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        });
      }
    }
    var textKey = this.textKey_;
    if (!(this.textKey_ in this.textStates)) {
      this.textStates[this.textKey_] = /** @type {module:ol/render/canvas~TextState} */ ({
        font: textState.font,
        textAlign: textState.textAlign || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextAlign"],
        scale: textState.scale
      });
    }
    var fillKey = this.fillKey_;
    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = /** @type {module:ol/render/canvas~FillState} */ ({
          fillStyle: fillState.fillStyle
        });
      }
    }

    var pixelRatio = this.pixelRatio;
    var baseline = _replay_js__WEBPACK_IMPORTED_MODULE_10__["TEXT_ALIGN"][textState.textBaseline];

    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var font = textState.font;
    var textScale = textState.scale;
    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
    var widths = this.widths_[font];
    if (!widths) {
      this.widths_[font] = widths = {};
    }
    this.instructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale * pixelRatio;
      },
      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1
    ]);
    this.hitDetectionInstructions.push([_canvas_Instruction_js__WEBPACK_IMPORTED_MODULE_8__["default"].DRAW_CHARS,
      begin, end, baseline, declutterGroup,
      textState.overflow, fillKey, textState.maxAngle,
      function(text) {
        var width = widths[text];
        if (!width) {
          width = widths[text] = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, text);
        }
        return width * textScale;
      },
      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio
    ]);
  };

  /**
   * @inheritDoc
   */
  CanvasTextReplay.prototype.setTextStyle = function setTextStyle (textStyle, declutterGroup) {
    var textState, fillState, strokeState;
    if (!textStyle) {
      this.text_ = '';
    } else {
      this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);

      var textFillStyle = textStyle.getFill();
      if (!textFillStyle) {
        fillState = this.textFillState_ = null;
      } else {
        fillState = this.textFillState_;
        if (!fillState) {
          fillState = this.textFillState_ = /** @type {module:ol/render/canvas~FillState} */ ({});
        }
        fillState.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textFillStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFillStyle"]);
      }

      var textStrokeStyle = textStyle.getStroke();
      if (!textStrokeStyle) {
        strokeState = this.textStrokeState_ = null;
      } else {
        strokeState = this.textStrokeState_;
        if (!strokeState) {
          strokeState = this.textStrokeState_ = /** @type {module:ol/render/canvas~StrokeState} */ ({});
        }
        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineCap"];
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDash"];
        strokeState.lineDashOffset =
            lineDashOffset === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineDashOffset"] : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineJoin"];
        strokeState.lineWidth =
            lineWidth === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultLineWidth"] : lineWidth;
        strokeState.miterLimit =
            miterLimit === undefined ? _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultMiterLimit"] : miterLimit;
        strokeState.strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__["asColorLike"])(
          textStrokeStyle.getColor() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultStrokeStyle"]);
      }

      textState = this.textState_;
      var font = textStyle.getFont() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultFont"];
      Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["checkFont"])(font);
      var textScale = textStyle.getScale();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultTextBaseline"];
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas_js__WEBPACK_IMPORTED_MODULE_7__["defaultPadding"];
      textState.scale = textScale === undefined ? 1 : textScale;

      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;

      this.strokeKey_ = strokeState ?
        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(strokeState.strokeStyle)) +
        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +
        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :
        '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
      this.fillKey_ = fillState ?
        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(fillState.fillStyle))) :
        '';
    }
  };

  return CanvasTextReplay;
}(_canvas_Replay_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {string} font Font to use for measuring.
 * @param {Array.<string>} lines Lines to measure.
 * @param {Array.<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */
function measureTextWidths(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  for (var i = 0; i < numLines; ++i) {
    var currentWidth = Object(_canvas_js__WEBPACK_IMPORTED_MODULE_7__["measureTextWidth"])(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }
  return width;
}


/* harmony default export */ __webpack_exports__["default"] = (CanvasTextReplay);

//# sourceMappingURL=TextReplay.js.map

/***/ }),

/***/ "./node_modules/ol/render/replay.js":
/*!******************************************!*\
  !*** ./node_modules/ol/render/replay.js ***!
  \******************************************/
/*! exports provided: ORDER, TEXT_ALIGN */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORDER", function() { return ORDER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_ALIGN", function() { return TEXT_ALIGN; });
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/render/replay
 */



/**
 * @const
 * @type {Array.<module:ol/render/ReplayType>}
 */
var ORDER = [
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].POLYGON,
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].CIRCLE,
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].LINE_STRING,
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].IMAGE,
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].TEXT,
  _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__["default"].DEFAULT
];

/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {};
TEXT_ALIGN['left'] = 0;
TEXT_ALIGN['end'] = 0;
TEXT_ALIGN['center'] = 0.5;
TEXT_ALIGN['right'] = 1;
TEXT_ALIGN['start'] = 1;
TEXT_ALIGN['top'] = 0;
TEXT_ALIGN['middle'] = 0.5;
TEXT_ALIGN['hanging'] = 0.2;
TEXT_ALIGN['alphabetic'] = 0.8;
TEXT_ALIGN['ideographic'] = 0.8;
TEXT_ALIGN['bottom'] = 1;

//# sourceMappingURL=replay.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/renderer/Layer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/Layer
 */









var LayerRenderer = (function (Observable) {
  function LayerRenderer(layer) {

    Observable.call(this);

    /**
     * @private
     * @type {module:ol/layer/Layer}
     */
    this.layer_ = layer;

  }

  if ( Observable ) LayerRenderer.__proto__ = Observable;
  LayerRenderer.prototype = Object.create( Observable && Observable.prototype );
  LayerRenderer.prototype.constructor = LayerRenderer;

  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {module:ol/source/Tile} source Tile source.
   * @param {module:ol/proj/Projection} projection Projection of the tiles.
   * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, module:ol/TileRange):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {module:ol/TileRange} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      function(zoom, tileRange) {
        function callback(tile) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
        }
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  };

  /**
   * @return {module:ol/layer/Layer} Layer.
   */
  LayerRenderer.prototype.getLayer = function getLayer () {
    return this.layer_;
  };

  /**
   * Handle changes in image state.
   * @param {module:ol/events/Event} event Image change event.
   * @private
   */
  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {
    var image = /** @type {module:ol/Image} */ (event.target);
    if (image.getState() === _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      this.renderIfReadyAndVisible();
    }
  };

  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {module:ol/ImageBase} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  LayerRenderer.prototype.loadImage = function loadImage (image) {
    var imageState = image.getState();
    if (imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED && imageState != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(image, _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CHANGE, this.handleImageChange_, this);
    }
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED;
  };

  /**
   * @protected
   */
  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {
    var layer = this.getLayer();
    if (layer.getVisible() && layer.getSourceState() == _source_State_js__WEBPACK_IMPORTED_MODULE_7__["default"].READY) {
      this.changed();
    }
  };

  /**
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/source/Tile} tileSource Tile source.
   * @protected
   */
  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {module:ol/source/Tile} tileSource Tile source.
       * @param {module:ol/PluggableMap} map Map.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       */
      var postRenderFunction = function(tileSource, map, frameState) {
        var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource).toString();
        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection,
            frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
        /** @type {module:ol/PluggableMap~PostRenderFunction} */ (postRenderFunction)
      );
    }
  };

  /**
   * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.
   * @param {module:ol/source/Tile} tileSource Tile source.
   * @param {number} z Z.
   * @param {module:ol/TileRange} tileRange Tile range.
   * @protected
   */
  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource).toString();
    var zKey = z.toString();
    if (tileSourceKey in usedTiles) {
      if (zKey in usedTiles[tileSourceKey]) {
        usedTiles[tileSourceKey][zKey].extend(tileRange);
      } else {
        usedTiles[tileSourceKey][zKey] = tileRange;
      }
    } else {
      usedTiles[tileSourceKey] = {};
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  };

  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/source/Tile} tileSource Tile source.
   * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @param {module:ol/extent~Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.
   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
   * @protected
   * @template T
   */
  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (
    frameState,
    tileSource,
    tileGrid,
    pixelRatio,
    projection,
    extent,
    currentZ,
    preload,
    opt_tileCallback,
    opt_this
  ) {
    var tileSourceKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tileSource).toString();
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }
            if (opt_tileCallback !== undefined) {
              opt_tileCallback.call(opt_this, tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
  };

  return LayerRenderer;
}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */
LayerRenderer.prototype.forEachFeatureAtCoordinate = _functions_js__WEBPACK_IMPORTED_MODULE_6__["UNDEFINED"];


/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */
LayerRenderer.prototype.hasFeatureAtCoordinate = _functions_js__WEBPACK_IMPORTED_MODULE_6__["FALSE"];


/* harmony default export */ __webpack_exports__["default"] = (LayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/Map.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/renderer/Map.js ***!
  \*****************************************/
/*! exports provided: sortByZIndex, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortByZIndex", function() { return sortByZIndex; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../style/IconImageCache.js */ "./node_modules/ol/style/IconImageCache.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/Map
 */











var MapRenderer = (function (Disposable) {
  function MapRenderer(map) {
    Disposable.call(this);

    /**
     * @private
     * @type {module:ol/PluggableMap}
     */
    this.map_ = map;

    /**
     * @private
     * @type {!Object.<string, module:ol/renderer/Layer>}
     */
    this.layerRenderers_ = {};

    /**
     * @private
     * @type {Object.<string, module:ol/events~EventsKey>}
     */
    this.layerRendererListeners_ = {};

    /**
     * @private
     * @type {Array.<module:ol/renderer/Layer>}
     */
    this.layerRendererConstructors_ = [];

  }

  if ( Disposable ) MapRenderer.__proto__ = Disposable;
  MapRenderer.prototype = Object.create( Disposable && Disposable.prototype );
  MapRenderer.prototype.constructor = MapRenderer;

  /**
   * Register layer renderer constructors.
   * @param {Array.<module:ol/renderer/Layer>} constructors Layer renderers.
   */
  MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);
  };

  /**
   * Get the registered layer renderer constructors.
   * @return {Array.<module:ol/renderer/Layer>} Registered layer renderers.
   */
  MapRenderer.prototype.getLayerRendererConstructors = function getLayerRendererConstructors () {
    return this.layerRendererConstructors_;
  };

  /**
   * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
   * @protected
   */
  MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(coordinateToPixelTransform,
      frameState.size[0] / 2, frameState.size[1] / 2,
      1 / viewState.resolution, -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0], -viewState.center[1]);

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["invert"])(
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["setFromArray"])(pixelToCoordinateTransform, coordinateToPixelTransform));
  };

  /**
   * Removes all layer renderers.
   */
  MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers () {
    var this$1 = this;

    for (var key in this$1.layerRenderers_) {
      this$1.removeLayerRendererByKey_(key).dispose();
    }
  };

  /**
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),
   *     module:ol/layer/Layer): T} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
    coordinate,
    frameState,
    hitTolerance,
    callback,
    thisArg,
    layerFilter,
    thisArg2
  ) {
    var this$1 = this;

    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    /**
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     * @param {module:ol/layer/Layer} layer Layer.
     * @return {?} Callback result.
     */
    function forEachFeatureAtCoordinate(feature, layer) {
      var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
      var managed = frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer)].managed;
      if (!(key in frameState.skippedFeatureUids && !managed)) {
        return callback.call(thisArg, feature, managed ? layer : null);
      }
    }

    var projection = viewState.projection;

    var translatedCoordinate = coordinate;
    if (projection.canWrapX()) {
      var projectionExtent = projection.getExtent();
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getWidth"])(projectionExtent);
      var x = coordinate[0];
      if (x < projectionExtent[0] || x > projectionExtent[2]) {
        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
      }
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_6__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = this$1.getLayerRenderer(layer);
        if (layer.getSource()) {
          result = layerRenderer.forEachFeatureAtCoordinate(
            layer.getSource().getWrapX() ? translatedCoordinate : coordinate,
            frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
        }
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @abstract
   * @param {module:ol/pixel~Pixel} pixel Pixel.
   * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {};

  /**
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(
      coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_5__["TRUE"], this, layerFilter, thisArg);

    return hasFeature !== undefined;
  };

  /**
   * @param {module:ol/layer/Layer} layer Layer.
   * @protected
   * @return {module:ol/renderer/Layer} Layer renderer.
   */
  MapRenderer.prototype.getLayerRenderer = function getLayerRenderer (layer) {
    var this$1 = this;

    var layerKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(layer).toString();
    if (layerKey in this.layerRenderers_) {
      return this.layerRenderers_[layerKey];
    } else {
      var renderer;
      for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {
        var candidate = this$1.layerRendererConstructors_[i];
        if (candidate['handles'](layer)) {
          renderer = candidate['create'](this$1, layer);
          break;
        }
      }
      if (renderer) {
        this.layerRenderers_[layerKey] = renderer;
        this.layerRendererListeners_[layerKey] = Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["listen"])(renderer,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CHANGE, this.handleLayerRendererChange_, this);
      } else {
        throw new Error('Unable to create renderer for layer: ' + layer.getType());
      }
      return renderer;
    }
  };

  /**
   * @param {string} layerKey Layer key.
   * @protected
   * @return {module:ol/renderer/Layer} Layer renderer.
   */
  MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey (layerKey) {
    return this.layerRenderers_[layerKey];
  };

  /**
   * @protected
   * @return {Object.<string, module:ol/renderer/Layer>} Layer renderers.
   */
  MapRenderer.prototype.getLayerRenderers = function getLayerRenderers () {
    return this.layerRenderers_;
  };

  /**
   * @return {module:ol/PluggableMap} Map.
   */
  MapRenderer.prototype.getMap = function getMap () {
    return this.map_;
  };

  /**
   * Handle changes in a layer renderer.
   * @private
   */
  MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_ () {
    this.map_.render();
  };

  /**
   * @param {string} layerKey Layer key.
   * @return {module:ol/renderer/Layer} Layer renderer.
   * @private
   */
  MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_ (layerKey) {
    var layerRenderer = this.layerRenderers_[layerKey];
    delete this.layerRenderers_[layerKey];

    Object(_events_js__WEBPACK_IMPORTED_MODULE_2__["unlistenByKey"])(this.layerRendererListeners_[layerKey]);
    delete this.layerRendererListeners_[layerKey];

    return layerRenderer;
  };

  /**
   * @param {module:ol/PluggableMap} map Map.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @private
   */
  MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_ (map, frameState) {
    var this$1 = this;

    for (var layerKey in this$1.layerRenderers_) {
      if (!frameState || !(layerKey in frameState.layerStates)) {
        this$1.removeLayerRendererByKey_(layerKey).dispose();
      }
    }
  };

  /**
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache (frameState) {
    frameState.postRenderFunctions.push(/** @type {module:ol/PluggableMap~PostRenderFunction} */ (expireIconCache));
  };

  /**
   * @param {!module:ol/PluggableMap~FrameState} frameState Frame state.
   * @protected
   */
  MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers (frameState) {
    var this$1 = this;

    for (var layerKey in this$1.layerRenderers_) {
      if (!(layerKey in frameState.layerStates)) {
        frameState.postRenderFunctions.push(
          /** @type {module:ol/PluggableMap~PostRenderFunction} */ (this$1.removeUnusedLayerRenderers_.bind(this$1))
        );
        return;
      }
    }
  };

  return MapRenderer;
}(_Disposable_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/**
 * @param {module:ol/PluggableMap} map Map.
 * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
 */
function expireIconCache(map, frameState) {
  _style_IconImageCache_js__WEBPACK_IMPORTED_MODULE_7__["shared"].expire();
}


/**
 * Render.
 * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.
 */
MapRenderer.prototype.renderFrame = _functions_js__WEBPACK_IMPORTED_MODULE_5__["UNDEFINED"];


/**
 * @param {module:ol/layer/Layer~State} state1 First layer state.
 * @param {module:ol/layer/Layer~State} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
function sortByZIndex(state1, state2) {
  return state1.zIndex - state2.zIndex;
}
/* harmony default export */ __webpack_exports__["default"] = (MapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/ImageLayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/ImageLayer.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../layer/VectorRenderType.js */ "./node_modules/ol/layer/VectorRenderType.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Map.js */ "./node_modules/ol/renderer/canvas/Map.js");
/* harmony import */ var _IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/ImageLayer
 */












/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer = (function (IntermediateCanvasRenderer) {
  function CanvasImageLayerRenderer(imageLayer) {
    var this$1 = this;


    IntermediateCanvasRenderer.call(this, imageLayer);

    /**
     * @private
     * @type {?module:ol/ImageBase}
     */
    this.image_ = null;

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["create"])();

    /**
     * @type {!Array.<string>}
     */
    this.skippedFeatures_ = [];

    /**
     * @private
     * @type {module:ol/renderer/canvas/VectorLayer}
     */
    this.vectorRenderer_ = null;

    if (imageLayer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR) {
      for (var i = 0, ii = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"].length; i < ii; ++i) {
        var ctor = _Map_js__WEBPACK_IMPORTED_MODULE_8__["layerRendererConstructors"][i];
        if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {
          this$1.vectorRenderer_ = new ctor(imageLayer);
          break;
        }
      }
    }

  }

  if ( IntermediateCanvasRenderer ) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasImageLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    if (this.vectorRenderer_) {
      this.vectorRenderer_.dispose();
    }
    IntermediateCanvasRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImage = function getImage () {
    return !this.image_ ? null : this.image_.getImage();
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;

    var image;
    var imageLayer = /** @type {module:ol/layer/Image} */ (this.getLayer());
    var imageSource = imageLayer.getSource();

    var hints = frameState.viewHints;

    var vectorRenderer = this.vectorRenderer_;
    var renderedExtent = frameState.extent;
    if (!vectorRenderer && layerState.extent !== undefined) {
      renderedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(renderedExtent, layerState.extent);
    }

    if (!hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].ANIMATING] && !hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_3__["default"].INTERACTING] &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["isEmpty"])(renderedExtent)) {
      var projection = viewState.projection;
      if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
        var sourceProjection = imageSource.getProjection();
        if (sourceProjection) {
          projection = sourceProjection;
        }
      }
      var skippedFeatures = this.skippedFeatures_;
      if (vectorRenderer) {
        var context = vectorRenderer.context;
        var imageFrameState = /** @type {module:ol/PluggableMap~FrameState} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState, {
          size: [
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(renderedExtent) / viewResolution,
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(renderedExtent) / viewResolution
          ],
          viewState: /** @type {module:ol/View~State} */ (Object(_obj_js__WEBPACK_IMPORTED_MODULE_7__["assign"])({}, frameState.viewState, {
            rotation: 0
          }))
        }));
        var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
        image = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_1__["default"](renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {
          if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&
              (vectorRenderer.replayGroupChanged ||
              !Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["equals"])(skippedFeatures, newSkippedFeatures))) {
            context.canvas.width = imageFrameState.size[0] * pixelRatio;
            context.canvas.height = imageFrameState.size[1] * pixelRatio;
            vectorRenderer.compose(context, imageFrameState, layerState);
            skippedFeatures = newSkippedFeatures;
            callback();
          }
        });
      } else {
        image = imageSource.getImage(
          renderedExtent, viewResolution, pixelRatio, projection);
      }
      if (image && this.loadImage(image)) {
        this.image_ = image;
        this.skippedFeatures_ = skippedFeatures;
      }
    }

    if (this.image_) {
      image = this.image_;
      var imageExtent = image.getExtent();
      var imageResolution = image.getResolution();
      var imagePixelRatio = image.getPixelRatio();
      var scale = pixelRatio * imageResolution /
          (viewResolution * imagePixelRatio);
      var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.imageTransform_,
        pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
        scale, scale,
        0,
        imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,
        imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
      Object(_transform_js__WEBPACK_IMPORTED_MODULE_10__["compose"])(this.coordinateToCanvasPixelTransform,
        pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
        pixelRatio / viewResolution, -pixelRatio / viewResolution,
        0,
        -viewCenter[0], -viewCenter[1]);

      this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    }

    return !!this.image_;
  };

  /**
   * @inheritDoc
   */
  CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (this.vectorRenderer_) {
      return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
    } else {
      return IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
    }
  };

  return CanvasImageLayerRenderer;
}(_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {module:ol/layer/Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasImageLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].IMAGE ||
    layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_2__["default"].VECTOR &&
    /** @type {module:ol/layer/Vector} */ (layer).getRenderMode() === _layer_VectorRenderType_js__WEBPACK_IMPORTED_MODULE_6__["default"].IMAGE;
};


/**
 * Create a layer renderer.
 * @param {module:ol/renderer/Map} mapRenderer The map renderer.
 * @param {module:ol/layer/Layer} layer The layer to be rendererd.
 * @return {module:ol/renderer/canvas/ImageLayer} The layer renderer.
 */
CanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasImageLayerRenderer(/** @type {module:ol/layer/Image} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasImageLayerRenderer);

//# sourceMappingURL=ImageLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js":
/*!***************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/IntermediateCanvas.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _canvas_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../canvas/Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/IntermediateCanvas
 */







var IntermediateCanvasRenderer = (function (CanvasLayerRenderer) {
  function IntermediateCanvasRenderer(layer) {

    CanvasLayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {module:ol/transform~Transform}
     */
    this.coordinateToCanvasPixelTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["create"])();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.hitCanvasContext_ = null;

  }

  if ( CanvasLayerRenderer ) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;
  IntermediateCanvasRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {

    this.preCompose(context, frameState);

    var image = this.getImage();
    if (image) {

      // clipped rendering if layer extent is set
      var extent = layerState.extent;
      var clipped = extent !== undefined &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsExtent"])(extent, frameState.extent) &&
          Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(extent, frameState.extent);
      if (clipped) {
        this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (extent));
      }

      var imageTransform = this.getImageTransform();
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      var alpha = context.globalAlpha;
      context.globalAlpha = layerState.opacity;

      // for performance reasons, context.setTransform is only used
      // when the view is rotated. see http://jsperf.com/canvas-transform
      var dx = imageTransform[4];
      var dy = imageTransform[5];
      var dw = image.width * imageTransform[0];
      var dh = image.height * imageTransform[3];
      context.drawImage(image, 0, 0, +image.width, +image.height,
        Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      context.globalAlpha = alpha;

      if (clipped) {
        context.restore();
      }
    }

    this.postCompose(context, frameState, layerState);
  };

  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.
   */
  IntermediateCanvasRenderer.prototype.getImage = function getImage () {};

  /**
   * @abstract
   * @return {!module:ol/transform~Transform} Image transform.
   */
  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform () {};

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var layer = this.getLayer();
    var source = layer.getSource();
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var skippedFeatureUids = frameState.skippedFeatureUids;
    return source.forEachFeatureAtCoordinate(
      coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
      /**
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       * @return {?} Callback result.
       */
      function(feature) {
        return callback.call(thisArg, feature, layer);
      });
  };

  /**
   * @inheritDoc
   */
  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.getImage()) {
      return undefined;
    }

    if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _functions_js__WEBPACK_IMPORTED_MODULE_3__["UNDEFINED"]) {
      // for ImageCanvas sources use the original hit-detection logic,
      // so that for example also transparent polygons are detected
      return CanvasLayerRenderer.prototype.forEachLayerAtCoordinate.apply(this, arguments);
    } else {
      var pixel = Object(_transform_js__WEBPACK_IMPORTED_MODULE_5__["apply"])(this.coordinateToCanvasPixelTransform, coordinate.slice());
      Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_0__["scale"])(pixel, frameState.viewState.resolution / this.renderedResolution);

      if (!this.hitCanvasContext_) {
        this.hitCanvasContext_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(1, 1);
      }

      this.hitCanvasContext_.clearRect(0, 0, 1, 1);
      this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

      var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
      if (imageData[3] > 0) {
        return callback.call(thisArg, this.getLayer(), imageData);
      } else {
        return undefined;
      }
    }
  };

  return IntermediateCanvasRenderer;
}(_canvas_Layer_js__WEBPACK_IMPORTED_MODULE_4__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (IntermediateCanvasRenderer);

//# sourceMappingURL=IntermediateCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Layer.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Layer.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Layer.js */ "./node_modules/ol/renderer/Layer.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/Layer
 */









var CanvasLayerRenderer = (function (LayerRenderer) {
  function CanvasLayerRenderer(layer) {

    LayerRenderer.call(this, layer);

    /**
     * @protected
     * @type {number}
     */
    this.renderedResolution;

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["create"])();

  }

  if ( LayerRenderer ) CanvasLayerRenderer.__proto__ = LayerRenderer;
  CanvasLayerRenderer.prototype = Object.create( LayerRenderer && LayerRenderer.prototype );
  CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/extent~Extent} extent Clip extent.
   * @protected
   */
  CanvasLayerRenderer.prototype.clip = function clip (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    var rotation = frameState.viewState.rotation;
    var topLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopLeft"])(/** @type {module:ol/extent~Extent} */ (extent));
    var topRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopRight"])(/** @type {module:ol/extent~Extent} */ (extent));
    var bottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomRight"])(/** @type {module:ol/extent~Extent} */ (extent));
    var bottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomLeft"])(/** @type {module:ol/extent~Extent} */ (extent));

    Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["apply"])(frameState.coordinateToPixelTransform, topLeft);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["apply"])(frameState.coordinateToPixelTransform, topRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["apply"])(frameState.coordinateToPixelTransform, bottomRight);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["apply"])(frameState.coordinateToPixelTransform, bottomLeft);

    context.save();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
  };

  /**
   * @param {module:ol/render/EventType} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/transform~Transform=} opt_transform Transform.
   * @private
   */
  CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, context, frameState, opt_transform) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var width = frameState.size[0] * frameState.pixelRatio;
      var height = frameState.size[1] * frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["rotateAtOffset"])(context, -rotation, width / 2, height / 2);
      var transform = opt_transform !== undefined ?
        opt_transform : this.getTransform(frameState, 0);
      var render = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_5__["default"](
        context, frameState.pixelRatio, frameState.extent, transform,
        frameState.viewState.rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_2__["default"](type, render, frameState,
        context, null);
      layer.dispatchEvent(composeEvent);
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }
  };

  /**
   * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
   * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions_js__WEBPACK_IMPORTED_MODULE_1__["TRUE"], this);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/layer/Layer~State} layerState Layer state.
   * @param {module:ol/transform~Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POSTCOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/transform~Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.preCompose = function preCompose (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PRECOMPOSE, context, frameState, opt_transform);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/transform~Transform=} opt_transform Transform.
   * @protected
   */
  CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (context, frameState, opt_transform) {
    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].RENDER, context, frameState, opt_transform);
  };

  /**
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!module:ol/transform~Transform} Transform.
   */
  CanvasLayerRenderer.prototype.getTransform = function getTransform (frameState, offsetX) {
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var dx1 = pixelRatio * frameState.size[0] / 2;
    var dy1 = pixelRatio * frameState.size[1] / 2;
    var sx = pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0] + offsetX;
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_7__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @abstract
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/layer/Layer~State} layerState Layer state.
   * @param {CanvasRenderingContext2D} context Context.
   */
  CanvasLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {};

  /**
   * @abstract
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/layer/Layer~State} layerState Layer state.
   * @return {boolean} whether composeFrame should be called.
   */
  CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {};

  return CanvasLayerRenderer;
}(_Layer_js__WEBPACK_IMPORTED_MODULE_6__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (CanvasLayerRenderer);

//# sourceMappingURL=Layer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/Map.js":
/*!************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/Map.js ***!
  \************************************************/
/*! exports provided: layerRendererConstructors, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerRendererConstructors", function() { return layerRendererConstructors; });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css.js */ "./node_modules/ol/css.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../layer/Layer.js */ "./node_modules/ol/layer/Layer.js");
/* harmony import */ var _render_Event_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../render/Event.js */ "./node_modules/ol/render/Event.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/canvas/Immediate.js */ "./node_modules/ol/render/canvas/Immediate.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Map.js */ "./node_modules/ol/renderer/Map.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/renderer/canvas/Map
 */













/**
 * @type {Array.<module:ol/renderer/Layer>}
 */
var layerRendererConstructors = [];

/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CanvasMapRenderer = (function (MapRenderer) {
  function CanvasMapRenderer(map) {
    MapRenderer.call(this, map);

    var container = map.getViewport();

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.context_ = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = this.context_.canvas;

    this.canvas_.style.width = '100%';
    this.canvas_.style.height = '100%';
    this.canvas_.style.display = 'block';
    this.canvas_.className = _css_js__WEBPACK_IMPORTED_MODULE_2__["CLASS_UNSELECTABLE"];
    container.insertBefore(this.canvas_, container.childNodes[0] || null);

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.transform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["create"])();

  }

  if ( MapRenderer ) CanvasMapRenderer.__proto__ = MapRenderer;
  CanvasMapRenderer.prototype = Object.create( MapRenderer && MapRenderer.prototype );
  CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;

  /**
   * @param {module:ol/render/EventType} type Event type.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @private
   */
  CanvasMapRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, frameState) {
    var map = this.getMap();
    var context = this.context_;
    if (map.hasListener(type)) {
      var extent = frameState.extent;
      var pixelRatio = frameState.pixelRatio;
      var viewState = frameState.viewState;
      var rotation = viewState.rotation;

      var transform = this.getTransform(frameState);

      var vectorContext = new _render_canvas_Immediate_js__WEBPACK_IMPORTED_MODULE_8__["default"](context, pixelRatio,
        extent, transform, rotation);
      var composeEvent = new _render_Event_js__WEBPACK_IMPORTED_MODULE_5__["default"](type, vectorContext,
        frameState, context, null);
      map.dispatchEvent(composeEvent);
    }
  };

  /**
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @protected
   * @return {!module:ol/transform~Transform} Transform.
   */
  CanvasMapRenderer.prototype.getTransform = function getTransform (frameState) {
    var viewState = frameState.viewState;
    var dx1 = this.canvas_.width / 2;
    var dy1 = this.canvas_.height / 2;
    var sx = frameState.pixelRatio / viewState.resolution;
    var sy = -sx;
    var angle = -viewState.rotation;
    var dx2 = -viewState.center[0];
    var dy2 = -viewState.center[1];
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["compose"])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.renderFrame = function renderFrame (frameState) {
    var this$1 = this;


    if (!frameState) {
      if (this.renderedVisible_) {
        this.canvas_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return;
    }

    var context = this.context_;
    var pixelRatio = frameState.pixelRatio;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    if (this.canvas_.width != width || this.canvas_.height != height) {
      this.canvas_.width = width;
      this.canvas_.height = height;
    } else {
      context.clearRect(0, 0, width, height);
    }

    var rotation = frameState.viewState.rotation;

    this.calculateMatrices2D(frameState);

    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].PRECOMPOSE, frameState);

    var layerStatesArray = frameState.layerStatesArray;
    Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["stableSort"])(layerStatesArray, _Map_js__WEBPACK_IMPORTED_MODULE_9__["sortByZIndex"]);

    if (rotation) {
      context.save();
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__["rotateAtOffset"])(context, rotation, width / 2, height / 2);
    }

    var viewResolution = frameState.viewState.resolution;
    var i, ii, layer, layerRenderer, layerState;
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerState = layerStatesArray[i];
      layer = layerState.layer;
      layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this$1.getLayerRenderer(layer));
      if (!Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) ||
          layerState.sourceState != _source_State_js__WEBPACK_IMPORTED_MODULE_10__["default"].READY) {
        continue;
      }
      if (layerRenderer.prepareFrame(frameState, layerState)) {
        layerRenderer.composeFrame(frameState, layerState, context);
      }
    }

    if (rotation) {
      context.restore();
    }

    this.dispatchComposeEvent_(_render_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.canvas_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleRemoveUnusedLayerRenderers(frameState);
    this.scheduleExpireIconCache(frameState);
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    var this$1 = this;

    var result;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    var coordinate = Object(_transform_js__WEBPACK_IMPORTED_MODULE_0__["apply"])(
      frameState.pixelToCoordinateTransform, pixel.slice());

    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (Object(_layer_Layer_js__WEBPACK_IMPORTED_MODULE_4__["visibleAtResolution"])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this$1.getLayerRenderer(layer));
        result = layerRenderer.forEachLayerAtCoordinate(
          coordinate, frameState, hitTolerance, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
    MapRenderer.prototype.registerLayerRenderers.call(this, constructors);
    for (var i = 0, ii = constructors.length; i < ii; ++i) {
      var ctor = constructors[i];
      if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_1__["includes"])(layerRendererConstructors, ctor)) {
        layerRendererConstructors.push(ctor);
      }
    }
  };

  return CanvasMapRenderer;
}(_Map_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CanvasMapRenderer);

//# sourceMappingURL=Map.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/TileLayer.js":
/*!******************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/TileLayer.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _canvas_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../canvas/IntermediateCanvas.js */ "./node_modules/ol/renderer/canvas/IntermediateCanvas.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/TileLayer
 */










/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer = (function (IntermediateCanvasRenderer) {
  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {

    IntermediateCanvasRenderer.call(this, tileLayer);

    /**
     * @protected
     * @type {CanvasRenderingContext2D}
     */
    this.context = opt_noContext ? null : Object(_dom_js__WEBPACK_IMPORTED_MODULE_5__["createCanvasContext2D"])();

    /**
     * @private
     * @type {number}
     */
    this.oversampling_;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.renderedExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.renderedRevision;

    /**
     * @protected
     * @type {!Array.<module:ol/Tile>}
     */
    this.renderedTiles = [];

    /**
     * @private
     * @type {boolean}
     */
    this.newTiles_ = false;

    /**
     * @protected
     * @type {module:ol/extent~Extent}
     */
    this.tmpExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["createEmpty"])();

    /**
     * @private
     * @type {module:ol/TileRange}
     */
    this.tmpTileRange_ = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](0, 0, 0, 0);

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.imageTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["create"])();

    /**
     * @protected
     * @type {number}
     */
    this.zDirection = 0;

  }

  if ( IntermediateCanvasRenderer ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;
  CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype );
  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;

  /**
   * @private
   * @param {module:ol/Tile} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {
    var tileState = tile.getState();
    var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
    return tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].EMPTY ||
        tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR && !useInterimTilesOnError;
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {!module:ol/Tile} Tile.
   */
  CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var layer = this.getLayer();
    var source = /** @type {module:ol/source/Tile} */ (layer.getSource());
    var tile = source.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERROR) {
      if (!layer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED);
      } else if (layer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile_(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var this$1 = this;


    var pixelRatio = frameState.pixelRatio;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;

    var tileLayer = this.getLayer();
    var tileSource = /** @type {module:ol/source/Tile} */ (tileLayer.getSource());
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var oversampling = Math.round(viewResolution / tileResolution) || 1;
    var extent = frameState.extent;

    if (layerState.extent !== undefined) {
      extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["getIntersection"])(extent, layerState.extent);
    }
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["isEmpty"])(extent)) {
      // Return false to prevent the rendering of the layer.
      return false;
    }

    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

    /**
     * @type {Object.<number, Object.<string, module:ol/Tile>>}
     */
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    var findLoadedTiles = this.createLoadedTileFinder(
      tileSource, projection, tilesToDrawByZ);

    var hints = frameState.viewHints;
    var animatingOrInteracting = hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].ANIMATING] || hints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_4__["default"].INTERACTING];

    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    var tile, x, y;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {
          continue;
        }
        tile = this$1.getTile(z, x, y, pixelRatio, projection);
        if (this$1.isDrawableTile_(tile)) {
          var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this$1);
          if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);
            if (!this$1.newTiles_ && (inTransition || this$1.renderedTiles.indexOf(tile) === -1)) {
              this$1.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(
          tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        }

      }
    }

    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (
      this.newTiles_ ||
          !(this.renderedExtent_ && Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["containsExtent"])(this.renderedExtent_, extent)) ||
          this.renderedRevision != sourceRevision ||
          oversampling != this.oversampling_ ||
          !animatingOrInteracting && renderedResolution != this.renderedResolution
    )) {

      var context = this.context;
      if (context) {
        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
        var canvas = context.canvas;
        if (canvas.width != width || canvas.height != height) {
          this.oversampling_ = oversampling;
          canvas.width = width;
          canvas.height = height;
        } else {
          if (this.renderedExtent_ && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_6__["equals"])(imageExtent, this.renderedExtent_)) {
            context.clearRect(0, 0, width, height);
          }
          oversampling = this.oversampling_;
        }
      }

      this.renderedTiles.length = 0;
      /** @type {Array.<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(function(a, b) {
        if (a === z) {
          return 1;
        } else if (b === z) {
          return -1;
        } else {
          return a > b ? 1 : a < b ? -1 : 0;
        }
      });
      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
      var tileExtent, tileGutter, tilesToDraw, w, h;
      for (i = 0, ii = zs.length; i < ii; ++i) {
        currentZ = zs[i];
        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
        currentResolution = tileGrid.getResolution(currentZ);
        currentScale = currentResolution / tileResolution;
        tileGutter = tilePixelRatio * tileSource.getGutter(projection);
        tilesToDraw = tilesToDrawByZ[currentZ];
        for (var tileCoordKey in tilesToDraw) {
          tile = tilesToDraw[tileCoordKey];
          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
          w = currentTilePixelSize[0] * currentScale / oversampling;
          h = currentTilePixelSize[1] * currentScale / oversampling;
          this$1.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
          this$1.renderedTiles.push(tile);
        }
      }

      this.renderedRevision = sourceRevision;
      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
      this.renderedExtent_ = imageExtent;
    }

    var scale = this.renderedResolution / viewResolution;
    var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.imageTransform_,
      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
      scale, scale,
      0,
      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,
      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
    Object(_transform_js__WEBPACK_IMPORTED_MODULE_8__["compose"])(this.coordinateToCanvasPixelTransform,
      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
      pixelRatio / viewResolution, -pixelRatio / viewResolution,
      0,
      -viewCenter[0], -viewCenter[1]);


    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,
      projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);

    return this.renderedTiles.length > 0;
  };

  /**
   * @param {module:ol/Tile} tile Tile.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/layer/Layer~State} layerState Layer state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {
    var image = tile.getImage(this.getLayer());
    if (!image) {
      return;
    }
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
      this.context.clearRect(x, y, w, h);
    }
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image, gutter, gutter,
      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImage = function getImage () {
    var context = this.context;
    return context ? context.canvas : null;
  };

  /**
   * @inheritDoc
   */
  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {
    return this.imageTransform_;
  };

  return CanvasTileLayerRenderer;
}(_canvas_IntermediateCanvas_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {module:ol/layer/Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].TILE;
};


/**
 * Create a layer renderer.
 * @param {module:ol/renderer/Map} mapRenderer The map renderer.
 * @param {module:ol/layer/Layer} layer The layer to be rendererd.
 * @return {module:ol/renderer/canvas/TileLayer} The layer renderer.
 */
CanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasTileLayerRenderer(/** @type {module:ol/layer/Tile} */ (layer));
};


/**
 * @function
 * @return {module:ol/layer/Tile|module:ol/layer/VectorTile}
 */
CanvasTileLayerRenderer.prototype.getLayer;


/* harmony default export */ __webpack_exports__["default"] = (CanvasTileLayerRenderer);

//# sourceMappingURL=TileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorLayer.js":
/*!********************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorLayer.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ViewHint.js */ "./node_modules/ol/ViewHint.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../render/EventType.js */ "./node_modules/ol/render/EventType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _canvas_Layer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../canvas/Layer.js */ "./node_modules/ol/renderer/canvas/Layer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/**
 * @module ol/renderer/canvas/VectorLayer
 */














/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer = (function (CanvasLayerRenderer) {
  function CanvasVectorLayerRenderer(vectorLayer) {

    CanvasLayerRenderer.call(this, vectorLayer);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.renderedExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createEmpty"])();

    /**
     * @private
     * @type {function(module:ol/Feature, module:ol/Feature): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {module:ol/render/canvas/ReplayGroup}
     */
    this.replayGroup_ = null;

    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */
    this.replayGroupChanged = true;

    /**
     * @type {CanvasRenderingContext2D}
     */
    this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasLayerRenderer ) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;
  CanvasVectorLayerRenderer.prototype = Object.create( CanvasLayerRenderer && CanvasLayerRenderer.prototype );
  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @param {module:ol/layer/Layer~State} layerState Layer state.
   */
  CanvasVectorLayerRenderer.prototype.compose = function compose (context, frameState, layerState) {
    var this$1 = this;

    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var skippedFeatureUids = layerState.managed ?
      frameState.skippedFeatureUids : {};
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = /** @type {module:ol/source/Vector} */ (this.getLayer().getSource());

    var transform = this.getTransform(frameState, 0);

    // clipped rendering if layer extent is set
    var clipExtent = layerState.extent;
    var clipped = clipExtent !== undefined;
    if (clipped) {
      this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (clipExtent));
    }
    var replayGroup = this.replayGroup_;
    if (replayGroup && !replayGroup.isEmpty()) {
      if (this.declutterTree_) {
        this.declutterTree_.clear();
      }
      var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
      var drawOffsetX = 0;
      var drawOffsetY = 0;
      var replayContext;
      var transparentLayer = layerState.opacity !== 1;
      var hasRenderListeners = layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].RENDER);
      if (transparentLayer || hasRenderListeners) {
        var drawWidth = context.canvas.width;
        var drawHeight = context.canvas.height;
        if (rotation) {
          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
          drawOffsetX = (drawSize - drawWidth) / 2;
          drawOffsetY = (drawSize - drawHeight) / 2;
          drawWidth = drawHeight = drawSize;
        }
        // resize and clear
        this.context.canvas.width = drawWidth;
        this.context.canvas.height = drawHeight;
        replayContext = this.context;
      } else {
        replayContext = context;
      }

      var alpha = replayContext.globalAlpha;
      if (!transparentLayer) {
        // for performance reasons, context.save / context.restore is not used
        // to save and restore the transformation matrix and the opacity.
        // see http://jsperf.com/context-save-restore-versus-variable
        replayContext.globalAlpha = layerState.opacity;
      }

      if (replayContext != context) {
        replayContext.translate(drawOffsetX, drawOffsetY);
      }

      var width = frameState.size[0] * pixelRatio;
      var height = frameState.size[1] * pixelRatio;
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, -rotation,
        width / 2, height / 2);
      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
      if (vectorSource.getWrapX() && projection.canWrapX() &&
          !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, extent)) {
        var startX = extent[0];
        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
        var world = 0;
        var offsetX;
        while (startX < projectionExtent[0]) {
          --world;
          offsetX = worldWidth * world;
          transform = this$1.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
          startX += worldWidth;
        }
        world = 0;
        startX = extent[2];
        while (startX > projectionExtent[2]) {
          ++world;
          offsetX = worldWidth * world;
          transform = this$1.getTransform(frameState, offsetX);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
          startX -= worldWidth;
        }
      }
      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__["rotateAtOffset"])(replayContext, rotation,
        width / 2, height / 2);

      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }
      if (replayContext != context) {
        if (transparentLayer) {
          var mainContextAlpha = context.globalAlpha;
          context.globalAlpha = layerState.opacity;
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
          context.globalAlpha = mainContextAlpha;
        } else {
          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        }
        replayContext.translate(-drawOffsetX, -drawOffsetY);
      }

      if (!transparentLayer) {
        replayContext.globalAlpha = alpha;
      }
    }

    if (clipped) {
      context.restore();
    }
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
    var transform = this.getTransform(frameState, 0);
    this.preCompose(context, frameState, transform);
    this.compose(context, frameState, layerState);
    this.postCompose(context, frameState, layerState, transform);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.replayGroup_) {
      return undefined;
    } else {
      var resolution = frameState.viewState.resolution;
      var rotation = frameState.viewState.rotation;
      var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
      /** @type {!Object.<string, boolean>} */
      var features = {};
      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
        /**
         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
         * @return {?} Callback result.
         */
        function(feature) {
          var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
          if (!(key in features)) {
            features[key] = true;
            return callback.call(thisArg, feature, layer);
          }
        }, null);
      return result;
    }
  };

  /**
   * @param {module:ol/events/Event} event Event.
   */
  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {module:ol/events/Event} event Image style change event.
   * @private
   */
  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var vectorLayer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
    var vectorSource = vectorLayer.getSource();

    var animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].ANIMATING];
    var interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__["default"].INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && (!updateWhileAnimating && animating) ||
        (!updateWhileInteracting && interacting)) {
      return true;
    }

    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_12__["defaultOrder"];
    }

    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(frameStateExtent,
      vectorLayerRenderBuffer * resolution);
    var projectionExtent = viewState.projection.getExtent();

    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&
        !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180° to +180°). To support geometries in a coordinate range from -540°
      // to +540°, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);
      var gutter = Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
    }

    if (!this.dirty_ &&
        this.renderedResolution_ == resolution &&
        this.renderedRevision_ == vectorLayerRevision &&
        this.renderedRenderOrder_ == vectorLayerRenderOrder &&
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(this.renderedExtent_, extent)) {
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;

    this.dirty_ = false;

    var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getTolerance"])(resolution, pixelRatio), extent, resolution,
      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
    vectorSource.loadFeatures(extent, resolution, projection);
    /**
     * @param {module:ol/Feature} feature Feature.
     * @this {module:ol/renderer/canvas/VectorLayer}
     */
    var render = function(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
      if (styles) {
        var dirty = this.renderFeature(
          feature, resolution, pixelRatio, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);
    if (vectorLayerRenderOrder) {
      /** @type {Array.<module:ol/Feature>} */
      var features = [];
      vectorSource.forEachFeatureInExtent(extent,
        /**
         * @param {module:ol/Feature} feature Feature.
         */
        function(feature) {
          features.push(feature);
        }, this);
      features.sort(vectorLayerRenderOrder);
      for (var i = 0, ii = features.length; i < ii; ++i) {
        render(features[i]);
      }
    } else {
      vectorSource.forEachFeatureInExtent(extent, render, this);
    }
    replayGroup.finish();

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.replayGroup_ = replayGroup;

    this.replayGroupChanged = true;
    return true;
  };

  /**
   * @param {module:ol/Feature} feature Feature.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.
   * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, resolution, pixelRatio, styles, replayGroup) {
    var this$1 = this;

    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
          replayGroup, feature, styles[i],
          Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
          this$1.handleStyleImageChange_, this$1) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["renderFeature"])(
        replayGroup, feature, styles,
        Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__["getSquaredTolerance"])(resolution, pixelRatio),
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_canvas_Layer_js__WEBPACK_IMPORTED_MODULE_11__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {module:ol/layer/Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR;
};


/**
 * Create a layer renderer.
 * @param {module:ol/renderer/Map} mapRenderer The map renderer.
 * @param {module:ol/layer/Layer} layer The layer to be rendererd.
 * @return {module:ol/renderer/canvas/VectorLayer} The layer renderer.
 */
CanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorLayerRenderer(/** @type {module:ol/layer/Vector} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorLayerRenderer);

//# sourceMappingURL=VectorLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/canvas/VectorTileLayer.js":
/*!************************************************************!*\
  !*** ./node_modules/ol/renderer/canvas/VectorTileLayer.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../LayerType.js */ "./node_modules/ol/LayerType.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../layer/VectorTileRenderType.js */ "./node_modules/ol/layer/VectorTileRenderType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../render/canvas/ReplayGroup.js */ "./node_modules/ol/render/canvas/ReplayGroup.js");
/* harmony import */ var _render_replay_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../render/replay.js */ "./node_modules/ol/render/replay.js");
/* harmony import */ var _canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../canvas/TileLayer.js */ "./node_modules/ol/renderer/canvas/TileLayer.js");
/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../vector.js */ "./node_modules/ol/renderer/vector.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../transform.js */ "./node_modules/ol/transform.js");
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */




















/**
 * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}
 */
var IMAGE_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].CIRCLE,
    _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].TEXT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].POLYGON, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].LINE_STRING]
};


/**
 * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}
 */
var VECTOR_REPLAYS = {
  'image': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].DEFAULT],
  'hybrid': [_render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].IMAGE, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].TEXT, _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_11__["default"].DEFAULT],
  'vector': _render_replay_js__WEBPACK_IMPORTED_MODULE_14__["ORDER"]
};


/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 */
var CanvasVectorTileLayerRenderer = (function (CanvasTileLayerRenderer) {
  function CanvasVectorTileLayerRenderer(layer) {

    CanvasTileLayerRenderer.call(this, layer, true);

    /**
     * Declutter tree.
     * @private
     */
    this.declutterTree_ = layer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9, undefined) : null;

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedLayerRevision_;

    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    this.tmpTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["create"])();

    // Use lower resolution for pure vector rendering. Closest resolution otherwise.
    this.zDirection = layer.getRenderMode() == _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR ? 1 : 0;

    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["listen"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);

  }

  if ( CanvasTileLayerRenderer ) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;
  CanvasVectorTileLayerRenderer.prototype = Object.create( CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype );
  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__["unlisten"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["labelCache"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__["default"].CLEAR, this.handleFontsChanged_, this);
    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);
    if (tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      this.createReplayGroup_(tile, pixelRatio, projection);
      if (this.context) {
        this.renderTileImage_(tile, pixelRatio, projection);
      }
    }
    return tile;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
    var layer = this.getLayer();
    var layerRevision = layer.getRevision();
    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
      var renderMode = layer.getRenderMode();
      if (!this.context && renderMode != _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR) {
        this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__["createCanvasContext2D"])();
      }
      if (this.context && renderMode == _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_8__["default"].VECTOR) {
        this.context = null;
      }
    }
    this.renderedLayerRevision_ = layerRevision;
    return CanvasTileLayerRenderer.prototype.prepareFrame.apply(this, arguments);
  };

  /**
   * @param {module:ol/VectorImageTile} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_ (tile, pixelRatio, projection) {
    var this$1 = this;

    var layer = this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = /** @type {module:ol/render~OrderFunction} */ (layer.getRenderOrder()) || null;

    var replayState = tile.getReplayState(layer);
    if (!replayState.dirty && replayState.renderedRevision == revision &&
        replayState.renderedRenderOrder == renderOrder) {
      return;
    }

    var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var resolution = tileGrid.getResolution(tile.tileCoord[0]);
    var tileExtent = tile.extent;

    var zIndexKeys = {};
    var loop = function ( t, tt ) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        return;
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getIntersection"])(tileExtent, sourceTileExtent);
      var bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["equals"])(sourceTileExtent, sharedExtent) ? null :
        Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);
      var tileProjection = sourceTile.getProjection();
      var reproject = false;
      if (!Object(_proj_js__WEBPACK_IMPORTED_MODULE_9__["equivalent"])(projection, tileProjection)) {
        reproject = true;
        sourceTile.setProjection(projection);
      }
      replayState.dirty = false;
      var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_13__["default"](0, sharedExtent, resolution,
        pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());
      var squaredTolerance = Object(_vector_js__WEBPACK_IMPORTED_MODULE_16__["getSquaredTolerance"])(resolution, pixelRatio);

      /**
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       * @this {module:ol/renderer/canvas/VectorTileLayer}
       */
      var render = function(feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
          this.dirty_ = this.dirty_ || dirty;
          replayState.dirty = replayState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();
      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
        features.sort(renderOrder);
      }
      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];
        if (reproject) {
          if (tileProjection.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_10__["default"].TILE_PIXELS) {
            // projected tile extent
            tileProjection.setWorldExtent(sourceTileExtent);
            // tile extent in tile pixel space
            tileProjection.setExtent(sourceTile.getExtent());
          }
          feature.getGeometry().transform(tileProjection, projection);
        }
        if (!bufferedExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["intersects"])(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this$1, feature);
        }
      }
      replayGroup.finish();
      for (var r in replayGroup.getReplays()) {
        zIndexKeys[r] = true;
      }
      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
    };

    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop( t, tt );
    replayState.renderedRevision = revision;
    replayState.renderedRenderOrder = renderOrder;
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer = this.getLayer();
    /** @type {!Object.<string, boolean>} */
    var features = {};

    /** @type {Array.<module:ol/VectorImageTile>} */
    var renderedTiles = this.renderedTiles;

    var bufferedExtent, found;
    var i, ii, replayGroup;
    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
      var tile = renderedTiles[i];
      bufferedExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(tile.extent, hitTolerance * resolution, bufferedExtent);
      if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsCoordinate"])(bufferedExtent, coordinate)) {
        continue;
      }
      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
        var sourceTile = tile.getTile(tile.tileKeys[t]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
          /**
           * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
           * @return {?} Callback result.
           */
          function(feature) {
            var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
            if (!(key in features)) {
              features[key] = true;
              return callback.call(thisArg, feature, layer);
            }
          }, null);
      }
    }
    return found;
  };

  /**
   * @param {module:ol/VectorTile} tile Tile.
   * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
   * @return {module:ol/transform~Transform} transform Transform.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_ (tile, frameState) {
    var layer = this.getLayer();
    var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
    var tileGrid = source.getTileGrid();
    var tileCoord = tile.tileCoord;
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var renderResolution = viewState.resolution / pixelRatio;
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var center = viewState.center;
    var origin = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getTopLeft"])(tileExtent);
    var size = frameState.size;
    var offsetX = Math.round(pixelRatio * size[0] / 2);
    var offsetY = Math.round(pixelRatio * size[1] / 2);
    return Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["compose"])(this.tmpTransform_,
      offsetX, offsetY,
      tileResolution / renderResolution, tileResolution / renderResolution,
      viewState.rotation,
      (origin[0] - center[0]) / tileResolution,
      (center[1] - origin[1]) / tileResolution);
  };

  /**
   * @param {module:ol/events/Event} event Event.
   */
  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
    var layer = this.getLayer();
    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };

  /**
   * Handle changes in image style state.
   * @param {module:ol/events/Event} event Image style change event.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState) {
    var this$1 = this;

    var layer = this.getLayer();
    var renderMode = layer.getRenderMode();
    if (renderMode != _layer_VectorTileRenderType_js__WEBPACK_IMPORTED_MODULE_8__["default"].IMAGE) {
      var declutterReplays = layer.getDeclutter() ? {} : null;
      var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
      var replayTypes = VECTOR_REPLAYS[renderMode];
      var pixelRatio = frameState.pixelRatio;
      var rotation = frameState.viewState.rotation;
      var size = frameState.size;
      var offsetX, offsetY;
      if (rotation) {
        offsetX = Math.round(pixelRatio * size[0] / 2);
        offsetY = Math.round(pixelRatio * size[1] / 2);
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["rotateAtOffset"])(context, -rotation, offsetX, offsetY);
      }
      if (declutterReplays) {
        this.declutterTree_.clear();
      }
      var tiles = this.renderedTiles;
      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
      var clips = [];
      var zs = [];
      for (var i = tiles.length - 1; i >= 0; --i) {
        var tile = /** @type {module:ol/VectorImageTile} */ (tiles[i]);
        if (tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ABORT) {
          continue;
        }
        var tileCoord = tile.tileCoord;
        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this$1.tmpExtent)[0] - tile.extent[0];
        var transform = undefined;
        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
          var sourceTile = tile.getTile(tile.tileKeys[t]);
          if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
            continue;
          }
          var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());
          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {
            // sourceTile was not yet loaded when this.createReplayGroup_() was
            // called, or it has no replays of the types we want to render
            continue;
          }
          if (!transform) {
            transform = this$1.getTransform(frameState, worldOffset);
          }
          var currentZ = sourceTile.tileCoord[0];
          var currentClip = replayGroup.getClipCoords(transform);
          context.save();
          context.globalAlpha = layerState.opacity;
          // Create a clip mask for regions in this low resolution tile that are
          // already filled by a higher resolution tile
          for (var j = 0, jj = clips.length; j < jj; ++j) {
            var clip = clips[j];
            if (currentZ < zs[j]) {
              context.beginPath();
              // counter-clockwise (outer ring) for current tile
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              // clockwise (inner ring) for higher resolution tile
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
          replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);
          context.restore();
          clips.push(currentClip);
          zs.push(currentZ);
        }
      }
      if (declutterReplays) {
        Object(_render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_13__["replayDeclutter"])(declutterReplays, context, rotation);
      }
      if (rotation) {
        Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_12__["rotateAtOffset"])(context, rotation,
          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));
      }
    }
    CanvasTileLayerRenderer.prototype.postCompose.apply(this, arguments);
  };

  /**
   * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.
   * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, squaredTolerance, styles, replayGroup) {
    var this$1 = this;

    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_16__["renderFeature"])(
          replayGroup, feature, styles[i], squaredTolerance,
          this$1.handleStyleImageChange_, this$1) || loading;
      }
    } else {
      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_16__["renderFeature"])(
        replayGroup, feature, styles, squaredTolerance,
        this.handleStyleImageChange_, this);
    }
    return loading;
  };

  /**
   * @param {module:ol/VectorImageTile} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @private
   */
  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_ (tile, pixelRatio, projection) {
    var this$1 = this;

    var layer = this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var replays = IMAGE_REPLAYS[layer.getRenderMode()];
    if (replays && replayState.renderedTileRevision !== revision) {
      replayState.renderedTileRevision = revision;
      var tileCoord = tile.wrappedTileCoord;
      var z = tileCoord[0];
      var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
      var tileGrid = source.getTileGridForProjection(projection);
      var resolution = tileGrid.getResolution(z);
      var context = tile.getContext(layer);
      var size = source.getTilePixelSize(z, pixelRatio, projection);
      context.canvas.width = size[0];
      context.canvas.height = size[1];
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
        var sourceTile = tile.getTile(tile.tileKeys[i]);
        if (sourceTile.getState() != _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
          continue;
        }
        var pixelScale = pixelRatio / resolution;
        var transform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["reset"])(this$1.tmpTransform_);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["scale"])(transform, pixelScale, -pixelScale);
        Object(_transform_js__WEBPACK_IMPORTED_MODULE_17__["translate"])(transform, -tileExtent[0], -tileExtent[3]);
        var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
        replayGroup.replay(context, transform, 0, {}, replays);
      }
    }
  };

  return CanvasVectorTileLayerRenderer;
}(_canvas_TileLayer_js__WEBPACK_IMPORTED_MODULE_15__["default"]));


/**
 * Determine if this renderer handles the provided layer.
 * @param {module:ol/layer/Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
CanvasVectorTileLayerRenderer['handles'] = function(layer) {
  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__["default"].VECTOR_TILE;
};


/**
 * Create a layer renderer.
 * @param {module:ol/renderer/Map} mapRenderer The map renderer.
 * @param {module:ol/layer/Layer} layer The layer to be rendererd.
 * @return {module:ol/renderer/canvas/VectorTileLayer} The layer renderer.
 */
CanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {
  return new CanvasVectorTileLayerRenderer(/** @type {module:ol/layer/VectorTile} */ (layer));
};


/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorTileLayerRenderer);

//# sourceMappingURL=VectorTileLayer.js.map

/***/ }),

/***/ "./node_modules/ol/renderer/vector.js":
/*!********************************************!*\
  !*** ./node_modules/ol/renderer/vector.js ***!
  \********************************************/
/*! exports provided: defaultOrder, getSquaredTolerance, getTolerance, renderFeature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOrder", function() { return defaultOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSquaredTolerance", function() { return getSquaredTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTolerance", function() { return getTolerance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderFeature", function() { return renderFeature; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render/ReplayType.js */ "./node_modules/ol/render/ReplayType.js");
/**
 * @module ol/renderer/vector
 */






/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;


/**
 * @const
 * @type {Object.<module:ol/geom/GeometryType,
 *                function(module:ol/render/ReplayGroup, module:ol/geom/Geometry,
 *                         module:ol/style/Style, Object)>}
 */
var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};


/**
 * @param {module:ol/Feature|module:ol/render/Feature} feature1 Feature 1.
 * @param {module:ol/Feature|module:ol/render/Feature} feature2 Feature 2.
 * @return {number} Order.
 */
function defaultOrder(feature1, feature2) {
  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature1) - Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature2);
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}


/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/Circle} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature} feature Feature.
 */
function renderCircleGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 * @param {module:ol/style/Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, module:ol/events/Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle = style.getImage();
  if (imageStyle) {
    var imageState = imageStyle.getImageState();
    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  renderFeatureInternal(replayGroup, feature, style, squaredTolerance);

  return loading;
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 * @param {module:ol/style/Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 */
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/Geometry} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__["default"].GEOMETRY_COLLECTION) {
    var geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT);
  replay.drawCustom(/** @type {module:ol/geom/SimpleGeometry} */ (geometry), feature, style.getRenderer());
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/GeometryCollection} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature} feature Feature.
 */
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer =
        GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/MultiPolygon} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature} feature Feature.
 */
function renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderMultiPointGeometry(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
}


/**
 * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
 * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Geometry.
 * @param {module:ol/style/Style} style Style.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 */
function renderPolygonGeometry(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__["default"].TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
}

//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "./node_modules/ol/reproj.js":
/*!***********************************!*\
  !*** ./node_modules/ol/reproj.js ***!
  \***********************************/
/*! exports provided: calculateSourceResolution, render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateSourceResolution", function() { return calculateSourceResolution; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj
 */






/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {module:ol/proj/Projection} sourceProj Source projection.
 * @param {module:ol/proj/Projection} targetProj Target projection.
 * @param {module:ol/coordinate~Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
function calculateSourceResolution(sourceProj, targetProj,
  targetCenter, targetResolution) {

  var sourceCenter = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["transform"])(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsCoordinate"])(sourceExtent, sourceCenter)) {
    var compensationFactor = Object(_proj_js__WEBPACK_IMPORTED_MODULE_3__["getPointResolution"])(sourceProj, sourceResolution, sourceCenter) /
        sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}


/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.
 */
function enlargeClipPoint(centroidX, centroidY, x, y) {
  var dX = x - centroidX;
  var dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
}


/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {module:ol/extent~Extent} targetExtent Target extent.
 * @param {module:ol/reproj/Triangulation} triangulation
 * Calculated triangulation.
 * @param {Array.<{extent: module:ol/extent~Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
function render(width, height, pixelRatio,
  sourceResolution, sourceExtent, targetResolution, targetExtent,
  triangulation, sources, gutter, opt_renderEdges) {

  var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(Math.round(pixelRatio * width),
    Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createEmpty"])();
  sources.forEach(function(src, i, arr) {
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["extend"])(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(sourceDataExtent);
  var canvasHeightInUnits = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(sourceDataExtent);
  var stitchContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_0__["createCanvasContext2D"])(
    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(src.extent);
    var srcHeight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(src.extent);

    stitchContext.drawImage(
      src.image,
      gutter, gutter,
      src.image.width - 2 * gutter, src.image.height - 2 * gutter,
      xPos * stitchScale, yPos * stitchScale,
      srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getTopLeft"])(targetExtent);

  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1];
    var x1 = source[1][0], y1 = source[1][1];
    var x2 = source[2][0], y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    var affineCoefs = Object(_math_js__WEBPACK_IMPORTED_MODULE_2__["solveLinearSystem"])(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3;
    var centroidY = (v0 + v1 + v2) / 3;
    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(
      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio,
      -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
}

//# sourceMappingURL=reproj.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/reproj/Image.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageBase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageBase.js */ "./node_modules/ol/ImageBase.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj/Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Image
 */











/**
 * @typedef {function(module:ol/extent~Extent, number, number) : module:ol/ImageBase} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
var ReprojImage = (function (ImageBase) {
  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_6__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    var errorThresholdInPixels = _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    var triangulation = new _reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_7__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    if (sourceImage) {
      state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE;
    }
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;

    ImageBase.call(this, targetExtent, targetResolution, sourcePixelRatio, state);

    /**
     * @private
     * @type {module:ol/proj/Projection}
     */
    this.targetProj_ = targetProj;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.maxSourceExtent_ = maxSourceExtent;

    /**
     * @private
     * @type {!module:ol/reproj/Triangulation}
     */
    this.triangulation_ = triangulation;

    /**
     * @private
     * @type {number}
     */
    this.targetResolution_ = targetResolution;

    /**
     * @private
     * @type {module:ol/extent~Extent}
     */
    this.targetExtent_ = targetExtent;

    /**
     * @private
     * @type {module:ol/ImageBase}
     */
    this.sourceImage_ = sourceImage;

    /**
     * @private
     * @type {number}
     */
    this.sourcePixelRatio_ = sourcePixelRatio;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {?module:ol/events~EventsKey}
     */
    this.sourceListenerKey_ = null;
  }

  if ( ImageBase ) ReprojImage.__proto__ = ImageBase;
  ReprojImage.prototype = Object.create( ImageBase && ImageBase.prototype );
  ReprojImage.prototype.constructor = ReprojImage;

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSource_();
    }
    ImageBase.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @return {module:ol/proj/Projection} Projection.
   */
  ReprojImage.prototype.getProjection = function getProjection () {
    return this.targetProj_;
  };

  /**
   * @private
   */
  ReprojImage.prototype.reproject_ = function reproject_ () {
    var sourceState = this.sourceImage_.getState();
    if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
      var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getWidth"])(this.targetExtent_) / this.targetResolution_;
      var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getHeight"])(this.targetExtent_) / this.targetResolution_;

      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_6__["render"])(width, height, this.sourcePixelRatio_,
        this.sourceImage_.getResolution(), this.maxSourceExtent_,
        this.targetResolution_, this.targetExtent_, this.triangulation_, [{
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }], 0);
    }
    this.state = sourceState;
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojImage.prototype.load = function load () {
    if (this.state == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var sourceState = this.sourceImage_.getState();
      if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(this.sourceImage_,
          _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE, function(e) {
            var sourceState = this.sourceImage_.getState();
            if (sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED || sourceState == _ImageState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR) {
              this.unlistenSource_();
              this.reproject_();
            }
          }, this);
        this.sourceImage_.load();
      }
    }
  };

  /**
   * @private
   */
  ReprojImage.prototype.unlistenSource_ = function unlistenSource_ () {
    Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(/** @type {!module:ol/events~EventsKey} */ (this.sourceListenerKey_));
    this.sourceListenerKey_ = null;
  };

  return ReprojImage;
}(_ImageBase_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojImage);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/reproj/Tile.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _Tile_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tile.js */ "./node_modules/ol/Tile.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _reproj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../reproj.js */ "./node_modules/ol/reproj.js");
/* harmony import */ var _reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/Triangulation.js */ "./node_modules/ol/reproj/Triangulation.js");
/**
 * @module ol/reproj/Tile
 */












/**
 * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType
 */


/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile = (function (Tile) {
  function ReprojTile(
    sourceProj,
    sourceTileGrid,
    targetProj,
    targetTileGrid,
    tileCoord,
    wrappedTileCoord,
    pixelRatio,
    gutter,
    getTileFunction,
    opt_errorThreshold,
    opt_renderEdges
  ) {
    var this$1 = this;

    Tile.call(this, tileCoord, _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE);

    /**
     * @private
     * @type {boolean}
     */
    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

    /**
     * @private
     * @type {number}
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     * @type {number}
     */
    this.gutter_ = gutter;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {module:ol/tilegrid/TileGrid}
     */
    this.sourceTileGrid_ = sourceTileGrid;

    /**
     * @private
     * @type {module:ol/tilegrid/TileGrid}
     */
    this.targetTileGrid_ = targetTileGrid;

    /**
     * @private
     * @type {module:ol/tilecoord~TileCoord}
     */
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

    /**
     * @private
     * @type {!Array.<module:ol/Tile>}
     */
    this.sourceTiles_ = [];

    /**
     * @private
     * @type {Array.<module:ol/events~EventsKey>}
     */
    this.sourcesListenerKeys_ = null;

    /**
     * @private
     * @type {number}
     */
    this.sourceZ_ = 0;

    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
    var maxTargetExtent = this.targetTileGrid_.getExtent();
    var maxSourceExtent = this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ?
      Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;

    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]);

    var targetCenter = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getCenter"])(limitedTargetExtent);
    var sourceResolution = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["calculateSourceResolution"])(
      sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ?
      opt_errorThreshold : _common_js__WEBPACK_IMPORTED_MODULE_0__["ERROR_THRESHOLD"];

    /**
     * @private
     * @type {!module:ol/reproj/Triangulation}
     */
    this.triangulation_ = new _reproj_Triangulation_js__WEBPACK_IMPORTED_MODULE_8__["default"](
      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
      sourceResolution * errorThresholdInPixels);

    if (this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      return;
    }

    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    var sourceExtent = this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__["clamp"])(
          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getIntersection"])(sourceExtent, maxSourceExtent);
      }
    }

    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_5__["getArea"])(sourceExtent)) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent, this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(this$1.sourceZ_, srcX, srcY, pixelRatio);
          if (tile) {
            this$1.sourceTiles_.push(tile);
          }
        }
      }

      if (this.sourceTiles_.length === 0) {
        this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY;
      }
    }
  }

  if ( Tile ) ReprojTile.__proto__ = Tile;
  ReprojTile.prototype = Object.create( Tile && Tile.prototype );
  ReprojTile.prototype.constructor = ReprojTile;

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.disposeInternal = function disposeInternal () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
      this.unlistenSources_();
    }
    Tile.prototype.disposeInternal.call(this);
  };

  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  ReprojTile.prototype.getImage = function getImage () {
    return this.canvas_;
  };

  /**
   * @private
   */
  ReprojTile.prototype.reproject_ = function reproject_ () {
    var sources = [];
    this.sourceTiles_.forEach(function(tile, i, arr) {
      if (tile && tile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

      var targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_);
      this.canvas_ = Object(_reproj_js__WEBPACK_IMPORTED_MODULE_7__["render"])(width, height, this.pixelRatio_,
        sourceResolution, this.sourceTileGrid_.getExtent(),
        targetResolution, targetExtent, this.triangulation_, sources,
        this.gutter_, this.renderEdges_);

      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
    }
    this.changed();
  };

  /**
   * @inheritDoc
   */
  ReprojTile.prototype.load = function load () {
    if (this.state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
      this.state = _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING;
      this.changed();

      var leftToLoad = 0;

      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE || state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADING) {
          leftToLoad++;

          var sourceListenKey = Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].CHANGE,
            function(e) {
              var state = tile.getState();
              if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERROR ||
                    state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].EMPTY) {
                Object(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"])(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            }, this);
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      }.bind(this));

      this.sourceTiles_.forEach(function(tile, i, arr) {
        var state = tile.getState();
        if (state == _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].IDLE) {
          tile.load();
        }
      });

      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };

  /**
   * @private
   */
  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {
    this.sourcesListenerKeys_.forEach(_events_js__WEBPACK_IMPORTED_MODULE_3__["unlistenByKey"]);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile_js__WEBPACK_IMPORTED_MODULE_1__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ReprojTile);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/Triangulation.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/reproj/Triangulation.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/**
 * @module ol/reproj/Triangulation
 */





/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array.<module:ol/coordinate~Coordinate>} source
 * @property {Array.<module:ol/coordinate~Coordinate>} target
 */


/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;


/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */
var MAX_TRIANGLE_WIDTH = 0.25;


/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */
var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {module:ol/proj/Projection}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */
  var transformInvCache = {};
  var transformInv = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["getTransform"])(this.targetProj_, this.sourceProj_);

  /**
   * @param {module:ol/coordinate~Coordinate} c A coordinate.
   * @return {module:ol/coordinate~Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function(c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {module:ol/extent~Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array.<module:ol/reproj/Triangulation~Triangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&
      !!maxSourceExtent &&
      !!this.sourceProj_.getExtent() &&
      (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(maxSourceExtent) == Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()));

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopLeft"])(targetExtent);
  var destinationTopRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getTopRight"])(targetExtent);
  var destinationBottomRight = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomRight"])(targetExtent);
  var destinationBottomLeft = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getBottomLeft"])(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(
    destinationTopLeft, destinationTopRight,
    destinationBottomRight, destinationBottomLeft,
    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,
    MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function(triangle, i, arr) {
      leftBound = Math.min(leftBound,
        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function(triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0],
        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],
          [triangle.source[1][0], triangle.source[1][1]],
          [triangle.source[2][0], triangle.source[2][1]]];
        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(
          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }.bind(this));
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @private
 */
Triangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
 * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
 * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
 * @param {module:ol/coordinate~Coordinate} d The target d coordinate.
 * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
 * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
 * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
 * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
Triangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ?
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() &&
               sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["boundingExtent"])([a, b, c, d]);
      var targetCoverageX = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["getWidth"])(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |=
          targetCoverageX > MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |=
          sourceCoverageX > MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||
        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||
        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||
        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX =
            (Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(aSrc[0], sourceWorldWidth) +
             Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX -
            Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(
          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(
          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(
          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(
          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {module:ol/extent~Extent} Calculated extent.
 */
Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {
  var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])();

  this.triangles_.forEach(function(triangle, i, arr) {
    var src = triangle.source;
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[0]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[1]);
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendCoordinate"])(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.
 */
Triangulation.prototype.getTriangles = function getTriangles () {
  return this.triangles_;
};

/* harmony default export */ __webpack_exports__["default"] = (Triangulation);

//# sourceMappingURL=Triangulation.js.map

/***/ }),

/***/ "./node_modules/ol/reproj/common.js":
/*!******************************************!*\
  !*** ./node_modules/ol/reproj/common.js ***!
  \******************************************/
/*! exports provided: ERROR_THRESHOLD, ENABLE_RASTER_REPROJECTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERROR_THRESHOLD", function() { return ERROR_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENABLE_RASTER_REPROJECTION", function() { return ENABLE_RASTER_REPROJECTION; });
/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;

/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */
var ENABLE_RASTER_REPROJECTION = true;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/resolutionconstraint.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/resolutionconstraint.js ***!
  \*************************************************/
/*! exports provided: createSnapToResolutions, createSnapToPower */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToResolutions", function() { return createSnapToResolutions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToPower", function() { return createSnapToPower; });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/resolutionconstraint
 */




/**
 * @typedef {function((number|undefined), number, number): (number|undefined)} Type
 */


/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {module:ol/resolutionconstraint~Type} Zoom function.
 */
function createSnapToResolutions(resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_0__["linearFindNearest"])(resolutions, resolution, direction);
        z = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["clamp"])(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);
        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
}


/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {module:ol/resolutionconstraint~Type} Zoom function.
 */
function createSnapToPower(power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function(resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(
          Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);
        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }
        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=resolutionconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/rotationconstraint.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/rotationconstraint.js ***!
  \***********************************************/
/*! exports provided: disable, none, createSnapToN, createSnapToZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "disable", function() { return disable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToN", function() { return createSnapToN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSnapToZero", function() { return createSnapToZero; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/rotationconstraint
 */



/**
 * @typedef {function((number|undefined), number): (number|undefined)} Type
 */


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function disable(rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}


/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
function none(rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
}


/**
 * @param {number} n N.
 * @return {module:ol/rotationconstraint~Type} Rotation constraint.
 */
function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    });
}


/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {module:ol/rotationconstraint~Type} Rotation constraint.
 */
function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function(rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    });
}

//# sourceMappingURL=rotationconstraint.js.map

/***/ }),

/***/ "./node_modules/ol/size.js":
/*!*********************************!*\
  !*** ./node_modules/ol/size.js ***!
  \*********************************/
/*! exports provided: buffer, hasArea, scale, toSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasArea", function() { return hasArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSize", function() { return toSize; });
/**
 * @module ol/size
 */


/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array.<number>} Size
 * @api
 */


/**
 * Returns a buffered size.
 * @param {module:ol/size~Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}


/**
 * Determines if a size has a positive area.
 * @param {module:ol/size~Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}


/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {module:ol/size~Size} size Size.
 * @param {number} ratio Ratio.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} The scaled size.
 */
function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = (size[0] * ratio + 0.5) | 0;
  opt_size[1] = (size[1] * ratio + 0.5) | 0;
  return opt_size;
}


/**
 * Returns an `module:ol/size~Size` array for the passed in number (meaning: square) or
 * `module:ol/size~Size` array.
 * (meaning: non-square),
 * @param {number|module:ol/size~Size} size Width and height.
 * @param {module:ol/size~Size=} opt_size Optional reusable size array.
 * @return {module:ol/size~Size} Size.
 * @api
 */
function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */ (size);
    }
    return opt_size;
  }
}

//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/ol/source/Image.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/Image.js ***!
  \*****************************************/
/*! exports provided: defaultImageLoadFunction, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultImageLoadFunction", function() { return defaultImageLoadFunction; });
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Image_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../reproj/Image.js */ "./node_modules/ol/reproj/Image.js");
/* harmony import */ var _source_Source_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../source/Source.js */ "./node_modules/ol/source/Source.js");
/**
 * @module ol/source/Image
 */











/**
 * @enum {string}
 */
var ImageSourceEventType = {

  /**
   * Triggered when an image starts loading.
   * @event ol/source/Image~ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event ol/source/Image~ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event ol/source/Image~ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'

};


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */
var ImageSourceEvent = (function (Event) {
  function ImageSourceEvent(type, image) {

    Event.call(this, type);

    /**
     * The image related to the event.
     * @type {module:ol/Image}
     * @api
     */
    this.image = image;

  }

  if ( Event ) ImageSourceEvent.__proto__ = Event;
  ImageSourceEvent.prototype = Object.create( Event && Event.prototype );
  ImageSourceEvent.prototype.constructor = ImageSourceEvent;

  return ImageSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {module:ol/extent~Extent} [extent]
 * @property {module:ol/proj~ProjectionLike} projection
 * @property {Array.<number>} [resolutions]
 * @property {module:ol/source/State} [state]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @api
 */
var ImageSource = (function (Source) {
  function ImageSource(options) {
    Source.call(this, {
      attributions: options.attributions,
      extent: options.extent,
      projection: options.projection,
      state: options.state
    });

    /**
     * @private
     * @type {Array.<number>}
     */
    this.resolutions_ = options.resolutions !== undefined ?
      options.resolutions : null;


    /**
     * @private
     * @type {module:ol/reproj/Image}
     */
    this.reprojectedImage_ = null;


    /**
     * @private
     * @type {number}
     */
    this.reprojectedRevision_ = 0;
  }

  if ( Source ) ImageSource.__proto__ = Source;
  ImageSource.prototype = Object.create( Source && Source.prototype );
  ImageSource.prototype.constructor = ImageSource;

  /**
   * @return {Array.<number>} Resolutions.
   * @override
   */
  ImageSource.prototype.getResolutions = function getResolutions () {
    return this.resolutions_;
  };

  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  ImageSource.prototype.findNearestResolution = function findNearestResolution (resolution) {
    if (this.resolutions_) {
      var idx = Object(_array_js__WEBPACK_IMPORTED_MODULE_2__["linearFindNearest"])(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  };

  /**
   * @param {module:ol/extent~Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {module:ol/ImageBase} Single image.
   */
  ImageSource.prototype.getImage = function getImage (extent, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection ||
        !projection ||
        Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["equivalent"])(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() &&
            Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["equivalent"])(
              this.reprojectedImage_.getProjection(), projection) &&
            this.reprojectedImage_.getResolution() == resolution &&
            Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["equals"])(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }

      this.reprojectedImage_ = new _reproj_Image_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        sourceProjection, projection, extent, resolution, pixelRatio,
        function(extent, resolution, pixelRatio) {
          return this.getImageInternal(extent, resolution,
            pixelRatio, sourceProjection);
        }.bind(this));
      this.reprojectedRevision_ = this.getRevision();

      return this.reprojectedImage_;
    }
  };

  /**
   * @abstract
   * @param {module:ol/extent~Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {module:ol/ImageBase} Single image.
   * @protected
   */
  ImageSource.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {};

  /**
   * Handle image change events.
   * @param {module:ol/events/Event} event Event.
   * @protected
   */
  ImageSource.prototype.handleImageChange = function handleImageChange (event) {
    var image = /** @type {module:ol/Image} */ (event.target);
    switch (image.getState()) {
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING:
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART,
            image));
        break;
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED:
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND,
            image));
        break;
      case _ImageState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR:
        this.dispatchEvent(
          new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR,
            image));
        break;
      default:
        // pass
    }
  };

  return ImageSource;
}(_source_Source_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * Default image load function for image sources that use module:ol/Image~Image image
 * instances.
 * @param {module:ol/Image} image Image.
 * @param {string} src Source.
 */
function defaultImageLoadFunction(image, src) {
  image.getImage().src = src;
}


/* harmony default export */ __webpack_exports__["default"] = (ImageSource);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/source/ImageCanvas.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/source/ImageCanvas.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ImageCanvas.js */ "./node_modules/ol/ImageCanvas.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _source_Image_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../source/Image.js */ "./node_modules/ol/source/Image.js");
/**
 * @module ol/source/ImageCanvas
 */






/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and
 * {@link module:ol/proj/Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:ol/source/ImageCanvas}.
 *
 * @typedef {function(this:module:ol/ImageCanvas, module:ol/extent~Extent, number,
 *     number, module:ol/size~Size, module:ol/proj/Projection): HTMLCanvasElement} FunctionType
 */


/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {module:ol/source/ImageCanvas~FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: `{module:ol/extent~Extent}` the
 * image extent, `{number}` the image resolution, `{number}` the device pixel
 * ratio, `{module:ol/size~Size}` the image size, and `{module:ol/proj/Projection~Projection}` the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See @link: {@link module:ol/Observable~Observable#changed}
 * @property {module:ol/proj~ProjectionLike} projection Projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array.<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {module:ol/source/State} [state] Source state.
 */


/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */
var ImageCanvasSource = (function (ImageSource) {
  function ImageCanvasSource(options) {

    ImageSource.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    });

    /**
    * @private
    * @type {module:ol/source/ImageCanvas~FunctionType}
    */
    this.canvasFunction_ = options.canvasFunction;

    /**
    * @private
    * @type {module:ol/ImageCanvas}
    */
    this.canvas_ = null;

    /**
    * @private
    * @type {number}
    */
    this.renderedRevision_ = 0;

    /**
    * @private
    * @type {number}
    */
    this.ratio_ = options.ratio !== undefined ?
      options.ratio : 1.5;

  }

  if ( ImageSource ) ImageCanvasSource.__proto__ = ImageSource;
  ImageCanvasSource.prototype = Object.create( ImageSource && ImageSource.prototype );
  ImageCanvasSource.prototype.constructor = ImageCanvasSource;

  /**
  * @inheritDoc
  */
  ImageCanvasSource.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);

    var canvas = this.canvas_;
    if (canvas &&
       this.renderedRevision_ == this.getRevision() &&
       canvas.getResolution() == resolution &&
       canvas.getPixelRatio() == pixelRatio &&
       Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["containsExtent"])(canvas.getExtent(), extent)) {
      return canvas;
    }

    extent = extent.slice();
    Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["scaleFromCenter"])(extent, this.ratio_);
    var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getWidth"])(extent) / resolution;
    var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getHeight"])(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];

    var canvasElement = this.canvasFunction_(
      extent, resolution, pixelRatio, size, projection);
    if (canvasElement) {
      canvas = new _ImageCanvas_js__WEBPACK_IMPORTED_MODULE_0__["default"](extent, resolution, pixelRatio, canvasElement);
    }
    this.canvas_ = canvas;
    this.renderedRevision_ = this.getRevision();

    return canvas;
  };

  return ImageCanvasSource;
}(_source_Image_js__WEBPACK_IMPORTED_MODULE_2__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (ImageCanvasSource);

//# sourceMappingURL=ImageCanvas.js.map

/***/ }),

/***/ "./node_modules/ol/source/OSM.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/OSM.js ***!
  \***************************************/
/*! exports provided: ATTRIBUTION, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTION", function() { return ATTRIBUTION; });
/* harmony import */ var _source_XYZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../source/XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/OSM
 */




/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&copy; ' +
      '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
      'contributors.';


/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */
var OSM = (function (XYZ) {
  function OSM(opt_options) {

    var options = opt_options || {};

    var attributions;
    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ?
      options.crossOrigin : 'anonymous';

    var url = options.url !== undefined ?
      options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

    XYZ.call(this, {
      attributions: attributions,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      opaque: options.opaque !== undefined ? options.opaque : true,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX
    });

  }

  if ( XYZ ) OSM.__proto__ = XYZ;
  OSM.prototype = Object.create( XYZ && XYZ.prototype );
  OSM.prototype.constructor = OSM;

  return OSM;
}(_source_XYZ_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (OSM);

//# sourceMappingURL=OSM.js.map

/***/ }),

/***/ "./node_modules/ol/source/Source.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Source.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/**
 * @module ol/source/Source
 */







/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(module:ol/PluggableMap~FrameState): (string|Array.<string>)} Attribution
 */


/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
 *
 * @typedef {string|Array.<string>|module:ol/source/Source~Attribution} AttributionLike
 */


/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {module:ol/proj~ProjectionLike} projection
 * @property {module:ol/source/State} [state]
 * @property {boolean} [wrapX]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @api
 */
var Source = (function (BaseObject) {
  function Source(options) {

    BaseObject.call(this);

    /**
    * @private
    * @type {module:ol/proj/Projection}
    */
    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(options.projection);

    /**
    * @private
    * @type {?module:ol/source/Source~Attribution}
    */
    this.attributions_ = this.adaptAttributions_(options.attributions);

    /**
    * @private
    * @type {module:ol/source/State}
    */
    this.state_ = options.state !== undefined ?
      options.state : _source_State_js__WEBPACK_IMPORTED_MODULE_3__["default"].READY;

    /**
    * @private
    * @type {boolean}
    */
    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

  }

  if ( BaseObject ) Source.__proto__ = BaseObject;
  Source.prototype = Object.create( BaseObject && BaseObject.prototype );
  Source.prototype.constructor = Source;

  /**
  * Turns the attributions option into an attributions function.
  * @param {module:ol/source/Source~AttributionLike|undefined} attributionLike The attribution option.
  * @return {?module:ol/source/Source~Attribution} An attribution function (or null).
  */
  Source.prototype.adaptAttributions_ = function adaptAttributions_ (attributionLike) {
    if (!attributionLike) {
      return null;
    }
    if (Array.isArray(attributionLike)) {
      return function(frameState) {
        return attributionLike;
      };
    }

    if (typeof attributionLike === 'function') {
      return attributionLike;
    }

    return function(frameState) {
      return [attributionLike];
    };
  };

  /**
  * Get the attribution function for the source.
  * @return {?module:ol/source/Source~Attribution} Attribution function.
  */
  Source.prototype.getAttributions = function getAttributions () {
    return this.attributions_;
  };

  /**
  * Get the projection of the source.
  * @return {module:ol/proj/Projection} Projection.
  * @api
  */
  Source.prototype.getProjection = function getProjection () {
    return this.projection_;
  };

  /**
  * @abstract
  * @return {Array.<number>|undefined} Resolutions.
  */
  Source.prototype.getResolutions = function getResolutions () {};

  /**
  * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
  * @return {module:ol/source/State} State.
  * @api
  */
  Source.prototype.getState = function getState () {
    return this.state_;
  };

  /**
  * @return {boolean|undefined} Wrap X.
  */
  Source.prototype.getWrapX = function getWrapX () {
    return this.wrapX_;
  };

  /**
  * Refreshes the source and finally dispatches a 'change' event.
  * @api
  */
  Source.prototype.refresh = function refresh () {
    this.changed();
  };

  /**
  * Set the attributions of the source.
  * @param {module:ol/source/Source~AttributionLike|undefined} attributions Attributions.
  *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
  *     or `undefined`.
  * @api
  */
  Source.prototype.setAttributions = function setAttributions (attributions) {
    this.attributions_ = this.adaptAttributions_(attributions);
    this.changed();
  };

  /**
  * Set the state of the source.
  * @param {module:ol/source/State} state State.
  * @protected
  */
  Source.prototype.setState = function setState (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/**
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
Source.prototype.forEachFeatureAtCoordinate = _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];


/* harmony default export */ __webpack_exports__["default"] = (Source);

//# sourceMappingURL=Source.js.map

/***/ }),

/***/ "./node_modules/ol/source/Stamen.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Stamen.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _source_OSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../source/OSM.js */ "./node_modules/ol/source/OSM.js");
/* harmony import */ var _source_XYZ_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../source/XYZ.js */ "./node_modules/ol/source/XYZ.js");
/**
 * @module ol/source/Stamen
 */





/**
 * @const
 * @type {Array.<string>}
 */
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' +
        'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' +
        ' 3.0</a>.',
  _source_OSM_js__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTION"]
];


/**
 * @type {Object.<string, {extension: string, opaque: boolean}>}
 */
var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};


/**
 * @type {Object.<string, {minZoom: number, maxZoom: number}>}
 */
var ProviderConfig = {
  'terrain': {
    minZoom: 4,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 1,
    maxZoom: 16
  }
};


/**
 * @typedef {Object} Options
 * @property {number} [cacheSize=2048] Cache size.
 * @property {string} [layer] Layer.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {boolean} [opaque] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */


/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */
var Stamen = (function (XYZ) {
  function Stamen(options) {
    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];

    var layerConfig = LayerConfig[options.layer];

    var url = options.url !== undefined ? options.url :
      'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer +
        '/{z}/{x}/{y}.' + layerConfig.extension;

    XYZ.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      url: url,
      wrapX: options.wrapX
    });

  }

  if ( XYZ ) Stamen.__proto__ = XYZ;
  Stamen.prototype = Object.create( XYZ && XYZ.prototype );
  Stamen.prototype.constructor = Stamen;

  return Stamen;
}(_source_XYZ_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (Stamen);

//# sourceMappingURL=Stamen.js.map

/***/ }),

/***/ "./node_modules/ol/source/State.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/source/State.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/State
 */

/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
});

//# sourceMappingURL=State.js.map

/***/ }),

/***/ "./node_modules/ol/source/Tile.js":
/*!****************************************!*\
  !*** ./node_modules/ol/source/Tile.js ***!
  \****************************************/
/*! exports provided: TileSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileSourceEvent", function() { return TileSourceEvent; });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _source_Source_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../source/Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/Tile
 */











/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {number} [tilePixelRatio]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @api
 */
var TileSource = (function (Source) {
  function TileSource(options) {

    Source.call(this, {
      attributions: options.attributions,
      extent: options.extent,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    });

    /**
     * @private
     * @type {boolean}
     */
    this.opaque_ = options.opaque !== undefined ? options.opaque : false;

    /**
     * @private
     * @type {number}
     */
    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?
      options.tilePixelRatio : 1;

    /**
     * @protected
     * @type {module:ol/tilegrid/TileGrid}
     */
    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

    /**
     * @protected
     * @type {module:ol/TileCache}
     */
    this.tileCache = new _TileCache_js__WEBPACK_IMPORTED_MODULE_1__["default"](options.cacheSize);

    /**
     * @protected
     * @type {module:ol/size~Size}
     */
    this.tmpSize = [0, 0];

    /**
     * @private
     * @type {string}
     */
    this.key_ = '';

    /**
     * @protected
     * @type {module:ol/Tile~Options}
     */
    this.tileOptions = {transition: options.transition};

  }

  if ( Source ) TileSource.__proto__ = Source;
  TileSource.prototype = Object.create( Source && Source.prototype );
  TileSource.prototype.constructor = TileSource;

  /**
   * @return {boolean} Can expire cache.
   */
  TileSource.prototype.canExpireCache = function canExpireCache () {
    return this.tileCache.canExpireCache();
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
   */
  TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @param {number} z Zoom level.
   * @param {module:ol/TileRange} tileRange Tile range.
   * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["getKeyZXY"])(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile = /** @type {!module:ol/Tile} */ (tileCache.get(tileCoordKey));
          loaded = tile.getState() === _TileState_js__WEBPACK_IMPORTED_MODULE_2__["default"].LOADED;
          if (loaded) {
            loaded = (callback(tile) !== false);
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {number} Gutter.
   */
  TileSource.prototype.getGutter = function getGutter (projection) {
    return 0;
  };

  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */
  TileSource.prototype.getKey = function getKey () {
    return this.key_;
  };

  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  TileSource.prototype.setKey = function setKey (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {boolean} Opaque.
   */
  TileSource.prototype.getOpaque = function getOpaque (projection) {
    return this.opaque_;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.getResolutions = function getResolutions () {
    return this.tileGrid.getResolutions();
  };

  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {!module:ol/Tile} Tile.
   */
  TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {};

  /**
   * Return the tile grid of the tile source.
   * @return {module:ol/tilegrid/TileGrid} Tile grid.
   * @api
   */
  TileSource.prototype.getTileGrid = function getTileGrid () {
    return this.tileGrid;
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {!module:ol/tilegrid/TileGrid} Tile grid.
   */
  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!this.tileGrid) {
      return Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["getForProjection"])(projection);
    } else {
      return this.tileGrid;
    }
  };

  /**
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {module:ol/TileCache} Tile cache.
   * @protected
   */
  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    var thisProj = this.getProjection();
    if (thisProj && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["equivalent"])(thisProj, projection)) {
      return null;
    } else {
      return this.tileCache;
    }
  };

  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
    return this.tilePixelRatio_;
  };

  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @return {module:ol/size~Size} Tile size.
   */
  TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["toSize"])(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return Object(_size_js__WEBPACK_IMPORTED_MODULE_5__["scale"])(tileSize, tilePixelRatio, this.tmpSize);
    }
  };

  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
   * @param {module:ol/proj/Projection=} opt_projection Projection.
   * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ?
      opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_8__["wrapX"])(tileGrid, tileCoord, projection);
    }
    return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["withinExtentAndZ"])(tileCoord, tileGrid) ? tileCoord : null;
  };

  /**
   * @inheritDoc
   */
  TileSource.prototype.refresh = function refresh () {
    this.tileCache.clear();
    this.changed();
  };

  return TileSource;
}(_source_Source_js__WEBPACK_IMPORTED_MODULE_6__["default"]));


/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {module:ol/proj/Projection} projection Projection.
 */
TileSource.prototype.useTile = _functions_js__WEBPACK_IMPORTED_MODULE_0__["UNDEFINED"];


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */
var TileSourceEvent = (function (Event) {
  function TileSourceEvent(type, tile) {

    Event.call(this, type);

    /**
     * The tile related to the event.
     * @type {module:ol/Tile}
     * @api
     */
    this.tile = tile;

  }

  if ( Event ) TileSourceEvent.__proto__ = Event;
  TileSourceEvent.prototype = Object.create( Event && Event.prototype );
  TileSourceEvent.prototype.constructor = TileSourceEvent;

  return TileSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (TileSource);

//# sourceMappingURL=Tile.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileEventType.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/source/TileEventType.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({

  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile~TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile~TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

});

//# sourceMappingURL=TileEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/TileImage.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/source/TileImage.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reproj_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../reproj/common.js */ "./node_modules/ol/reproj/common.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageTile.js */ "./node_modules/ol/ImageTile.js");
/* harmony import */ var _TileCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../TileCache.js */ "./node_modules/ol/TileCache.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../reproj/Tile.js */ "./node_modules/ol/reproj/Tile.js");
/* harmony import */ var _source_UrlTile_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../source/UrlTile.js */ "./node_modules/ol/source/UrlTile.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/TileImage
 */













/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} projection Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {module:ol/source/State} [state] Source state.
 * @property {module:ol/ImageTile~TileClass} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires module:ol/source/Tile~TileSourceEvent
 * @api
 */
var TileImage = (function (UrlTile) {
  function TileImage(options) {

    UrlTile.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      extent: options.extent,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ?
        options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition
    });

    /**
     * @protected
     * @type {?string}
     */
    this.crossOrigin =
        options.crossOrigin !== undefined ? options.crossOrigin : null;

    /**
     * @protected
     * @type {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,
     *        ?string, module:ol/Tile~LoadFunction, module:ol/Tile~Options=)}
     */
    this.tileClass = options.tileClass !== undefined ?
      options.tileClass : _ImageTile_js__WEBPACK_IMPORTED_MODULE_2__["default"];

    /**
     * @protected
     * @type {!Object.<string, module:ol/TileCache>}
     */
    this.tileCacheForProjection = {};

    /**
     * @protected
     * @type {!Object.<string, module:ol/tilegrid/TileGrid>}
     */
    this.tileGridForProjection = {};

    /**
     * @private
     * @type {number|undefined}
     */
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

    /**
     * @private
     * @type {boolean}
     */
    this.renderReprojectionEdges_ = false;
  }

  if ( UrlTile ) TileImage.__proto__ = UrlTile;
  TileImage.prototype = Object.create( UrlTile && UrlTile.prototype );
  TileImage.prototype.constructor = TileImage;

  /**
   * @inheritDoc
   */
  TileImage.prototype.canExpireCache = function canExpireCache () {
    var this$1 = this;

    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.canExpireCache.call(this);
    }
    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this$1.tileCacheForProjection) {
        if (this$1.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {
    var this$1 = this;

    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      UrlTile.prototype.expireCache.call(this, projection, usedTiles);
      return;
    }
    var usedTileCache = this.getTileCacheForProjection(projection);

    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
    for (var id in this$1.tileCacheForProjection) {
      var tileCache = this$1.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getGutter = function getGutter (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutterInternal();
    }
  };

  /**
   * @protected
   * @return {number} Gutter.
   */
  TileImage.prototype.getGutterInternal = function getGutterInternal () {
    return 0;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getOpaque = function getOpaque (projection) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] &&
        this.getProjection() && projection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(this.getProjection(), projection)) {
      return false;
    } else {
      return UrlTile.prototype.getOpaque.call(this, projection);
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileGridForProjection.call(this, projection);
    }
    var thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_11__["getForProjection"])(projection);
      }
      return (
        /** @type {!module:ol/tilegrid/TileGrid} */ (this.tileGridForProjection[projKey])
      );
    }
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);
    }
    var thisProj = this.getProjection(); if (!thisProj || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(projection).toString();
      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.tileCache.highWaterMark);
      }
      return this.tileCacheForProjection[projKey];
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {module:ol/proj/Projection} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!module:ol/Tile} Tile.
   * @private
   */
  TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord, projection);
    var tileUrl = urlTileCoord ?
      this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(
      tileCoord,
      tileUrl !== undefined ? _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE : _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].EMPTY,
      tileUrl !== undefined ? tileUrl : '',
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions);
    tile.key = key;
    Object(_events_js__WEBPACK_IMPORTED_MODULE_5__["listen"])(tile, _events_EventType_js__WEBPACK_IMPORTED_MODULE_6__["default"].CHANGE,
      this.handleTileChange, this);
    return tile;
  };

  /**
   * @inheritDoc
   */
  TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
    var sourceProjection = /** @type {!module:ol/proj/Projection} */ (this.getProjection());
    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        !sourceProjection || !projection || Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["equivalent"])(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile;
      var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKey"])(tileCoord);
      if (cache.containsKey(tileCoordKey)) {
        tile = /** @type {!module:ol/Tile} */ (cache.get(tileCoordKey));
      }
      var key = this.getKey();
      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord =
            this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _reproj_Tile_js__WEBPACK_IMPORTED_MODULE_8__["default"](
          sourceProjection, sourceTileGrid,
          projection, targetTileGrid,
          tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),
          this.getGutterInternal(),
          function(z, x, y, pixelRatio) {
            return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
          }.bind(this), this.reprojectionErrorThreshold_,
          this.renderReprojectionEdges_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }
        return newTile;
      }
    }
  };

  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!module:ol/proj/Projection} projection Projection.
   * @return {!module:ol/Tile} Tile.
   * @protected
   */
  TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_10__["getKeyZXY"])(z, x, y);
    var key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);
      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key);

        //make the new tile the head of the list,
        if (interimTile.getState() == _TileState_js__WEBPACK_IMPORTED_MODULE_4__["default"].IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }
        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }
    return tile;
  };

  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {
    var this$1 = this;

    if (!_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"] ||
        this.renderReprojectionEdges_ == render) {
      return;
    }
    this.renderReprojectionEdges_ = render;
    for (var id in this$1.tileCacheForProjection) {
      this$1.tileCacheForProjection[id].clear();
    }
    this.changed();
  };

  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {module:ol/proj~ProjectionLike} projection Projection.
   * @param {module:ol/tilegrid/TileGrid} tilegrid Tile grid to use for the projection.
   * @api
   */
  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {
    if (_reproj_common_js__WEBPACK_IMPORTED_MODULE_0__["ENABLE_RASTER_REPROJECTION"]) {
      var proj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection);
      if (proj) {
        var projKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_1__["getUid"])(proj).toString();
        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_source_UrlTile_js__WEBPACK_IMPORTED_MODULE_9__["default"]));


/**
 * @param {module:ol/ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}

/* harmony default export */ __webpack_exports__["default"] = (TileImage);

//# sourceMappingURL=TileImage.js.map

/***/ }),

/***/ "./node_modules/ol/source/UrlTile.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/source/UrlTile.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _TileState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../TileState.js */ "./node_modules/ol/TileState.js");
/* harmony import */ var _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tileurlfunction.js */ "./node_modules/ol/tileurlfunction.js");
/* harmony import */ var _source_Tile_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../source/Tile.js */ "./node_modules/ol/source/Tile.js");
/* harmony import */ var _source_TileEventType_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../source/TileEventType.js */ "./node_modules/ol/source/TileEventType.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/source/UrlTile
 */







/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions]
 * @property {number} [cacheSize]
 * @property {module:ol/extent~Extent} [extent]
 * @property {boolean} [opaque]
 * @property {module:ol/proj~ProjectionLike} [projection]
 * @property {module:ol/source/State} [state]
 * @property {module:ol/tilegrid/TileGrid} [tileGrid]
 * @property {module:ol/Tile~LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array.<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 */


/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires module:ol/source/TileEvent
 */
var UrlTile = (function (TileSource) {
  function UrlTile(options) {

    TileSource.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      extent: options.extent,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition
    });

    /**
     * @protected
     * @type {module:ol/Tile~LoadFunction}
     */
    this.tileLoadFunction = options.tileLoadFunction;

    /**
     * @protected
     * @type {module:ol/Tile~UrlFunction}
     */
    this.tileUrlFunction = this.fixedTileUrlFunction ?
      this.fixedTileUrlFunction.bind(this) : _tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["nullTileUrlFunction"];

    /**
     * @protected
     * @type {!Array.<string>|null}
     */
    this.urls = null;

    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    if (options.tileUrlFunction) {
      this.setTileUrlFunction(options.tileUrlFunction);
    }

    /**
     * @private
     * @type {!Object.<number, boolean>}
     */
    this.tileLoadingKeys_ = {};

  }

  if ( TileSource ) UrlTile.__proto__ = TileSource;
  UrlTile.prototype = Object.create( TileSource && TileSource.prototype );
  UrlTile.prototype.constructor = UrlTile;

  /**
   * Return the tile load function of the source.
   * @return {module:ol/Tile~LoadFunction} TileLoadFunction
   * @api
   */
  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {
    return this.tileLoadFunction;
  };

  /**
   * Return the tile URL function of the source.
   * @return {module:ol/Tile~UrlFunction} TileUrlFunction
   * @api
   */
  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {
    return this.tileUrlFunction;
  };

  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array.<string>|null} URLs.
   * @api
   */
  UrlTile.prototype.getUrls = function getUrls () {
    return this.urls;
  };

  /**
   * Handle tile change events.
   * @param {module:ol/events/Event} event Event.
   * @protected
   */
  UrlTile.prototype.handleTileChange = function handleTileChange (event) {
    var tile = /** @type {module:ol/Tile} */ (event.target);
    var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(tile);
    var tileState = tile.getState();
    var type;
    if (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _source_TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR ? _source_TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADERROR :
        (tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].LOADED || tileState == _TileState_js__WEBPACK_IMPORTED_MODULE_1__["default"].ABORT) ?
          _source_TileEventType_js__WEBPACK_IMPORTED_MODULE_4__["default"].TILELOADEND : undefined;
    }
    if (type != undefined) {
      this.dispatchEvent(new _source_Tile_js__WEBPACK_IMPORTED_MODULE_3__["TileSourceEvent"](type, tile));
    }
  };

  /**
   * Set the tile load function of the source.
   * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };

  /**
   * Set the tile URL function of the source.
   * @param {module:ol/Tile~UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} opt_key Optional new tile key for the source.
   * @api
   */
  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, opt_key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof opt_key !== 'undefined') {
      this.setKey(opt_key);
    } else {
      this.changed();
    }
  };

  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  UrlTile.prototype.setUrl = function setUrl (url) {
    var urls = this.urls = Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["expandUrl"])(url);
    this.setTileUrlFunction(this.fixedTileUrlFunction ?
      this.fixedTileUrlFunction.bind(this) :
      Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(urls, this.tileGrid), url);
  };

  /**
   * Set the URLs to use for requests.
   * @param {Array.<string>} urls URLs.
   * @api
   */
  UrlTile.prototype.setUrls = function setUrls (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    this.setTileUrlFunction(this.fixedTileUrlFunction ?
      this.fixedTileUrlFunction.bind(this) :
      Object(_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_2__["createFromTemplates"])(urls, this.tileGrid), key);
  };

  /**
   * @inheritDoc
   */
  UrlTile.prototype.useTile = function useTile (z, x, y) {
    var tileCoordKey = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_5__["getKeyZXY"])(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_source_Tile_js__WEBPACK_IMPORTED_MODULE_3__["default"]));


/**
 * @type {module:ol/Tile~UrlFunction|undefined}
 * @protected
 */
UrlTile.prototype.fixedTileUrlFunction;

/* harmony default export */ __webpack_exports__["default"] = (UrlTile);

//# sourceMappingURL=UrlTile.js.map

/***/ }),

/***/ "./node_modules/ol/source/Vector.js":
/*!******************************************!*\
  !*** ./node_modules/ol/source/Vector.js ***!
  \******************************************/
/*! exports provided: VectorSourceEvent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorSourceEvent", function() { return VectorSourceEvent; });
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Collection.js */ "./node_modules/ol/Collection.js");
/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CollectionEventType.js */ "./node_modules/ol/CollectionEventType.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../events.js */ "./node_modules/ol/events.js");
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _featureloader_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../featureloader.js */ "./node_modules/ol/featureloader.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../loadingstrategy.js */ "./node_modules/ol/loadingstrategy.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _source_Source_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../source/Source.js */ "./node_modules/ol/source/Source.js");
/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../source/State.js */ "./node_modules/ol/source/State.js");
/* harmony import */ var _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../source/VectorEventType.js */ "./node_modules/ol/source/VectorEventType.js");
/* harmony import */ var _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../structs/RBush.js */ "./node_modules/ol/structs/RBush.js");
/**
 * @module ol/source/Vector
 */




















/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(module:ol/extent~Extent, number): Array.<module:ol/extent~Extent>} LoadingStrategy
 * @api
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 */
var VectorSourceEvent = (function (Event) {
  function VectorSourceEvent(type, opt_feature) {

    Event.call(this, type);

    /**
     * The feature being added or removed.
     * @type {module:ol/Feature|undefined}
     * @api
     */
    this.feature = opt_feature;

  }

  if ( Event ) VectorSourceEvent.__proto__ = Event;
  VectorSourceEvent.prototype = Object.create( Event && Event.prototype );
  VectorSourceEvent.prototype.constructor = VectorSourceEvent;

  return VectorSourceEvent;
}(_events_Event_js__WEBPACK_IMPORTED_MODULE_7__["default"]));


/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {Array.<module:ol/Feature>|module:ol/Collection.<module:ol/Feature>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {module:ol/format/Feature} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {module:ol/featureloader~FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {module:ol/source/Vector~LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|module:ol/featureloader~FeatureUrlfunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlfunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */


/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires ol/source/Vector~VectorSourceEvent
 * @api
 */
var VectorSource = (function (Source) {
  function VectorSource(opt_options) {

    var options = opt_options || {};

    Source.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _source_State_js__WEBPACK_IMPORTED_MODULE_15__["default"].READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    });

    /**
     * @private
     * @type {module:ol/featureloader~FeatureLoader}
     */
    this.loader_ = _functions_js__WEBPACK_IMPORTED_MODULE_11__["UNDEFINED"];

    /**
     * @private
     * @type {module:ol/format/Feature|undefined}
     */
    this.format_ = options.format;

    /**
     * @private
     * @type {boolean}
     */
    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

    /**
     * @private
     * @type {string|module:ol/featureloader~FeatureUrlFunction|undefined}
     */
    this.url_ = options.url;

    if (options.loader !== undefined) {
      this.loader_ = options.loader;
    } else if (this.url_ !== undefined) {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"
      this.loader_ = Object(_featureloader_js__WEBPACK_IMPORTED_MODULE_10__["xhr"])(this.url_, /** @type {module:ol/format/Feature} */ (this.format_));
    }

    /**
     * @private
     * @type {module:ol/source/Vector~LoadingStrategy}
     */
    this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy_js__WEBPACK_IMPORTED_MODULE_12__["all"];

    var useSpatialIndex =
        options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

    /**
     * @private
     * @type {module:ol/structs/RBush.<module:ol/Feature>}
     */
    this.featuresRtree_ = useSpatialIndex ? new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]() : null;

    /**
     * @private
     * @type {module:ol/structs/RBush.<{extent: module:ol/extent~Extent}>}
     */
    this.loadedExtentsRtree_ = new _structs_RBush_js__WEBPACK_IMPORTED_MODULE_17__["default"]();

    /**
     * @private
     * @type {!Object.<string, module:ol/Feature>}
     */
    this.nullGeometryFeatures_ = {};

    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object.<string, module:ol/Feature>}
     */
    this.idIndex_ = {};

    /**
     * A lookup of features without id (keyed by getUid(feature)).
     * @private
     * @type {!Object.<string, module:ol/Feature>}
     */
    this.undefIdIndex_ = {};

    /**
     * @private
     * @type {Object.<string, Array.<module:ol/events~EventsKey>>}
     */
    this.featureChangeKeys_ = {};

    /**
     * @private
     * @type {module:ol/Collection.<module:ol/Feature>}
     */
    this.featuresCollection_ = null;

    var collection, features;
    if (options.features instanceof _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"]) {
      collection = options.features;
      features = collection.getArray();
    } else if (Array.isArray(options.features)) {
      features = options.features;
    }
    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection_js__WEBPACK_IMPORTED_MODULE_1__["default"](features);
    }
    if (features !== undefined) {
      this.addFeaturesInternal(features);
    }
    if (collection !== undefined) {
      this.bindFeaturesCollection_(collection);
    }

  }

  if ( Source ) VectorSource.__proto__ = Source;
  VectorSource.prototype = Object.create( Source && Source.prototype );
  VectorSource.prototype.constructor = VectorSource;

  return VectorSource;
}(_source_Source_js__WEBPACK_IMPORTED_MODULE_14__["default"]));


/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
 * instead. A feature will not be added to the source if feature with
 * the same id is already there. The reason for this behavior is to avoid
 * feature duplication when using bbox or tile loading strategies.
 * @param {module:ol/Feature} feature Feature to add.
 * @api
 */
VectorSource.prototype.addFeature = function(feature) {
  this.addFeatureInternal(feature);
  this.changed();
};


/**
 * Add a feature without firing a `change` event.
 * @param {module:ol/Feature} feature Feature.
 * @protected
 */
VectorSource.prototype.addFeatureInternal = function(feature) {
  var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();

  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }

  this.setupChangeEvents_(featureKey, feature);

  var geometry = feature.getGeometry();
  if (geometry) {
    var extent = geometry.getExtent();
    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }

  this.dispatchEvent(
    new VectorSourceEvent(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, feature));
};


/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {module:ol/Feature} feature The feature.
 * @private
 */
VectorSource.prototype.setupChangeEvents_ = function(featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _events_EventType_js__WEBPACK_IMPORTED_MODULE_8__["default"].CHANGE,
      this.handleFeatureChange_, this),
    Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(feature, _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE,
      this.handleFeatureChange_, this)
  ];
};


/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {module:ol/Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */
VectorSource.prototype.addToIndex_ = function(featureKey, feature) {
  var valid = true;
  var id = feature.getId();
  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_5__["assert"])(!(featureKey in this.undefIdIndex_),
      30); // The passed `feature` was already added to the source
    this.undefIdIndex_[featureKey] = feature;
  }
  return valid;
};


/**
 * Add a batch of features to the source.
 * @param {Array.<module:ol/Feature>} features Features to add.
 * @api
 */
VectorSource.prototype.addFeatures = function(features) {
  this.addFeaturesInternal(features);
  this.changed();
};


/**
 * Add features without firing a `change` event.
 * @param {Array.<module:ol/Feature>} features Features.
 * @protected
 */
VectorSource.prototype.addFeaturesInternal = function(features) {
  var this$1 = this;

  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];

  for (var i = 0, length = features.length; i < length; i++) {
    var feature = features[i];
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
    if (this$1.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }

  for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {
    var feature$1 = newFeatures[i$1];
    var featureKey$1 = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature$1).toString();
    this$1.setupChangeEvents_(featureKey$1, feature$1);

    var geometry = feature$1.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature$1);
    } else {
      this$1.nullGeometryFeatures_[featureKey$1] = feature$1;
    }
  }
  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }

  for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {
    this$1.dispatchEvent(new VectorSourceEvent(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE, newFeatures[i$2]));
  }
};


/**
 * @param {!module:ol/Collection.<module:ol/Feature>} collection Collection.
 * @private
 */
VectorSource.prototype.bindFeaturesCollection_ = function(collection) {
  var modifyingCollection = false;
  Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].ADDFEATURE,
    function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
  Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(this, _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE,
    function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
  Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].ADD,
    function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(/** @type {module:ol/Feature} */ (evt.element));
        modifyingCollection = false;
      }
    }, this);
  Object(_events_js__WEBPACK_IMPORTED_MODULE_6__["listen"])(collection, _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].REMOVE,
    function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(/** @type {module:ol/Feature} */ (evt.element));
        modifyingCollection = false;
      }
    }, this);
  this.featuresCollection_ = collection;
};


/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector~VectorSourceEvent#removefeature} events.
 * @api
 */
VectorSource.prototype.clear = function(opt_fast) {
  var this$1 = this;

  if (opt_fast) {
    for (var featureId in this$1.featureChangeKeys_) {
      var keys = this$1.featureChangeKeys_[featureId];
      keys.forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
    }
    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);
      for (var id in this$1.nullGeometryFeatures_) {
        this$1.removeFeatureInternal(this$1.nullGeometryFeatures_[id]);
      }
    }
  }
  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }
  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};

  var clearEvent = new VectorSourceEvent(_source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};


/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 * Note: this function only iterate through the feature that have a defined geometry.
 *
 * @param {function(module:ol/Feature): T} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @return {T|undefined} The return value from the last call to the callback.
 * @template T
 * @api
 */
VectorSource.prototype.forEachFeature = function(callback) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback);
  }
};


/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {function(module:ol/Feature): T} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @return {T|undefined} The return value from the last call to the callback.
 * @template T
 */
VectorSource.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function(feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsCoordinate(coordinate)) {
      return callback(feature);
    } else {
      return undefined;
    }
  });
};


/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(module:ol/Feature): T} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @return {T|undefined} The return value from the last call to the callback.
 * @template T
 * @api
 */
VectorSource.prototype.forEachFeatureInExtent = function(extent, callback) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback);
  }
};


/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(module:ol/Feature): T} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @return {T|undefined} The return value from the last call to the callback.
 * @template T
 * @api
 */
VectorSource.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
  return this.forEachFeatureInExtent(extent,
    /**
     * @param {module:ol/Feature} feature Feature.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsExtent(extent)) {
        var result = callback(feature);
        if (result) {
          return result;
        }
      }
    });
};


/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link module:ol/Collection} as `features`.
 * @return {module:ol/Collection.<module:ol/Feature>} The collection of features.
 * @api
 */
VectorSource.prototype.getFeaturesCollection = function() {
  return this.featuresCollection_;
};


/**
 * Get all features on the source in random order.
 * @return {Array.<module:ol/Feature>} Features.
 * @api
 */
VectorSource.prototype.getFeatures = function() {
  var features;
  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else if (this.featuresRtree_) {
    features = this.featuresRtree_.getAll();
    if (!Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_)) {
      Object(_array_js__WEBPACK_IMPORTED_MODULE_4__["extend"])(features, Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["getValues"])(this.nullGeometryFeatures_));
    }
  }
  return (
    /** @type {Array.<module:ol/Feature>} */ (features)
  );
};


/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @return {Array.<module:ol/Feature>} Features.
 * @api
 */
VectorSource.prototype.getFeaturesAtCoordinate = function(coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
    features.push(feature);
  });
  return features;
};


/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {Array.<module:ol/Feature>} Features.
 * @api
 */
VectorSource.prototype.getFeaturesInExtent = function(extent) {
  return this.featuresRtree_.getInExtent(extent);
};


/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {function(module:ol/Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link module:ol/Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {module:ol/Feature} Closest feature.
 * @api
 */
VectorSource.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
  // Find the closest feature using branch and bound.  We start searching an
  // infinite extent, and find the distance from the first feature found.  This
  // becomes the closest feature.  We then compute a smaller extent which any
  // closer feature must intersect.  We continue searching with this smaller
  // extent, trying to find a closer feature.  Every time we find a closer
  // feature, we update the extent being searched so that any even closer
  // feature must intersect it.  We continue until we run out of features.
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : _functions_js__WEBPACK_IMPORTED_MODULE_11__["TRUE"];
  this.featuresRtree_.forEachInExtent(extent,
    /**
     * @param {module:ol/Feature} feature Feature.
     */
    function(feature) {
      if (filter(feature)) {
        var geometry = feature.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(
          x, y, closestPoint, minSquaredDistance);
        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature;
          // This is sneaky.  Reduce the extent that it is currently being
          // searched while the R-Tree traversal using this same extent object
          // is still in progress.  This is safe because the new extent is
          // strictly contained by the old extent.
          var minDistance = Math.sqrt(minSquaredDistance);
          extent[0] = x - minDistance;
          extent[1] = y - minDistance;
          extent[2] = x + minDistance;
          extent[3] = y + minDistance;
        }
      }
    });
  return closestFeature;
};


/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {module:ol/extent~Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
VectorSource.prototype.getExtent = function(opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};


/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {module:ol/Feature} The feature (or `null` if not found).
 * @api
 */
VectorSource.prototype.getFeatureById = function(id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};


/**
 * Get the format associated with this source.
 *
 * @return {module:ol/format/Feature|undefined} The feature format.
 * @api
 */
VectorSource.prototype.getFormat = function() {
  return this.format_;
};


/**
 * @return {boolean} The source can have overlapping geometries.
 */
VectorSource.prototype.getOverlaps = function() {
  return this.overlaps_;
};


/**
 * @override
 */
VectorSource.prototype.getResolutions = function() {};


/**
 * Get the url associated with this source.
 *
 * @return {string|module:ol/featureloader~FeatureUrlFunction|undefined} The url.
 * @api
 */
VectorSource.prototype.getUrl = function() {
  return this.url_;
};


/**
 * @param {module:ol/events/Event} event Event.
 * @private
 */
VectorSource.prototype.handleFeatureChange_ = function(event) {
  var feature = /** @type {module:ol/Feature} */ (event.target);
  var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
  var geometry = feature.getGeometry();
  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }
  var id = feature.getId();
  if (id !== undefined) {
    var sid = id.toString();
    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }
  this.changed();
  this.dispatchEvent(new VectorSourceEvent(
    _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].CHANGEFEATURE, feature));
};

/**
 * Returns true if the feature is contained within the source.
 * @param {module:ol/Feature} feature Feature.
 * @return {boolean} Has feature.
 * @api
 */
VectorSource.prototype.hasFeature = function(feature) {
  var id = feature.getId();
  if (id !== undefined) {
    return id in this.idIndex_;
  } else {
    var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
    return featureKey in this.undefIdIndex_;
  }
};

/**
 * @return {boolean} Is empty.
 */
VectorSource.prototype.isEmpty = function() {
  return this.featuresRtree_.isEmpty() && Object(_obj_js__WEBPACK_IMPORTED_MODULE_13__["isEmpty"])(this.nullGeometryFeatures_);
};


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {module:ol/proj/Projection} projection Projection.
 */
VectorSource.prototype.loadFeatures = function(extent, resolution, projection) {
  var this$1 = this;

  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var loop = function ( i, ii ) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
      /**
       * @param {{extent: module:ol/extent~Extent}} object Object.
       * @return {boolean} Contains.
       */
      function(object) {
        return Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["containsExtent"])(object.extent, extentToLoad);
      });
    if (!alreadyLoaded) {
      this$1.loader_.call(this$1, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
    }
  };

  for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) loop( i, ii );
};


/**
 * Remove an extent from the list of loaded extents.
 * @param {module:ol/extent~Extent} extent Extent.
 * @api
 */
VectorSource.prototype.removeLoadedExtent = function(extent) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var obj;
  loadedExtentsRtree.forEachInExtent(extent, function(object) {
    if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_9__["equals"])(object.extent, extent)) {
      obj = object;
      return true;
    }
  });
  if (obj) {
    loadedExtentsRtree.remove(obj);
  }
};


/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
 * instead.
 * @param {module:ol/Feature} feature Feature to remove.
 * @api
 */
VectorSource.prototype.removeFeature = function(feature) {
  var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }
  this.removeFeatureInternal(feature);
  this.changed();
};


/**
 * Remove feature without firing a `change` event.
 * @param {module:ol/Feature} feature Feature.
 * @protected
 */
VectorSource.prototype.removeFeatureInternal = function(feature) {
  var featureKey = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(feature).toString();
  this.featureChangeKeys_[featureKey].forEach(_events_js__WEBPACK_IMPORTED_MODULE_6__["unlistenByKey"]);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();
  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }
  this.dispatchEvent(new VectorSourceEvent(
    _source_VectorEventType_js__WEBPACK_IMPORTED_MODULE_16__["default"].REMOVEFEATURE, feature));
};


/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {module:ol/Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */
VectorSource.prototype.removeFromIdIndex_ = function(feature) {
  var this$1 = this;

  var removed = false;
  for (var id in this$1.idIndex_) {
    if (this$1.idIndex_[id] === feature) {
      delete this$1.idIndex_[id];
      removed = true;
      break;
    }
  }
  return removed;
};


/**
 * Set the new loader of the source. The next loadFeatures call will use the
 * new loader.
 * @param {module:ol/featureloader~FeatureLoader} loader The loader to set.
 * @api
 */
VectorSource.prototype.setLoader = function(loader) {
  this.loader_ = loader;
};

/* harmony default export */ __webpack_exports__["default"] = (VectorSource);

//# sourceMappingURL=Vector.js.map

/***/ }),

/***/ "./node_modules/ol/source/VectorEventType.js":
/*!***************************************************!*\
  !*** ./node_modules/ol/source/VectorEventType.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  /**
   * Triggered when a feature is added to the source.
   * @event ol/source/Vector~VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol/source/Vector~VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol/source/Vector~VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event ol/source/Vector~VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
});

//# sourceMappingURL=VectorEventType.js.map

/***/ }),

/***/ "./node_modules/ol/source/XYZ.js":
/*!***************************************!*\
  !*** ./node_modules/ol/source/XYZ.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _source_TileImage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../source/TileImage.js */ "./node_modules/ol/source/TileImage.js");
/* harmony import */ var _tilegrid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tilegrid.js */ "./node_modules/ol/tilegrid.js");
/**
 * @module ol/source/XYZ
 */




/**
 * @typedef {Object} Options
 * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize=2048] Cache size.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
 * access pixel data with the Canvas renderer.  See
 * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=18] Optional max zoom level.
 * @property {number} [minZoom=0] Optional min zoom level.
 * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
 * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if url or urls are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array.<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */


/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 * @api
 */
var XYZ = (function (TileImage) {
  function XYZ(opt_options) {
    var options = opt_options || {};
    var projection = options.projection !== undefined ?
      options.projection : 'EPSG:3857';

    var tileGrid = options.tileGrid !== undefined ? options.tileGrid :
      Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["createXYZ"])({
        extent: Object(_tilegrid_js__WEBPACK_IMPORTED_MODULE_1__["extentFromProjection"])(projection),
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });

    TileImage.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    });

  }

  if ( TileImage ) XYZ.__proto__ = TileImage;
  XYZ.prototype = Object.create( TileImage && TileImage.prototype );
  XYZ.prototype.constructor = XYZ;

  return XYZ;
}(_source_TileImage_js__WEBPACK_IMPORTED_MODULE_0__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (XYZ);

//# sourceMappingURL=XYZ.js.map

/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/*! exports provided: DEFAULT_RADIUS, getDistance, getLength, getArea, offset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLength", function() { return getLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "offset", function() { return offset; });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

/**
 * @module ol/sphere
 */




/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
 * earth is used (Clarke 1866 Authalic Sphere).
 */


/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;


/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
      Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
      Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}


/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}


/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}


/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<module:ol/coordinate~Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(x2 - x1) *
        (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y1)) +
        Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
}


/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {module:ol/geom/Geometry} geometry A geometry.
 * @param {module:ol/sphere~SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();
  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING:
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINEAR_RING: {
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON: {
      coordinates = /** @type {module:ol/geom/Polygon} */ (geometry).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON: {
      coordinates = /** @type {module:ol/geom/SimpleGeometry} */ (geometry).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION: {
      var geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], opt_options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}


/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {module:ol/coordinate~Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {module:ol/coordinate~Coordinate} The target point.
 */
function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[1]);
  var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toRadians"])(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__["toDegrees"])(lat)];
}

//# sourceMappingURL=sphere.js.map

/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/*! exports provided: padNumber, compareVersions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padNumber", function() { return padNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareVersions", function() { return compareVersions; });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}


/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}

//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/ol/structs/LRUCache.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/structs/LRUCache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../events/EventTarget.js */ "./node_modules/ol/events/EventTarget.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../events/EventType.js */ "./node_modules/ol/events/EventType.js");
/**
 * @module ol/structs/LRUCache
 */






/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */


/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires module:ol/events/Event~Event
 * @template T
 */
var LRUCache = (function (EventTarget) {
  function LRUCache(opt_highWaterMark) {

    EventTarget.call(this);

    /**
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

    /**
     * @private
     * @type {number}
     */
    this.count_ = 0;

    /**
     * @private
     * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}
     */
    this.entries_ = {};

    /**
     * @private
     * @type {?module:ol/structs/LRUCache~Entry}
     */
    this.oldest_ = null;

    /**
     * @private
     * @type {?module:ol/structs/LRUCache~Entry}
     */
    this.newest_ = null;

  }

  if ( EventTarget ) LRUCache.__proto__ = EventTarget;
  LRUCache.prototype = Object.create( EventTarget && EventTarget.prototype );
  LRUCache.prototype.constructor = LRUCache;


  /**
   * @return {boolean} Can expire cache.
   */
  LRUCache.prototype.canExpireCache = function canExpireCache () {
    return this.getCount() > this.highWaterMark;
  };


  /**
   * FIXME empty description for jsdoc
   */
  LRUCache.prototype.clear = function clear () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CLEAR);
  };


  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  LRUCache.prototype.containsKey = function containsKey (key) {
    return this.entries_.hasOwnProperty(key);
  };


  /**
   * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   * @param {S=} opt_this The object to use as `this` in `f`.
   * @template S
   */
  LRUCache.prototype.forEach = function forEach (f, opt_this) {
    var this$1 = this;

    var entry = this.oldest_;
    while (entry) {
      f.call(opt_this, entry.value_, entry.key_, this$1);
      entry = entry.newer;
    }
  };


  /**
   * @param {string} key Key.
   * @return {T} Value.
   */
  LRUCache.prototype.get = function get (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined,
      15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (this.oldest_.newer);
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };


  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  LRUCache.prototype.remove = function remove (key) {
    var entry = this.entries_[key];
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
    if (entry === this.newest_) {
      this.newest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.older);
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };


  /**
   * @return {number} Count.
   */
  LRUCache.prototype.getCount = function getCount () {
    return this.count_;
  };


  /**
   * @return {Array.<string>} Keys.
   */
  LRUCache.prototype.getKeys = function getKeys () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  };


  /**
   * @return {Array.<T>} Values.
   */
  LRUCache.prototype.getValues = function getValues () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  };


  /**
   * @return {T} Last value.
   */
  LRUCache.prototype.peekLast = function peekLast () {
    return this.oldest_.value_;
  };


  /**
   * @return {string} Last key.
   */
  LRUCache.prototype.peekLastKey = function peekLastKey () {
    return this.oldest_.key_;
  };


  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  LRUCache.prototype.peekFirstKey = function peekFirstKey () {
    return this.newest_.key_;
  };


  /**
   * @return {T} value Value.
   */
  LRUCache.prototype.pop = function pop () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.replace = function replace (key, value) {
    this.get(key); // update `newest_`
    this.entries_[key].value_ = value;
  };


  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  LRUCache.prototype.set = function set (key, value) {
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(key in this.entries_),
      16); // Tried to set a value for a key that is used already
    var entry = /** @type {module:ol/structs/LRUCache~Entry} */ ({
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    });
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };


  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  LRUCache.prototype.setSize = function setSize (size) {
    this.highWaterMark = size;
  };


  /**
   * Prune the cache.
   */
  LRUCache.prototype.prune = function prune () {
    var this$1 = this;

    while (this.canExpireCache()) {
      this$1.pop();
    }
  };

  return LRUCache;
}(_events_EventTarget_js__WEBPACK_IMPORTED_MODULE_1__["default"]));

/* harmony default export */ __webpack_exports__["default"] = (LRUCache);

//# sourceMappingURL=LRUCache.js.map

/***/ }),

/***/ "./node_modules/ol/structs/PriorityQueue.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/structs/PriorityQueue.js ***!
  \**************************************************/
/*! exports provided: DROP, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DROP", function() { return DROP; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/PriorityQueue
 */




/**
 * @type {number}
 */
var DROP = Infinity;


/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */
var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array.<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array.<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {!Object.<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};

};

/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.clear = function clear$1 () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_1__["clear"])(this.queuedElements_);
};


/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
PriorityQueue.prototype.dequeue = function dequeue () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};


/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
PriorityQueue.prototype.enqueue = function enqueue (element) {
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(!(this.keyFunction_(element) in this.queuedElements_),
    31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};


/**
 * @return {number} Count.
 */
PriorityQueue.prototype.getCount = function getCount () {
  return this.elements_.length;
};


/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_ (index) {
  return index * 2 + 1;
};


/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_ (index) {
  return index * 2 + 2;
};


/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
PriorityQueue.prototype.getParentIndex_ = function getParentIndex_ (index) {
  return (index - 1) >> 1;
};


/**
 * Make this a heap. O(N).
 * @private
 */
PriorityQueue.prototype.heapify_ = function heapify_ () {
    var this$1 = this;

  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this$1.siftUp_(i);
  }
};


/**
 * @return {boolean} Is empty.
 */
PriorityQueue.prototype.isEmpty = function isEmpty () {
  return this.elements_.length === 0;
};


/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
PriorityQueue.prototype.isKeyQueued = function isKeyQueued (key) {
  return key in this.queuedElements_;
};


/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
PriorityQueue.prototype.isQueued = function isQueued (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};


/**
 * @param {number} index The index of the node to move down.
 * @private
 */
PriorityQueue.prototype.siftUp_ = function siftUp_ (index) {
    var this$1 = this;

  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < (count >> 1)) {
    var lIndex = this$1.getLeftChildIndex_(index);
    var rIndex = this$1.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count &&
        priorities[rIndex] < priorities[lIndex] ?
      rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};


/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
PriorityQueue.prototype.siftDown_ = function siftDown_ (startIndex, index) {
    var this$1 = this;

  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this$1.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};


/**
 * FIXME empty description for jsdoc
 */
PriorityQueue.prototype.reprioritize = function reprioritize () {
    var this$1 = this;

  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == DROP) {
      delete this$1.queuedElements_[this$1.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};


/* harmony default export */ __webpack_exports__["default"] = (PriorityQueue);

//# sourceMappingURL=PriorityQueue.js.map

/***/ }),

/***/ "./node_modules/ol/structs/RBush.js":
/*!******************************************!*\
  !*** ./node_modules/ol/structs/RBush.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/structs/RBush
 */





/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush = function RBush(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = rbush__WEBPACK_IMPORTED_MODULE_1___default()(opt_maxEntries, undefined);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, module:ol/structs/RBush~Entry>}
   */
  this.items_ = {};

};

/**
 * Insert a value into the RBush.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.insert = function insert (extent, value) {
  /** @type {module:ol/structs/RBush~Entry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
};


/**
 * Bulk-insert values into the RBush.
 * @param {Array.<module:ol/extent~Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */
RBush.prototype.load = function load (extents, values) {
    var this$1 = this;

  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {module:ol/structs/RBush~Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this$1.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)] = item;
  }
  this.rbush_.load(items);
};


/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
RBush.prototype.remove = function remove (value) {
  var uid = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};


/**
 * Update the extent of a value in the RBush.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {T} value Value.
 */
RBush.prototype.update = function update (extent, value) {
  var item = this.items_[Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["equals"])(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};


/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */
RBush.prototype.getAll = function getAll () {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Return all values in the given extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */
RBush.prototype.getInExtent = function getInExtent (extent) {
  /** @type {module:ol/structs/RBush~Entry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};


/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach = function forEach (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};


/**
 * Calls a callback function with each value in the provided extent.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEachInExtent = function forEachInExtent (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};


/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
RBush.prototype.forEach_ = function forEach_ (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};


/**
 * @return {boolean} Is empty.
 */
RBush.prototype.isEmpty = function isEmpty$1 () {
  return Object(_obj_js__WEBPACK_IMPORTED_MODULE_3__["isEmpty"])(this.items_);
};


/**
 * Remove all values from the RBush.
 */
RBush.prototype.clear = function clear () {
  this.rbush_.clear();
  this.items_ = {};
};


/**
 * @param {module:ol/extent~Extent=} opt_extent Extent.
 * @return {module:ol/extent~Extent} Extent.
 */
RBush.prototype.getExtent = function getExtent (opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};


/**
 * @param {module:ol/structs/RBush} rbush R-Tree.
 */
RBush.prototype.concat = function concat (rbush) {
    var this$1 = this;

  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this$1.items_[i | 0] = rbush.items_[i | 0];
  }
};


/* harmony default export */ __webpack_exports__["default"] = (RBush);

//# sourceMappingURL=RBush.js.map

/***/ }),

/***/ "./node_modules/ol/style/Circle.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Circle.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../style/RegularShape.js */ "./node_modules/ol/style/RegularShape.js");
/**
 * @module ol/style/Circle
 */




/**
 * @typedef {Object} Options
 * @property {module:ol/style/Fill} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate
 * when drawing the circle in the output canvas. If `false` fractional numbers may be used. Using `true` allows for
 * "sharp" rendering (no blur), while using `false` allows for "accurate" rendering. Note that accuracy is important if
 * the circle's position is animated. Without it, the circle may jitter noticeably.
 * @property {module:ol/style/Stroke} [stroke] Stroke style.
 * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this circle.
 * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,
 * the circle is added to an atlas. By default no atlas manager is used.
 */


/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle = (function (RegularShape) {
  function CircleStyle(opt_options) {

    var options = opt_options || {};

    RegularShape.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      snapToPixel: options.snapToPixel,
      stroke: options.stroke,
      atlasManager: options.atlasManager
    });

  }

  if ( RegularShape ) CircleStyle.__proto__ = RegularShape;
  CircleStyle.prototype = Object.create( RegularShape && RegularShape.prototype );
  CircleStyle.prototype.constructor = CircleStyle;

  /**
  * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
  * @return {module:ol/style/Circle} The cloned style.
  * @override
  * @api
  */
  CircleStyle.prototype.clone = function clone () {
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      snapToPixel: this.getSnapToPixel(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
  * Set the circle radius.
  *
  * @param {number} radius Circle radius.
  * @api
  */
  CircleStyle.prototype.setRadius = function setRadius (radius) {
    this.radius_ = radius;
    this.render_(this.atlasManager_);
  };

  return CircleStyle;
}(_style_RegularShape_js__WEBPACK_IMPORTED_MODULE_0__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (CircleStyle);

//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ "./node_modules/ol/style/Fill.js":
/*!***************************************!*\
  !*** ./node_modules/ol/style/Fill.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/Fill
 */




/**
 * @typedef {Object} Options
 * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */


/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill = function Fill(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
 * @return {module:ol/style/Fill} The cloned style.
 * @api
 */
Fill.prototype.clone = function clone () {
  var color = this.getColor();
  return new Fill({
    color: (color && color.slice) ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.
 * @api
 */
Fill.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
 * @api
 */
Fill.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Fill.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    if (
      this.color_ instanceof CanvasPattern ||
        this.color_ instanceof CanvasGradient
    ) {
      this.checksum_ = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? Object(_color_js__WEBPACK_IMPORTED_MODULE_1__["asString"])(this.color_) : '-');
    }
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Fill);

//# sourceMappingURL=Fill.js.map

/***/ }),

/***/ "./node_modules/ol/style/IconImageCache.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/style/IconImageCache.js ***!
  \*************************************************/
/*! exports provided: default, shared */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shared", function() { return shared; });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color.js */ "./node_modules/ol/color.js");
/**
 * @module ol/style/IconImageCache
 */


/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache = function IconImageCache() {

  /**
  * @type {!Object.<string, module:ol/style/IconImage>}
  * @private
  */
  this.cache_ = {};

  /**
  * @type {number}
  * @private
  */
  this.cacheSize_ = 0;

  /**
  * @type {number}
  * @private
  */
  this.maxCacheSize_ = 32;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.clear = function clear () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
* FIXME empty description for jsdoc
*/
IconImageCache.prototype.expire = function expire () {
    var this$1 = this;

  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    for (var key in this$1.cache_) {
      var iconImage = this$1.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this$1.cache_[key];
        --this$1.cacheSize_;
      }
    }
  }
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {module:ol/color~Color} color Color.
* @return {module:ol/style/IconImage} Icon image.
*/
IconImageCache.prototype.get = function get (src, crossOrigin, color) {
  var key = getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
* @param {string} src Src.
* @param {?string} crossOrigin Cross origin.
* @param {module:ol/color~Color} color Color.
* @param {module:ol/style/IconImage} iconImage Icon image.
*/
IconImageCache.prototype.set = function set (src, crossOrigin, color, iconImage) {
  var key = getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};

/**
* Set the cache size of the icon cache. Default is `32`. Change this value when
* your map uses more than 32 different icon images and you are not caching icon
* styles on the application level.
* @param {number} maxCacheSize Cache max size.
* @api
*/
IconImageCache.prototype.setSize = function setSize (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};


/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {module:ol/color~Color} color Color.
 * @return {string} Cache key.
 */
function getKey(src, crossOrigin, color) {
  var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__["asString"])(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}


/* harmony default export */ __webpack_exports__["default"] = (IconImageCache);


/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */
var shared = new IconImageCache();

//# sourceMappingURL=IconImageCache.js.map

/***/ }),

/***/ "./node_modules/ol/style/Image.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Image.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/Image
 */


/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number} scale
 * @property {boolean} snapToPixel
 */


/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @api
 */
var ImageStyle = function ImageStyle(options) {

  /**
  * @private
  * @type {number}
  */
  this.opacity_ = options.opacity;

  /**
  * @private
  * @type {boolean}
  */
  this.rotateWithView_ = options.rotateWithView;

  /**
  * @private
  * @type {number}
  */
  this.rotation_ = options.rotation;

  /**
  * @private
  * @type {number}
  */
  this.scale_ = options.scale;

  /**
  * @private
  * @type {boolean}
  */
  this.snapToPixel_ = options.snapToPixel;

};

/**
* Get the symbolizer opacity.
* @return {number} Opacity.
* @api
*/
ImageStyle.prototype.getOpacity = function getOpacity () {
  return this.opacity_;
};

/**
* Determine whether the symbolizer rotates with the map.
* @return {boolean} Rotate with map.
* @api
*/
ImageStyle.prototype.getRotateWithView = function getRotateWithView () {
  return this.rotateWithView_;
};

/**
* Get the symoblizer rotation.
* @return {number} Rotation.
* @api
*/
ImageStyle.prototype.getRotation = function getRotation () {
  return this.rotation_;
};

/**
* Get the symbolizer scale.
* @return {number} Scale.
* @api
*/
ImageStyle.prototype.getScale = function getScale () {
  return this.scale_;
};

/**
* Determine whether the symbolizer should be snapped to a pixel.
* @return {boolean} The symbolizer should snap to a pixel.
* @api
*/
ImageStyle.prototype.getSnapToPixel = function getSnapToPixel () {
  return this.snapToPixel_;
};

/**
* Get the anchor point in pixels. The anchor determines the center point for the
* symbolizer.
* @abstract
* @return {Array.<number>} Anchor.
*/
ImageStyle.prototype.getAnchor = function getAnchor () {};

/**
* Get the image element for the symbolizer.
* @abstract
* @param {number} pixelRatio Pixel ratio.
* @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
*/
ImageStyle.prototype.getImage = function getImage (pixelRatio) {};

/**
* @abstract
* @param {number} pixelRatio Pixel ratio.
* @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
*/
ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {};

/**
* @abstract
* @return {module:ol/ImageState} Image state.
*/
ImageStyle.prototype.getImageState = function getImageState () {};

/**
* @abstract
* @return {module:ol/size~Size} Image size.
*/
ImageStyle.prototype.getImageSize = function getImageSize () {};

/**
* @abstract
* @return {module:ol/size~Size} Size of the hit-detection image.
*/
ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {};

/**
* Get the origin of the symbolizer.
* @abstract
* @return {Array.<number>} Origin.
*/
ImageStyle.prototype.getOrigin = function getOrigin () {};

/**
* Get the size of the symbolizer (in pixels).
* @abstract
* @return {module:ol/size~Size} Size.
*/
ImageStyle.prototype.getSize = function getSize () {};

/**
* Set the opacity.
*
* @param {number} opacity Opacity.
* @api
*/
ImageStyle.prototype.setOpacity = function setOpacity (opacity) {
  this.opacity_ = opacity;
};

/**
* Set whether to rotate the style with the view.
*
* @param {boolean} rotateWithView Rotate with map.
* @api
*/
ImageStyle.prototype.setRotateWithView = function setRotateWithView (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
* Set the rotation.
*
* @param {number} rotation Rotation.
* @api
*/
ImageStyle.prototype.setRotation = function setRotation (rotation) {
  this.rotation_ = rotation;
};

/**
* Set the scale.
*
* @param {number} scale Scale.
* @api
*/
ImageStyle.prototype.setScale = function setScale (scale) {
  this.scale_ = scale;
};

/**
* Set whether to snap the image to the closest pixel.
*
* @param {boolean} snapToPixel Snap to pixel?
* @api
*/
ImageStyle.prototype.setSnapToPixel = function setSnapToPixel (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};

/**
* @abstract
* @param {function(this: T, module:ol/events/Event)} listener Listener function.
* @param {T} thisArg Value to use as `this` when executing `listener`.
* @return {module:ol/events~EventsKey|undefined} Listener key.
* @template T
*/
ImageStyle.prototype.listenImageChange = function listenImageChange (listener, thisArg) {};

/**
* Load not yet loaded URI.
* @abstract
*/
ImageStyle.prototype.load = function load () {};

/**
* @abstract
* @param {function(this: T, module:ol/events/Event)} listener Listener function.
* @param {T} thisArg Value to use as `this` when executing `listener`.
* @template T
*/
ImageStyle.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

/* harmony default export */ __webpack_exports__["default"] = (ImageStyle);

//# sourceMappingURL=Image.js.map

/***/ }),

/***/ "./node_modules/ol/style/RegularShape.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/style/RegularShape.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../colorlike.js */ "./node_modules/ol/colorlike.js");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom.js */ "./node_modules/ol/dom.js");
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ImageState.js */ "./node_modules/ol/ImageState.js");
/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../render/canvas.js */ "./node_modules/ol/render/canvas.js");
/* harmony import */ var _style_Image_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../style/Image.js */ "./node_modules/ol/style/Image.js");
/**
 * @module ol/style/RegularShape
 */









/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {module:ol/style/Fill} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate
 * when drawing the shape in the output canvas. If `false` fractional numbers may be used. Using `true` allows for
 * "sharp" rendering (no blur), while using `false` allows for "accurate" rendering. Note that accuracy is important if
 * the shape's position is animated. Without it, the shape may jitter noticeably.
 * @property {module:ol/style/Stroke} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this symbol. When
 * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the
 * symbol is added to an atlas. By default no atlas manager is used.
 */


/**
 * @typedef {Object} RenderOptions
 * @property {module:ol/colorlike~ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {string} lineCap
 * @property {Array.<number>} lineDash
 * @property {number} lineDashOffset
 * @property {string} lineJoin
 * @property {number} miterLimit
 */


/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape = (function (ImageStyle) {
  function RegularShape(options) {
    /**
     * @type {boolean}
     */
    var snapToPixel = options.snapToPixel !== undefined ?
      options.snapToPixel : true;

    /**
     * @type {boolean}
     */
    var rotateWithView = options.rotateWithView !== undefined ?
      options.rotateWithView : false;

    ImageStyle.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: 1,
      snapToPixel: snapToPixel
    });

    /**
     * @private
     * @type {Array.<string>}
     */
    this.checksums_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.hitDetectionCanvas_ = null;

    /**
     * @private
     * @type {module:ol/style/Fill}
     */
    this.fill_ = options.fill !== undefined ? options.fill : null;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.origin_ = [0, 0];

    /**
     * @private
     * @type {number}
     */
    this.points_ = options.points;

    /**
     * @protected
     * @type {number}
     */
    this.radius_ = /** @type {number} */ (options.radius !== undefined ?
      options.radius : options.radius1);

    /**
     * @private
     * @type {number|undefined}
     */
    this.radius2_ = options.radius2;

    /**
     * @private
     * @type {number}
     */
    this.angle_ = options.angle !== undefined ? options.angle : 0;

    /**
     * @private
     * @type {module:ol/style/Stroke}
     */
    this.stroke_ = options.stroke !== undefined ? options.stroke : null;

    /**
     * @private
     * @type {Array.<number>}
     */
    this.anchor_ = null;

    /**
     * @private
     * @type {module:ol/size~Size}
     */
    this.size_ = null;

    /**
     * @private
     * @type {module:ol/size~Size}
     */
    this.imageSize_ = null;

    /**
     * @private
     * @type {module:ol/size~Size}
     */
    this.hitDetectionImageSize_ = null;

    /**
     * @protected
     * @type {module:ol/style/AtlasManager|undefined}
     */
    this.atlasManager_ = options.atlasManager;

    this.render_(this.atlasManager_);

  }

  if ( ImageStyle ) RegularShape.__proto__ = ImageStyle;
  RegularShape.prototype = Object.create( ImageStyle && ImageStyle.prototype );
  RegularShape.prototype.constructor = RegularShape;

  /**
   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
   * @return {module:ol/style/RegularShape} The cloned style.
   * @api
   */
  RegularShape.prototype.clone = function clone () {
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      snapToPixel: this.getSnapToPixel(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      atlasManager: this.atlasManager_
    });
    style.setOpacity(this.getOpacity());
    style.setScale(this.getScale());
    return style;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getAnchor = function getAnchor () {
    return this.anchor_;
  };

  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  RegularShape.prototype.getAngle = function getAngle () {
    return this.angle_;
  };

  /**
   * Get the fill style for the shape.
   * @return {module:ol/style/Fill} Fill style.
   * @api
   */
  RegularShape.prototype.getFill = function getFill () {
    return this.fill_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
    return this.hitDetectionCanvas_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getImage = function getImage (pixelRatio) {
    return this.canvas_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageSize = function getImageSize () {
    return this.imageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
    return this.hitDetectionImageSize_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.getImageState = function getImageState () {
    return _ImageState_js__WEBPACK_IMPORTED_MODULE_3__["default"].LOADED;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getOrigin = function getOrigin () {
    return this.origin_;
  };

  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  RegularShape.prototype.getPoints = function getPoints () {
    return this.points_;
  };

  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  RegularShape.prototype.getRadius = function getRadius () {
    return this.radius_;
  };

  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  RegularShape.prototype.getRadius2 = function getRadius2 () {
    return this.radius2_;
  };

  /**
   * @inheritDoc
   * @api
   */
  RegularShape.prototype.getSize = function getSize () {
    return this.size_;
  };

  /**
   * Get the stroke style for the shape.
   * @return {module:ol/style/Stroke} Stroke style.
   * @api
   */
  RegularShape.prototype.getStroke = function getStroke () {
    return this.stroke_;
  };

  /**
   * @inheritDoc
   */
  RegularShape.prototype.listenImageChange = function listenImageChange (listener, thisArg) {};

  /**
   * @inheritDoc
   */
  RegularShape.prototype.load = function load () {};

  /**
   * @inheritDoc
   */
  RegularShape.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

  /**
   * @protected
   * @param {module:ol/style/AtlasManager|undefined} atlasManager An atlas manager.
   */
  RegularShape.prototype.render_ = function render_ (atlasManager) {
    var imageSize;
    var lineCap = '';
    var lineJoin = '';
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();
      if (strokeStyle === null) {
        strokeStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultStrokeStyle"];
      }
      strokeStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_0__["asColorLike"])(strokeStyle);
      strokeWidth = this.stroke_.getWidth();
      if (strokeWidth === undefined) {
        strokeWidth = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultLineWidth"];
      }
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      if (!_has_js__WEBPACK_IMPORTED_MODULE_2__["CANVAS_LINE_DASH"]) {
        lineDash = null;
        lineDashOffset = 0;
      }
      lineJoin = this.stroke_.getLineJoin();
      if (lineJoin === undefined) {
        lineJoin = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultLineJoin"];
      }
      lineCap = this.stroke_.getLineCap();
      if (lineCap === undefined) {
        lineCap = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultLineCap"];
      }
      miterLimit = this.stroke_.getMiterLimit();
      if (miterLimit === undefined) {
        miterLimit = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultMiterLimit"];
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;

    /** @type {module:ol/style/RegularShape~RenderOptions} */
    var renderOptions = {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };

    if (atlasManager === undefined) {
      // no atlas manager is used, create a new canvas
      var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(size, size);
      this.canvas_ = context.canvas;

      // canvas.width and height are rounded to the closest integer
      size = this.canvas_.width;
      imageSize = size;

      this.draw_(renderOptions, context, 0, 0);

      this.createHitDetectionCanvas_(renderOptions);
    } else {
      // an atlas manager is used, add the symbol to an atlas
      size = Math.round(size);

      var hasCustomHitDetectionImage = !this.fill_;
      var renderHitDetectionCallback;
      if (hasCustomHitDetectionImage) {
        // render the hit-detection image into a separate atlas image
        renderHitDetectionCallback =
            this.drawHitDetectionCanvas_.bind(this, renderOptions);
      }

      var id = this.getChecksum();
      var info = atlasManager.add(
        id, size, size, this.draw_.bind(this, renderOptions),
        renderHitDetectionCallback);

      this.canvas_ = info.image;
      this.origin_ = [info.offsetX, info.offsetY];
      imageSize = info.image.width;

      if (hasCustomHitDetectionImage) {
        this.hitDetectionCanvas_ = info.hitImage;
        this.hitDetectionImageSize_ =
            [info.hitImage.width, info.hitImage.height];
      } else {
        this.hitDetectionCanvas_ = this.canvas_;
        this.hitDetectionImageSize_ = [imageSize, imageSize];
      }
    }

    this.anchor_ = [size / 2, size / 2];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };

  /**
   * @private
   * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.draw_ = function draw_ (renderOptions, context, x, y) {
    var this$1 = this;

    var i, angle0, radiusC;
    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this$1.angle_;
        radiusC = i % 2 === 0 ? this$1.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }


    if (this.fill_) {
      var color = this.fill_.getColor();
      if (color === null) {
        color = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultFillStyle"];
      }
      context.fillStyle = Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_0__["asColorLike"])(color);
      context.fill();
    }
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @private
   * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
   */
  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_ (renderOptions) {
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    if (this.fill_) {
      this.hitDetectionCanvas_ = this.canvas_;
      return;
    }

    // if no fill style is set, create an extra hit-detection image with a
    // default fill style
    var context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__["createCanvasContext2D"])(renderOptions.size, renderOptions.size);
    this.hitDetectionCanvas_ = context.canvas;

    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
  };

  /**
   * @private
   * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */
  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_ (renderOptions, context, x, y) {
    var this$1 = this;

    // reset transform
    context.setTransform(1, 0, 0, 1, 0, 0);

    // then move to (x, y)
    context.translate(x, y);

    context.beginPath();

    var points = this.points_;
    if (points === Infinity) {
      context.arc(
        renderOptions.size / 2, renderOptions.size / 2,
        this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = (this.radius2_ !== undefined) ? this.radius2_
        : this.radius_;
      if (radius2 !== this.radius_) {
        points = 2 * points;
      }
      var i, radiusC, angle0;
      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this$1.angle_;
        radiusC = i % 2 === 0 ? this$1.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
          renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = _render_canvas_js__WEBPACK_IMPORTED_MODULE_4__["defaultFillStyle"];
    context.fill();
    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.stroke();
    }
    context.closePath();
  };

  /**
   * @return {string} The checksum.
   */
  RegularShape.prototype.getChecksum = function getChecksum () {
    var strokeChecksum = this.stroke_ ?
      this.stroke_.getChecksum() : '-';
    var fillChecksum = this.fill_ ?
      this.fill_.getChecksum() : '-';

    var recalculate = !this.checksums_ ||
        (strokeChecksum != this.checksums_[1] ||
        fillChecksum != this.checksums_[2] ||
        this.radius_ != this.checksums_[3] ||
        this.radius2_ != this.checksums_[4] ||
        this.angle_ != this.checksums_[5] ||
        this.points_ != this.checksums_[6]);

    if (recalculate) {
      var checksum = 'r' + strokeChecksum + fillChecksum +
          (this.radius_ !== undefined ? this.radius_.toString() : '-') +
          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +
          (this.angle_ !== undefined ? this.angle_.toString() : '-') +
          (this.points_ !== undefined ? this.points_.toString() : '-');
      this.checksums_ = [checksum, strokeChecksum, fillChecksum,
        this.radius_, this.radius2_, this.angle_, this.points_];
    }

    return this.checksums_[0];
  };

  return RegularShape;
}(_style_Image_js__WEBPACK_IMPORTED_MODULE_5__["default"]));


/* harmony default export */ __webpack_exports__["default"] = (RegularShape);

//# sourceMappingURL=RegularShape.js.map

/***/ }),

/***/ "./node_modules/ol/style/Stroke.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/style/Stroke.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/**
 * @module ol/style/Stroke
 */



/**
 * @typedef {Object} Options
 * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array.<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */


/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke = function Stroke(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {module:ol/style/Stroke} The cloned style.
 * @api
 */
Stroke.prototype.clone = function clone () {
  var color = this.getColor();
  return new Stroke({
    color: (color && color.slice) ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.
 * @api
 */
Stroke.prototype.getColor = function getColor () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
Stroke.prototype.getLineCap = function getLineCap () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */
Stroke.prototype.getLineDash = function getLineDash () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
Stroke.prototype.getLineDashOffset = function getLineDashOffset () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
Stroke.prototype.getLineJoin = function getLineJoin () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
Stroke.prototype.getMiterLimit = function getMiterLimit () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
Stroke.prototype.getWidth = function getWidth () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
 * @api
 */
Stroke.prototype.setColor = function setColor (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
Stroke.prototype.setLineCap = function setLineCap (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */
Stroke.prototype.setLineDash = function setLineDash (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
Stroke.prototype.setLineDashOffset = function setLineDashOffset (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
Stroke.prototype.setLineJoin = function setLineJoin (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
Stroke.prototype.setMiterLimit = function setMiterLimit (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
Stroke.prototype.setWidth = function setWidth (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
Stroke.prototype.getChecksum = function getChecksum () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += Object(_util_js__WEBPACK_IMPORTED_MODULE_0__["getUid"])(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' +
        (this.lineCap_ !== undefined ?
          this.lineCap_.toString() : '-') + ',' +
        (this.lineDash_ ?
          this.lineDash_.toString() : '-') + ',' +
        (this.lineDashOffset_ !== undefined ?
          this.lineDashOffset_ : '-') + ',' +
        (this.lineJoin_ !== undefined ?
          this.lineJoin_ : '-') + ',' +
        (this.miterLimit_ !== undefined ?
          this.miterLimit_.toString() : '-') + ',' +
        (this.width_ !== undefined ?
          this.width_.toString() : '-');
  }

  return this.checksum_;
};

/* harmony default export */ __webpack_exports__["default"] = (Stroke);

//# sourceMappingURL=Stroke.js.map

/***/ }),

/***/ "./node_modules/ol/style/Style.js":
/*!****************************************!*\
  !*** ./node_modules/ol/style/Style.js ***!
  \****************************************/
/*! exports provided: toFunction, createDefaultStyle, createEditingStyle, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFunction", function() { return toFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultStyle", function() { return createDefaultStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditingStyle", function() { return createEditingStyle; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geom/GeometryType.js */ "./node_modules/ol/geom/GeometryType.js");
/* harmony import */ var _style_Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/Circle.js */ "./node_modules/ol/style/Circle.js");
/* harmony import */ var _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style/Fill.js */ "./node_modules/ol/style/Fill.js");
/* harmony import */ var _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../style/Stroke.js */ "./node_modules/ol/style/Stroke.js");
/**
 * @module ol/style/Style
 */

/**
 * Feature styles.
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 */







/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled.
 *
 * @typedef {function((module:ol/Feature|module:ol/render/Feature), number):
 *     (module:ol/style/Style|Array.<module:ol/style/Style>)} StyleFunction
 */


/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function((module:ol/Feature|module:ol/render/Feature)):
 *     (module:ol/geom/Geometry|module:ol/render/Feature|undefined)} GeometryFunction
 */


/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((module:ol/coordinate~Coordinate|Array<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>),module:ol/render~State)}
 * RenderFunction
 */


/**
 * @typedef {Object} Options
 * @property {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {module:ol/style/Fill} [fill] Fill style.
 * @property {module:ol/style/Image} [image] Image style.
 * @property {module:ol/style/Style~RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {module:ol/style/Stroke} [stroke] Stroke style.
 * @property {module:ol/style/Text} [text] Text style.
 * @property {number} [zIndex] Z index.
 */


/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 * @api
 */
var Style = function Style(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!module:ol/style/Style~GeometryFunction}
   */
  this.geometryFunction_ = defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {module:ol/style/Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
     * @private
     * @type {module:ol/style/Image}
     */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {module:ol/style/Style~RenderFunction|null}
   */
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;

  /**
   * @private
   * @type {module:ol/style/Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {module:ol/style/Text}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;

};

/**
 * Clones the style.
 * @return {module:ol/style/Style} The cloned style.
 * @api
 */
Style.prototype.clone = function clone () {
  var geometry = this.getGeometry();
  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }
  return new Style({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {module:ol/style/Style~RenderFunction|null} Custom renderer function.
 * @api
 */
Style.prototype.getRenderer = function getRenderer () {
  return this.renderer_;
};

/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {module:ol/style/Style~RenderFunction|null} renderer Custom renderer function.
 * @api
 */
Style.prototype.setRenderer = function setRenderer (renderer) {
  this.renderer_ = renderer;
};

/**
 * Get the geometry to be rendered.
 * @return {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
Style.prototype.getGeometry = function getGeometry () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!module:ol/style/Style~GeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
Style.prototype.getGeometryFunction = function getGeometryFunction () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {module:ol/style/Fill} Fill style.
 * @api
 */
Style.prototype.getFill = function getFill () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {module:ol/style/Fill} fill Fill style.
 * @api
 */
Style.prototype.setFill = function setFill (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {module:ol/style/Image} Image style.
 * @api
 */
Style.prototype.getImage = function getImage () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {module:ol/style/Image} image Image style.
 * @api
 */
Style.prototype.setImage = function setImage (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {module:ol/style/Stroke} Stroke style.
 * @api
 */
Style.prototype.getStroke = function getStroke () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {module:ol/style/Stroke} stroke Stroke style.
 * @api
 */
Style.prototype.setStroke = function setStroke (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {module:ol/style/Text} Text style.
 * @api
 */
Style.prototype.getText = function getText () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {module:ol/style/Text} text Text style.
 * @api
 */
Style.prototype.setText = function setText (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
Style.prototype.getZIndex = function getZIndex () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} geometry
 *   Feature property or geometry or function returning a geometry to render
 *   for this style.
 * @api
 */
Style.prototype.setGeometry = function setGeometry (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function(feature) {
      return (
        /** @type {module:ol/geom/Geometry} */ (feature.get(geometry))
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function() {
      return (
        /** @type {module:ol/geom/Geometry} */ (geometry)
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
Style.prototype.setZIndex = function setZIndex (zIndex) {
  this.zIndex_ = zIndex;
};


/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of module:ol/style/Style or single style objects wrapped in a
 * new style function.
 * @param {module:ol/style/Style~StyleFunction|Array.<module:ol/style/Style>|module:ol/style/Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {module:ol/style/Style~StyleFunction} A style function.
 */
function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<module:ol/style/Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(obj instanceof Style,
        41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`
      styles = [obj];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}


/**
 * @type {Array.<module:ol/style/Style>}
 */
var defaultStyles = null;


/**
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<module:ol/style/Style>} Style.
 */
function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (module:ol/style/Circle~CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new _style_Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
          fill: fill,
          stroke: stroke,
          radius: 5
        }),
        fill: fill,
        stroke: stroke
      })
    ];
  }
  return defaultStyles;
}


/**
 * Default styles for editing features.
 * @return {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} Styles
 */
function createEditingStyle() {
  /** @type {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON] = [
    new Style({
      fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POLYGON] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING] = [
    new Style({
      stroke: new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
        color: blue,
        width: width
      })
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_LINE_STRING] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CIRCLE] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING]
      );


  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT] = [
    new Style({
      image: new _style_Circle_js__WEBPACK_IMPORTED_MODULE_2__["default"]({
        radius: width * 2,
        fill: new _style_Fill_js__WEBPACK_IMPORTED_MODULE_3__["default"]({
          color: blue
        }),
        stroke: new _style_Stroke_js__WEBPACK_IMPORTED_MODULE_4__["default"]({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].MULTI_POINT] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT];

  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].GEOMETRY_COLLECTION] =
      styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POLYGON].concat(
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].LINE_STRING],
        styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__["default"].POINT]
      );

  return styles;
}


/**
 * Function that is called with a feature and returns its default geometry.
 * @param {module:ol/Feature|module:ol/render/Feature} feature Feature to get the geometry for.
 * @return {module:ol/geom/Geometry|module:ol/render/Feature|undefined} Geometry to render.
 */
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

/* harmony default export */ __webpack_exports__["default"] = (Style);

//# sourceMappingURL=Style.js.map

/***/ }),

/***/ "./node_modules/ol/style/TextPlacement.js":
/*!************************************************!*\
  !*** ./node_modules/ol/style/TextPlacement.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @module ol/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
/* harmony default export */ __webpack_exports__["default"] = ({
  POINT: 'point',
  LINE: 'line'
});

//# sourceMappingURL=TextPlacement.js.map

/***/ }),

/***/ "./node_modules/ol/tilecoord.js":
/*!**************************************!*\
  !*** ./node_modules/ol/tilecoord.js ***!
  \**************************************/
/*! exports provided: createOrUpdate, getKeyZXY, getKey, fromKey, hash, quadKey, withinExtentAndZ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyZXY", function() { return getKeyZXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromKey", function() { return fromKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadKey", function() { return quadKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withinExtentAndZ", function() { return withinExtentAndZ; });
/**
 * @module ol/tilecoord
 */


/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
 * @typedef {Array.<number>} TileCoord
 * @api
 */


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Tile coordinate.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}


/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}


/**
 * Get the key for a tile coord.
 * @param {module:ol/tilecoord~TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}


/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {module:ol/tilecoord~TileCoord} The tile coord.
 */
function fromKey(key) {
  return key.split('/').map(Number);
}


/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}


/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << (z - 1);
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
}


/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {!module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}

//# sourceMappingURL=tilecoord.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid.js":
/*!*************************************!*\
  !*** ./node_modules/ol/tilegrid.js ***!
  \*************************************/
/*! exports provided: getForProjection, wrapX, createForExtent, createXYZ, createForProjection, extentFromProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForProjection", function() { return getForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForExtent", function() { return createForExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createXYZ", function() { return createXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForProjection", function() { return createForProjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentFromProjection", function() { return extentFromProjection; });
/* harmony import */ var _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tilegrid/common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent/Corner.js */ "./node_modules/ol/extent/Corner.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tilegrid/TileGrid.js */ "./node_modules/ol/tilegrid/TileGrid.js");
/**
 * @module ol/tilegrid
 */










/**
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {!module:ol/tilegrid/TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}


/**
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 */
function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);
  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["containsCoordinate"])(projectionExtent, center)) {
    var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}


/**
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _extent_Corner_js__WEBPACK_IMPORTED_MODULE_3__["default"].TOP_LEFT;

  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_7__["default"]({
    extent: extent,
    origin: Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getCorner"])(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}


/**
 * @typedef {Object} XYZOptions
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
 * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|module:ol/size~Size} [tileSize=[256, 256]] Tile size in pixels.
 */


/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {module:ol/tilegrid~XYZOptions=} opt_options Tile grid options.
 * @return {!module:ol/tilegrid/TileGrid} Tile grid instance.
 * @api
 */
function createXYZ(opt_options) {
  var options = /** @type {module:ol/tilegrid/TileGrid~Options} */ ({});
  Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__["assign"])(options, opt_options !== undefined ?
    opt_options : /** @type {module:ol/tilegrid~XYZOptions} */ ({}));
  if (options.extent === undefined) {
    options.extent = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])('EPSG:3857').getExtent();
  }
  options.resolutions = resolutionsFromExtent(
    options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;

  return new _tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_7__["default"](options);
}


/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */
function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ?
    opt_maxZoom : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_MAX_ZOOM"];

  var height = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(extent);
  var width = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getWidth"])(extent);

  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_1__["toSize"])(opt_tileSize !== undefined ?
    opt_tileSize : _tilegrid_common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"]);
  var maxResolution = Math.max(
    width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}


/**
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
 */
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}


/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {module:ol/proj~ProjectionLike} projection Projection.
 * @return {module:ol/extent~Extent} Extent.
 */
function extentFromProjection(projection) {
  projection = Object(_proj_js__WEBPACK_IMPORTED_MODULE_5__["get"])(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj_js__WEBPACK_IMPORTED_MODULE_5__["METERS_PER_UNIT"][_proj_Units_js__WEBPACK_IMPORTED_MODULE_6__["default"].DEGREES] / projection.getMetersPerUnit();
    extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(-half, -half, half, half);
  }
  return extent;
}

//# sourceMappingURL=tilegrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/TileGrid.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/tilegrid/TileGrid.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/ol/tilegrid/common.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _TileRange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../TileRange.js */ "./node_modules/ol/TileRange.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../size.js */ "./node_modules/ol/size.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tilegrid/TileGrid
 */










/**
 * @private
 * @type {module:ol/tilecoord~TileCoord}
 */
var tmpTileCoord = [0, 0, 0];


/**
 * @typedef {Object} Options
 * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {module:ol/coordinate~Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array.<module:ol/coordinate~Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array.<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array.<module:ol/size~Size>} [sizes] Sizes.
 * @property {number|module:ol/size~Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array.<module:ol/size~Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */


/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */
var TileGrid = function TileGrid(options) {
  var this$1 = this;


  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array.<number>}
   */
  this.resolutions_ = options.resolutions;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["isSorted"])(this.resolutions_, function(a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this$1.resolutions_[i] / this$1.resolutions_[i + 1];
      } else {
        if (this$1.resolutions_[i] / this$1.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }


  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;


  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {module:ol/coordinate~Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array.<module:ol/coordinate~Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.origins_.length == this.resolutions_.length,
      20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined &&
      !this.origin_ && !this.origins_) {
    this.origin_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["getTopLeft"])(extent);
  }

  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
    18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|module:ol/size~Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(this.tileSizes_.length == this.resolutions_.length,
      19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|module:ol/size~Size}
   */
  this.tileSize_ = options.tileSize !== undefined ?
    options.tileSize :
    !this.tileSizes_ ? _common_js__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TILE_SIZE"] : null;
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__["assert"])(
    (!this.tileSize_ && this.tileSizes_) ||
      (this.tileSize_ && !this.tileSizes_),
    22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {module:ol/extent~Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;


  /**
   * @private
   * @type {Array.<module:ol/TileRange>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {module:ol/size~Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function(size, z) {
      var tileRange = new _TileRange_js__WEBPACK_IMPORTED_MODULE_2__["default"](
        Math.min(0, size[0]), Math.max(size[0] - 1, -1),
        Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }

};

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(module:ol/tilecoord~TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
TileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, module:ol/TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
    var this$1 = this;

  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this$1.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this$1.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getExtent = function getExtent () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
TileGrid.prototype.getMaxZoom = function getMaxZoom () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
TileGrid.prototype.getMinZoom = function getMinZoom () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {module:ol/coordinate~Coordinate} Origin.
 * @api
 */
TileGrid.prototype.getOrigin = function getOrigin (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
TileGrid.prototype.getResolution = function getResolution (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */
TileGrid.prototype.getResolutions = function getResolutions () {
  return this.resolutions_;
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(
      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange} tileRange Tile range.
 * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
 * @return {module:ol/extent~Extent} Extent.
 */
TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {module:ol/extent~Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {module:ol/TileRange=} opt_tileRange Temporary tile range object.
 * @return {module:ol/TileRange} Tile range.
 */
TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {
  var tileCoord = tmpTileCoord;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return Object(_TileRange_js__WEBPACK_IMPORTED_MODULE_2__["createOrUpdate"])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {module:ol/coordinate~Coordinate} Tile center.
 */
TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [
    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution
  ];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {module:ol/extent~Extent=} opt_extent Temporary extent object.
 * @return {module:ol/extent~Extent} Extent.
 * @api
 */
TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return Object(_extent_js__WEBPACK_IMPORTED_MODULE_4__["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(
    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.This method is for integer zoom
 * levels.The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *   intersections go to the higher tile coordinate, let edge intersections
 *   go to the lower tile coordinate.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @private
 */
TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = Object(_size_js__WEBPACK_IMPORTED_MODULE_6__["toSize"])(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_7__["createOrUpdate"])(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
 * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
 * @api
 */
TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(
    coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `module:ol/size~Size`, run the result through `module:ol/size~Size.toSize()`.
 * @param {number} z Z.
 * @return {number|module:ol/size~Size} Tile size.
 * @api
 */
TileGrid.prototype.getTileSize = function getTileSize (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {module:ol/TileRange} Extent tile range for the specified zoom level.
 */
TileGrid.prototype.getFullTileRange = function getFullTileRange (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *   If 1, the nearest lower resolution will be used. If -1, the nearest
 *   higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
TileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {
  var z = Object(_array_js__WEBPACK_IMPORTED_MODULE_3__["linearFindNearest"])(this.resolutions_, resolution, opt_direction || 0);
  return Object(_math_js__WEBPACK_IMPORTED_MODULE_5__["clamp"])(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!module:ol/extent~Extent} extent Extent for this tile grid.
 * @private
 */
TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {
    var this$1 = this;

  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this$1.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};


/* harmony default export */ __webpack_exports__["default"] = (TileGrid);

//# sourceMappingURL=TileGrid.js.map

/***/ }),

/***/ "./node_modules/ol/tilegrid/common.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tilegrid/common.js ***!
  \********************************************/
/*! exports provided: DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_MAX_ZOOM", function() { return DEFAULT_MAX_ZOOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TILE_SIZE", function() { return DEFAULT_TILE_SIZE; });
/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;

/**
 * Default tile size.
 * @type {number}
 */
var DEFAULT_TILE_SIZE = 256;

//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/ol/tileurlfunction.js":
/*!********************************************!*\
  !*** ./node_modules/ol/tileurlfunction.js ***!
  \********************************************/
/*! exports provided: createFromTemplate, createFromTemplates, createFromTileUrlFunctions, nullTileUrlFunction, expandUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplate", function() { return createFromTemplate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTemplates", function() { return createFromTemplates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFromTileUrlFunctions", function() { return createFromTileUrlFunctions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nullTileUrlFunction", function() { return nullTileUrlFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expandUrl", function() { return expandUrl; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _tilecoord_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tilecoord.js */ "./node_modules/ol/tilecoord.js");
/**
 * @module ol/tileurlfunction
 */





/**
 * @param {string} template Template.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString())
          .replace(xRegEx, tileCoord[1].toString())
          .replace(yRegEx, function() {
            var y = -tileCoord[2] - 1;
            return y.toString();
          })
          .replace(dashYRegEx, function() {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(range, 55); // The {-y} placeholder requires a tile grid with extent
            var y = range.getHeight() + tileCoord[2];
            return y.toString();
          });
      }
    }
  );
}


/**
 * @param {Array.<string>} templates Templates.
 * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}


/**
 * @param {Array.<module:ol/Tile~UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {module:ol/Tile~UrlFunction} Tile URL function.
 */
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = Object(_tilecoord_js__WEBPACK_IMPORTED_MODULE_2__["hash"])(tileCoord);
        var index = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__["modulo"])(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}


/**
 * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {module:ol/proj/Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}


/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */
function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

//# sourceMappingURL=tileurlfunction.js.map

/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/*! exports provided: create, reset, multiply, set, setFromArray, apply, rotate, scale, translate, compose, invert, determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reset", function() { return reset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setFromArray", function() { return setFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array.<number>} Transform
 */


/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */


/**
 * @private
 * @type {module:ol/transform~Transform}
 */
var tmp_ = new Array(6);


/**
 * Create an identity transform.
 * @return {!module:ol/transform~Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}


/**
 * Resets the given transform to an identity transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @return {!module:ol/transform~Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}


/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!module:ol/transform~Transform} transform1 Transform parameters of matrix 1.
 * @param {!module:ol/transform~Transform} transform2 Transform parameters of matrix 2.
 * @return {!module:ol/transform~Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!module:ol/transform~Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}


/**
 * Set transform on one matrix from another matrix.
 * @param {!module:ol/transform~Transform} transform1 Matrix to set transform to.
 * @param {!module:ol/transform~Transform} transform2 Matrix to set transform from.
 * @return {!module:ol/transform~Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}


/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {module:ol/transform~Transform} transform The transformation.
 * @param {module:ol/coordinate~Coordinate|module:ol/pixel~Pixel} coordinate The coordinate to transform.
 * @return {module:ol/coordinate~Coordinate|module:ol/pixel~Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}


/**
 * Applies rotation to the given transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!module:ol/transform~Transform} The rotated transform.
 */
function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}


/**
 * Applies scale to a given transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!module:ol/transform~Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}


/**
 * Applies translation to the given transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!module:ol/transform~Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}


/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!module:ol/transform~Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!module:ol/transform~Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}


/**
 * Invert the given transform.
 * @param {!module:ol/transform~Transform} transform Transform.
 * @return {!module:ol/transform~Transform} Inverse of the transform.
 */
function invert(transform) {
  var det = determinant(transform);
  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__["assert"])(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
}


/**
 * Returns the determinant of the given matrix.
 * @param {!module:ol/transform~Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/*! exports provided: inherits, getUid, VERSION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inherits", function() { return inherits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUid", function() { return getUid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/**
 * @module ol/util
 */

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function module:ol.inherits
 * @deprecated
 * @api
 */
function inherits(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
var uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = ++uidCounter_);
}

/**
 * OpenLayers version.
 * @type {string}
 */
var VERSION = '5.1.3';

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/ol/webgl.js":
/*!**********************************!*\
  !*** ./node_modules/ol/webgl.js ***!
  \**********************************/
/*! exports provided: ONE, SRC_ALPHA, COLOR_ATTACHMENT0, COLOR_BUFFER_BIT, TRIANGLES, TRIANGLE_STRIP, ONE_MINUS_SRC_ALPHA, ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER, STREAM_DRAW, STATIC_DRAW, DYNAMIC_DRAW, CULL_FACE, BLEND, STENCIL_TEST, DEPTH_TEST, SCISSOR_TEST, UNSIGNED_BYTE, UNSIGNED_SHORT, UNSIGNED_INT, FLOAT, RGBA, FRAGMENT_SHADER, VERTEX_SHADER, LINK_STATUS, LINEAR, TEXTURE_MAG_FILTER, TEXTURE_MIN_FILTER, TEXTURE_WRAP_S, TEXTURE_WRAP_T, TEXTURE_2D, TEXTURE0, CLAMP_TO_EDGE, COMPILE_STATUS, FRAMEBUFFER, getContext, DEBUG, HAS, MAX_TEXTURE_SIZE, EXTENSIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE", function() { return ONE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRC_ALPHA", function() { return SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_ATTACHMENT0", function() { return COLOR_ATTACHMENT0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR_BUFFER_BIT", function() { return COLOR_BUFFER_BIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLES", function() { return TRIANGLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE_STRIP", function() { return TRIANGLE_STRIP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ONE_MINUS_SRC_ALPHA", function() { return ONE_MINUS_SRC_ALPHA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_BUFFER", function() { return ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ELEMENT_ARRAY_BUFFER", function() { return ELEMENT_ARRAY_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STREAM_DRAW", function() { return STREAM_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC_DRAW", function() { return STATIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DYNAMIC_DRAW", function() { return DYNAMIC_DRAW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CULL_FACE", function() { return CULL_FACE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND", function() { return BLEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STENCIL_TEST", function() { return STENCIL_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEPTH_TEST", function() { return DEPTH_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCISSOR_TEST", function() { return SCISSOR_TEST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_BYTE", function() { return UNSIGNED_BYTE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_SHORT", function() { return UNSIGNED_SHORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSIGNED_INT", function() { return UNSIGNED_INT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLOAT", function() { return FLOAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA", function() { return RGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINK_STATUS", function() { return LINK_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LINEAR", function() { return LINEAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MAG_FILTER", function() { return TEXTURE_MAG_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_MIN_FILTER", function() { return TEXTURE_MIN_FILTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_S", function() { return TEXTURE_WRAP_S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_WRAP_T", function() { return TEXTURE_WRAP_T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_2D", function() { return TEXTURE_2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE0", function() { return TEXTURE0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLAMP_TO_EDGE", function() { return CLAMP_TO_EDGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPILE_STATUS", function() { return COMPILE_STATUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER", function() { return FRAMEBUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContext", function() { return getContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEBUG", function() { return DEBUG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HAS", function() { return HAS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_TEXTURE_SIZE", function() { return MAX_TEXTURE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/**
 * @module ol/webgl
 */


/**
 * Constants taken from goog.webgl
 */


/**
 * @const
 * @type {number}
 */
var ONE = 1;


/**
 * @const
 * @type {number}
 */
var SRC_ALPHA = 0x0302;


/**
 * @const
 * @type {number}
 */
var COLOR_ATTACHMENT0 = 0x8CE0;


/**
 * @const
 * @type {number}
 */
var COLOR_BUFFER_BIT = 0x00004000;


/**
 * @const
 * @type {number}
 */
var TRIANGLES = 0x0004;


/**
 * @const
 * @type {number}
 */
var TRIANGLE_STRIP = 0x0005;


/**
 * @const
 * @type {number}
 */
var ONE_MINUS_SRC_ALPHA = 0x0303;


/**
 * @const
 * @type {number}
 */
var ARRAY_BUFFER = 0x8892;


/**
 * @const
 * @type {number}
 */
var ELEMENT_ARRAY_BUFFER = 0x8893;


/**
 * @const
 * @type {number}
 */
var STREAM_DRAW = 0x88E0;


/**
 * @const
 * @type {number}
 */
var STATIC_DRAW = 0x88E4;


/**
 * @const
 * @type {number}
 */
var DYNAMIC_DRAW = 0x88E8;


/**
 * @const
 * @type {number}
 */
var CULL_FACE = 0x0B44;


/**
 * @const
 * @type {number}
 */
var BLEND = 0x0BE2;


/**
 * @const
 * @type {number}
 */
var STENCIL_TEST = 0x0B90;


/**
 * @const
 * @type {number}
 */
var DEPTH_TEST = 0x0B71;


/**
 * @const
 * @type {number}
 */
var SCISSOR_TEST = 0x0C11;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_BYTE = 0x1401;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_SHORT = 0x1403;


/**
 * @const
 * @type {number}
 */
var UNSIGNED_INT = 0x1405;


/**
 * @const
 * @type {number}
 */
var FLOAT = 0x1406;


/**
 * @const
 * @type {number}
 */
var RGBA = 0x1908;


/**
 * @const
 * @type {number}
 */
var FRAGMENT_SHADER = 0x8B30;


/**
 * @const
 * @type {number}
 */
var VERTEX_SHADER = 0x8B31;


/**
 * @const
 * @type {number}
 */
var LINK_STATUS = 0x8B82;


/**
 * @const
 * @type {number}
 */
var LINEAR = 0x2601;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MAG_FILTER = 0x2800;


/**
 * @const
 * @type {number}
 */
var TEXTURE_MIN_FILTER = 0x2801;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_S = 0x2802;


/**
 * @const
 * @type {number}
 */
var TEXTURE_WRAP_T = 0x2803;


/**
 * @const
 * @type {number}
 */
var TEXTURE_2D = 0x0DE1;


/**
 * @const
 * @type {number}
 */
var TEXTURE0 = 0x84C0;


/**
 * @const
 * @type {number}
 */
var CLAMP_TO_EDGE = 0x812F;


/**
 * @const
 * @type {number}
 */
var COMPILE_STATUS = 0x8B81;


/**
 * @const
 * @type {number}
 */
var FRAMEBUFFER = 0x8D40;


/** end of goog.webgl constants
 */


/**
 * @const
 * @type {Array.<string>}
 */
var CONTEXT_IDS = [
  'experimental-webgl',
  'webgl',
  'webkit-3d',
  'moz-webgl'
];


/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
function getContext(canvas, opt_attributes) {
  var ii = CONTEXT_IDS.length;
  for (var i = 0; i < ii; ++i) {
    try {
      var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
      if (context) {
        return /** @type {!WebGLRenderingContext} */ (context);
      }
    } catch (e) {
      // pass
    }
  }
  return null;
}


/**
 * Include debuggable shader sources.  Default is `true`. This should be set to
 * `false` for production builds.
 * @type {boolean}
 */
var DEBUG = true;


/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @type {number|undefined}
 */
var MAX_TEXTURE_SIZE; // value is set below


/**
 * List of supported WebGL extensions.
 * @type {Array.<string>}
 */
var EXTENSIONS; // value is set below


/**
 * True if both OpenLayers and browser support WebGL.
 * @type {boolean}
 * @api
 */
var HAS = false;

//TODO Remove side effects
if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
  try {
    var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));
    var gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});
    if (gl) {
      HAS = true;
      MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));
      EXTENSIONS = gl.getSupportedExtensions();
    }
  } catch (e) {
    // pass
  }
}



//# sourceMappingURL=webgl.js.map

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./src/animationBucket.ts":
/*!********************************!*\
  !*** ./src/animationBucket.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AnimationBucket = /** @class */ (function () {
    function AnimationBucket(colorScale) {
        this.buckets = [];
        this.colorScale = colorScale;
        for (var i = 0; i < colorScale.size; i++) {
            this.buckets.push([]);
        }
    }
    AnimationBucket.prototype.clear = function () {
        this.buckets.forEach(function (particuleSet) {
            particuleSet.splice(0, particuleSet.length);
        });
    };
    AnimationBucket.prototype.add = function (p, v) {
        // console.log('aaaa', p, v);
        var index = this.colorScale.getColorIndex(p.intensity);
        if (index < 0 || index >= this.buckets.length) {
            console.log(index);
            return;
        }
        p.xt = p.x + v.u;
        p.yt = p.y + v.v;
        // console.log('aaaa', p, v);
        this.buckets[index].push(p);
    };
    AnimationBucket.prototype.draw = function (context2D) {
        var _this = this;
        // console.log('this.buckets', this.buckets);
        this.buckets.forEach(function (bucket, i) {
          // console.log('aaaaaaa', bucket, i);
            if (bucket.length > 0) {
                context2D.beginPath();
                context2D.strokeStyle = _this.colorScale.colorAt(i);
                bucket.forEach(function (particle) {
                    context2D.moveTo(particle.x, particle.y);
                    context2D.lineTo(particle.xt, particle.yt);
                    particle.x = particle.xt;
                    particle.y = particle.yt;
                });
                context2D.stroke();
            }
        });
    };
    return AnimationBucket;
}());
exports.default = AnimationBucket;


/***/ }),

/***/ "./src/canvasBound.ts":
/*!****************************!*\
  !*** ./src/canvasBound.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var particle_1 = __webpack_require__(/*! ./particle */ "./src/particle.ts");
var CanvasBound = /** @class */ (function () {
    function CanvasBound(xMin, yMin, xMax, yMax) {
        this.xMin = xMin;
        this.yMin = yMin;
        this.xMax = xMax;
        this.yMax = yMax;
    }
    Object.defineProperty(CanvasBound.prototype, "width", {
        get: function () {
            return this.xMax - this.xMin;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasBound.prototype, "height", {
        get: function () {
            return this.yMax - this.yMin;
        },
        enumerable: true,
        configurable: true
    });
    CanvasBound.prototype.getRandomParticule = function (maxAge) {
        var x = Math.round(Math.floor(Math.random() * this.width) + this.xMin);
        var y = Math.round(Math.floor(Math.random() * this.height) + this.yMin);
        return new particle_1.default(x, y, maxAge);
    };
    CanvasBound.prototype.resetParticule = function (p) {
        var x = Math.round(Math.floor(Math.random() * this.width) + this.xMin);
        var y = Math.round(Math.floor(Math.random() * this.height) + this.yMin);
        p.reset(x, y);
        return p;
    };
    return CanvasBound;
}());
exports.default = CanvasBound;


/***/ }),

/***/ "./src/colorScale.ts":
/*!***************************!*\
  !*** ./src/colorScale.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ColorScale = /** @class */ (function () {
    function ColorScale(minValue, maxValue, scale) {
        this.scale = [
            "rgb(36,104, 180)",
            "rgb(60,157, 194)",
            "rgb(128,205,193 )",
            "rgb(151,218,168 )",
            "rgb(198,231,181)",
            "rgb(238,247,217)",
            "rgb(255,238,159)",
            "rgb(252,217,125)",
            "rgb(255,182,100)",
            "rgb(252,150,75)",
            "rgb(250,112,52)",
            "rgb(245,64,32)",
            "rgb(237,45,28)",
            "rgb(220,24,32)",
            "rgb(180,0,35)"
        ];
        this.setMinMax(minValue, maxValue);

        if ((scale instanceof Array) && scale.length) {
            this.scale = scale;
        }
    }
    ColorScale.prototype.setMinMax = function (minValue, maxValue) {
        this.minValue = minValue;
        this.maxValue = maxValue;
    };
    Object.defineProperty(ColorScale.prototype, "size", {
        get: function () {
            return this.scale.length;
        },
        enumerable: true,
        configurable: true
    });
    ColorScale.prototype.getColorIndex = function (value) {
      // console.log('value', value);
      // console.log('this.minValue', this.minValue);
      // console.log('this.maxValue', this.maxValue);
        if (value <= this.minValue) {
            return 0;
        }
        if (value >= this.maxValue) {
            return this.scale.length - 1;
        }
        var index = this.scale.length * (value - this.minValue) / (this.maxValue - this.minValue);
        if (index < 0) {
            return 0;
        }
        if (index > this.scale.length - 1) {
            return this.scale.length - 1;
        }
        // console.log('Math.floor(index)', Math.floor(index));
        return Math.floor(index);
    };
    ColorScale.prototype.colorAt = function (index) {
        return this.scale[index];
    };
    ColorScale.prototype.getColor = function (value) {
        return this.scale[this.getColorIndex(value)];
    };
    return ColorScale;
}());
exports.default = ColorScale;


/***/ }),

/***/ "./src/grid.ts":
/*!*********************!*\
  !*** ./src/grid.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = __webpack_require__(/*! ./vector */ "./src/vector.ts");
var Grid = /** @class */ (function () {
    function Grid(data, φ0, λ0, Δφ, Δλ, height, width) {
        this.data = data;
        this.φ0 = φ0;
        this.λ0 = λ0;
        this.Δλ = Δλ;
        this.Δφ = Δφ;
        this.height = height;
        this.width = width;
    }
    Object.defineProperty(Grid.prototype, "valueRange", {
        get: function () {
            if (!this.data.length) {
                return [0, 0];
            }
            var min = this.data[0].intensity;
            var max = this.data[0].intensity;
            this.data.forEach(function (value) {
                min = Math.min(min, value.intensity);
                max = Math.max(max, value.intensity);
            });
            return [min, max];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get vector at any point
     * @param λ Longitude
     * @param φ Latitude
     */
    Grid.prototype.get = function (λ, φ) {
        var fλ = this.floorMod(λ - this.λ0, 360) / this.Δλ; // calculate longitude index in wrapped range [0, 360)
        var fφ = (this.φ0 - φ) / this.Δφ; // calculate latitude index in direction +90 to -90
        var iλ = Math.floor(fλ); // col n
        var jλ = iλ + 1; // col n+1
        if (jλ >= this.width) {
            jλ = this.λ0;
        }
        var iφ = Math.floor(fφ); // line m
        var jφ = iφ + 1; // line m+1
        if (jφ >= this.height) {
            jφ = iφ;
        }
        var vλ = fλ - iλ; // col variation [0..1]
        var vφ = fφ - iφ; // line variation [0..1]
        if (iλ >= 0 && iφ >= 0 && iλ < this.width && iφ < this.height) {
            var g00 = this.data[iλ + iφ * this.width];
            var g10 = this.data[jλ + iφ * this.width];
            if (this.isValue(g00) && this.isValue(g10)) {
                var g01 = this.data[iλ + jφ * this.width];
                var g11 = this.data[jλ + jφ * this.width];
                if (this.isValue(g01) && this.isValue(g11)) {
                    return this.interpolation(vλ, vφ, g00, //l0c0
                    g10, //l0c1
                    g01, //l1c0
                    g11 //l1cl
                    );
                }
            }
        }
        return new vector_1.default(0, 0);
    };
    /**
     * Interpolate value
     * @param x variation between g0* and g1*
     * @param y variation between g*0 dans g*1
     * @param g00 point at col_0 and line_0
     * @param g10 point at col_1 and line_0
     * @param g01 point at col_0 and line_1
     * @param g11 point at col_1 and line_1
     * @return interpolated vector
     */
    Grid.prototype.interpolation = function (x, y, g00, g10, g01, g11) {
        var rx = (1 - x);
        var ry = (1 - y);
        var a = rx * ry, b = x * ry, c = rx * y, d = x * y;
        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;
        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;
        return new vector_1.default(u, v);
    };
    /**
     * Custom modulo
     * @returns {number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo
     *          of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
     */
    Grid.prototype.floorMod = function (a, n) {
        return a - n * Math.floor(a / n);
    };
    ;
    /**
     * Detect if x is a value
     * @returns {boolean} true if the specified value is not null and not undefined.
     */
    Grid.prototype.isValue = function (x) {
        return x !== null && x !== undefined;
    };
    ;
    return Grid;
}());
exports.default = Grid;


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var velocityLayer_1 = __webpack_require__(/*! ./velocityLayer */ "./src/velocityLayer.ts");
var canvasBound_1 = __webpack_require__(/*! ./canvasBound */ "./src/canvasBound.ts");
var mapBound_1 = __webpack_require__(/*! ./mapBound */ "./src/mapBound.ts");
var windy_1 = __webpack_require__(/*! ./windy */ "./src/windy.ts");
window.VelocityLayer = velocityLayer_1.default;
window.CanvasBound = canvasBound_1.default;
window.MapBound = mapBound_1.default;
window.Windy = windy_1.default;
var testlayer_1 = __webpack_require__(/*! ./testlayer */ "./src/testlayer.ts");
window.TestLayer = testlayer_1.default;
var Map_1 = __webpack_require__(/*! ol/Map */ "./node_modules/ol/Map.js");
var View_1 = __webpack_require__(/*! ol/View */ "./node_modules/ol/View.js");
var Tile_1 = __webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js");
var OSM_1 = __webpack_require__(/*! ol/source/OSM */ "./node_modules/ol/source/OSM.js");
var Stamen_1 = __webpack_require__(/*! ol/source/Stamen */ "./node_modules/ol/source/Stamen.js");
window.Map = Map_1.default;
window.View = View_1.default;
window.TileLayer = Tile_1.default;
window.OSM = OSM_1.default;
window.Stamen = Stamen_1.default;
var proj = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js").default;
window.proj = proj;


/***/ }),

/***/ "./src/layer.ts":
/*!**********************!*\
  !*** ./src/layer.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var layer = /** @class */ (function () {
    function layer(mapBound, canvasBound) {
        this.canvasBound = canvasBound;
        this.mapBound = mapBound;
    }
    /**
     * Find geocoordinate from canvas point
     * @param x
     * @param y
     * return [lng, lat]
     */
    layer.prototype.canvasToMap = function (x, y) {
        var mapLonDelta = this.mapBound.east - this.mapBound.west;
        var worldMapRadius = (this.canvasBound.width / this.rad2deg(mapLonDelta)) * 360 / (2 * Math.PI);
        var mapOffsetY = (worldMapRadius / 2 * Math.log((1 + Math.sin(this.mapBound.south)) / (1 - Math.sin(this.mapBound.south))));
        var equatorY = this.canvasBound.height + mapOffsetY;
        var a = (equatorY - y) / worldMapRadius;
        var φ = 180 / Math.PI * (2 * Math.atan(Math.exp(a)) - Math.PI / 2);
        var λ = this.rad2deg(this.mapBound.west) + x / this.canvasBound.width * this.rad2deg(mapLonDelta);
        return [λ, φ];
    };
    ;
    layer.prototype.mercY = function (φ) {
        return Math.log(Math.tan(φ / 2 + Math.PI / 4));
    };
    ;
    /**
     * Project a point on the map
     * @param λ Longitude
     * @param φ Latitude
     * @return [x, y]
     */
    layer.prototype.mapToCanvas = function (λ, φ) {
        var ymin = this.mercY(this.mapBound.south);
        var ymax = this.mercY(this.mapBound.north);
        var xFactor = this.canvasBound.width / (this.mapBound.east - this.mapBound.west);
        var yFactor = this.canvasBound.height / (ymax - ymin);
        var y = this.mercY(this.deg2rad(φ));
        var x = (this.deg2rad(λ) - this.mapBound.west) * xFactor;
        y = (ymax - y) * yFactor;
        return [x, y];
    };
    ;
    layer.prototype.deg2rad = function (deg) {
        return deg * Math.PI / 180;
    };
    ;
    layer.prototype.rad2deg = function (rad) {
        return rad * 180 / Math.PI;
    };
    ;
    /**
     *
     * @param λ Longitude
     * @param φ Latitude
     * @param x
     * @param y
     * @return []
     */
    layer.prototype.distortion = function (λ, φ, x, y) {
        var τ = 2 * Math.PI;
        var H = Math.pow(10, -5.2);
        var hλ = λ < 0 ? H : -H;
        var hφ = φ < 0 ? H : -H;
        var pλ = this.mapToCanvas(λ + hλ, φ);
        var pφ = this.mapToCanvas(λ, φ + hφ);
        // Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1º λ
        // changes depending on φ. Without this, there is a pinching effect at the poles.
        var k = Math.cos(φ / 360 * τ);
        return [
            (pλ[0] - x) / hλ / k,
            (pλ[1] - y) / hλ / k,
            (pφ[0] - x) / hφ,
            (pφ[1] - y) / hφ
        ];
    };
    /**
     * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind
     * vector is modified in place and returned by this function.
     * @param λ
     * @param φ
     * @param x
     * @param y
     * @param scale scale factor
     * @param wind [u, v]
     * @return []
     */
    layer.prototype.distort = function (λ, φ, x, y, scale, wind) {
        var u = wind.u * scale;
        var v = wind.v * scale;
        var d = this.distortion(λ, φ, x, y);
        // Scale distortion vectors by u and v, then add.
        wind.u = d[0] * u + d[2] * v;
        wind.v = d[1] * u + d[3] * v;
        return wind;
    };
    return layer;
}());
exports.default = layer;


/***/ }),

/***/ "./src/mapBound.ts":
/*!*************************!*\
  !*** ./src/mapBound.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var MapBound = /** @class */ (function () {
    function MapBound(north, east, south, west) {
        this.north = north * Math.PI / 180;
        this.east = east * Math.PI / 180;
        this.south = south * Math.PI / 180;
        this.west = west * Math.PI / 180;
    }
    Object.defineProperty(MapBound.prototype, "width", {
        get: function () {
            // return (720 + this.east - this.west) % 360;
            return ((720 + this.east * 180 / Math.PI - this.west * 180 / Math.PI) % 360) * Math.PI / 180;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MapBound.prototype, "height", {
        get: function () {
            // return (360 + this.north - this.south) % 180;
            return ((360 + this.north * 180 / Math.PI - this.south * 180 / Math.PI) % 180) * Math.PI / 180;
        },
        enumerable: true,
        configurable: true
    });
    return MapBound;
}());
exports.default = MapBound;


/***/ }),

/***/ "./src/particle.ts":
/*!*************************!*\
  !*** ./src/particle.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Particule = /** @class */ (function () {
    function Particule(x, y, maxAge) {
        this.x = x;
        this.y = y;
        this.age = Math.floor(Math.random() * maxAge);
        this.maxAge = maxAge;
    }
    Particule.prototype.reset = function (x, y) {
        this.x = x;
        this.y = y;
        this.age = 0;
    };
    Object.defineProperty(Particule.prototype, "isDead", {
        get: function () {
            return this.age > this.maxAge;
        },
        enumerable: true,
        configurable: true
    });
    Particule.prototype.grow = function () {
        this.age++;
    };
    return Particule;
}());
exports.default = Particule;


/***/ }),

/***/ "./src/testlayer.ts":
/*!**************************!*\
  !*** ./src/testlayer.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Tile_1 = __webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js");
var Stamen_1 = __webpack_require__(/*! ol/source/Stamen */ "./node_modules/ol/source/Stamen.js");
var TestLayer = /** @class */ (function () {
    function TestLayer(options) {
        this._map = null;
        // console.debug('TestLayer.constructor');
        this.options = {};
        for (var i in options) {
            this.options[i] = options[i];
        }
    }
    TestLayer.prototype.getMapLayer = function () {
        // console.debug('TestLayer.getMapLayer');
        this._layer = this._layer || new Tile_1.default({
            source: new Stamen_1.default({
                layer: 'toner'
            })
        });
        // console.debug('TestLayer.getMapLayer return');
        return this._layer;
    };
    TestLayer.prototype.addToMap = function (map) {
        // console.debug('VelocityLayer.addToMap');
        map.addLayer(this.getMapLayer());
        this._map = map;
        // console.debug('TestLayer.addToMap return');
    };
    return TestLayer;
}());
exports.default = TestLayer;


/***/ }),

/***/ "./src/vector.ts":
/*!***********************!*\
  !*** ./src/vector.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Vector = /** @class */ (function () {
    function Vector(u, v) {
        this.u = u || 0;
        this.v = v || 0;
    }
    Object.defineProperty(Vector.prototype, "intensity", {
        get: function () {
            return Math.sqrt(this.u * this.u + this.v * this.v);
        },
        enumerable: true,
        configurable: true
    });
    return Vector;
}());
exports.default = Vector;


/***/ }),

/***/ "./src/velocityLayer.ts":
/*!******************************!*\
  !*** ./src/velocityLayer.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var windy_1 = __webpack_require__(/*! ./windy */ "./src/windy.ts");
var canvasBound_1 = __webpack_require__(/*! ./canvasBound */ "./src/canvasBound.ts");
var mapBound_1 = __webpack_require__(/*! ./mapBound */ "./src/mapBound.ts");
var layer_1 = __webpack_require__(/*! ./layer */ "./src/layer.ts");
var Image_1 = __webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js");
var ImageCanvas_1 = __webpack_require__(/*! ol/source/ImageCanvas */ "./node_modules/ol/source/ImageCanvas.js");
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
// declare function require(name:string):any;
// const proj = (<any>require('ol/proj')).default;
// Fix: https://github.com/openlayers/openlayers/issues/8037
var VelocityLayer = /** @class */ (function () {
    function VelocityLayer(options) {
        this._map = null;
        this._canvas = null;
        this._canvasExtent = null;
        this._canvasSize = null;
        this._canvasLayer = null;
        this._windy = null;
        this._context = null;
        this._displayTimeout = 0;
        this._mouseControl = null;
        // console.debug('VelocityLayer.constructor');
        this.options = Object.assign({
            displayValues: true,
            displayOptions: {
                velocityType: 'Velocity',
                position: 'bottomleft',
                emptyString: 'No velocity data',
                angleConvention: 'bearingCCW',
                speedUnit: 'm/s'
            },
            maxVelocity: 10,
            colorScale: null,
            data: null
        }, options || {});
        // console.debug(this.options);
    }
    VelocityLayer.prototype._canvasFunction = function (extent, resolution, pixelRatio, size, projection) {
        // console.debug('VelocityLayer.canvasFunction');
        // console.debug('extent: ' + extent + ' | resolution: ' + resolution + ' | pixelRatio: ' + pixelRatio + ' | size: ' + size);
        this._canvas = this._canvas || document.createElement('canvas');
        this._canvas.setAttribute('width', size[0]);
        this._canvas.setAttribute('height', size[1]);
        this._context = this._canvas.getContext('2d');
        this._canvasExtent = extent;
        this._canvasSize = size;
        this._restartWindy();
        return this._canvas;
    };
    VelocityLayer.prototype.getMapLayer = function () {
        this._canvasLayer = this._canvasLayer || new Image_1.default({
            source: new ImageCanvas_1.default({
                canvasFunction: this._canvasFunction.bind(this),
                projection: 'EPSG:3857'
            })
        });
        return this._canvasLayer;
    };
    VelocityLayer.prototype.addToMap = function (map, canvas) {
        if (canvas === void 0) { canvas = null; }
        // console.debug('VelocityLayer.addToMap');
        // this._canvas = canvas || this._canvas || document.createElement('canvas');
        this._map = map;
        this._map.addLayer(this.getMapLayer());
        this._startWindy();
    };
    VelocityLayer.prototype.removeFromMap = function () {
        // console.debug('VelocityLayer.removeFromMap');
        if (!this._map) {
            console.log('VelocityLayer.removeFromMap: No map!');
            return;
        }
        this._destroyWind();
        this._map.removeLayer(this._canvasLayer);
    };
    VelocityLayer.prototype.setData = function (data) {
        // console.debug('VelocityLayer.setData');
        this.options.data = data;
        if (this._windy) {
            this._windy.setData(data);
            if (this._canvasLayer)
                this._canvasLayer.changed();
        }
    };
    VelocityLayer.prototype._initWindy = function () {
        // console.debug('VelocityLayer._initWindy');
        this._canvas = this._canvas || document.createElement('canvas');
        // windy object, copy options
        var options = Object.assign({}, this.options, {
            canvas: this._canvas
        });
        this._windy = new windy_1.default(options);
        // this._initMouseHandler();
    };
    VelocityLayer.prototype._canvasLayer_changed = function () {
        this._canvasLayer.changed();
    };
    // _initMouseHandler() {
    //   if (!this._mouseControl && this.options.displayValues) {
    //     var options = this.options.displayOptions || {};
    //     options['leafletVelocity'] = this;
    //     this._mouseControl = L_controlVelocity();
    //     this._mouseControl.setWindy(this._windy);
    //     this._mouseControl.setOptions(this.options.displayOptions);
    //     this._mouseControl.addTo(this._map);
    //   }
    // }
    VelocityLayer.prototype._startWindy = function () {
        // console.debug('VelocityLayer._startWindy');
        var _this = this;
        if (!this._windy) {
            this._initWindy();
            this._startWindy();
            return;
        }
        if (!this.options.data) {
            // console.debug('VelocityLayer._startWindy: no data!');
            return;
        }
        if (this._displayTimeout)
            clearTimeout(this._displayTimeout);
        this._displayTimeout = setTimeout(function () {
            var mapSize = _this._map.getSize();
            // console.debug('mapSize: ' + mapSize);
            // console.debug('canvasSize: ' + _this._canvasSize);
            var extent = _this._map.getView().calculateExtent(_this._canvasSize);
            var extentLL = proj_1.transformExtent(extent, 'EPSG:3857', 'EPSG:4326');
            // console.debug('extentLL' + extentLL);
            // console.debug('--------------------------');
            _this._windy.start(new layer_1.default(new mapBound_1.default(extentLL[3], // maxy (north)
            extentLL[2], // maxx (east)
            extentLL[1], // miny (south)
            extentLL[0] // minx (west)
            ), new canvasBound_1.default(0, 0, _this._canvasSize[0], _this._canvasSize[1])));
        }, 150); // showing velocity delayed while layer is being added to the map
    };
    VelocityLayer.prototype._restartWindy = function () {
        //console.debug('VelocityLayer._restartWindy');
        if (this._windy) {
            this._windy.stop();
        }
        this._startWindy();
    };
    VelocityLayer.prototype._destroyWind = function () {
        // console.debug('VelocityLayer._destroyWind');
        if (this._displayTimeout)
            clearTimeout(this._displayTimeout);
        if (this._windy)
            this._windy.stop();
        if (this._context)
            this._context.clearRect(0, 0, 3000, 3000);
        // if (this._mouseControl)
        //   this._map.removeControl(this._mouseControl);
        // this._mouseControl = null;
        this._windy = null;
        // this._map.removeLayer(this._canvasLayer);
    };
    return VelocityLayer;
}());
exports.default = VelocityLayer;


/***/ }),

/***/ "./src/windy.ts":
/*!**********************!*\
  !*** ./src/windy.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vector_1 = __webpack_require__(/*! ./vector */ "./src/vector.ts");
var grid_1 = __webpack_require__(/*! ./grid */ "./src/grid.ts");
var colorScale_1 = __webpack_require__(/*! ./colorScale */ "./src/colorScale.ts");
var animationBucket_1 = __webpack_require__(/*! ./animationBucket */ "./src/animationBucket.ts");
var Windy = /** @class */ (function () {
    function Windy(options) {
        this.canvas = null;
        this.particuleMultiplier = 1 / 300;
        this.autoColorRange = false;
        this.particules = [];
        this.animationLoop = null;
        this.then = 0;
        this.canvas = options.canvas;
        if (options.minVelocity === undefined && options.maxVelocity === undefined) {
            this.autoColorRange = true;
        }
        this.colorScale = new colorScale_1.default(options.minVelocity || 0, options.maxVelocity || 10, options.colorScale);
        this.velocityScale = options.velocityScale || 0.01;
        this.particleAge = options.particleAge || 64;
        this.setData(options.data);
        this.particuleMultiplier = options.particleMultiplier || 1 / 300;
        this.particuleLineWidth = options.lineWidth || 1;
        var frameRate = options.frameRate || 15;
        this.frameTime = 1000 / frameRate;
    }
    Object.defineProperty(Windy.prototype, "particuleCount", {
        get: function () {
            var particuleReduction = ((/android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i).test(navigator.userAgent)) ? (Math.pow(window.devicePixelRatio, 1 / 3) || 1.6) : 1;
            return Math.round(this.layer.canvasBound.width * this.layer.canvasBound.height * this.particuleMultiplier) * particuleReduction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Load data
     * @param data
     */
    Windy.prototype.setData = function (data) {
        var uData = null;
        var vData = null;
        var grid = [];
        data.forEach(function (record) {
            switch (record.header.parameterCategory + "," + record.header.parameterNumber) {
                case "1,2":
                case "2,2":
                    uData = record;
                    break;
                case "1,3":
                case "2,3":
                    vData = record;
                    break;
                default:
            }
        });
        if (!uData || !vData) {
            console.warn("Data are not correct format");
            return;
        }
        uData.data.forEach(function (u, index) {
            grid.push(new vector_1.default(u, vData.data[index]));
        });
        //console.log('uData', uData);
        //console.log('vData', vData);
        this.grid = new grid_1.default(grid, uData.header.la1, uData.header.lo1, uData.header.dy, uData.header.dx, uData.header.ny, uData.header.nx);
        this.λ0 = uData.header.lo1;
        this.φ0 = uData.header.la1;
        this.Δλ = uData.header.dx;
        this.Δφ = uData.header.dy;
        this.ni = uData.header.nx;
        this.nj = uData.header.ny; // number of grid points W-E and N-S (e.g., 144 x 73)
        var p = 0;
        var isContinuous = Math.floor(this.ni * this.Δλ) >= 360;
        for (var j = 0; j < this.nj; j++) {
            var row = [];
            for (var i = 0; i < this.ni; i++, p++) {
                row[i] = this.grid.data[p];
            }
            if (isContinuous) {
                // For wrapped grids, duplicate first column as last column to simplify interpolation logic
                row.push(row[0]);
            }
            this.grid[j] = row;
        }
        if (this.autoColorRange) {
            var minMax = this.grid.valueRange;
            this.colorScale.setMinMax(minMax[0], minMax[1]);
        }
    };
    Windy.prototype.floorMod = function (a, n) {
        return a - n * Math.floor(a / n);
    };
    ;
    Windy.prototype.isValue = function (x) {
        return x !== null && x !== undefined;
    };
    ;
    Windy.prototype.bilinearInterpolateVector = function (x, y, g00, g10, g01, g11) {
        var rx = (1 - x);
        var ry = (1 - y);
        var a = rx * ry, b = x * ry, c = rx * y, d = x * y;
        var u = g00.u * a + g10.u * b + g01.u * c + g11.u * d;
        var v = g00.v * a + g10.v * b + g01.v * c + g11.v * d;
        return [u, v, Math.sqrt(u * u + v * v)];
    };
    ;
    /* Get interpolated grid value from Lon/Lat position
    * @param λ {Float} Longitude
    * @param φ {Float} Latitude
    * @returns {Object}
    */
    Windy.prototype.interpolate = function (λ, φ) {
        if (!this.grid) {
            return null;
        }
        var i = this.floorMod(λ - this.λ0, 360) / this.Δλ; // calculate longitude index in wrapped range [0, 360)
        var j = (this.φ0 - φ) / this.Δφ; // calculate latitude index in direction +90 to -90
        var fi = Math.floor(i);
        var ci = fi + 1;
        var fj = Math.floor(j);
        var cj = fj + 1;
        var row = this.grid[fj]; //Dont know why he dosent found any row ERRRROR
        if (row) {
            var g00 = row[fi];
            var g10 = row[ci];
            if (this.isValue(g00) && this.isValue(g10) && (row = this.grid[cj])) {
                var g01 = row[fi];
                var g11 = row[ci];
                if (this.isValue(g01) && this.isValue(g11)) {
                    // All four points found, so interpolate the value.
                    return this.bilinearInterpolateVector(i - fi, j - fj, g00, g10, g01, g11);
                }
            }
        }
        return null;
    };
    ;
    Windy.prototype.getParticuleWind = function (p) {
        var lngLat = this.layer.canvasToMap(p.x, p.y);
        var wind = this.grid.get(lngLat[0], lngLat[1]);
        p.intensity = wind.intensity;
        var mapArea = this.layer.mapBound.height * this.layer.mapBound.width;
        var velocityScale = this.velocityScale * Math.pow(mapArea, 0.4);
        this.layer.distort(lngLat[0], lngLat[1], p.x, p.y, velocityScale, wind);
        return wind;
    };
    Windy.prototype.start = function (layer) {
        this.context2D = this.canvas.getContext("2d");
        this.context2D.lineWidth = this.particuleLineWidth;
        this.context2D.fillStyle = "rgba(0, 0, 0, 0.97)";
        this.context2D.globalAlpha = 0.6;
        this.layer = layer;
        this.animationBucket = new animationBucket_1.default(this.colorScale);
        this.particules.splice(0, this.particules.length);
        for (var i = 0; i < this.particuleCount; i++) {
            this.particules.push(this.layer.canvasBound.getRandomParticule(this.particleAge));
        }
        this.then = new Date().getTime();
        this.frame();
    };
    Windy.prototype.frame = function () {
        var _this = this;
        this.animationLoop = requestAnimationFrame(function () {
            _this.frame();
        });
        var now = new Date().getTime();
        var delta = now - this.then;
        if (delta > this.frameTime) {
            this.then = now - (delta % this.frameTime);
            this.evolve();
            this.draw();
        }
    };
    Windy.prototype.evolve = function () {
        var _this = this;
        this.animationBucket.clear();
        this.particules.forEach(function (p) {
            p.grow();
            if (p.isDead) {
                _this.layer.canvasBound.resetParticule(p);
            }
            var wind = _this.getParticuleWind(p);
            _this.animationBucket.add(p, wind);
        });
    };
    Windy.prototype.draw = function () {
        this.context2D.globalCompositeOperation = "destination-in";
        this.context2D.fillRect(this.layer.canvasBound.xMin, this.layer.canvasBound.yMin, this.layer.canvasBound.width, this.layer.canvasBound.height);
        // Fade existing particle trails.
        this.context2D.globalCompositeOperation = "lighter";
        this.context2D.globalAlpha = 0.9;
        this.animationBucket.draw(this.context2D);
    };
    Windy.prototype.stop = function () {
        this.particules.splice(0, this.particules.length);
        if (this.animationBucket) {
            this.animationBucket.clear();
        }
        if (this.animationLoop) {
            clearTimeout(this.animationLoop);
            this.animationLoop = null;
        }
    };
    return Windy;
}());
exports.default = Windy;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL0Fzc2VydGlvbkVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9GZWF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZUJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL0ltYWdlQ2FudmFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVRpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL0tpbmV0aWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL0xheWVyVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBCcm93c2VyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9NYXBFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL01hcFByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL09iamVjdEV2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvUGx1Z2dhYmxlTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL1RpbGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvVGlsZVJhbmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9UaWxlU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL1ZpZXdIaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9WaWV3UHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9hc3NlcnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jZW50ZXJjb25zdHJhaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29sb3JsaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0F0dHJpYnV0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0NvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvUm90YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1pvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2NvbnRyb2wvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvY3NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9ldmVudHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0V2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL0tleUNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9jb25kaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2V4dGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L0Nvcm5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZmVhdHVyZWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZm9ybWF0L0Zvcm1hdFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2Z1bmN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnlMYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnlUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0xpbmVTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZWFyUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vTXVsdGlQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aVBvbHlnb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2FyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jZW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvY29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9kZWZsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9pbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9vcmllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9yZXZlcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvc2VnbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zaW1wbGlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3N0cmFpZ2h0Y2h1bmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC90ZXh0cGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZUFuZFpvb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RyYWdab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9EcmF3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9FeHRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Nb2RpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vUGluY2hab29tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vU2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9TbmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xheWVyL1ZlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVmVjdG9yUmVuZGVyVHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvVmVjdG9yVGlsZVJlbmRlclR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL2xvYWRpbmdzdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvbWF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvb2JqLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL0V2ZW50U291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL0V2ZW50VHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Nb3VzZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9Nc1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9OYXRpdmVTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9wb2ludGVyL1BvaW50ZXJFdmVudEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3BvaW50ZXIvVG91Y2hTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3Byb2ovUHJvamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Vbml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnMzg1Ny5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai9lcHNnNDMyNi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai9wcm9qZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcHJvai90cmFuc2Zvcm1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvQm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9SZXBsYXlHcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1JlcGxheVR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9WZWN0b3JDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0ltYWdlUmVwbGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9JbnN0cnVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nUmVwbGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1BvbHlnb25SZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUmVwbGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1JlcGxheUdyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1RleHRSZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9yZXBsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL0xheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9JbWFnZUxheWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvSW50ZXJtZWRpYXRlQ2FudmFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvclRpbGVMYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZXByb2ovY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9JbWFnZUNhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL09TTS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1N0YW1lbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1N0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1RpbGVFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9VcmxUaWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVmVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvWFlaLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zcGhlcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9MUlVDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1JCdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvUmVndWxhclNoYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9TdHJva2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0UGxhY2VtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC90aWxlY29vcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9UaWxlR3JpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQvY29tbW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29sL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2wvd2ViZ2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYnVzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYW5pbWF0aW9uQnVja2V0LnRzIiwid2VicGFjazovLy8uL3NyYy9jYW52YXNCb3VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29sb3JTY2FsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xheWVyLnRzIiwid2VicGFjazovLy8uL3NyYy9tYXBCb3VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFydGljbGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Rlc3RsYXllci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWxvY2l0eUxheWVyLnRzIiwid2VicGFjazovLy8uL3NyYy93aW5keS50cyJdLCJuYW1lcyI6W10sIm1h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QUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUEsMkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRkE7QUFBQTtBQUNBO0FBQ0E7QUFDMkI7QUFDM0I7QUFDQTtBQUM4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSxrRDs7Ozs7Ozs7Ozs7OztBQ3ZVQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxrRDs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLG9DOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakY7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0EsSUFBSSxnQ0FBZ0M7QUFDcEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7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O0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLCtGQUEyQztBQUMzQztBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUEsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzR0E7QUFBQTtBQUNBO0FBQ0E7QUFDZTtBQUM2QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytCO0FBQ1E7QUFDZTtBQUN4QjtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ2M7QUFDMUI7QUFDUDs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JC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QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0Qjs7QUFFeEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRCxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUNBQXlDO0FBQzVEO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRCxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx1Q0FBdUMscUJBQXFCO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUNBQXlDO0FBQy9FO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLDBCQUEwQjtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdURBQXVEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4QkFBOEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZ0JBQWdCLGtEQUFrRDtBQUNsRTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBOzs7QUFHQTs7QUFFQSxnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RnQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUk7QUFDakk7QUFDZ0M7QUFDaEM7QUFDQTtBQUN3QztBQUNzQjtBQUM5RDtBQUNBO0FBQzJCOzs7QUFHM0I7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxjQUFjLHdGQUF3RjtBQUN0RztBQUNBLElBQUk7QUFDSixjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLHdGQUF3RjtBQUN0RztBQUNBLElBQUk7QUFDSixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSx1QkFBdUI7QUFDcEMsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0ZBQXNDO0FBQ3RDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3QyxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjs7QUFFQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsYUFBYSxvRUFBb0U7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyxnQ0FBZ0M7QUFDM0MsYUFBYSx5RUFBeUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0I7QUFDeEI7QUFDYzs7O0FBR2Q7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLDRDQUE0QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzREFBc0Q7QUFDdkUsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxpQ0FBaUM7QUFDcEQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RQQTtBQUFBO0FBQ0E7QUFDQTtBQUNtQztBQUNuQztBQUNBO0FBQzBDO0FBQ2pCOzs7QUFHekI7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxxQ0FBcUM7QUFDbkQsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQSxJQUFJLGdEQUFnRDtBQUNwRCxJQUFJLG1EQUFtRDtBQUN2RCxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBLGFBQWEsc0RBQXNEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDOzs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQjtBQUNPOzs7QUFHakM7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMscUNBQXFDO0FBQ25ELGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0EsSUFBSSxtREFBbUQ7QUFDdkQsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0JBQXdCO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsR0E7QUFBQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUM4STtBQUNwSTtBQUN6QjtBQUNBO0FBQ3VEO0FBQ007QUFDN0Q7QUFDQTtBQUM4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUMyQjs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLDhCQUE4QjtBQUM1QyxjQUFjLE9BQU87QUFDckIsY0FBYyxnQ0FBZ0M7QUFDOUMsY0FBYyxpREFBaUQ7QUFDL0Q7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMscUNBQXFDO0FBQ25ELGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0E7QUFDQSxJQUFJLCtDQUErQztBQUNuRCxjQUFjLHFDQUFxQztBQUNuRCxrQkFBa0IsZ0RBQWdEO0FBQ2xFO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQsSUFBSSw0Q0FBNEM7QUFDaEQsY0FBYyxxQ0FBcUM7QUFDbkQsMkJBQTJCLGdEQUFnRDtBQUMzRTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakUsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyx3RkFBd0Y7QUFDdEc7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjLHlDQUF5QztBQUN2RDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBaUQ7QUFDcEU7QUFDQTtBQUNBLGlCQUFpQix5Q0FBeUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSx1Q0FBdUMseUNBQXlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwwQkFBMEI7QUFDaEM7QUFDQSxNQUFNLGlDQUFpQztBQUN2QztBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDhDQUE4Qyx5Q0FBeUM7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3QyxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlDQUF5QztBQUN0RCxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5Q0FBeUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQyxhQUFhLE9BQU87QUFDcEIsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxXQUFXLHlDQUF5QztBQUNwRCxXQUFXLHlDQUF5QztBQUNwRCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxZQUFZLFFBQVE7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxnQkFBZ0Isa0RBQWtEO0FBQ2xFO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQSxXQUFXLHlDQUF5QztBQUNwRDtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0Msc0JBQXNCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQztBQUNBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsa0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMXZDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDQztBQUNoQjtBQUM0QztBQUNYO0FBQ25COzs7QUFHZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMscUNBQXFDO0FBQ25ELGFBQWEsZ0RBQWdEO0FBQzdEO0FBQ0EsSUFBSSx3Q0FBd0M7QUFDNUMsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLFFBQVE7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixXQUFXOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLDBDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xVQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2M7QUFDMkI7QUFDb0I7QUFDN0M7OztBQUdoQjtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaExBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDYztBQUN1QjtBQUN3Qjs7O0FBRzdEO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxZQUFZLFFBQVE7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaExBO0FBQUE7QUFDQTtBQUNBO0FBQ3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNrQjs7O0FBR2xCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWSxRQUFRO0FBQ3BCLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxxREFBcUQ7QUFDbkU7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQSxjQUFjLDhDQUE4QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMscURBQXFEO0FBQ25FO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQzs7Ozs7Ozs7Ozs7O0FDdlBBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFBQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ3lCO0FBQ1Y7QUFDZjtBQUNzRDtBQUN6QztBQUNiO0FBQ0E7QUFDQTtBQUNjO0FBQ2Q7QUFDMkI7OztBQUczQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRCxJQUFJLCtCQUErQjtBQUNuQyxJQUFJLDRCQUE0QjtBQUNoQztBQUNBLGFBQWE7QUFDYixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMscUNBQXFDO0FBQ25ELGtCQUFrQixnREFBZ0Q7QUFDbEU7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0EsY0FBYyxxQ0FBcUM7QUFDbkQsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBLElBQUksNkNBQTZDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1RUFBdUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0ZBQXdGO0FBQ3RHO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0IsY0FBYyxxQ0FBcUM7QUFDbkQsa0JBQWtCLGdEQUFnRDtBQUNsRTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQSxjQUFjLHFDQUFxQztBQUNuRCxrQkFBa0IsZ0RBQWdEO0FBQ2xFO0FBQ0E7QUFDQSxJQUFJLDhDQUE4QztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLElBQUksc0RBQXNEO0FBQzFELGNBQWMsNENBQTRDO0FBQzFELGtCQUFrQix3QkFBd0I7QUFDMUMsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxlQUFlLHlDQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDJDQUEyQztBQUN4RCxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdEQUFnRDtBQUM3RTtBQUNBO0FBQ0EsTUFBTSxpRUFBaUU7QUFDdkUsYUFBYSwyQ0FBMkM7QUFDeEQsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLFFBQVE7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBMkM7QUFDOUQsbUJBQW1CLHNCQUFzQjtBQUN6QyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBMkM7QUFDOUQsbUJBQW1CLHNCQUFzQjtBQUN6QyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZlQTtBQUFBO0FBQ0E7QUFDQTtBQUNlO0FBQ1M7QUFDeEI7QUFDa0o7QUFDcEg7QUFDOUI7QUFDb0M7QUFDaEI7QUFDcEI7QUFDbUI7QUFDMkM7QUFDNUM7QUFDUTtBQUMxQjtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxxQ0FBcUM7QUFDbkQsY0FBYywyQkFBMkI7QUFDekM7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDLGNBQWMsd0NBQXdDO0FBQ3REOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLHlDQUF5QztBQUN2RCxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCLEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxRUFBcUU7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDs7QUFFQTtBQUNBLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSx1QkFBdUI7QUFDcEMsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQSxxQ0FBcUMsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EsbUNBQW1DLHVDQUF1QztBQUMxRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0EsdUNBQXVDLHVDQUF1QztBQUM5RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0EscUNBQXFDLHVDQUF1QztBQUM1RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsV0FBVyx1Q0FBdUM7QUFDbEQsWUFBWSxPQUFPO0FBQ25CLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVvQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUNaO0FBQ2Y7QUFDYTtBQUNJO0FBQ2pCO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQSxjQUFjLHVFQUF1RTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQWdEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlDQUF5QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHVCQUF1QjtBQUNwQyxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxZQUFZLFFBQVE7QUFDcEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLHFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNVVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNjO0FBQ0M7OztBQUdmO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4RUFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSxnQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1BBO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQzJCO0FBQzNCO0FBQ2U7QUFDZTtBQUM5QjtBQUN3QjtBQUN4QjtBQUNzQjtBQUN0Qjs7O0FBR0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHdCQUF3QjtBQUN0QztBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsMkVBQTJFO0FBQ3pGOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTSxzQ0FBc0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsOEJBQThCLCtEQUFjO0FBQzdFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RkFBaUQsYUFBYTtBQUM5RCxPQUFPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxzRkFBMEMsYUFBYTtBQUN2RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFDQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNDQUFzQyxLQUFLO0FBQzdEO0FBQ0EsY0FBYyw2Q0FBNkM7QUFDM0QsUUFBUSxrQ0FBa0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0NBQXNDLEtBQUs7QUFDekQ7QUFDQSxhQUFhLDZDQUE2QztBQUMxRCxRQUFRLGtDQUFrQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSxpQzs7Ozs7Ozs7Ozs7Ozs7QUN0UEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDLGNBQWMsdUJBQXVCO0FBQ3JDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsMEJBQTBCLG9DQUFvQztBQUM5RDtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckVBO0FBQUE7QUFDQTtBQUNBO0FBQzhCO0FBQzlCO0FBQ2U7QUFDWTtBQUMzQjtBQUNBO0FBQ2U7QUFDZjtBQUNBOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEMscUNBQXFDLDhEQUE4RDtBQUNuRztBQUNBOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLHNCQUFzQjtBQUNwQyxjQUFjLE9BQU87QUFDckIsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFLFNBQVMsMENBQTBDO0FBQ25EO0FBQ0EsSUFBSSx5Q0FBeUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStCO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0NBQXdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2QkFBNkI7QUFDbkMsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsaUM7Ozs7Ozs7Ozs7OztBQ3pPQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlOzs7QUFHZjtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBLFFBQVEsNkJBQTZCO0FBQ3JDLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxnQzs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDMkM7OztBQUcxRDtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QyxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0EsUUFBUSw2QkFBNkI7QUFDckMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLHdGQUF3RjtBQUN0RyxJQUFJLHNCQUFzQjtBQUMxQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0JBQStCLE9BQU87O0FBRXJFLCtFQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzRUFBc0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUE4QztBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3Q0FBd0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGtDOzs7Ozs7Ozs7Ozs7QUN0UkE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0Q7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsT0FBTztBQUNsQixZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLE9BQU87QUFDbEIsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDLFlBQVksMkVBQTJFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0EseUNBQXlDLGdDQUFnQztBQUN6RSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUFBO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSx3RUFBb0I7QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUM7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHNDQUFzQztBQUNqRCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUEsdUM7Ozs7Ozs7Ozs7Ozs7QUMxUEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxvQzs7Ozs7Ozs7Ozs7OztBQ25NQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsd0M7Ozs7Ozs7Ozs7Ozs7QUM1SUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSx3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1FBO0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRXlCO0FBQ3pCO0FBQ2tDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQixjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsK0M7Ozs7Ozs7Ozs7Ozs7OztBQ3phQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDbUI7OztBQUduQjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsTUFBTTtBQUNuQixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsdUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL2FBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQsTUFBTSxnQ0FBZ0M7QUFDdEMsSUFBSSxtQ0FBbUM7QUFDdkMsbUJBQW1CLDZDQUE2QztBQUNoRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNELElBQUksbUNBQW1DO0FBQ3ZDO0FBQ0E7QUFDb0I7QUFDRztBQUNSO0FBQ3VEO0FBQzFCO0FBQzVDO0FBQytCO0FBQy9CO0FBQ3VGOzs7QUFHdkY7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0EsYUFBYSwyQ0FBMkM7QUFDeEQ7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRUFBbUU7QUFDaEY7QUFDQTs7O0FBR1E7OztBQUdSO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkNBQTJDO0FBQy9DLElBQUksaUVBQWlFO0FBQ3JFO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQsV0FBVyxPQUFPO0FBQ2xCLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQSxXQUFXLDJFQUEyRTtBQUN0RjtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDhCQUE4QjtBQUN6QyxXQUFXLDJFQUEyRTtBQUN0RjtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkUsd0JBQXdCLHNDQUFzQztBQUM5RCxXQUFXLDJFQUEyRTtBQUN0RjtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkUsd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQztBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyw4QkFBOEI7QUFDekMsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUM7QUFDN0MsZ0NBQWdDLHVDQUF1QztBQUN2RTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVyw4QkFBOEI7QUFDekMsV0FBVyw4QkFBOEI7QUFDekMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsOEJBQThCO0FBQ3pDLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsV0FBVywwQkFBMEI7QUFDckMsV0FBVywwQkFBMEI7QUFDckMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDOzs7Ozs7Ozs7Ozs7O0FDbmdCQTtBQUFBO0FBQ0E7QUFDQTtBQUN3Qjs7O0FBR3hCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLDhFQUE4RTtBQUM5RTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0EsS0FBSyxPQUFPLDJCQUEyQixnQ0FBZ0M7QUFDdkUsU0FBUyxPQUFPO0FBQ2hCLGdCQUFnQix3Q0FBd0M7QUFDeEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxQkFBcUI7QUFDeEU7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwyQkFBMkIscUJBQXFCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsV0FBVyx5REFBeUQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxtRUFBbUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7Ozs7Ozs7OztBQzdRQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUFBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JKQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFBQTtBQUNBO0FBQ0E7QUFDZ0I7OztBQUdoQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLDJDQUEyQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSwrQjs7Ozs7Ozs7Ozs7OztBQ25JQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLGlDOzs7Ozs7Ozs7Ozs7QUNwREE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7O0FBRUEsdUM7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0M7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1EQUFtRDtBQUM5RCxXQUFXLDJDQUEyQztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3REFBd0Q7QUFDbkUsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QyxXQUFXLDJDQUEyQztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0RBQWdEO0FBQzNELFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlEQUFpRDtBQUM1RCxXQUFXLDJDQUEyQztBQUN0RDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsd0NBQXdDO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLHdDQUF3QztBQUNuRDtBQUNBOztBQUVBOztBQUVBLHlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUFBO0FBQ0E7QUFDQTtBQUN3QjtBQUNNO0FBQ2hCO0FBQ2Q7QUFDa0M7OztBQUdsQztBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLDhCQUE4QjtBQUM1Qzs7O0FBR0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyw4QkFBOEI7QUFDNUMsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsT0FBTztBQUNyQixjQUFjLGVBQWU7QUFDN0IsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLDhCQUE4QjtBQUM1Qzs7O0FBR0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0NBQXdDO0FBQ3pELGFBQWEsVUFBVTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGlCQUFpQix5Q0FBeUM7QUFDMUQsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLE9BQU87QUFDbEIsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0M7Ozs7Ozs7Ozs7Ozs7O0FDeFdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUNBQXVDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEOztBQUVBLHVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL05BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ0s7QUFDRDtBQUNuQjtBQUN3QjtBQUNKO0FBQ0s7QUFDekI7QUFDK007QUFDaEo7O0FBRS9EO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLElBQUkseUNBQXlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0saURBQWlEO0FBQ3ZEO0FBQ0EsYUFBYSxpREFBaUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQSwrQ0FBK0Msa0NBQWtDO0FBQ2pGO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5Q0FBeUM7QUFDL0M7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBd0Q7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxx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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSx5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDek5BO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDRztBQUNjO0FBQ1o7QUFFd0M7QUFDNUQ7QUFDQTtBQUNrRjtBQUN6RDtBQUNGO0FBQ0g7QUFDSztBQUNUO0FBQ2hCO0FBR2tDO0FBQ2xDO0FBQ21CO0FBTWxCOzs7QUFHRDtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDOUI7QUFDNEM7QUFDOUI7QUFDaUQ7QUFDL0Q7OztBQUdBO0FBQ0EsYUFBYSwwREFBMEQ7QUFDdkU7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQTJDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDLDBCQUEwQjtBQUNqRSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSxnQzs7Ozs7Ozs7Ozs7Ozs7O0FDelRBO0FBQUE7QUFDQTtBQUNBO0FBRWdEO0FBQ2pDO0FBQ007OztBQUdyQjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsY0FBYyx3Q0FBd0M7QUFDdEQsY0FBYyx3Q0FBd0M7QUFDdEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrREFBa0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLGdDQUFnQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDLFdB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLDJDQUEyQztBQUMx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QUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsZ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHFCQUFxQjs7O0FBR3JCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLGlDQUFpQyxtQ0FBbUM7QUFDcEU7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVROztBQUVSLGlDOzs7Ozs7Ozs7OztBQ25WQTtBQUNBO0FBQ0EsVUFDQTtBQUNBLENBQUMscUJBQXFCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUM5REQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFNBQVM7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFNBQVM7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUyxlQUFlO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEIiwiZmlsZSI6Im9wZW5sYXllcnMtdmVsb2NpdHkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9Bc3NlcnRpb25FcnJvclxuICovXG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vdXRpbC5qcyc7XG5cbi8qKlxuICogRXJyb3Igb2JqZWN0IHRocm93biB3aGVuIGFuIGFzc2VydGlvbiBmYWlsZWQuIFRoaXMgaXMgYW4gRUNNQS0yNjIgRXJyb3IsXG4gKiBleHRlbmRlZCB3aXRoIGEgYGNvZGVgIHByb3BlcnR5LlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yLlxuICovXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKEVycm9yKSB7XG4gIGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKGNvZGUpIHtcbiAgICB2YXIgcGF0aCA9IFZFUlNJT04uc3BsaXQoJy0nKVswXTtcbiAgICB2YXIgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLiBTZWUgaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi8nICsgcGF0aCArXG4gICAgJy9kb2MvZXJyb3JzLyMnICsgY29kZSArICcgZm9yIGRldGFpbHMuJztcblxuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlLiBUaGUgbWVhbmluZyBvZiB0aGUgY29kZSBjYW4gYmUgZm91bmQgb25cbiAgICAgKiBodHRwczovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9kb2MvZXJyb3JzLyAocmVwbGFjZSBgbGF0ZXN0YCB3aXRoXG4gICAgICogdGhlIHZlcnNpb24gZm91bmQgaW4gdGhlIE9wZW5MYXllcnMgc2NyaXB0J3MgaGVhZGVyIGNvbW1lbnQgaWYgYSB2ZXJzaW9uXG4gICAgICogb3RoZXIgdGhhbiB0aGUgbGF0ZXN0IGlzIHVzZWQpLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbiAgICAvLyBSZS1hc3NpZ24gbWVzc2FnZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SaWNoLUhhcnJpcy9idWJsZS9pc3N1ZXMvNDBcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgaWYgKCBFcnJvciApIEFzc2VydGlvbkVycm9yLl9fcHJvdG9fXyA9IEVycm9yO1xuICBBc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvciAmJiBFcnJvci5wcm90b3R5cGUgKTtcbiAgQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbiAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShFcnJvcikpO1xuXG5leHBvcnQgZGVmYXVsdCBBc3NlcnRpb25FcnJvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNzZXJ0aW9uRXJyb3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0NvbGxlY3Rpb25cbiAqL1xuaW1wb3J0IEFzc2VydGlvbkVycm9yIGZyb20gJy4vQXNzZXJ0aW9uRXJyb3IuanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIFByb3BlcnR5ID0ge1xuICBMRU5HVEg6ICdsZW5ndGgnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgQ29sbGVjdGlvbkV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBDb2xsZWN0aW9uRXZlbnQodHlwZSwgb3B0X2VsZW1lbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBpcyBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogQHR5cGUgeyp9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdF9lbGVtZW50O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgQ29sbGVjdGlvbkV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBDb2xsZWN0aW9uRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIENvbGxlY3Rpb25FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uRXZlbnQ7XG5cbiAgcmV0dXJuIENvbGxlY3Rpb25FdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VuaXF1ZT1mYWxzZV0gRGlzYWxsb3cgdGhlIHNhbWUgaXRlbSBmcm9tIGJlaW5nIGFkZGVkIHRvXG4gKiB0aGUgY29sbGVjdGlvbiB0d2ljZS5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFuIGV4cGFuZGVkIHZlcnNpb24gb2Ygc3RhbmRhcmQgSlMgQXJyYXksIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIGZvclxuICogbWFuaXB1bGF0aW9uLiBBZGQgYW5kIHJlbW92ZSBjaGFuZ2VzIHRvIHRoZSBDb2xsZWN0aW9uIHRyaWdnZXIgYSBDb2xsZWN0aW9uXG4gKiBldmVudC4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgY292ZXIgY2hhbmdlcyB0byB0aGUgb2JqZWN0cyBfd2l0aGluXyB0aGVcbiAqIENvbGxlY3Rpb247IHRoZXkgdHJpZ2dlciBldmVudHMgb24gdGhlIGFwcHJvcHJpYXRlIG9iamVjdCwgbm90IG9uIHRoZVxuICogQ29sbGVjdGlvbiBhcyBhIHdob2xlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAYXBpXG4gKi9cbnZhciBDb2xsZWN0aW9uID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIENvbGxlY3Rpb24ob3B0X2FycmF5LCBvcHRfb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZV8gPSAhIW9wdGlvbnMudW5pcXVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5LjxUPn1cbiAgICAgKi9cbiAgICB0aGlzLmFycmF5XyA9IG9wdF9hcnJheSA/IG9wdF9hcnJheSA6IFtdO1xuXG4gICAgaWYgKHRoaXMudW5pcXVlXykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB0aGlzJDEuYXNzZXJ0VW5pcXVlXyh0aGlzJDEuYXJyYXlfW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2hpbGUgKHRoaXMuZ2V0TGVuZ3RoKCkgPiAwKSB7XG4gICAgICB0aGlzJDEucG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudHMgdG8gdGhlIGNvbGxlY3Rpb24uICBUaGlzIHB1c2hlcyBlYWNoIGl0ZW0gaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gICAqIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxUPn0gYXJyIEFycmF5LlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48VD59IFRoaXMgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChhcnIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzJDEucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggZWxlbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCwgbnVtYmVyLCBBcnJheS48VD4pOiAqfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICAgKiAgICAgaW5kZXggYW5kIHRoZSBhcnJheSkuIFRoZSByZXR1cm4gdmFsdWUgaXMgaWdub3JlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXkgb2JqZWN0LiBXYXJuaW5nOiBpZiB0aGUgYXJyYXlcbiAgICogaXMgbXV0YXRlZCwgbm8gZXZlbnRzIHdpbGwgYmUgZGlzcGF0Y2hlZCBieSB0aGUgY29sbGVjdGlvbiwgYW5kIHRoZVxuICAgKiBjb2xsZWN0aW9uJ3MgXCJsZW5ndGhcIiBwcm9wZXJ0eSB3b24ndCBiZSBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsZW5ndGhcbiAgICogb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPFQ+fSBBcnJheS5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiBnZXRBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbiBpdGVtIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChQcm9wZXJ0eS5MRU5HVEgpKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGFuIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRBdCA9IGZ1bmN0aW9uIGluc2VydEF0IChpbmRleCwgZWxlbSkge1xuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAwLCBlbGVtKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQodGhpcy5nZXRMZW5ndGgoKSAtIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIHByb3ZpZGVkIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGVsZW0pIHtcbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIHZhciBuID0gdGhpcy5nZXRMZW5ndGgoKTtcbiAgICB0aGlzLmluc2VydEF0KG4sIGVsZW0pO1xuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoZWxlbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFyciA9IHRoaXMuYXJyYXlfO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyci5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSBlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzJDEucmVtb3ZlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXggYW5kIHJldHVybiBpdC5cbiAgICogUmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZSBjb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gcmVtb3ZlQXQgKGluZGV4KSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV8uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnVwZGF0ZUxlbmd0aF8oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgcHJldikpO1xuICAgIHJldHVybiBwcmV2O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uIHNldEF0IChpbmRleCwgZWxlbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG4gPSB0aGlzLmdldExlbmd0aCgpO1xuICAgIGlmIChpbmRleCA8IG4pIHtcbiAgICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0sIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2ID0gdGhpcy5hcnJheV9baW5kZXhdO1xuICAgICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSwgcHJldikpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuQURELCBlbGVtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSBuOyBqIDwgaW5kZXg7ICsraikge1xuICAgICAgICB0aGlzJDEuaW5zZXJ0QXQoaiwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0QXQoaW5kZXgsIGVsZW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUxlbmd0aF8gPSBmdW5jdGlvbiB1cGRhdGVMZW5ndGhfICgpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MRU5HVEgsIHRoaXMuYXJyYXlfLmxlbmd0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9leGNlcHQgT3B0aW9uYWwgaW5kZXggdG8gaWdub3JlLlxuICAgKi9cbiAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYXNzZXJ0VW5pcXVlXyA9IGZ1bmN0aW9uIGFzc2VydFVuaXF1ZV8gKGVsZW0sIG9wdF9leGNlcHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICh0aGlzJDEuYXJyYXlfW2ldID09PSBlbGVtICYmIGkgIT09IG9wdF9leGNlcHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKDU4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbGxlY3Rpb247XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDb2xsZWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9Db2xsZWN0aW9uRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhbiBpdGVtIGlzIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbkV2ZW50I2FkZFxuICAgKiBAYXBpXG4gICAqL1xuICBBREQ6ICdhZGQnLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBldmVudCBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnQjcmVtb3ZlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTU9WRTogJ3JlbW92ZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxlY3Rpb25FdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0Rpc3Bvc2FibGVcbiAqL1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBPYmplY3RzIHRoYXQgbmVlZCB0byBjbGVhbiB1cCBhZnRlciB0aGVtc2VsdmVzLlxuICovXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uIERpc3Bvc2FibGUgKCkge307XG5cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlICgpIHtcbiAgaWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuICAgIHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuRGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZWRfID0gZmFsc2U7XG5cbi8qKlxuICogRXh0ZW5zaW9uIHBvaW50IGZvciBkaXNwb3NhYmxlIG9iamVjdHMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IFVOREVGSU5FRDtcbmV4cG9ydCBkZWZhdWx0IERpc3Bvc2FibGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3Bvc2FibGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ZlYXR1cmVcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0LCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9nZW9tL0dlb21ldHJ5LmpzJztcbmltcG9ydCBTdHlsZSBmcm9tICcuL3N0eWxlL1N0eWxlLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHZlY3RvciBvYmplY3QgZm9yIGdlb2dyYXBoaWMgZmVhdHVyZXMgd2l0aCBhIGdlb21ldHJ5IGFuZCBvdGhlclxuICogYXR0cmlidXRlIHByb3BlcnRpZXMsIHNpbWlsYXIgdG8gdGhlIGZlYXR1cmVzIGluIHZlY3RvciBmaWxlIGZvcm1hdHMgbGlrZVxuICogR2VvSlNPTi5cbiAqXG4gKiBGZWF0dXJlcyBjYW4gYmUgc3R5bGVkIGluZGl2aWR1YWxseSB3aXRoIGBzZXRTdHlsZWA7IG90aGVyd2lzZSB0aGV5IHVzZSB0aGVcbiAqIHN0eWxlIG9mIHRoZWlyIHZlY3RvciBsYXllci5cbiAqXG4gKiBOb3RlIHRoYXQgYXR0cmlidXRlIHByb3BlcnRpZXMgYXJlIHNldCBhcyB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH0gcHJvcGVydGllcyBvblxuICogdGhlIGZlYXR1cmUgb2JqZWN0LCBzbyB0aGV5IGFyZSBvYnNlcnZhYmxlLCBhbmQgaGF2ZSBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBUeXBpY2FsbHksIGEgZmVhdHVyZSBoYXMgYSBzaW5nbGUgZ2VvbWV0cnkgcHJvcGVydHkuIFlvdSBjYW4gc2V0IHRoZVxuICogZ2VvbWV0cnkgdXNpbmcgdGhlIGBzZXRHZW9tZXRyeWAgbWV0aG9kIGFuZCBnZXQgaXQgd2l0aCBgZ2V0R2VvbWV0cnlgLlxuICogSXQgaXMgcG9zc2libGUgdG8gc3RvcmUgbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBvbiBhIGZlYXR1cmUgdXNpbmcgYXR0cmlidXRlXG4gKiBwcm9wZXJ0aWVzLiBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgdXNlZCBmb3IgcmVuZGVyaW5nIGlzIGlkZW50aWZpZWQgYnlcbiAqIHRoZSBwcm9wZXJ0eSBuYW1lIGBnZW9tZXRyeWAuIElmIHlvdSB3YW50IHRvIHVzZSBhbm90aGVyIGdlb21ldHJ5IHByb3BlcnR5XG4gKiBmb3IgcmVuZGVyaW5nLCB1c2UgdGhlIGBzZXRHZW9tZXRyeU5hbWVgIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGF0dHJpYnV0ZVxuICogcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICpcbiAqIGltcG9ydCBGZWF0dXJlIGZyb20gJ29sL0ZlYXR1cmUnO1xuICogaW1wb3J0IFBvbHlnb24gZnJvbSAnb2wvZ2VvbS9Qb2x5Z29uJztcbiAqIGltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50JztcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKHtcbiAqICAgZ2VvbWV0cnk6IG5ldyBQb2x5Z29uKHBvbHlDb29yZHMpLFxuICogICBsYWJlbFBvaW50OiBuZXcgUG9pbnQobGFiZWxDb29yZHMpLFxuICogICBuYW1lOiAnTXkgUG9seWdvbidcbiAqIH0pO1xuICpcbiAqIC8vIGdldCB0aGUgcG9seWdvbiBnZW9tZXRyeVxuICogdmFyIHBvbHkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKlxuICogLy8gUmVuZGVyIHRoZSBmZWF0dXJlIGFzIGEgcG9pbnQgdXNpbmcgdGhlIGNvb3JkaW5hdGVzIGZyb20gbGFiZWxQb2ludFxuICogZmVhdHVyZS5zZXRHZW9tZXRyeU5hbWUoJ2xhYmVsUG9pbnQnKTtcbiAqXG4gKiAvLyBnZXQgdGhlIHBvaW50IGdlb21ldHJ5XG4gKiB2YXIgcG9pbnQgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBGZWF0dXJlID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEZlYXR1cmUob3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmlkXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5TmFtZV8gPSAnZ2VvbWV0cnknO1xuXG4gICAgLyoqXG4gICAgICogVXNlciBwcm92aWRlZCBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV8QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT58bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5zdHlsZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgaWYgKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzIGluc3RhbmNlb2YgR2VvbWV0cnkgfHxcbiAgICAgICAgICAhb3B0X2dlb21ldHJ5T3JQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcztcbiAgICAgICAgdGhpcy5zZXRHZW9tZXRyeShnZW9tZXRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCAqPn0gKi9cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBGZWF0dXJlLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIEZlYXR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBGZWF0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZlYXR1cmU7XG5cbiAgLyoqXG4gICAqIENsb25lIHRoaXMgZmVhdHVyZS4gSWYgdGhlIG9yaWdpbmFsIGZlYXR1cmUgaGFzIGEgZ2VvbWV0cnkgaXRcbiAgICogaXMgYWxzbyBjbG9uZWQuIFRoZSBmZWF0dXJlIGlkIGlzIG5vdCBzZXQgaW4gdGhlIGNsb25lLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvRmVhdHVyZX0gVGhlIGNsb25lLlxuICAgKiBAYXBpXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgY2xvbmUgPSBuZXcgRmVhdHVyZSh0aGlzLmdldFByb3BlcnRpZXMoKSk7XG4gICAgY2xvbmUuc2V0R2VvbWV0cnlOYW1lKHRoaXMuZ2V0R2VvbWV0cnlOYW1lKCkpO1xuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIGNsb25lLnNldEdlb21ldHJ5KGdlb21ldHJ5LmNsb25lKCkpO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjbG9uZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS4gIEEgZmVhdHVyZSBtYXkgaGF2ZSBhbnkgbnVtYmVyIG9mIG5hbWVkXG4gICAqIGdlb21ldHJpZXMuICBUaGUgXCJkZWZhdWx0XCIgZ2VvbWV0cnkgKHRoZSBvbmUgdGhhdCBpcyByZW5kZXJlZCBieSBkZWZhdWx0KSBpc1xuICAgKiBzZXQgd2hlbiBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldEdlb21ldHJ5fS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8dW5kZWZpbmVkfSBUaGUgZGVmYXVsdCBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KHRoaXMuZ2VvbWV0cnlOYW1lXykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlIGlkZW50aWZpZXIuICBUaGlzIGlzIGEgc3RhYmxlIGlkZW50aWZpZXIgZm9yIHRoZSBmZWF0dXJlIGFuZFxuICAgKiBpcyBlaXRoZXIgc2V0IHdoZW4gcmVhZGluZyBkYXRhIGZyb20gYSByZW1vdGUgc291cmNlIG9yIHNldCBleHBsaWNpdGx5IGJ5XG4gICAqIGNhbGxpbmcge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0SWR9LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gSWQuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gZ2V0SWQgKCkge1xuICAgIHJldHVybiB0aGlzLmlkXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBkZWZhdWx0XG4gICAqIGdlb21ldHJ5IGlzIG5hbWVkIGBnZW9tZXRyeWAuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gR2V0IHRoZSBwcm9wZXJ0eSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmYXVsdCBnZW9tZXRyeVxuICAgKiAgICAgZm9yIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuZ2V0R2VvbWV0cnlOYW1lID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5hbWVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUncyBzdHlsZS4gV2lsbCByZXR1cm4gd2hhdCB3YXMgcHJvdmlkZWQgdG8gdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldFN0eWxlfSBtZXRob2QuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9TdHlsZXxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn0gVGhlIGZlYXR1cmUgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gZ2V0U3R5bGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3Mgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH0gUmV0dXJuIGEgZnVuY3Rpb25cbiAgICogcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoaXMgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuZ2V0U3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFN0eWxlRnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlRnVuY3Rpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuaGFuZGxlR2VvbWV0cnlDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlR2VvbWV0cnlDaGFuZ2VfICgpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVHZW9tZXRyeUNoYW5nZWRfICgpIHtcbiAgICBpZiAodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdldEdlb21ldHJ5KCk7XG4gICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5Q2hhbmdlS2V5XyA9IGxpc3RlbihnZW9tZXRyeSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IGdlb21ldHJ5IGZvciB0aGUgZmVhdHVyZS4gIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHByb3BlcnR5XG4gICAqIHdpdGggdGhlIG5hbWUgcmV0dXJuZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjZ2V0R2VvbWV0cnlOYW1lfS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXx1bmRlZmluZWR9IGdlb21ldHJ5IFRoZSBuZXcgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24gc2V0R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gICAgdGhpcy5zZXQodGhpcy5nZW9tZXRyeU5hbWVfLCBnZW9tZXRyeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgZm9yIHRoZSBmZWF0dXJlLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlc29sdXRpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogc3R5bGVzLiBJZiBpdCBpcyBgbnVsbGAgdGhlIGZlYXR1cmUgaGFzIG5vIHN0eWxlIChhIGBudWxsYCBzdHlsZSkuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+fG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufSBzdHlsZSBTdHlsZSBmb3IgdGhpcyBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2V2ZW50OmNoYW5nZVxuICAgKi9cbiAgRmVhdHVyZS5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlO1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPSAhc3R5bGUgPyB1bmRlZmluZWQgOiBjcmVhdGVTdHlsZUZ1bmN0aW9uKHN0eWxlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBmZWF0dXJlIGlkLiAgVGhlIGZlYXR1cmUgaWQgaXMgY29uc2lkZXJlZCBzdGFibGUgYW5kIG1heSBiZSB1c2VkIHdoZW5cbiAgICogcmVxdWVzdGluZyBmZWF0dXJlcyBvciBjb21wYXJpbmcgaWRlbnRpZmllcnMgcmV0dXJuZWQgZnJvbSBhIHJlbW90ZSBzb3VyY2UuXG4gICAqIFRoZSBmZWF0dXJlIGlkIGNhbiBiZSB1c2VkIHdpdGggdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RmVhdHVyZUJ5SWR9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH0gaWQgVGhlIGZlYXR1cmUgaWQuXG4gICAqIEBhcGlcbiAgICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnQjZXZlbnQ6Y2hhbmdlXG4gICAqL1xuICBGZWF0dXJlLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICAgIHRoaXMuaWRfID0gaWQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgbmFtZSB0byBiZSB1c2VkIHdoZW4gZ2V0dGluZyB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNnZXRHZW9tZXRyeX0sIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aFxuICAgKiB0aGlzIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIEZlYXR1cmUucHJvdG90eXBlLnNldEdlb21ldHJ5TmFtZSA9IGZ1bmN0aW9uIHNldEdlb21ldHJ5TmFtZSAobmFtZSkge1xuICAgIHVubGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9IG5hbWU7XG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXygpO1xuICB9O1xuXG4gIHJldHVybiBGZWF0dXJlO1xufShCYXNlT2JqZWN0KSk7XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkXG4gKiB0aHJvdWdoIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBtb2R1bGU6b2wvc3R5bGUvU3R5bGUgb3Igc2luZ2xlIHN0eWxlIG9iamVjdHMgd3JhcHBlZFxuICogaW4gYSBuZXcgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb258IUFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+fCFtb2R1bGU6b2wvc3R5bGUvU3R5bGV9IG9ialxuICogICAgIEEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbiwgYSBzaW5nbGUgc3R5bGUsIG9yIGFuIGFycmF5IG9mIHN0eWxlcy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVGdW5jdGlvbihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPn1cbiAgICAgKi9cbiAgICB2YXIgc3R5bGVzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHN0eWxlcyA9IG9iajtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG9iaiBpbnN0YW5jZW9mIFN0eWxlLFxuICAgICAgICA0MSk7IC8vIEV4cGVjdGVkIGFuIGBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVgIG9yIGFuIGFycmF5IG9mIGBtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVgXG4gICAgICBzdHlsZXMgPSBbb2JqXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBGZWF0dXJlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GZWF0dXJlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZUJhc2VcbiAqL1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL0V2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIEltYWdlQmFzZSA9IChmdW5jdGlvbiAoRXZlbnRUYXJnZXQpIHtcbiAgZnVuY3Rpb24gSW1hZ2VCYXNlKGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgc3RhdGUpIHtcblxuICAgIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9JbWFnZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIEltYWdlQmFzZS5fX3Byb3RvX18gPSBFdmVudFRhcmdldDtcbiAgSW1hZ2VCYXNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VCYXNlO1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gICAqL1xuICBJbWFnZUJhc2UucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7fTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBQaXhlbFJhdGlvLlxuICAgKi9cbiAgSW1hZ2VCYXNlLnByb3RvdHlwZS5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gZ2V0UGl4ZWxSYXRpbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpb187XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuZ2V0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9JbWFnZVN0YXRlfSBTdGF0ZS5cbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiBnZXRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgbm90IHlldCBsb2FkZWQgVVJJLlxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIEltYWdlQmFzZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge307XG5cbiAgcmV0dXJuIEltYWdlQmFzZTtcbn0oRXZlbnRUYXJnZXQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZUJhc2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlQmFzZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VDYW52YXNcbiAqL1xuaW1wb3J0IEltYWdlQmFzZSBmcm9tICcuL0ltYWdlQmFzZS5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuL0ltYWdlU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byB0cmlnZ2VyIGFzeW5jaHJvbm91cyBjYW52YXMgZHJhd2luZy4gIEl0IGlzXG4gKiBjYWxsZWQgd2l0aCBhIFwiZG9uZVwiIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGRyYXdpbmcgaXMgZG9uZS5cbiAqIElmIGFueSBlcnJvciBvY2N1cnMgZHVyaW5nIGRyYXdpbmcsIHRoZSBcImRvbmVcIiBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGhcbiAqIHRoYXQgZXJyb3IuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGZ1bmN0aW9uKEVycm9yKSl9IExvYWRlclxuICovXG5cblxudmFyIEltYWdlQ2FudmFzID0gKGZ1bmN0aW9uIChJbWFnZUJhc2UpIHtcbiAgZnVuY3Rpb24gSW1hZ2VDYW52YXMoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBjYW52YXMsIG9wdF9sb2FkZXIpIHtcblxuICAgIHZhciBzdGF0ZSA9IG9wdF9sb2FkZXIgIT09IHVuZGVmaW5lZCA/IEltYWdlU3RhdGUuSURMRSA6IEltYWdlU3RhdGUuTE9BREVEO1xuXG4gICAgSW1hZ2VCYXNlLmNhbGwodGhpcywgZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdGF0ZSk7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBjYW52YXMgbG9hZGVyIGZ1bmN0aW9uLlxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL0ltYWdlQ2FudmFzfkxvYWRlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyXyA9IG9wdF9sb2FkZXIgIT09IHVuZGVmaW5lZCA/IG9wdF9sb2FkZXIgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gY2FudmFzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RXJyb3J9XG4gICAgICovXG4gICAgdGhpcy5lcnJvcl8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIEltYWdlQmFzZSApIEltYWdlQ2FudmFzLl9fcHJvdG9fXyA9IEltYWdlQmFzZTtcbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW1hZ2VCYXNlICYmIEltYWdlQmFzZS5wcm90b3R5cGUgKTtcbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1hZ2VDYW52YXM7XG5cbiAgLyoqXG4gICAqIEdldCBhbnkgZXJyb3IgYXNzb2NpYXRlZCB3aXRoIGFzeW5jaHJvbm91cyByZW5kZXJpbmcuXG4gICAqIEByZXR1cm4ge0Vycm9yfSBBbnkgZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcmVuZGVyaW5nLlxuICAgKi9cbiAgSW1hZ2VDYW52YXMucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gZ2V0RXJyb3IgKCkge1xuICAgIHJldHVybiB0aGlzLmVycm9yXztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIGFzeW5jIGRyYXdpbmcgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBBbnkgZXJyb3IgZHVyaW5nIGRyYXdpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJbWFnZUNhbnZhcy5wcm90b3R5cGUuaGFuZGxlTG9hZF8gPSBmdW5jdGlvbiBoYW5kbGVMb2FkXyAoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgdGhpcy5lcnJvcl8gPSBlcnI7XG4gICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5FUlJPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEltYWdlQ2FudmFzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLnN0YXRlID0gSW1hZ2VTdGF0ZS5MT0FESU5HO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICB0aGlzLmxvYWRlcl8odGhpcy5oYW5kbGVMb2FkXy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgZWxlbWVudC5cbiAgICovXG4gIEltYWdlQ2FudmFzLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9O1xuXG4gIHJldHVybiBJbWFnZUNhbnZhcztcbn0oSW1hZ2VCYXNlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VDYW52YXM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlQ2FudmFzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9JbWFnZVN0YXRlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElETEU6IDAsXG4gIExPQURJTkc6IDEsXG4gIExPQURFRDogMixcbiAgRVJST1I6IDNcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlU3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlVGlsZVxuICovXG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG5ldzogbW9kdWxlOm9sL0ltYWdlVGlsZSwgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQsXG4gKiBtb2R1bGU6b2wvVGlsZVN0YXRlLCBzdHJpbmcsID9zdHJpbmcsIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbil9IFRpbGVDbGFzc1xuICogQGFwaVxuICovXG5cbnZhciBJbWFnZVRpbGUgPSAoZnVuY3Rpb24gKFRpbGUpIHtcbiAgZnVuY3Rpb24gSW1hZ2VUaWxlKHRpbGVDb29yZCwgc3RhdGUsIHNyYywgY3Jvc3NPcmlnaW4sIHRpbGVMb2FkRnVuY3Rpb24sIG9wdF9vcHRpb25zKSB7XG5cbiAgICBUaWxlLmNhbGwodGhpcywgdGlsZUNvb3JkLCBzdGF0ZSwgb3B0X29wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgVVJJXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcmNfID0gc3JjO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb25fID0gdGlsZUxvYWRGdW5jdGlvbjtcblxuICB9XG5cbiAgaWYgKCBUaWxlICkgSW1hZ2VUaWxlLl9fcHJvdG9fXyA9IFRpbGU7XG4gIEltYWdlVGlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUaWxlICYmIFRpbGUucHJvdG90eXBlICk7XG4gIEltYWdlVGlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZVRpbGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gZ2V0QmxhbmtJbWFnZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnRlcmltVGlsZSkge1xuICAgICAgdGhpcy5pbnRlcmltVGlsZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuQUJPUlQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgVGlsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBpbWFnZSBlbGVtZW50IGZvciB0aGlzIHRpbGUgKG1heSBiZSBhIENhbnZhcywgSW1hZ2UsIG9yIFZpZGVvKS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICogQGFwaVxuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIGdldEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfTtcblxuICAvKipcbiAgICogVHJhY2tzIGxvYWRpbmcgb3IgcmVhZCBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmhhbmRsZUltYWdlRXJyb3JfID0gZnVuY3Rpb24gaGFuZGxlSW1hZ2VFcnJvcl8gKCkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuaW1hZ2VfID0gZ2V0QmxhbmtJbWFnZSgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFja3Mgc3VjY2Vzc2Z1bCBpbWFnZSBsb2FkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgSW1hZ2VUaWxlLnByb3RvdHlwZS5oYW5kbGVJbWFnZUxvYWRfID0gZnVuY3Rpb24gaGFuZGxlSW1hZ2VMb2FkXyAoKSB7XG4gICAgaWYgKHRoaXMuaW1hZ2VfLm5hdHVyYWxXaWR0aCAmJiB0aGlzLmltYWdlXy5uYXR1cmFsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBJbWFnZVRpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuSURMRTtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAodGhpcy5jcm9zc09yaWdpbl8gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luXztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgICAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18gPSBbXG4gICAgICAgIGxpc3Rlbk9uY2UodGhpcy5pbWFnZV8sIEV2ZW50VHlwZS5FUlJPUixcbiAgICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuT25jZSh0aGlzLmltYWdlXywgRXZlbnRUeXBlLkxPQUQsXG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWRfLCB0aGlzKVxuICAgICAgXTtcbiAgICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbl8odGhpcywgdGhpcy5zcmNfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIGV2ZW50IGhhbmRsZXJzIHdoaWNoIGxpc3RlbiBmb3IgbG9hZCBjb21wbGV0aW9uIG9yIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEltYWdlVGlsZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZV8gPSBmdW5jdGlvbiB1bmxpc3RlbkltYWdlXyAoKSB7XG4gICAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEltYWdlVGlsZTtcbn0oVGlsZSkpO1xuXG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgdmFyIGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICByZXR1cm4gY3R4LmNhbnZhcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VUaWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0tpbmV0aWNcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudGF0aW9uIG9mIGluZXJ0aWFsIGRlY2VsZXJhdGlvbiBmb3IgbWFwIG1vdmVtZW50LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIEtpbmV0aWMgPSBmdW5jdGlvbiBLaW5ldGljKGRlY2F5LCBtaW5WZWxvY2l0eSwgZGVsYXkpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuZGVjYXlfID0gZGVjYXk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblZlbG9jaXR5XyA9IG1pblZlbG9jaXR5O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5kZWxheV8gPSBkZWxheTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGhpcy5wb2ludHNfID0gW107XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmFuZ2xlXyA9IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmluaXRpYWxWZWxvY2l0eV8gPSAwO1xufTtcblxuLyoqXG4gKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAqL1xuS2luZXRpYy5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbiBiZWdpbiAoKSB7XG4gIHRoaXMucG9pbnRzXy5sZW5ndGggPSAwO1xuICB0aGlzLmFuZ2xlXyA9IDA7XG4gIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICovXG5LaW5ldGljLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHgsIHkpIHtcbiAgdGhpcy5wb2ludHNfLnB1c2goeCwgeSwgRGF0ZS5ub3coKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgd2Ugc2hvdWxkIGRvIGtpbmV0aWMgYW5pbWF0aW9uLlxuICovXG5LaW5ldGljLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQgKCkge1xuICBpZiAodGhpcy5wb2ludHNfLmxlbmd0aCA8IDYpIHtcbiAgICAvLyBhdCBsZWFzdCAyIHBvaW50cyBhcmUgcmVxdWlyZWQgKGkuZS4gdGhlcmUgbXVzdCBiZSBhdCBsZWFzdCA2IGVsZW1lbnRzXG4gICAgLy8gaW4gdGhlIGFycmF5KVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZGVsYXkgPSBEYXRlLm5vdygpIC0gdGhpcy5kZWxheV87XG4gIHZhciBsYXN0SW5kZXggPSB0aGlzLnBvaW50c18ubGVuZ3RoIC0gMztcbiAgaWYgKHRoaXMucG9pbnRzX1tsYXN0SW5kZXggKyAyXSA8IGRlbGF5KSB7XG4gICAgLy8gdGhlIGxhc3QgdHJhY2tlZCBwb2ludCBpcyB0b28gb2xkLCB3aGljaCBtZWFucyB0aGF0IHRoZSB1c2VyIHN0b3BwZWRcbiAgICAvLyBwYW5uaW5nIGJlZm9yZSByZWxlYXNpbmcgdGhlIG1hcFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggc3RpbGwgZmFsbHMgaW50byB0aGUgZGVsYXkgdGltZVxuICB2YXIgZmlyc3RJbmRleCA9IGxhc3RJbmRleCAtIDM7XG4gIHdoaWxlIChmaXJzdEluZGV4ID4gMCAmJiB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDJdID4gZGVsYXkpIHtcbiAgICBmaXJzdEluZGV4IC09IDM7XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSB0aGlzLnBvaW50c19bbGFzdEluZGV4ICsgMl0gLSB0aGlzLnBvaW50c19bZmlyc3RJbmRleCArIDJdO1xuICAvLyB3ZSBkb24ndCB3YW50IGEgZHVyYXRpb24gb2YgMCAoZGl2aWRlIGJ5IHplcm8pXG4gIC8vIHdlIGFsc28gbWFrZSBzdXJlIHRoZSB1c2VyIHBhbm5lZCBmb3IgYSBkdXJhdGlvbiBvZiBhdCBsZWFzdCBvbmUgZnJhbWVcbiAgLy8gKDEvNjBzKSB0byBjb21wdXRlIHNhbmUgZGlzcGxhY2VtZW50IHZhbHVlc1xuICBpZiAoZHVyYXRpb24gPCAxMDAwIC8gNjApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZHggPSB0aGlzLnBvaW50c19bbGFzdEluZGV4XSAtIHRoaXMucG9pbnRzX1tmaXJzdEluZGV4XTtcbiAgdmFyIGR5ID0gdGhpcy5wb2ludHNfW2xhc3RJbmRleCArIDFdIC0gdGhpcy5wb2ludHNfW2ZpcnN0SW5kZXggKyAxXTtcbiAgdGhpcy5hbmdsZV8gPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLyBkdXJhdGlvbjtcbiAgcmV0dXJuIHRoaXMuaW5pdGlhbFZlbG9jaXR5XyA+IHRoaXMubWluVmVsb2NpdHlfO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRvdGFsIGRpc3RhbmNlIHRyYXZlbGxlZCAocGl4ZWxzKS5cbiAqL1xuS2luZXRpYy5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiAodGhpcy5taW5WZWxvY2l0eV8gLSB0aGlzLmluaXRpYWxWZWxvY2l0eV8pIC8gdGhpcy5kZWNheV87XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgb2YgdGhlIGtpbmV0aWMgcGFubmluZyBhbmltYXRpb24gKHJhZGlhbnMpLlxuICovXG5LaW5ldGljLnByb3RvdHlwZS5nZXRBbmdsZSA9IGZ1bmN0aW9uIGdldEFuZ2xlICgpIHtcbiAgcmV0dXJuIHRoaXMuYW5nbGVfO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgS2luZXRpYztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2luZXRpYy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTGF5ZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBBIGxheWVyIHR5cGUgdXNlZCB3aGVuIGNyZWF0aW5nIGxheWVyIHJlbmRlcmVycy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSU1BR0U6ICdJTUFHRScsXG4gIFRJTEU6ICdUSUxFJyxcbiAgVkVDVE9SX1RJTEU6ICdWRUNUT1JfVElMRScsXG4gIFZFQ1RPUjogJ1ZFQ1RPUidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheWVyVHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwXG4gKi9cbmltcG9ydCBQbHVnZ2FibGVNYXAgZnJvbSAnLi9QbHVnZ2FibGVNYXAuanMnO1xuaW1wb3J0IHtkZWZhdWx0cyBhcyBkZWZhdWx0Q29udHJvbHN9IGZyb20gJy4vY29udHJvbC91dGlsLmpzJztcbmltcG9ydCB7ZGVmYXVsdHMgYXMgZGVmYXVsdEludGVyYWN0aW9uc30gZnJvbSAnLi9pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi9vYmouanMnO1xuaW1wb3J0IENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL2NhbnZhcy9JbWFnZUxheWVyLmpzJztcbmltcG9ydCBDYW52YXNNYXBSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL2NhbnZhcy9NYXAuanMnO1xuaW1wb3J0IENhbnZhc1RpbGVMYXllclJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllci5qcyc7XG5pbXBvcnQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllci5qcyc7XG5pbXBvcnQgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaGUgbWFwIGlzIHRoZSBjb3JlIGNvbXBvbmVudCBvZiBPcGVuTGF5ZXJzLiBGb3IgYSBtYXAgdG8gcmVuZGVyLCBhIHZpZXcsXG4gKiBvbmUgb3IgbW9yZSBsYXllcnMsIGFuZCBhIHRhcmdldCBjb250YWluZXIgYXJlIG5lZWRlZDpcbiAqXG4gKiAgICAgaW1wb3J0IE1hcCBmcm9tICdvbC9NYXAnO1xuICogICAgIGltcG9ydCBWaWV3IGZyb20gJ29sL1ZpZXcnO1xuICogICAgIGltcG9ydCBUaWxlTGF5ZXIgZnJvbSAnb2wvbGF5ZXIvVGlsZSc7XG4gKiAgICAgaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNJztcbiAqXG4gKiAgICAgdmFyIG1hcCA9IG5ldyBNYXAoe1xuICogICAgICAgdmlldzogbmV3IFZpZXcoe1xuICogICAgICAgICBjZW50ZXI6IFswLCAwXSxcbiAqICAgICAgICAgem9vbTogMVxuICogICAgICAgfSksXG4gKiAgICAgICBsYXllcnM6IFtcbiAqICAgICAgICAgbmV3IFRpbGVMYXllcih7XG4gKiAgICAgICAgICAgc291cmNlOiBuZXcgT1NNKClcbiAqICAgICAgICAgfSlcbiAqICAgICAgIF0sXG4gKiAgICAgICB0YXJnZXQ6ICdtYXAnXG4gKiAgICAgfSk7XG4gKlxuICogVGhlIGFib3ZlIHNuaXBwZXQgY3JlYXRlcyBhIG1hcCB1c2luZyBhIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVGlsZX0gdG9cbiAqIGRpc3BsYXkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvT1NNfk9TTX0gT1NNIGRhdGEgYW5kIHJlbmRlciBpdCB0byBhIERPTVxuICogZWxlbWVudCB3aXRoIHRoZSBpZCBgbWFwYC5cbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgcGxhY2VzIGEgdmlld3BvcnQgY29udGFpbmVyICh3aXRoIENTUyBjbGFzcyBuYW1lXG4gKiBgb2wtdmlld3BvcnRgKSBpbiB0aGUgdGFyZ2V0IGVsZW1lbnQgKHNlZSBgZ2V0Vmlld3BvcnQoKWApLCBhbmQgdGhlbiB0d29cbiAqIGZ1cnRoZXIgZWxlbWVudHMgd2l0aGluIHRoZSB2aWV3cG9ydDogb25lIHdpdGggQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGAgZm9yIGNvbnRyb2xzIGFuZCBzb21lIG92ZXJsYXlzLCBhbmQgb25lIHdpdGhcbiAqIENTUyBjbGFzcyBuYW1lIGBvbC1vdmVybGF5Y29udGFpbmVyYCBmb3Igb3RoZXIgb3ZlcmxheXMgKHNlZSB0aGUgYHN0b3BFdmVudGBcbiAqIG9wdGlvbiBvZiB7QGxpbmsgbW9kdWxlOm9sL092ZXJsYXl+T3ZlcmxheX0gZm9yIHRoZSBkaWZmZXJlbmNlKS4gVGhlIG1hcFxuICogaXRzZWxmIGlzIHBsYWNlZCBpbiBhIGZ1cnRoZXIgZWxlbWVudCB3aXRoaW4gdGhlIHZpZXdwb3J0LlxuICpcbiAqIExheWVycyBhcmUgc3RvcmVkIGFzIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IGluXG4gKiBsYXllckdyb3Vwcy4gQSB0b3AtbGV2ZWwgZ3JvdXAgaXMgcHJvdmlkZWQgYnkgdGhlIGxpYnJhcnkuIFRoaXMgaXMgd2hhdCBpc1xuICogYWNjZXNzZWQgYnkgYGdldExheWVyR3JvdXBgIGFuZCBgc2V0TGF5ZXJHcm91cGAuIExheWVycyBlbnRlcmVkIGluIHRoZVxuICogb3B0aW9ucyBhcmUgYWRkZWQgdG8gdGhpcyBncm91cCwgYW5kIGBhZGRMYXllcmAgYW5kIGByZW1vdmVMYXllcmAgY2hhbmdlIHRoZVxuICogbGF5ZXIgY29sbGVjdGlvbiBpbiB0aGUgZ3JvdXAuIGBnZXRMYXllcnNgIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yXG4gKiBgZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpYC4gTm90ZSB0aGF0IHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvR3JvdXB+R3JvdXB9XG4gKiBpcyBhIHN1YmNsYXNzIG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZX0sIHNvIGxheWVycyBlbnRlcmVkIGluIHRoZVxuICogb3B0aW9ucyBvciBhZGRlZCB3aXRoIGBhZGRMYXllcmAgY2FuIGJlIGdyb3Vwcywgd2hpY2ggY2FuIGNvbnRhaW4gZnVydGhlclxuICogZ3JvdXBzLCBhbmQgc28gb24uXG4gKlxuICogQGZpcmVzIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICogQGFwaVxuICovXG52YXIgTWFwID0gKGZ1bmN0aW9uIChQbHVnZ2FibGVNYXApIHtcbiAgZnVuY3Rpb24gTWFwKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMuY29udHJvbHMpIHtcbiAgICAgIG9wdGlvbnMuY29udHJvbHMgPSBkZWZhdWx0Q29udHJvbHMoKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmludGVyYWN0aW9ucykge1xuICAgICAgb3B0aW9ucy5pbnRlcmFjdGlvbnMgPSBkZWZhdWx0SW50ZXJhY3Rpb25zKCk7XG4gICAgfVxuXG4gICAgUGx1Z2dhYmxlTWFwLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIFBsdWdnYWJsZU1hcCApIE1hcC5fX3Byb3RvX18gPSBQbHVnZ2FibGVNYXA7XG4gIE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQbHVnZ2FibGVNYXAgJiYgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZSApO1xuICBNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwO1xuXG4gIE1hcC5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJlciAoKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gbmV3IENhbnZhc01hcFJlbmRlcmVyKHRoaXMpO1xuICAgIHJlbmRlcmVyLnJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMoW1xuICAgICAgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLFxuICAgICAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIsXG4gICAgICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLFxuICAgICAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJcbiAgICBdKTtcbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH07XG5cbiAgcmV0dXJuIE1hcDtcbn0oUGx1Z2dhYmxlTWFwKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFxuICovXG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGJyb3dzZXIgZXZlbnRzIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gZm9yIHdoaWNoIGV2ZW50cyB0cmlnZ2VyIGEgbWFwIGJyb3dzZXIgZXZlbnQuXG4gKi9cbnZhciBNYXBCcm93c2VyRXZlbnQgPSAoZnVuY3Rpb24gKE1hcEV2ZW50KSB7XG4gIGZ1bmN0aW9uIE1hcEJyb3dzZXJFdmVudCh0eXBlLCBtYXAsIGJyb3dzZXJFdmVudCwgb3B0X2RyYWdnaW5nLCBvcHRfZnJhbWVTdGF0ZSkge1xuXG4gICAgTWFwRXZlbnQuY2FsbCh0aGlzLCB0eXBlLCBtYXAsIG9wdF9mcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gYnJvd3NlckV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBwaXhlbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsID0gbWFwLmdldEV2ZW50UGl4ZWwoYnJvd3NlckV2ZW50KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIGluIHZpZXcgcHJvamVjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLnBpeGVsKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgbWFwIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiBPbmx5IHNldCBmb3JcbiAgICAgKiBgUE9JTlRFUkRSQUdgIGFuZCBgUE9JTlRFUk1PVkVgIGV2ZW50cy4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBvcHRfZHJhZ2dpbmcgIT09IHVuZGVmaW5lZCA/IG9wdF9kcmFnZ2luZyA6IGZhbHNlO1xuXG4gIH1cblxuICBpZiAoIE1hcEV2ZW50ICkgTWFwQnJvd3NlckV2ZW50Ll9fcHJvdG9fXyA9IE1hcEV2ZW50O1xuICBNYXBCcm93c2VyRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwRXZlbnQgJiYgTWFwRXZlbnQucHJvdG90eXBlICk7XG4gIE1hcEJyb3dzZXJFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBCcm93c2VyRXZlbnQ7XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2V2ZW50LnByZXZlbnREZWZhdWx0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHtcbiAgICBNYXBFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5zdG9wUHJvcGFnYXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbiAoKSB7XG4gICAgTWFwRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xuICAgIHRoaXMub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICByZXR1cm4gTWFwQnJvd3NlckV2ZW50O1xufShNYXBFdmVudCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwQnJvd3NlckV2ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9NYXBCcm93c2VyRXZlbnRIYW5kbGVyXG4gKi9cbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPfSBmcm9tICcuL2hhcy5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQgZnJvbSAnLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IFBvaW50ZXJFdmVudFR5cGUgZnJvbSAnLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50SGFuZGxlciBmcm9tICcuL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlci5qcyc7XG5cbnZhciBNYXBCcm93c2VyRXZlbnRIYW5kbGVyID0gKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBNYXBCcm93c2VyRXZlbnRIYW5kbGVyKG1hcCwgbW92ZVRvbGVyYW5jZSkge1xuXG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGxpc3RlbiB0byB0aGUgcmVhbCBldmVudHMgb24uXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gPSBtb3ZlVG9sZXJhbmNlID9cbiAgICAgIG1vdmVUb2xlcmFuY2UgKiBERVZJQ0VfUElYRUxfUkFUSU8gOiBERVZJQ0VfUElYRUxfUkFUSU87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgXCJkb3duXCIgdHlwZSBldmVudCAob3IgbnVsbCBpZiBub25lIGhhdmUgb2NjdXJyZWQpLlxuICAgICAqIFNldCBvbiBwb2ludGVyZG93bi5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMubWFwXy5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxudW1iZXIsIGJvb2xlYW4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmFja2VkVG91Y2hlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgd2hpY2ggZ2VuZXJhdGVzIHBvaW50ZXIgZXZlbnRzIGZvclxuICAgICAqIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudEhhbmRsZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfID0gbmV3IFBvaW50ZXJFdmVudEhhbmRsZXIoZWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIHdoaWNoIGdlbmVyYXRlcyBwb2ludGVyIGV2ZW50cyBmb3JcbiAgICAgKiB0aGUgZG9jdW1lbnQgKHVzZWQgd2hlbiBkcmFnZ2luZykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IGxpc3Rlbih0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTixcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd25fLCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBsaXN0ZW4odGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsXG4gICAgICB0aGlzLnJlbGF5RXZlbnRfLCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIuX19wcm90b19fID0gRXZlbnRUYXJnZXQ7XG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwQnJvd3NlckV2ZW50SGFuZGxlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcG9pbnRlci9Qb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW11bGF0ZUNsaWNrXyA9IGZ1bmN0aW9uIGVtdWxhdGVDbGlja18gKHBvaW50ZXJFdmVudCkge1xuICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5DTElDSywgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgaWYgKHRoaXMuY2xpY2tUaW1lb3V0SWRfICE9PSAwKSB7XG4gICAgICAvLyBkb3VibGUtY2xpY2tcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNsaWNrVGltZW91dElkXyk7XG4gICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IDA7XG4gICAgICBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjbGlja1xuICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IDA7XG4gICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuU0lOR0xFQ0xJQ0ssIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMjUwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9uIGhvdyBtYW55IHBvaW50ZXJzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVBY3RpdmVQb2ludGVyc18gPSBmdW5jdGlvbiB1cGRhdGVBY3RpdmVQb2ludGVyc18gKHBvaW50ZXJFdmVudCkge1xuICAgIHZhciBldmVudCA9IHBvaW50ZXJFdmVudDtcblxuICAgIGlmIChldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQIHx8XG4gICAgICAgIGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMKSB7XG4gICAgICBkZWxldGUgdGhpcy50cmFja2VkVG91Y2hlc19bZXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTikge1xuICAgICAgdGhpcy50cmFja2VkVG91Y2hlc19bZXZlbnQucG9pbnRlcklkXSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlUG9pbnRlcnNfID0gT2JqZWN0LmtleXModGhpcy50cmFja2VkVG91Y2hlc18pLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcG9pbnRlci9Qb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlUG9pbnRlclVwXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcF8gKHBvaW50ZXJFdmVudCkge1xuICAgIHRoaXMudXBkYXRlQWN0aXZlUG9pbnRlcnNfKHBvaW50ZXJFdmVudCk7XG4gICAgdmFyIG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCwgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cbiAgICAvLyBXZSBlbXVsYXRlIGNsaWNrIGV2ZW50cyBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBjbGljaywgdG91Y2ggY29udGFjdCwgYW5kIHBlblxuICAgIC8vIGNvbnRhY3QuIGlzTW91c2VBY3Rpb25CdXR0b24gcmV0dXJucyB0cnVlIGluIHRoZXNlIGNhc2VzIChldnQuYnV0dG9uIGlzIHNldFxuICAgIC8vIHRvIDApLlxuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzXG4gICAgLy8gV2Ugb25seSBmaXJlIGNsaWNrLCBzaW5nbGVjbGljaywgYW5kIGRvdWJsZWNsaWNrIGlmIG5vYm9keSBoYXMgY2FsbGVkXG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgb3IgZXZlbnQucHJldmVudERlZmF1bHQoKS5cbiAgICBpZiAoIW5ld0V2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCAmJiAhdGhpcy5kcmFnZ2luZ18gJiYgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfID09PSAwKSB7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5kb3duXyA9IG51bGw7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIHdhcyBwcmVzc2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaXNNb3VzZUFjdGlvbkJ1dHRvbl8gPSBmdW5jdGlvbiBpc01vdXNlQWN0aW9uQnV0dG9uXyAocG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIHBvaW50ZXJFdmVudC5idXR0b24gPT09IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcEJyb3dzZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZVBvaW50ZXJEb3duXyA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duXyAocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KTtcbiAgICB2YXIgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sIHRoaXMubWFwXywgcG9pbnRlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXG4gICAgdGhpcy5kb3duXyA9IHBvaW50ZXJFdmVudDtcblxuICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLyogU2V0IHVwIGEgcG9pbnRlciBldmVudCBoYW5kbGVyIG9uIHRoZSBgZG9jdW1lbnRgLFxuICAgICAgICogd2hpY2ggaXMgcmVxdWlyZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZlZCBvdXRzaWRlXG4gICAgICAgKiB0aGUgdmlld3BvcnQgd2hlbiBkcmFnZ2luZy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID1cbiAgICAgICAgICBuZXcgUG9pbnRlckV2ZW50SGFuZGxlcihkb2N1bWVudCk7XG5cbiAgICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ucHVzaChcbiAgICAgICAgbGlzdGVuKHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sIHRoaXMpLFxuICAgICAgICAvKiBOb3RlIHRoYXQgdGhlIGxpc3RlbmVyIGZvciBgcG9pbnRlcmNhbmNlbCBpcyBzZXQgdXAgb25cbiAgICAgICAgICogYHBvaW50ZXJFdmVudEhhbmRsZXJfYCBhbmQgbm90IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBsaWtlXG4gICAgICAgICAqIHRoZSBgcG9pbnRlcnVwYCBhbmQgYHBvaW50ZXJtb3ZlYCBsaXN0ZW5lcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhlIGZvbGxvd2luZzogYFRvdWNoU291cmNlLnZhY3V1bVRvdWNoZXNfKClgXG4gICAgICAgICAqIGlzc3VlcyBgcG9pbnRlcmNhbmNlbGAgZXZlbnRzLCB3aGVuIHRoZXJlIHdhcyBubyBgdG91Y2hlbmRgIGZvciBhXG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gTm93LCBsZXQncyBzYXkgYSBmaXJzdCBgdG91Y2hzdGFydGAgaXMgcmVnaXN0ZXJlZCBvblxuICAgICAgICAgKiBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLiBUaGUgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGlzIHNldCB1cC5cbiAgICAgICAgICogQnV0IGBkb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfYCBkb2Vzbid0IGtub3cgYWJvdXQgdGhlIGZpcnN0XG4gICAgICAgICAqIGB0b3VjaHN0YXJ0YC4gSWYgdGhlcmUgaXMgbm8gYHRvdWNoZW5kYCBmb3IgdGhlIGB0b3VjaHN0YXJ0YCwgd2UgY2FuXG4gICAgICAgICAqIG9ubHkgcmVjZWl2ZSBhIGB0b3VjaGNhbmNlbGAgZnJvbSBgcG9pbnRlckV2ZW50SGFuZGxlcl9gLCBiZWNhdXNlIGl0IGlzXG4gICAgICAgICAqIG9ubHkgcmVnaXN0ZXJlZCB0aGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGxpc3Rlbih0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCxcbiAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcF8sIHRoaXMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcG9pbnRlci9Qb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwQnJvd3NlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmVfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmVfIChwb2ludGVyRXZlbnQpIHtcbiAgICAvLyBCZXR3ZWVuIHBvaW50ZXJkb3duIGFuZCBwb2ludGVydXAsIHBvaW50ZXJtb3ZlIGV2ZW50cyBhcmUgdHJpZ2dlcmVkLlxuICAgIC8vIFRvIGF2b2lkIGEgJ2ZhbHNlJyB0b3VjaG1vdmUgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZCwgd2UgdGVzdCBpZiB0aGUgcG9pbnRlclxuICAgIC8vIG1vdmVkIGEgc2lnbmlmaWNhbnQgZGlzdGFuY2UuXG4gICAgaWYgKHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdfID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCxcbiAgICAgICAgdGhpcy5kcmFnZ2luZ18pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBTb21lIG5hdGl2ZSBhbmRyb2lkIGJyb3dzZXIgdHJpZ2dlcnMgbW91c2Vtb3ZlIGV2ZW50cyBkdXJpbmcgc21hbGwgcGVyaW9kXG4gICAgLy8gb2YgdGltZS4gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD01NDkxIG9yXG4gICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk4MjdcbiAgICAvLyBleDogR2FsYXh5IFRhYiBQMzExMCArIEFuZHJvaWQgNC4xLjFcbiAgICBwb2ludGVyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcCBhbmQgcmVsYXkgYSBwb2ludGVyIGV2ZW50LiAgTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgdGhhdCB0aGUgdHlwZVxuICAgKiBzdHJpbmcgZm9yIHRoZSBNYXBCcm93c2VyUG9pbnRlckV2ZW50IG1hdGNoZXMgdGhlIFBvaW50ZXJFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZWxheUV2ZW50XyA9IGZ1bmN0aW9uIHJlbGF5RXZlbnRfIChwb2ludGVyRXZlbnQpIHtcbiAgICB2YXIgZHJhZ2dpbmcgPSAhISh0aGlzLmRvd25fICYmIHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIHBvaW50ZXJFdmVudC50eXBlLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCwgZHJhZ2dpbmcpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcG9pbnRlci9Qb2ludGVyRXZlbnR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBtb3ZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5pc01vdmluZ18gPSBmdW5jdGlvbiBpc01vdmluZ18gKHBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiB0aGlzLmRyYWdnaW5nXyB8fFxuICAgICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WCAtIHRoaXMuZG93bl8uY2xpZW50WCkgPiB0aGlzLm1vdmVUb2xlcmFuY2VfIHx8XG4gICAgICAgIE1hdGguYWJzKHBvaW50ZXJFdmVudC5jbGllbnRZIC0gdGhpcy5kb3duXy5jbGllbnRZKSA+IHRoaXMubW92ZVRvbGVyYW5jZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNYXBCcm93c2VyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMucmVsYXllZExpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5XyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID0gMDtcblxuICAgIGlmICh0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8pIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXykge1xuICAgICAgdGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gICAgRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBNYXBCcm93c2VyRXZlbnRIYW5kbGVyO1xufShFdmVudFRhcmdldCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFR5cGVcbiAqL1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgZXZlbnQgbmFtZXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIEEgdHJ1ZSBzaW5nbGUgY2xpY2sgd2l0aCBubyBkcmFnZ2luZyBhbmQgbm8gZG91YmxlIGNsaWNrLiBOb3RlIHRoYXQgdGhpc1xuICAgKiBldmVudCBpcyBkZWxheWVkIGJ5IDI1MCBtcyB0byBlbnN1cmUgdGhhdCBpdCBpcyBub3QgYSBkb3VibGUgY2xpY2suXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNzaW5nbGVjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBTSU5HTEVDTElDSzogJ3NpbmdsZWNsaWNrJyxcblxuICAvKipcbiAgICogQSBjbGljayB3aXRoIG5vIGRyYWdnaW5nLiBBIGRvdWJsZSBjbGljayB3aWxsIGZpcmUgdHdvIG9mIHRoaXMuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBDTElDSzogRXZlbnRUeXBlLkNMSUNLLFxuXG4gIC8qKlxuICAgKiBBIHRydWUgZG91YmxlIGNsaWNrLCB3aXRoIG5vIGRyYWdnaW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjZGJsY2xpY2tcbiAgICogQGFwaVxuICAgKi9cbiAgREJMQ0xJQ0s6IEV2ZW50VHlwZS5EQkxDTElDSyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIGRyYWdnZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVyZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSRFJBRzogJ3BvaW50ZXJkcmFnJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBwb2ludGVyIGlzIG1vdmVkLiBOb3RlIHRoYXQgb24gdG91Y2ggZGV2aWNlcyB0aGlzIGlzXG4gICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgcGFubmVkLCBzbyBpcyBub3QgdGhlIHNhbWUgYXMgbW91c2Vtb3ZlLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnQjcG9pbnRlcm1vdmVcbiAgICogQGFwaVxuICAgKi9cbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG5cbiAgUE9JTlRFUkRPV046ICdwb2ludGVyZG93bicsXG4gIFBPSU5URVJVUDogJ3BvaW50ZXJ1cCcsXG4gIFBPSU5URVJPVkVSOiAncG9pbnRlcm92ZXInLFxuICBQT0lOVEVST1VUOiAncG9pbnRlcm91dCcsXG4gIFBPSU5URVJFTlRFUjogJ3BvaW50ZXJlbnRlcicsXG4gIFBPSU5URVJMRUFWRTogJ3BvaW50ZXJsZWF2ZScsXG4gIFBPSU5URVJDQU5DRUw6ICdwb2ludGVyY2FuY2VsJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwQnJvd3NlckV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudFxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlckV2ZW50LmpzJztcblxudmFyIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQgPSAoZnVuY3Rpb24gKE1hcEJyb3dzZXJFdmVudCkge1xuICBmdW5jdGlvbiBNYXBCcm93c2VyUG9pbnRlckV2ZW50KHR5cGUsIG1hcCwgcG9pbnRlckV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKSB7XG5cbiAgICBNYXBCcm93c2VyRXZlbnQuY2FsbCh0aGlzLCB0eXBlLCBtYXAsIHBvaW50ZXJFdmVudC5vcmlnaW5hbEV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcG9pbnRlci9Qb2ludGVyRXZlbnR9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyRXZlbnQgPSBwb2ludGVyRXZlbnQ7XG5cbiAgfVxuXG4gIGlmICggTWFwQnJvd3NlckV2ZW50ICkgTWFwQnJvd3NlclBvaW50ZXJFdmVudC5fX3Byb3RvX18gPSBNYXBCcm93c2VyRXZlbnQ7XG4gIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwQnJvd3NlckV2ZW50ICYmIE1hcEJyb3dzZXJFdmVudC5wcm90b3R5cGUgKTtcbiAgTWFwQnJvd3NlclBvaW50ZXJFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBCcm93c2VyUG9pbnRlckV2ZW50O1xuXG4gIHJldHVybiBNYXBCcm93c2VyUG9pbnRlckV2ZW50O1xufShNYXBCcm93c2VyRXZlbnQpKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQnJvd3NlclBvaW50ZXJFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFwQnJvd3NlclBvaW50ZXJFdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwRXZlbnRcbiAqL1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBhcyBtYXAgZXZlbnRzIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gZm9yIHdoaWNoIGV2ZW50cyB0cmlnZ2VyIGEgbWFwIGV2ZW50LlxuICovXG52YXIgTWFwRXZlbnQgPSAoZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIE1hcEV2ZW50KHR5cGUsIG1hcCwgb3B0X2ZyYW1lU3RhdGUpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWFwIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUgc3RhdGUgYXQgdGhlIHRpbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBvcHRfZnJhbWVTdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2ZyYW1lU3RhdGUgOiBudWxsO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgTWFwRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIE1hcEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBNYXBFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBFdmVudDtcblxuICByZXR1cm4gTWFwRXZlbnQ7XG59KEV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBFdmVudC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciBhIG1hcCBmcmFtZSBpcyByZW5kZXJlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNwb3N0cmVuZGVyXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RSRU5ERVI6ICdwb3N0cmVuZGVyJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBzdGFydHMgbW92aW5nLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBNT1ZFU1RBUlQ6ICdtb3Zlc3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgYWZ0ZXIgdGhlIG1hcCBpcyBtb3ZlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBFdmVudH5NYXBFdmVudCNtb3ZlZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVFTkQ6ICdtb3ZlZW5kJ1xuXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcFByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIExBWUVSR1JPVVA6ICdsYXllcmdyb3VwJyxcbiAgU0laRTogJ3NpemUnLFxuICBUQVJHRVQ6ICd0YXJnZXQnLFxuICBWSUVXOiAndmlldydcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcFByb3BlcnR5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9PYmplY3RcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAgKi9cbnZhciBPYmplY3RFdmVudCA9IChmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gT2JqZWN0RXZlbnQodHlwZSwga2V5LCBvbGRWYWx1ZSkge1xuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgY2hhbmdpbmcuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2xkIHZhbHVlLiBUbyBnZXQgdGhlIG5ldyB2YWx1ZSB1c2UgYGUudGFyZ2V0LmdldChlLmtleSlgIHdoZXJlXG4gICAgICogYGVgIGlzIHRoZSBldmVudCBvYmplY3QuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIE9iamVjdEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBPYmplY3RFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgT2JqZWN0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JqZWN0RXZlbnQ7XG5cbiAgcmV0dXJuIE9iamVjdEV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTW9zdCBub24tdHJpdmlhbCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0aGlzLlxuICpcbiAqIFRoaXMgZXh0ZW5kcyB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV9IHdpdGggb2JzZXJ2YWJsZVxuICogcHJvcGVydGllcywgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBvYnNlcnZhYmxlIGFzIHdlbGwgYXMgdGhlIG9iamVjdCBhcyBhXG4gKiB3aG9sZS5cbiAqXG4gKiBDbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgaGF2ZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzLCB0byB3aGljaCB5b3UgY2FuXG4gKiBhZGQgeW91ciBvd25zLiBUaGUgcHJlLWRlZmluZWQgcHJvcGVydGllcyBhcmUgbGlzdGVkIGluIHRoaXMgZG9jdW1lbnRhdGlvbiBhc1xuICogJ09ic2VydmFibGUgUHJvcGVydGllcycsIGFuZCBoYXZlIHRoZWlyIG93biBhY2Nlc3NvcnM7IGZvciBleGFtcGxlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBoYXMgYSBgdGFyZ2V0YCBwcm9wZXJ0eSwgYWNjZXNzZWQgd2l0aFxuICogYGdldFRhcmdldCgpYCBhbmQgY2hhbmdlZCB3aXRoIGBzZXRUYXJnZXQoKWAuIE5vdCBhbGwgcHJvcGVydGllcyBhcmUgaG93ZXZlclxuICogc2V0dGFibGUuIFRoZXJlIGFyZSBhbHNvIGdlbmVyYWwtcHVycG9zZSBhY2Nlc3NvcnMgYGdldCgpYCBhbmQgYHNldCgpYC4gRm9yXG4gKiBleGFtcGxlLCBgZ2V0KCd0YXJnZXQnKWAgaXMgZXF1aXZhbGVudCB0byBgZ2V0VGFyZ2V0KClgLlxuICpcbiAqIFRoZSBgc2V0YCBhY2Nlc3NvcnMgdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgYW5kIHlvdSBjYW4gbW9uaXRvciB0aGlzIGJ5XG4gKiByZWdpc3RlcmluZyBhIGxpc3RlbmVyLiBGb3IgZXhhbXBsZSwge0BsaW5rIG1vZHVsZTpvbC9WaWV3flZpZXd9IGhhcyBhXG4gKiBgY2VudGVyYCBwcm9wZXJ0eSwgc28gYHZpZXcub24oJ2NoYW5nZTpjZW50ZXInLCBmdW5jdGlvbihldnQpIHsuLi59KTtgIHdvdWxkXG4gKiBjYWxsIHRoZSBmdW5jdGlvbiB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIGNlbnRlciBwcm9wZXJ0eSBjaGFuZ2VzLiBXaXRoaW5cbiAqIHRoZSBmdW5jdGlvbiwgYGV2dC50YXJnZXRgIHdvdWxkIGJlIHRoZSB2aWV3LCBzbyBgZXZ0LnRhcmdldC5nZXRDZW50ZXIoKWBcbiAqIHdvdWxkIHJldHVybiB0aGUgbmV3IGNlbnRlci5cbiAqXG4gKiBZb3UgY2FuIGFkZCB5b3VyIG93biBvYnNlcnZhYmxlIHByb3BlcnRpZXMgd2l0aFxuICogYG9iamVjdC5zZXQoJ3Byb3AnLCAndmFsdWUnKWAsIGFuZCByZXRyaWV2ZSB0aGF0IHdpdGggYG9iamVjdC5nZXQoJ3Byb3AnKWAuXG4gKiBZb3UgY2FuIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGF0IHByb3BlcnR5IHZhbHVlIHdpdGhcbiAqIGBvYmplY3Qub24oJ2NoYW5nZTpwcm9wJywgbGlzdGVuZXIpYC4gWW91IGNhbiBnZXQgYSBsaXN0IG9mIGFsbFxuICogcHJvcGVydGllcyB3aXRoIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3QjZ2V0UHJvcGVydGllc30uXG4gKlxuICogTm90ZSB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb3BlcnRpZXMgYXJlIHNlcGFyYXRlIGZyb20gc3RhbmRhcmQgSlMgcHJvcGVydGllcy5cbiAqIFlvdSBjYW4sIGZvciBleGFtcGxlLCBnaXZlIHlvdXIgbWFwIG9iamVjdCBhIHRpdGxlIHdpdGhcbiAqIGBtYXAudGl0bGU9J05ldyB0aXRsZSdgIGFuZCB3aXRoIGBtYXAuc2V0KCd0aXRsZScsICdBbm90aGVyIHRpdGxlJylgLiBUaGVcbiAqIGZpcnN0IHdpbGwgYmUgYSBgaGFzT3duUHJvcGVydHlgOyB0aGUgc2Vjb25kIHdpbGwgYXBwZWFyIGluXG4gKiBgZ2V0UHJvcGVydGllcygpYC4gT25seSB0aGUgc2Vjb25kIGlzIG9ic2VydmFibGUuXG4gKlxuICogUHJvcGVydGllcyBjYW4gYmUgZGVsZXRlZCBieSB1c2luZyB0aGUgdW5zZXQgbWV0aG9kLiBFLmcuXG4gKiBvYmplY3QudW5zZXQoJ2ZvbycpLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvT2JqZWN0fk9iamVjdEV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBCYXNlT2JqZWN0ID0gKGZ1bmN0aW9uIChPYnNlcnZhYmxlKSB7XG4gIGZ1bmN0aW9uIEJhc2VPYmplY3Qob3B0X3ZhbHVlcykge1xuICAgIE9ic2VydmFibGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIENhbGwge0BsaW5rIG1vZHVsZTpvbC91dGlsfmdldFVpZH0gdG8gZW5zdXJlIHRoYXQgdGhlIG9yZGVyIG9mIG9iamVjdHMnIGlkcyBpc1xuICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgY3JlYXRlZC4gIFRoaXMgYWxzbyBoZWxwcyB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgYWRkZWQgaW4gdGhlIHNhbWUgb3JkZXIsIHdoaWNoXG4gICAgLy8gaGVscHMgbWFueSBKYXZhU2NyaXB0IGVuZ2luZXMgZ2VuZXJhdGUgZmFzdGVyIGNvZGUuXG4gICAgZ2V0VWlkKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc18gPSB7fTtcblxuICAgIGlmIChvcHRfdmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRfdmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIE9ic2VydmFibGUgKSBCYXNlT2JqZWN0Ll9fcHJvdG9fXyA9IE9ic2VydmFibGU7XG4gIEJhc2VPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLnByb3RvdHlwZSApO1xuICBCYXNlT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2VPYmplY3Q7XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmICh0aGlzLnZhbHVlc18uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIG9iamVjdCBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpc3Qgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiBnZXRLZXlzICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy52YWx1ZXNfKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsICo+fSBPYmplY3QuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzICgpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnZhbHVlc18pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IG9sZFZhbHVlIE9sZCB2YWx1ZS5cbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoa2V5LCBvbGRWYWx1ZSkge1xuICAgIHZhciBldmVudFR5cGU7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbiAgICBldmVudFR5cGUgPSBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0U7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBPYmplY3RFdmVudChldmVudFR5cGUsIGtleSwgb2xkVmFsdWUpKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEJhc2VPYmplY3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSwgb3B0X3NpbGVudCkge1xuICAgIGlmIChvcHRfc2lsZW50KSB7XG4gICAgICB0aGlzLnZhbHVlc19ba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlc19ba2V5XTtcbiAgICAgIHRoaXMudmFsdWVzX1trZXldID0gdmFsdWU7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGNvbGxlY3Rpb24gb2Yga2V5LXZhbHVlIHBhaXJzLiAgTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyBhbnkgZXhpc3RpbmdcbiAgICogcHJvcGVydGllcyBhbmQgYWRkcyBuZXcgb25lcyAoaXQgZG9lcyBub3QgcmVtb3ZlIGFueSBleGlzdGluZyBwcm9wZXJ0aWVzKS5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgKj59IHZhbHVlcyBWYWx1ZXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaWxlbnQgVXBkYXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZU9iamVjdC5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIHNldFByb3BlcnRpZXMgKHZhbHVlcywgb3B0X3NpbGVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgdGhpcyQxLnNldChrZXksIHZhbHVlc1trZXldLCBvcHRfc2lsZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuc2V0cyBhIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVuc2V0IHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgQmFzZU9iamVjdC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiB1bnNldCAoa2V5LCBvcHRfc2lsZW50KSB7XG4gICAgaWYgKGtleSBpbiB0aGlzLnZhbHVlc18pIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgZGVsZXRlIHRoaXMudmFsdWVzX1trZXldO1xuICAgICAgaWYgKCFvcHRfc2lsZW50KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KGtleSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQmFzZU9iamVjdDtcbn0oT2JzZXJ2YWJsZSkpO1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCBzdHJpbmc+fVxuICovXG52YXIgY2hhbmdlRXZlbnRUeXBlQ2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENoYW5nZSBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSkge1xuICByZXR1cm4gY2hhbmdlRXZlbnRUeXBlQ2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/XG4gICAgY2hhbmdlRXZlbnRUeXBlQ2FjaGVba2V5XSA6XG4gICAgKGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gPSAnY2hhbmdlOicgKyBrZXkpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvT2JqZWN0RXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHByb3BlcnR5IGlzIGNoYW5nZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvT2JqZWN0fk9iamVjdEV2ZW50I3Byb3BlcnR5Y2hhbmdlXG4gICAqIEBhcGlcbiAgICovXG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL09ic2VydmFibGVcbiAqL1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXksIHVubGlzdGVuLCBsaXN0ZW5PbmNlfSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEFuIGV2ZW50IHRhcmdldCBwcm92aWRpbmcgY29udmVuaWVudCBtZXRob2RzIGZvciBsaXN0ZW5lciByZWdpc3RyYXRpb25cbiAqIGFuZCB1bnJlZ2lzdHJhdGlvbi4gQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGFsd2F5cyBhdmFpbGFibGUgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjY2hhbmdlZH0uXG4gKlxuICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIE9ic2VydmFibGUoKSB7XG5cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmV2aXNpb25fID0gMDtcblxuICB9XG5cbiAgaWYgKCBFdmVudFRhcmdldCApIE9ic2VydmFibGUuX19wcm90b19fID0gRXZlbnRUYXJnZXQ7XG4gIE9ic2VydmFibGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIE9ic2VydmFibGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2JzZXJ2YWJsZTtcblxuICAvKipcbiAgICogSW5jcmVhc2VzIHRoZSByZXZpc2lvbiBjb3VudGVyIGFuZCBkaXNwYXRjaGVzIGEgJ2NoYW5nZScgZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICArK3RoaXMucmV2aXNpb25fO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2ZXJzaW9uIG51bWJlciBmb3IgdGhpcyBvYmplY3QuICBFYWNoIHRpbWUgdGhlIG9iamVjdCBpcyBtb2RpZmllZCxcbiAgICogaXRzIHZlcnNpb24gbnVtYmVyIHdpbGwgYmUgaW5jcmVtZW50ZWQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmV2aXNpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLmdldFJldmlzaW9uID0gZnVuY3Rpb24gZ2V0UmV2aXNpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJldmlzaW9uXztcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl8QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICAgKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gICAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdmFyIGxlbiA9IHR5cGUubGVuZ3RoO1xuICAgICAgdmFyIGtleXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5c1tpXSA9IGxpc3Rlbih0aGlzJDEsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RlbiBvbmNlIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl8QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICAgKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gICAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gICAqIEBhcGlcbiAgICovXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlICh0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHZhciBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIHZhciBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW5PbmNlKHRoaXMkMSwgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaXN0ZW5PbmNlKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVubGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudW4gPSBmdW5jdGlvbiB1biAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0eXBlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdW5saXN0ZW4odGhpcyQxLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubGlzdGVuKHRoaXMsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KEV2ZW50VGFyZ2V0KSk7XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIHVzaW5nIHRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgIG9yIGBvbmNlKClgLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXxBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+fSBrZXkgVGhlIGtleSByZXR1cm5lZCBieSBgb24oKWBcbiAqICAgICBvciBgb25jZSgpYCAob3IgYW4gYXJyYXkgb2Yga2V5cykuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bkJ5S2V5KGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0ga2V5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkoa2V5W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdW5saXN0ZW5CeUtleSgvKiogQHR5cGUge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSAqLyAoa2V5KSk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9QbHVnZ2FibGVNYXBcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnQgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnQuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXIgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRIYW5kbGVyLmpzJztcbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBQcm9wZXJ0eSBmcm9tICcuL01hcFByb3BlcnR5LmpzJztcbmltcG9ydCBCYXNlT2JqZWN0LCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBUaWxlUXVldWUgZnJvbSAnLi9UaWxlUXVldWUuanMnO1xuaW1wb3J0IFZpZXcgZnJvbSAnLi9WaWV3LmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtyZW1vdmVOb2RlfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleSwgdW5saXN0ZW59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7c3RvcFByb3BhZ2F0aW9ufSBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUVtcHR5LCBjbG9uZSwgY3JlYXRlT3JVcGRhdGVFbXB0eSwgZXF1YWxzLCBnZXRGb3JWaWV3QW5kU2l6ZSwgaXNFbXB0eX0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IHtUUlVFfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJTywgVE9VQ0h9IGZyb20gJy4vaGFzLmpzJztcbmltcG9ydCBMYXllckdyb3VwIGZyb20gJy4vbGF5ZXIvR3JvdXAuanMnO1xuaW1wb3J0IHtoYXNBcmVhfSBmcm9tICcuL3NpemUuanMnO1xuaW1wb3J0IHtEUk9QfSBmcm9tICcuL3N0cnVjdHMvUHJpb3JpdHlRdWV1ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtfSBmcm9tICcuL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBTdGF0ZSBvZiB0aGUgY3VycmVudCBmcmFtZS4gT25seSBgcGl4ZWxSYXRpb2AsIGB0aW1lYCBhbmQgYHZpZXdTdGF0ZWAgc2hvdWxkXG4gKiBiZSB1c2VkIGluIGFwcGxpY2F0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEZyYW1lU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaXhlbFJhdGlvIFRoZSBwaXhlbCByYXRpbyBvZiB0aGUgZnJhbWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZSBUaGUgdGltZSB3aGVuIHJlbmRlcmluZyBvZiB0aGUgZnJhbWUgd2FzIHJlcXVlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1ZpZXd+U3RhdGV9IHZpZXdTdGF0ZSBUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1cbiAqIEBwcm9wZXJ0eSB7bnVsbHxtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50XG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGZvY3VzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxudW1iZXIsIG1vZHVsZTpvbC9sYXllci9MYXllcn5TdGF0ZT59IGxheWVyU3RhdGVzXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGU+fSBsYXllclN0YXRlc0FycmF5XG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSBwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybVxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5Qb3N0UmVuZGVyRnVuY3Rpb24+fSBwb3N0UmVuZGVyRnVuY3Rpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zaXplflNpemV9IHNpemVcbiAqIEBwcm9wZXJ0eSB7IU9iamVjdC48c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVVaWRzXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlUXVldWV9IHRpbGVRdWV1ZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9UaWxlUmFuZ2U+Pn0gdXNlZFRpbGVzXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSB2aWV3SGludHNcbiAqIEBwcm9wZXJ0eSB7IU9iamVjdC48c3RyaW5nLCBPYmplY3QuPHN0cmluZywgYm9vbGVhbj4+fSB3YW50ZWRUaWxlc1xuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL1BsdWdnYWJsZU1hcCwgP21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZSk6IGJvb2xlYW59IFBvc3RSZW5kZXJGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBdFBpeGVsT3B0aW9uc1xuICogQHByb3BlcnR5IHsoKGZ1bmN0aW9uKG1vZHVsZTpvbC9sYXllci9MYXllcik6IGJvb2xlYW4pfHVuZGVmaW5lZCl9IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICogZnVuY3Rpb24uIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG9uZSBhcmd1bWVudCwgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyLWNhbmRpZGF0ZX0gYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICogT25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgXG4gKiB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlIGluIHBpeGVscy4gUGl4ZWxzXG4gKiBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seVxuICogd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kIG5vdCBmb3IgV2ViR0wuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNJbnRlcm5hbFxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2NvbnRyb2wvQ29udHJvbD59IFtjb250cm9sc11cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbj59IFtpbnRlcmFjdGlvbnNdXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fERvY3VtZW50fSBrZXlib2FyZEV2ZW50VGFyZ2V0XG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvT3ZlcmxheT59IG92ZXJsYXlzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCAqPn0gdmFsdWVzXG4gKi9cblxuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggY29uZmlnIG9wdGlvbnMgZm9yIHRoZSBtYXAuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvY29udHJvbC9Db250cm9sPnxBcnJheS48bW9kdWxlOm9sL2NvbnRyb2wvQ29udHJvbD59IFtjb250cm9sc11cbiAqIENvbnRyb2xzIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL3V0aWx+ZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW9dIFRoZSByYXRpbyBiZXR3ZWVuXG4gKiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHMgKGRpcHMpIG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24+fEFycmF5Ljxtb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24+fSBbaW50ZXJhY3Rpb25zXVxuICogSW50ZXJhY3Rpb25zIHRoYXQgYXJlIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbn5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR8c3RyaW5nfSBba2V5Ym9hcmRFdmVudFRhcmdldF0gVGhlIGVsZW1lbnQgdG9cbiAqIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24uIFRoaXMgZGV0ZXJtaW5lcyB3aGVuIHRoZSBgS2V5Ym9hcmRQYW5gIGFuZFxuICogYEtleWJvYXJkWm9vbWAgaW50ZXJhY3Rpb25zIHRyaWdnZXIuIEZvciBleGFtcGxlLCBpZiB0aGlzIG9wdGlvbiBpcyBzZXQgdG9cbiAqIGBkb2N1bWVudGAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9ucyB3aWxsIGFsd2F5cyB0cmlnZ2VyLiBJZiB0aGlzIG9wdGlvbiBpc1xuICogbm90IHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgdGhlIGxpYnJhcnkgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb24gaXMgdGhlXG4gKiBtYXAgdGFyZ2V0IChpLmUuIHRoZSB1c2VyLXByb3ZpZGVkIGRpdiBmb3IgdGhlIG1hcCkuIElmIHRoaXMgaXMgbm90XG4gKiBgZG9jdW1lbnRgLCB0aGUgdGFyZ2V0IGVsZW1lbnQgbmVlZHMgdG8gYmUgZm9jdXNlZCBmb3Iga2V5IGV2ZW50cyB0byBiZVxuICogZW1pdHRlZCwgcmVxdWlyaW5nIHRoYXQgdGhlIHRhcmdldCBlbGVtZW50IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL2xheWVyL0Jhc2U+fG1vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvbGF5ZXIvQmFzZT59IFtsYXllcnNdXG4gKiBMYXllcnMuIElmIHRoaXMgaXMgbm90IGRlZmluZWQsIGEgbWFwIHdpdGggbm8gbGF5ZXJzIHdpbGwgYmUgcmVuZGVyZWQuIE5vdGVcbiAqIHRoYXQgbGF5ZXJzIGFyZSByZW5kZXJlZCBpbiB0aGUgb3JkZXIgc3VwcGxpZWQsIHNvIGlmIHlvdSB3YW50LCBmb3IgZXhhbXBsZSxcbiAqIGEgdmVjdG9yIGxheWVyIHRvIGFwcGVhciBvbiB0b3Agb2YgYSB0aWxlIGxheWVyLCBpdCBtdXN0IGNvbWUgYWZ0ZXIgdGhlIHRpbGVcbiAqIGxheWVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhUaWxlc0xvYWRpbmc9MTZdIE1heGltdW0gbnVtYmVyIHRpbGVzIHRvIGxvYWRcbiAqIHNpbXVsdGFuZW91c2x5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZFRpbGVzV2hpbGVBbmltYXRpbmc9ZmFsc2VdIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGlsZXNcbiAqIHdpbGwgYmUgbG9hZGVkIGR1cmluZyBhbmltYXRpb25zLiBUaGlzIG1heSBpbXByb3ZlIHRoZSB1c2VyIGV4cGVyaWVuY2UsIGJ1dFxuICogY2FuIGFsc28gbWFrZSBhbmltYXRpb25zIHN0dXR0ZXIgb24gZGV2aWNlcyB3aXRoIHNsb3cgbWVtb3J5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbG9hZFRpbGVzV2hpbGVJbnRlcmFjdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLFxuICogdGlsZXMgd2lsbCBiZSBsb2FkZWQgd2hpbGUgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgbWFwLiBUaGlzIG1heSBpbXByb3ZlIHRoZVxuICogdXNlciBleHBlcmllbmNlLCBidXQgY2FuIGFsc28gbWFrZSBtYXAgcGFubmluZyBhbmQgem9vbWluZyBjaG9wcHkgb24gZGV2aWNlc1xuICogd2l0aCBzbG93IG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbW92ZVRvbGVyYW5jZT0xXSBUaGUgbWluaW11bSBkaXN0YW5jZSBpbiBwaXhlbHMgdGhlXG4gKiBjdXJzb3IgbXVzdCBtb3ZlIHRvIGJlIGRldGVjdGVkIGFzIGEgbWFwIG1vdmUgZXZlbnQgaW5zdGVhZCBvZiBhIGNsaWNrLlxuICogSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBtYWtlIGl0IGVhc2llciB0byBjbGljayBvbiB0aGUgbWFwLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL092ZXJsYXk+fEFycmF5Ljxtb2R1bGU6b2wvT3ZlcmxheT59IFtvdmVybGF5c11cbiAqIE92ZXJsYXlzIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBCeSBkZWZhdWx0LCBubyBvdmVybGF5cyBhcmUgYWRkZWQuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fHN0cmluZ30gW3RhcmdldF0gVGhlIGNvbnRhaW5lciBmb3IgdGhlIG1hcCwgZWl0aGVyIHRoZVxuICogZWxlbWVudCBpdHNlbGYgb3IgdGhlIGBpZGAgb2YgdGhlIGVsZW1lbnQuIElmIG5vdCBzcGVjaWZpZWQgYXQgY29uc3RydWN0aW9uXG4gKiB0aW1lLCB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjc2V0VGFyZ2V0fSBtdXN0IGJlIGNhbGxlZCBmb3IgdGhlIG1hcCB0byBiZVxuICogcmVuZGVyZWQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9WaWV3fSBbdmlld10gVGhlIG1hcCdzIHZpZXcuICBObyBsYXllciBzb3VyY2VzIHdpbGwgYmVcbiAqIGZldGNoZWQgdW5sZXNzIHRoaXMgaXMgc3BlY2lmaWVkIGF0IGNvbnN0cnVjdGlvbiB0aW1lIG9yIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRWaWV3fS5cbiAqL1xuXG5cbi8qKlxuICogQGZpcmVzIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICogQGFwaVxuICovXG52YXIgUGx1Z2dhYmxlTWFwID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIFBsdWdnYWJsZU1hcChvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIHZhciBvcHRpb25zSW50ZXJuYWwgPSBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhUaWxlc0xvYWRpbmdfID0gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4VGlsZXNMb2FkaW5nIDogMTY7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID1cbiAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlQW5pbWF0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVJbnRlcmFjdGluZ18gPVxuICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IG9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyA6IERFVklDRV9QSVhFTF9SQVRJTztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVuZGVyRnJhbWVfLmNhbGwodGhpcywgRGF0ZS5ub3coKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5mcmFtZUluZGV4XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBhdCB0aGUgcHJldmlvdXMgJ21vdmVlbmQnIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdwb3J0XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMudmlld3BvcnRfLmNsYXNzTmFtZSA9ICdvbC12aWV3cG9ydCcgKyAoVE9VQ0ggPyAnIG9sLXRvdWNoJyA6ICcnKTtcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgLy8gcHJldmVudCBwYWdlIHpvb20gb24gSUUgPj0gMTAgYnJvd3NlcnNcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnO1xuICAgIHZhciBvdmVybGF5RXZlbnRzID0gW1xuICAgICAgRXZlbnRUeXBlLkNMSUNLLFxuICAgICAgRXZlbnRUeXBlLkRCTENMSUNLLFxuICAgICAgRXZlbnRUeXBlLk1PVVNFRE9XTixcbiAgICAgIEV2ZW50VHlwZS5UT1VDSFNUQVJULFxuICAgICAgRXZlbnRUeXBlLk1TUE9JTlRFUkRPV04sXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOLFxuICAgICAgRXZlbnRUeXBlLk1PVVNFV0hFRUwsXG4gICAgICBFdmVudFR5cGUuV0hFRUxcbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG92ZXJsYXlFdmVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgbGlzdGVuKHRoaXMkMS5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xywgb3ZlcmxheUV2ZW50c1tpXSwgc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9XG4gICAgdGhpcy52aWV3cG9ydF8uYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfID0gbmV3IE1hcEJyb3dzZXJFdmVudEhhbmRsZXIodGhpcywgb3B0aW9ucy5tb3ZlVG9sZXJhbmNlKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gTWFwQnJvd3NlckV2ZW50VHlwZSkge1xuICAgICAgbGlzdGVuKHRoaXMkMS5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXywgTWFwQnJvd3NlckV2ZW50VHlwZVtrZXldLFxuICAgICAgICB0aGlzJDEuaGFuZGxlTWFwQnJvd3NlckV2ZW50LCB0aGlzJDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fERvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF8gPSBvcHRpb25zSW50ZXJuYWwua2V5Ym9hcmRFdmVudFRhcmdldDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBudWxsO1xuXG4gICAgbGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuQ09OVEVYVE1FTlUsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5XSEVFTCwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLk1PVVNFV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2NvbnRyb2wvQ29udHJvbD59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbHMgPSBvcHRpb25zSW50ZXJuYWwuY29udHJvbHMgfHwgbmV3IENvbGxlY3Rpb24oKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uPn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMgPSBvcHRpb25zSW50ZXJuYWwuaW50ZXJhY3Rpb25zIHx8IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9PdmVybGF5Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheXNfID0gb3B0aW9uc0ludGVybmFsLm92ZXJsYXlzO1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2Ygb3ZlcmxheXMgYnkgaWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9PdmVybGF5Pn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlJZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9yZW5kZXJlci9NYXB9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IHRoaXMuY3JlYXRlUmVuZGVyZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihFdmVudCl8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVSZXNpemVfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZvY3VzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshQXJyYXkuPG1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UG9zdFJlbmRlckZ1bmN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZVF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVF1ZXVlXyA9IG5ldyBUaWxlUXVldWUoXG4gICAgICB0aGlzLmdldFRpbGVQcmlvcml0eS5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlXy5iaW5kKHRoaXMpKTtcblxuICAgIC8qKlxuICAgICAqIFVpZHMgb2YgZmVhdHVyZXMgdG8gc2tpcCBhdCByZW5kZXJpbmcgdGltZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfID0ge307XG5cbiAgICBsaXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCksXG4gICAgICB0aGlzLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXywgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShNYXBQcm9wZXJ0eS5WSUVXKSxcbiAgICAgIHRoaXMuaGFuZGxlVmlld0NoYW5nZWRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKE1hcFByb3BlcnR5LlNJWkUpLFxuICAgICAgdGhpcy5oYW5kbGVTaXplQ2hhbmdlZF8sIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuVEFSR0VUKSxcbiAgICAgIHRoaXMuaGFuZGxlVGFyZ2V0Q2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgLy8gc2V0UHJvcGVydGllcyB3aWxsIHRyaWdnZXIgdGhlIHJlbmRlcmluZyBvZiB0aGUgbWFwIGlmIHRoZSBtYXBcbiAgICAvLyBpcyBcImRlZmluZWRcIiBhbHJlYWR5LlxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhvcHRpb25zSW50ZXJuYWwudmFsdWVzKTtcblxuICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29udHJvbC9Db250cm9sfSBjb250cm9sIENvbnRyb2wuXG4gICAgICAgKiBAdGhpcyB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH1cbiAgICAgICAqL1xuICAgICAgKGZ1bmN0aW9uKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5zZXRNYXAodGhpcyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIGxpc3Rlbih0aGlzLmNvbnRyb2xzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAodGhpcyk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIGxpc3Rlbih0aGlzLmNvbnRyb2xzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9ufSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbi5cbiAgICAgICAqIEB0aGlzIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfVxuICAgICAgICovXG4gICAgICAoZnVuY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uc2V0TWFwKHRoaXMpO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICBsaXN0ZW4odGhpcy5pbnRlcmFjdGlvbnMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgbGlzdGVuKHRoaXMuaW50ZXJhY3Rpb25zLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMub3ZlcmxheXNfLmZvckVhY2godGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfLmJpbmQodGhpcykpO1xuXG4gICAgbGlzdGVuKHRoaXMub3ZlcmxheXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5hZGRPdmVybGF5SW50ZXJuYWxfKC8qKiBAdHlwZSB7bW9kdWxlOm9sL092ZXJsYXl9ICovIChldmVudC5lbGVtZW50KSk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIGxpc3Rlbih0aGlzLm92ZXJsYXlzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBvdmVybGF5ID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvT3ZlcmxheX0gKi8gKGV2ZW50LmVsZW1lbnQpO1xuICAgICAgICB2YXIgaWQgPSBvdmVybGF5LmdldElkKCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIFBsdWdnYWJsZU1hcC5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGx1Z2dhYmxlTWFwO1xuXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiBjcmVhdGVSZW5kZXJlciAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtYXAgdHlwZSB0aGF0IGhhcyBhIGNyZWF0ZVJlbmRlcmVyIG1ldGhvZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29udHJvbC9Db250cm9sfSBjb250cm9sIENvbnRyb2wuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIGFkZENvbnRyb2wgKGNvbnRyb2wpIHtcbiAgICB0aGlzLmdldENvbnRyb2xzKCkucHVzaChjb250cm9sKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBpbnRlcmFjdGlvbiB0byB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbn0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZEludGVyYWN0aW9uID0gZnVuY3Rpb24gYWRkSW50ZXJhY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5wdXNoKGludGVyYWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbGF5ZXIgdG8gdGhlIHRvcCBvZiB0aGlzIG1hcC4gSWYgeW91IHdhbnQgdG8gYWRkIGEgbGF5ZXJcbiAgICogZWxzZXdoZXJlIGluIHRoZSBzdGFjaywgdXNlIGBnZXRMYXllcnMoKWAgYW5kIHRoZSBtZXRob2RzIGF2YWlsYWJsZSBvblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0Jhc2V9IGxheWVyIExheWVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gYWRkTGF5ZXIgKGxheWVyKSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpLmdldExheWVycygpO1xuICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBvdmVybGF5IHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL092ZXJsYXl9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5hZGRPdmVybGF5ID0gZnVuY3Rpb24gYWRkT3ZlcmxheSAob3ZlcmxheSkge1xuICAgIHRoaXMuZ2V0T3ZlcmxheXMoKS5wdXNoKG92ZXJsYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGRlYWxzIHdpdGggbWFwJ3Mgb3ZlcmxheSBjb2xsZWN0aW9uIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL092ZXJsYXl9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuYWRkT3ZlcmxheUludGVybmFsXyA9IGZ1bmN0aW9uIGFkZE92ZXJsYXlJbnRlcm5hbF8gKG92ZXJsYXkpIHtcbiAgICB2YXIgaWQgPSBvdmVybGF5LmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gb3ZlcmxheTtcbiAgICB9XG4gICAgb3ZlcmxheS5zZXRNYXAodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnRIYW5kbGVyXy5kaXNwb3NlKCk7XG4gICAgdW5saXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5DT05URVhUTUVOVSwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpO1xuICAgIHVubGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICB1bmxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLk1PVVNFV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICBpZiAodGhpcy5oYW5kbGVSZXNpemVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICB0aGlzLmhhbmRsZVJlc2l6ZV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheUtleV8pO1xuICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuc2V0VGFyZ2V0KG51bGwpO1xuICAgIEJhc2VPYmplY3QucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQsIGFuZCBleGVjdXRlIGFcbiAgICogY2FsbGJhY2sgd2l0aCBlYWNoIGludGVyc2VjdGluZyBmZWF0dXJlLiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlIGRldGVjdGlvbiBjYW5cbiAgICogYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbiBpbiBgb3B0X29wdGlvbnNgLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgKG1vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZSksXG4gICAqICAgICBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIG9uZVxuICAgKiAgICAge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlIGZlYXR1cmV9IG9yXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlIHJlbmRlciBmZWF0dXJlfSBhdCB0aGUgcGl4ZWwsIHRoZSBzZWNvbmQgaXNcbiAgICogICAgIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyfSBvZiB0aGUgZmVhdHVyZSBhbmQgd2lsbCBiZSBudWxsIGZvclxuICAgKiAgICAgdW5tYW5hZ2VkIGxheWVycy4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrIGZ1bmN0aW9ucyBjYW4gcmV0dXJuIGFcbiAgICogICAgIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkF0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFMsVFxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRQaXhlbCAocGl4ZWwsIGNhbGxiYWNrLCBvcHRfb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgb3B0X29wdGlvbnMgPSBvcHRfb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0X29wdGlvbnMgOiB7fTtcbiAgICB2YXIgaGl0VG9sZXJhbmNlID0gb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICogdGhpcy5mcmFtZVN0YXRlXy5waXhlbFJhdGlvIDogMDtcbiAgICB2YXIgbGF5ZXJGaWx0ZXIgPSBvcHRfb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCBudWxsLFxuICAgICAgbGF5ZXJGaWx0ZXIsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5BdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmU+fSBUaGUgZGV0ZWN0ZWQgZmVhdHVyZXMgb3JcbiAgICogYG51bGxgIGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRGZWF0dXJlc0F0UGl4ZWwgPSBmdW5jdGlvbiBnZXRGZWF0dXJlc0F0UGl4ZWwgKHBpeGVsLCBvcHRfb3B0aW9ucykge1xuICAgIHZhciBmZWF0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIGlmICghZmVhdHVyZXMpIHtcbiAgICAgICAgZmVhdHVyZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgfSwgb3B0X29wdGlvbnMpO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZWN0IGxheWVycyB0aGF0IGhhdmUgYSBjb2xvciB2YWx1ZSBhdCBhIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCwgYW5kXG4gICAqIGV4ZWN1dGUgYSBjYWxsYmFjayB3aXRoIGVhY2ggbWF0Y2hpbmcgbGF5ZXIuIExheWVycyBpbmNsdWRlZCBpbiB0aGVcbiAgICogZGV0ZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggYG9wdF9sYXllckZpbHRlcmAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIsIChVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5KSk6IFR9IGNhbGxiYWNrXG4gICAqICAgICBMYXllciBjYWxsYmFjay4gVGhpcyBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50czogZmlyc3QgaXMgdGhlXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyfSwgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIGFycmF5IHJlcHJlc2VudGluZ1xuICAgKiAgICAgW1IsIEcsIEIsIEFdIHBpeGVsIHZhbHVlcyAoMCAtIDI1NSkgYW5kIHdpbGwgYmUgYG51bGxgIGZvciBsYXllciB0eXBlc1xuICAgKiAgICAgdGhhdCBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgdGhpcyBhcmd1bWVudC4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrXG4gICAqICAgICBmdW5jdGlvbnMgY2FuIHJldHVybiBhIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkF0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LCBpLmUuIHRoZSByZXR1cm4gdmFsdWUgb2YgbGFzdFxuICAgKiBjYWxsYmFjayBleGVjdXRpb24sIG9yIHRoZSBmaXJzdCB0cnV0aHkgY2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUgUyxUXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0UGl4ZWwgKHBpeGVsLCBjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgaGl0VG9sZXJhbmNlID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfb3B0aW9ucy5oaXRUb2xlcmFuY2UgKiB0aGlzLmZyYW1lU3RhdGVfLnBpeGVsUmF0aW8gOiAwO1xuICAgIHZhciBsYXllckZpbHRlciA9IG9wdGlvbnMubGF5ZXJGaWx0ZXIgfHwgVFJVRTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaExheWVyQXRQaXhlbChcbiAgICAgIHBpeGVsLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCBudWxsLCBsYXllckZpbHRlciwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBmZWF0dXJlcyBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuIExheWVycyBpbmNsdWRlZCBpbiB0aGVcbiAgICogZGV0ZWN0aW9uIGNhbiBiZSBjb25maWd1cmVkIHRocm91Z2ggYG9wdF9sYXllckZpbHRlcmAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkF0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBwaXhlbD9cbiAgICogQHRlbXBsYXRlIFVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5oYXNGZWF0dXJlQXRQaXhlbCA9IGZ1bmN0aW9uIGhhc0ZlYXR1cmVBdFBpeGVsIChwaXhlbCwgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgIG9wdF9vcHRpb25zID0gb3B0X29wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdF9vcHRpb25zIDoge307XG4gICAgdmFyIGxheWVyRmlsdGVyID0gb3B0X29wdGlvbnMubGF5ZXJGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG9wdF9vcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICB2YXIgaGl0VG9sZXJhbmNlID0gb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X29wdGlvbnMuaGl0VG9sZXJhbmNlICogdGhpcy5mcmFtZVN0YXRlXy5waXhlbFJhdGlvIDogMDtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsIHRoaXMuZnJhbWVTdGF0ZV8sIGhpdFRvbGVyYW5jZSwgbGF5ZXJGaWx0ZXIsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGluIHZpZXcgcHJvamVjdGlvbiBmb3IgYSBicm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRFdmVudENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRFdmVudENvb3JkaW5hdGUgKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCh0aGlzLmdldEV2ZW50UGl4ZWwoZXZlbnQpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFwIHBpeGVsIHBvc2l0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfSBQaXhlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRFdmVudFBpeGVsID0gZnVuY3Rpb24gZ2V0RXZlbnRQaXhlbCAoZXZlbnQpIHtcbiAgICB2YXIgdmlld3BvcnRQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBldmVudFBvc2l0aW9uID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuICAgIHJldHVybiBbXG4gICAgICBldmVudFBvc2l0aW9uLmNsaWVudFggLSB2aWV3cG9ydFBvc2l0aW9uLmxlZnQsXG4gICAgICBldmVudFBvc2l0aW9uLmNsaWVudFkgLSB2aWV3cG9ydFBvc2l0aW9uLnRvcFxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFyZ2V0IGluIHdoaWNoIHRoaXMgbWFwIGlzIHJlbmRlcmVkLlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHdoYXQgaXMgZW50ZXJlZCBhcyBhbiBvcHRpb24gb3IgaW4gc2V0VGFyZ2V0OlxuICAgKiBpZiB0aGF0IHdhcyBhbiBlbGVtZW50LCBpdCByZXR1cm5zIGFuIGVsZW1lbnQ7IGlmIGEgc3RyaW5nLCBpdCByZXR1cm5zIHRoYXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fHN0cmluZ3x1bmRlZmluZWR9IFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50IHRoYXQgdGhlXG4gICAqICAgICBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0ICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuVEFSR0VUKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgRE9NIGVsZW1lbnQgaW50byB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC4gSW4gY29udHJhc3QgdG9cbiAgICogYGdldFRhcmdldGAgdGhpcyBtZXRob2QgYWx3YXlzIHJldHVybiBhbiBgRWxlbWVudGAsIG9yIGBudWxsYCBpZiB0aGVcbiAgICogbWFwIGhhcyBubyB0YXJnZXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldFRhcmdldEVsZW1lbnQgKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldCgpO1xuICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KSA6IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gcGl4ZWwuICBUaGlzIHJldHVybnMgYSBjb29yZGluYXRlIGluIHRoZVxuICAgKiBtYXAgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgUGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVGhlIGNvb3JkaW5hdGUgZm9yIHRoZSBwaXhlbCBwb3NpdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRDb29yZGluYXRlRnJvbVBpeGVsID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCAocGl4ZWwpIHtcbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0sIHBpeGVsLnNsaWNlKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY29udHJvbHMuIE1vZGlmeWluZyB0aGlzIGNvbGxlY3Rpb24gY2hhbmdlcyB0aGUgY29udHJvbHNcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvY29udHJvbC9Db250cm9sPn0gQ29udHJvbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0Q29udHJvbHMgPSBmdW5jdGlvbiBnZXRDb250cm9scyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIG92ZXJsYXlzLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIG92ZXJsYXlzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL092ZXJsYXk+fSBPdmVybGF5cy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5cyA9IGZ1bmN0aW9uIGdldE92ZXJsYXlzICgpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVybGF5c187XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvdmVybGF5IGJ5IGl0cyBpZGVudGlmaWVyICh0aGUgdmFsdWUgcmV0dXJuZWQgYnkgb3ZlcmxheS5nZXRJZCgpKS5cbiAgICogTm90ZSB0aGF0IHRoZSBpbmRleCB0cmVhdHMgc3RyaW5nIGFuZCBudW1lcmljIGlkZW50aWZpZXJzIGFzIHRoZSBzYW1lLiBTb1xuICAgKiBgbWFwLmdldE92ZXJsYXlCeUlkKDIpYCB3aWxsIHJldHVybiBhbiBvdmVybGF5IHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIE92ZXJsYXkgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL092ZXJsYXl9IE92ZXJsYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0T3ZlcmxheUJ5SWQgPSBmdW5jdGlvbiBnZXRPdmVybGF5QnlJZCAoaWQpIHtcbiAgICB2YXIgb3ZlcmxheSA9IHRoaXMub3ZlcmxheUlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICAgIHJldHVybiBvdmVybGF5ICE9PSB1bmRlZmluZWQgPyBvdmVybGF5IDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgaW50ZXJhY3Rpb25zLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGludGVyYWN0aW9uc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICpcbiAgICogSW50ZXJhY3Rpb25zIGFyZSB1c2VkIGZvciBlLmcuIHBhbiwgem9vbSBhbmQgcm90YXRlLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uPn0gSW50ZXJhY3Rpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyYWN0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyZ3JvdXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvbGF5ZXIvR3JvdXB9IEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldExheWVyR3JvdXAgPSBmdW5jdGlvbiBnZXRMYXllckdyb3VwICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvR3JvdXB9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gb2YgbGF5ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvbGF5ZXIvQmFzZT59IExheWVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiBnZXRMYXllcnMgKCkge1xuICAgIHZhciBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBpeGVsIGZvciBhIGNvb3JkaW5hdGUuICBUaGlzIHRha2VzIGEgY29vcmRpbmF0ZSBpbiB0aGUgbWFwIHZpZXdcbiAgICogcHJvamVjdGlvbiBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwaXhlbC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIEEgbWFwIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gQSBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgbWFwIHZpZXdwb3J0LlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRQaXhlbEZyb21Db29yZGluYXRlIChjb29yZGluYXRlKSB7XG4gICAgdmFyIGZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCBjb29yZGluYXRlLnNsaWNlKDAsIDIpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIHJlbmRlcmVyLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvcmVuZGVyZXIvTWFwfSBSZW5kZXJlclxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uIGdldFJlbmRlcmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2l6ZSBvZiB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZXx1bmRlZmluZWR9IFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9zaXplflNpemV8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuU0laRSkpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC4gQSB2aWV3IG1hbmFnZXMgcHJvcGVydGllcyBzdWNoIGFzXG4gICAqIGNlbnRlciBhbmQgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL1ZpZXd9IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uIGdldFZpZXcgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9WaWV3fSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuVklFVykpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBWaWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIGdldFZpZXdwb3J0ICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyB0aGUgY29udGFpbmVyIGZvciBvdmVybGF5cy4gIEVsZW1lbnRzIGFkZGVkIHRvXG4gICAqIHRoaXMgY29udGFpbmVyIHdpbGwgbGV0IG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLFxuICAgKiBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXkgd2lsbCB0cmlnZ2VyIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH1cbiAgICogZXZlbnRzLlxuICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IFRoZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lci5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0T3ZlcmxheUNvbnRhaW5lciA9IGZ1bmN0aW9uIGdldE92ZXJsYXlDb250YWluZXIgKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlDb250YWluZXJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgdGhhdCBzZXJ2ZXMgYXMgYSBjb250YWluZXIgZm9yIG92ZXJsYXlzIHRoYXQgZG9uJ3QgYWxsb3dcbiAgICogZXZlbnQgcHJvcGFnYXRpb24uIEVsZW1lbnRzIGFkZGVkIHRvIHRoaXMgY29udGFpbmVyIHdvbid0IGxldCBtb3VzZWRvd24gYW5kXG4gICAqIHRvdWNoc3RhcnQgZXZlbnRzIHRocm91Z2ggdG8gdGhlIG1hcCwgc28gY2xpY2tzIGFuZCBnZXN0dXJlcyBvbiBhbiBvdmVybGF5XG4gICAqIGRvbid0IHRyaWdnZXIgYW55IHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0uXG4gICAqIEByZXR1cm4geyFIVE1MRWxlbWVudH0gVGhlIG1hcCdzIG92ZXJsYXkgY29udGFpbmVyIHRoYXQgc3RvcHMgZXZlbnRzLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5nZXRPdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50ID0gZnVuY3Rpb24gZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpbGVTb3VyY2VLZXkgVGlsZSBzb3VyY2Uga2V5LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuZ2V0VGlsZVByaW9yaXR5ID0gZnVuY3Rpb24gZ2V0VGlsZVByaW9yaXR5ICh0aWxlLCB0aWxlU291cmNlS2V5LCB0aWxlQ2VudGVyLCB0aWxlUmVzb2x1dGlvbikge1xuICAgIC8vIEZpbHRlciBvdXQgdGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCwgb3IgdGhhdFxuICAgIC8vIGFyZSBvdXRzaWRlIHRoZSB2aXNpYmxlIGV4dGVudC5cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlIHx8ICEodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzKSkge1xuICAgICAgcmV0dXJuIERST1A7XG4gICAgfVxuICAgIGlmICghZnJhbWVTdGF0ZS53YW50ZWRUaWxlc1t0aWxlU291cmNlS2V5XVt0aWxlLmdldEtleSgpXSkge1xuICAgICAgcmV0dXJuIERST1A7XG4gICAgfVxuICAgIC8vIFByaW9yaXRpemUgdGhlIGhpZ2hlc3Qgem9vbSBsZXZlbCB0aWxlcyBjbG9zZXN0IHRvIHRoZSBmb2N1cy5cbiAgICAvLyBUaWxlcyBhdCBoaWdoZXIgem9vbSBsZXZlbHMgYXJlIHByaW9yaXRpemVkIHVzaW5nIE1hdGgubG9nKHRpbGVSZXNvbHV0aW9uKS5cbiAgICAvLyBXaXRoaW4gYSB6b29tIGxldmVsLCB0aWxlcyBhcmUgcHJpb3JpdGl6ZWQgYnkgdGhlIGRpc3RhbmNlIGluIHBpeGVsc1xuICAgIC8vIGJldHdlZW4gdGhlIGNlbnRlciBvZiB0aGUgdGlsZSBhbmQgdGhlIGZvY3VzLiAgVGhlIGZhY3RvciBvZiA2NTUzNiBtZWFuc1xuICAgIC8vIHRoYXQgdGhlIHByaW9yaXRpemF0aW9uIHNob3VsZCBiZWhhdmUgYXMgZGVzaXJlZCBmb3IgdGlsZXMgdXAgdG9cbiAgICAvLyA2NTUzNiAqIE1hdGgubG9nKDIpID0gNDU0MjYgcGl4ZWxzIGZyb20gdGhlIGZvY3VzLlxuICAgIHZhciBkZWx0YVggPSB0aWxlQ2VudGVyWzBdIC0gZnJhbWVTdGF0ZS5mb2N1c1swXTtcbiAgICB2YXIgZGVsdGFZID0gdGlsZUNlbnRlclsxXSAtIGZyYW1lU3RhdGUuZm9jdXNbMV07XG4gICAgcmV0dXJuIDY1NTM2ICogTWF0aC5sb2codGlsZVJlc29sdXRpb24pICtcbiAgICAgICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyB0aWxlUmVzb2x1dGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3R5cGUgVHlwZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlQnJvd3NlckV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQnJvd3NlckV2ZW50IChicm93c2VyRXZlbnQsIG9wdF90eXBlKSB7XG4gICAgdmFyIHR5cGUgPSBvcHRfdHlwZSB8fCBicm93c2VyRXZlbnQudHlwZTtcbiAgICB2YXIgbWFwQnJvd3NlckV2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudCh0eXBlLCB0aGlzLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IFRoZSBldmVudCB0byBoYW5kbGUuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZU1hcEJyb3dzZXJFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZU1hcEJyb3dzZXJFdmVudCAobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICAvLyBXaXRoIG5vIHZpZXcgZGVmaW5lZCwgd2UgY2Fubm90IHRyYW5zbGF0ZSBwaXhlbHMgaW50byBnZW9ncmFwaGljYWxcbiAgICAgIC8vIGNvb3JkaW5hdGVzIHNvIGludGVyYWN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5mb2N1c18gPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICBtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgdmFyIGludGVyYWN0aW9uc0FycmF5ID0gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5nZXRBcnJheSgpO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQobWFwQnJvd3NlckV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSBpbnRlcmFjdGlvbnNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNBcnJheVtpXTtcbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbi5nZXRBY3RpdmUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ID0gaW50ZXJhY3Rpb24uaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgaWYgKCFjb250KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlUG9zdFJlbmRlciA9IGZ1bmN0aW9uIGhhbmRsZVBvc3RSZW5kZXIgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG5cbiAgICAvLyBNYW5hZ2UgdGhlIHRpbGUgcXVldWVcbiAgICAvLyBJbWFnZSBsb2FkcyBhcmUgZXhwZW5zaXZlIGFuZCBhIGxpbWl0ZWQgcmVzb3VyY2UsIHNvIHRyeSB0byB1c2UgdGhlbVxuICAgIC8vIGVmZmljaWVudGx5OlxuICAgIC8vICogV2hlbiB0aGUgdmlldyBpcyBzdGF0aWMgd2UgYWxsb3cgYSBsYXJnZSBudW1iZXIgb2YgcGFyYWxsZWwgdGlsZSBsb2Fkc1xuICAgIC8vICAgdG8gY29tcGxldGUgdGhlIGZyYW1lIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgLy8gKiBXaGVuIGFuaW1hdGluZyBvciBpbnRlcmFjdGluZywgaW1hZ2UgbG9hZHMgY2FuIGNhdXNlIGphbmtzLCBzbyB3ZSByZWR1Y2VcbiAgICAvLyAgIHRoZSBtYXhpbXVtIG51bWJlciBvZiBsb2FkcyBwZXIgZnJhbWUgYW5kIGxpbWl0IHRoZSBudW1iZXIgb2YgcGFyYWxsZWxcbiAgICAvLyAgIHRpbGUgbG9hZHMgdG8gcmVtYWluIHJlYWN0aXZlIHRvIHZpZXcgY2hhbmdlcyBhbmQgdG8gcmVkdWNlIHRoZSBjaGFuY2Ugb2ZcbiAgICAvLyAgIGxvYWRpbmcgdGlsZXMgdGhhdCB3aWxsIHF1aWNrbHkgZGlzYXBwZWFyIGZyb20gdmlldy5cbiAgICB2YXIgdGlsZVF1ZXVlID0gdGhpcy50aWxlUXVldWVfO1xuICAgIGlmICghdGlsZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgdmFyIG1heFRvdGFsTG9hZGluZyA9IHRoaXMubWF4VGlsZXNMb2FkaW5nXztcbiAgICAgIHZhciBtYXhOZXdMb2FkcyA9IG1heFRvdGFsTG9hZGluZztcbiAgICAgIGlmIChmcmFtZVN0YXRlKSB7XG4gICAgICAgIHZhciBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSkge1xuICAgICAgICAgIG1heFRvdGFsTG9hZGluZyA9IHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pIHtcbiAgICAgICAgICBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGlsZVF1ZXVlLmdldFRpbGVzTG9hZGluZygpIDwgbWF4VG90YWxMb2FkaW5nKSB7XG4gICAgICAgIHRpbGVRdWV1ZS5yZXByaW9yaXRpemUoKTsgLy8gRklYTUUgb25seSBjYWxsIGlmIHZpZXcgaGFzIGNoYW5nZWRcbiAgICAgICAgdGlsZVF1ZXVlLmxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBvc3RSZW5kZXJGdW5jdGlvbnMgPSB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uc1tpXSh0aGlzJDEsIGZyYW1lU3RhdGUpO1xuICAgIH1cbiAgICBwb3N0UmVuZGVyRnVuY3Rpb25zLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZVNpemVDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZVNpemVDaGFuZ2VkXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVGFyZ2V0Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVUYXJnZXRDaGFuZ2VkXyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvLyB0YXJnZXQgbWF5IGJlIHVuZGVmaW5lZCwgbnVsbCwgYSBzdHJpbmcgb3IgYW4gRWxlbWVudC5cbiAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIHdlIGNvbnZlcnQgaXQgdG8gYW4gRWxlbWVudCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAvLyBJZiBpdCdzIG5vdCBub3cgYW4gRWxlbWVudCB3ZSByZW1vdmUgdGhlIHZpZXdwb3J0IGZyb20gdGhlIERPTS5cbiAgICAvLyBJZiBpdCdzIGFuIEVsZW1lbnQgd2UgYXBwZW5kIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIGl0LlxuXG4gICAgdmFyIHRhcmdldEVsZW1lbnQ7XG4gICAgaWYgKHRoaXMuZ2V0VGFyZ2V0KCkpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlIYW5kbGVyS2V5c18pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMua2V5SGFuZGxlcktleXNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdW5saXN0ZW5CeUtleSh0aGlzJDEua2V5SGFuZGxlcktleXNfW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5SGFuZGxlcktleXNfID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucmVuZGVyZXJfLnJlbW92ZUxheWVyUmVuZGVyZXJzKCk7XG4gICAgICByZW1vdmVOb2RlKHRoaXMudmlld3BvcnRfKTtcbiAgICAgIGlmICh0aGlzLmhhbmRsZVJlc2l6ZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5SRVNJWkUsIHRoaXMuaGFuZGxlUmVzaXplXywgZmFsc2UpO1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZV8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy52aWV3cG9ydF8pO1xuXG4gICAgICB2YXIga2V5Ym9hcmRFdmVudFRhcmdldCA9ICF0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfID9cbiAgICAgICAgdGFyZ2V0RWxlbWVudCA6IHRoaXMua2V5Ym9hcmRFdmVudFRhcmdldF87XG4gICAgICB0aGlzLmtleUhhbmRsZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuKGtleWJvYXJkRXZlbnRUYXJnZXQsIEV2ZW50VHlwZS5LRVlET1dOLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyksXG4gICAgICAgIGxpc3RlbihrZXlib2FyZEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUuS0VZUFJFU1MsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKVxuICAgICAgXTtcblxuICAgICAgaWYgKCF0aGlzLmhhbmRsZVJlc2l6ZV8pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemVfID0gdGhpcy51cGRhdGVTaXplLmJpbmQodGhpcyk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaXplKCk7XG4gICAgLy8gdXBkYXRlU2l6ZSBjYWxscyBzZXRTaXplLCBzbyBubyBuZWVkIHRvIGNhbGwgdGhpcy5yZW5kZXJcbiAgICAvLyBvdXJzZWx2ZXMgaGVyZS5cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVGlsZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVUaWxlQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVmlld1Byb3BlcnR5Q2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXyAoKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuaGFuZGxlVmlld0NoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlVmlld0NoYW5nZWRfICgpIHtcbiAgICBpZiAodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy52aWV3UHJvcGVydHlMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlldycsIGdldFVpZCh2aWV3KSk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfLCB0aGlzKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLmhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXyAoKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXykge1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbGF5ZXJHcm91cCA9IHRoaXMuZ2V0TGF5ZXJHcm91cCgpO1xuICAgIGlmIChsYXllckdyb3VwKSB7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihcbiAgICAgICAgICBsYXllckdyb3VwLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgICAgdGhpcy5yZW5kZXIsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAgbGF5ZXJHcm91cCwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICB0aGlzLnJlbmRlciwgdGhpcylcbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHJlbmRlcmVkLlxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5pc1JlbmRlcmVkID0gZnVuY3Rpb24gaXNSZW5kZXJlZCAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5mcmFtZVN0YXRlXztcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdHMgYW4gaW1tZWRpYXRlIHJlbmRlciBpbiBhIHN5bmNocm9ub3VzIG1hbm5lci5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW5kZXJTeW5jID0gZnVuY3Rpb24gcmVuZGVyU3luYyAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgYSBtYXAgcmVuZGVyaW5nIChhdCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY29udHJvbCBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2NvbnRyb2wvQ29udHJvbH0gY29udHJvbCBDb250cm9sLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29udHJvbC9Db250cm9sfHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgY29udHJvbCAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgY29udHJvbCB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gcmVtb3ZlQ29udHJvbCAoY29udHJvbCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRyb2xzKCkucmVtb3ZlKGNvbnRyb2wpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGludGVyYWN0aW9uIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb259IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9ufHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgaW50ZXJhY3Rpb24gKG9yXG4gICAqICAgICB1bmRlZmluZWQgaWYgdGhlIGludGVyYWN0aW9uIHdhcyBub3QgZm91bmQpLlxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnJlbW92ZUludGVyYWN0aW9uID0gZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucmVtb3ZlKGludGVyYWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGF5ZXIgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9CYXNlfSBsYXllciBMYXllci5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2xheWVyL0Jhc2V8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBsYXllciAob3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiAgICAgbGF5ZXIgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiByZW1vdmVMYXllciAobGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXRMYXllckdyb3VwKCkuZ2V0TGF5ZXJzKCk7XG4gICAgcmV0dXJuIGxheWVycy5yZW1vdmUobGF5ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIG92ZXJsYXkgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9PdmVybGF5fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9PdmVybGF5fHVuZGVmaW5lZH0gVGhlIHJlbW92ZWQgb3ZlcmxheSAob3IgdW5kZWZpbmVkXG4gICAqICAgICBpZiB0aGUgb3ZlcmxheSB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24gcmVtb3ZlT3ZlcmxheSAob3ZlcmxheSkge1xuICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXlzKCkucmVtb3ZlKG92ZXJsYXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaW1lLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5yZW5kZXJGcmFtZV8gPSBmdW5jdGlvbiByZW5kZXJGcmFtZV8gKHRpbWUpIHtcbiAgICB2YXIgdmlld1N0YXRlO1xuXG4gICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICB2YXIgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIHZhciBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICAgIHZhciBwcmV2aW91c0ZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIC8qKiBAdHlwZSB7P21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gKi9cbiAgICB2YXIgZnJhbWVTdGF0ZSA9IG51bGw7XG4gICAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBoYXNBcmVhKHNpemUpICYmIHZpZXcgJiYgdmlldy5pc0RlZigpKSB7XG4gICAgICB2YXIgdmlld0hpbnRzID0gdmlldy5nZXRIaW50cyh0aGlzLmZyYW1lU3RhdGVfID8gdGhpcy5mcmFtZVN0YXRlXy52aWV3SGludHMgOiB1bmRlZmluZWQpO1xuICAgICAgdmFyIGxheWVyU3RhdGVzQXJyYXkgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyU3RhdGVzQXJyYXkubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsYXllclN0YXRlc1tnZXRVaWQobGF5ZXJTdGF0ZXNBcnJheVtpXS5sYXllcildID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIH1cbiAgICAgIHZpZXdTdGF0ZSA9IHZpZXcuZ2V0U3RhdGUoKTtcbiAgICAgIHZhciBmb2N1cyA9IHRoaXMuZm9jdXNfO1xuICAgICAgaWYgKCFmb2N1cykge1xuICAgICAgICBmb2N1cyA9IHZpZXdTdGF0ZS5jZW50ZXI7XG4gICAgICAgIHZhciBwaXhlbFJlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbiAvIHRoaXMucGl4ZWxSYXRpb187XG4gICAgICAgIGZvY3VzWzBdID0gTWF0aC5yb3VuZChmb2N1c1swXSAvIHBpeGVsUmVzb2x1dGlvbikgKiBwaXhlbFJlc29sdXRpb247XG4gICAgICAgIGZvY3VzWzFdID0gTWF0aC5yb3VuZChmb2N1c1sxXSAvIHBpeGVsUmVzb2x1dGlvbikgKiBwaXhlbFJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBmcmFtZVN0YXRlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9ICovICh7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTogdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8sXG4gICAgICAgIGV4dGVudDogZXh0ZW50LFxuICAgICAgICBmb2N1czogZm9jdXMsXG4gICAgICAgIGluZGV4OiB0aGlzLmZyYW1lSW5kZXhfKyssXG4gICAgICAgIGxheWVyU3RhdGVzOiBsYXllclN0YXRlcyxcbiAgICAgICAgbGF5ZXJTdGF0ZXNBcnJheTogbGF5ZXJTdGF0ZXNBcnJheSxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm06IHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fLFxuICAgICAgICBwb3N0UmVuZGVyRnVuY3Rpb25zOiBbXSxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgc2tpcHBlZEZlYXR1cmVVaWRzOiB0aGlzLnNraXBwZWRGZWF0dXJlVWlkc18sXG4gICAgICAgIHRpbGVRdWV1ZTogdGhpcy50aWxlUXVldWVfLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB1c2VkVGlsZXM6IHt9LFxuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgdmlld0hpbnRzOiB2aWV3SGludHMsXG4gICAgICAgIHdhbnRlZFRpbGVzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lU3RhdGUpIHtcbiAgICAgIGZyYW1lU3RhdGUuZXh0ZW50ID0gZ2V0Rm9yVmlld0FuZFNpemUodmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgdmlld1N0YXRlLnJlc29sdXRpb24sIHZpZXdTdGF0ZS5yb3RhdGlvbiwgZnJhbWVTdGF0ZS5zaXplLCBleHRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWVTdGF0ZV8gPSBmcmFtZVN0YXRlO1xuICAgIHRoaXMucmVuZGVyZXJfLnJlbmRlckZyYW1lKGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKGZyYW1lU3RhdGUpIHtcbiAgICAgIGlmIChmcmFtZVN0YXRlLmFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc18sIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucyk7XG5cbiAgICAgIGlmIChwcmV2aW91c0ZyYW1lU3RhdGUpIHtcbiAgICAgICAgdmFyIG1vdmVTdGFydCA9ICF0aGlzLnByZXZpb3VzRXh0ZW50XyB8fFxuICAgICAgICAgICAgICAgICAgICAoIWlzRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pICYmXG4gICAgICAgICAgICAgICAgICAgICFlcXVhbHMoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKSk7XG4gICAgICAgIGlmIChtb3ZlU3RhcnQpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLk1PVkVTVEFSVCwgdGhpcywgcHJldmlvdXNGcmFtZVN0YXRlKSk7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c0V4dGVudF8gPSBjcmVhdGVPclVwZGF0ZUVtcHR5KHRoaXMucHJldmlvdXNFeHRlbnRfKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaWRsZSA9IHRoaXMucHJldmlvdXNFeHRlbnRfICYmXG4gICAgICAgICAgIWZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gJiZcbiAgICAgICAgICAhZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddICYmXG4gICAgICAgICAgIWVxdWFscyhmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pO1xuXG4gICAgICBpZiAoaWRsZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1hcEV2ZW50KE1hcEV2ZW50VHlwZS5NT1ZFRU5ELCB0aGlzLCBmcmFtZVN0YXRlKSk7XG4gICAgICAgIGNsb25lKGZyYW1lU3RhdGUuZXh0ZW50LCB0aGlzLnByZXZpb3VzRXh0ZW50Xyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuUE9TVFJFTkRFUiwgdGhpcywgZnJhbWVTdGF0ZSkpO1xuXG4gICAgc2V0VGltZW91dCh0aGlzLmhhbmRsZVBvc3RSZW5kZXIuYmluZCh0aGlzKSwgMCk7XG5cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXJncm91cCBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvR3JvdXB9IGxheWVyR3JvdXAgQSBsYXllciBncm91cCBjb250YWluaW5nIHRoZSBsYXllcnMgaW4gdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0TGF5ZXJHcm91cCA9IGZ1bmN0aW9uIHNldExheWVyR3JvdXAgKGxheWVyR3JvdXApIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQLCBsYXllckdyb3VwKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzaXplIG9mIHRoaXMgbWFwLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemV8dW5kZWZpbmVkfSBzaXplIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHNpemUpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5TSVpFLCBzaXplKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0YXJnZXQgZWxlbWVudCB0byByZW5kZXIgdGhpcyBtYXAgaW50by5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSB0YXJnZXQgVGhlIEVsZW1lbnQgb3IgaWQgb2YgdGhlIEVsZW1lbnRcbiAgICogICAgIHRoYXQgdGhlIG1hcCBpcyByZW5kZXJlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgUGx1Z2dhYmxlTWFwLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQgKHRhcmdldCkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlRBUkdFVCwgdGFyZ2V0KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3IGZvciB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvVmlld30gdmlldyBUaGUgdmlldyB0aGF0IGNvbnRyb2xzIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnNldFZpZXcgPSBmdW5jdGlvbiBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5zZXQoTWFwUHJvcGVydHkuVklFVywgdmlldyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUuc2tpcEZlYXR1cmUgPSBmdW5jdGlvbiBza2lwRmVhdHVyZSAoZmVhdHVyZSkge1xuICAgIHZhciBmZWF0dXJlVWlkID0gZ2V0VWlkKGZlYXR1cmUpLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfW2ZlYXR1cmVVaWRdID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIG1hcCB2aWV3cG9ydCBzaXplLiAgVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhpcmQtcGFydHkgY29kZSBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFBsdWdnYWJsZU1hcC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIHVwZGF0ZVNpemUgKCkge1xuICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZSh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICB0aGlzLnNldFNpemUoW1xuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyTGVmdFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0xlZnQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nUmlnaHQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJSaWdodFdpZHRoJ10pLFxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclRvcFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ1RvcCddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJCb3R0b21XaWR0aCddKVxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBQbHVnZ2FibGVNYXAucHJvdG90eXBlLnVuc2tpcEZlYXR1cmUgPSBmdW5jdGlvbiB1bnNraXBGZWF0dXJlIChmZWF0dXJlKSB7XG4gICAgdmFyIGZlYXR1cmVVaWQgPSBnZXRVaWQoZmVhdHVyZSkudG9TdHJpbmcoKTtcbiAgICBkZWxldGUgdGhpcy5za2lwcGVkRmVhdHVyZVVpZHNfW2ZlYXR1cmVVaWRdO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH07XG5cbiAgcmV0dXJuIFBsdWdnYWJsZU1hcDtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtNYXBPcHRpb25zfSBvcHRpb25zIE1hcCBvcHRpb25zLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5NYXBPcHRpb25zSW50ZXJuYWx9IEludGVybmFsIG1hcCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAqL1xuICB2YXIga2V5Ym9hcmRFdmVudFRhcmdldCA9IG51bGw7XG4gIGlmIChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQgPSB0eXBlb2Ygb3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ID09PSAnc3RyaW5nJyA/XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQpIDpcbiAgICAgIG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsICo+fVxuICAgKi9cbiAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gIHZhciBsYXllckdyb3VwID0gKG9wdGlvbnMubGF5ZXJzIGluc3RhbmNlb2YgTGF5ZXJHcm91cCkgP1xuICAgIG9wdGlvbnMubGF5ZXJzIDogbmV3IExheWVyR3JvdXAoe2xheWVyczogb3B0aW9ucy5sYXllcnN9KTtcbiAgdmFsdWVzW01hcFByb3BlcnR5LkxBWUVSR1JPVVBdID0gbGF5ZXJHcm91cDtcblxuICB2YWx1ZXNbTWFwUHJvcGVydHkuVEFSR0VUXSA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5WSUVXXSA9IG9wdGlvbnMudmlldyAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnZpZXcgOiBuZXcgVmlldygpO1xuXG4gIHZhciBjb250cm9scztcbiAgaWYgKG9wdGlvbnMuY29udHJvbHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuY29udHJvbHMpKSB7XG4gICAgICBjb250cm9scyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuY29udHJvbHMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChvcHRpb25zLmNvbnRyb2xzIGluc3RhbmNlb2YgQ29sbGVjdGlvbixcbiAgICAgICAgNDcpOyAvLyBFeHBlY3RlZCBgY29udHJvbHNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uYFxuICAgICAgY29udHJvbHMgPSBvcHRpb25zLmNvbnRyb2xzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnRlcmFjdGlvbnM7XG4gIGlmIChvcHRpb25zLmludGVyYWN0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmFjdGlvbnMpKSB7XG4gICAgICBpbnRlcmFjdGlvbnMgPSBuZXcgQ29sbGVjdGlvbihvcHRpb25zLmludGVyYWN0aW9ucy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG9wdGlvbnMuaW50ZXJhY3Rpb25zIGluc3RhbmNlb2YgQ29sbGVjdGlvbixcbiAgICAgICAgNDgpOyAvLyBFeHBlY3RlZCBgaW50ZXJhY3Rpb25zYCB0byBiZSBhbiBhcnJheSBvciBhbiBgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbmBcbiAgICAgIGludGVyYWN0aW9ucyA9IG9wdGlvbnMuaW50ZXJhY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdmVybGF5cztcbiAgaWYgKG9wdGlvbnMub3ZlcmxheXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3ZlcmxheXMpKSB7XG4gICAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMub3ZlcmxheXMuc2xpY2UoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChvcHRpb25zLm92ZXJsYXlzIGluc3RhbmNlb2YgQ29sbGVjdGlvbixcbiAgICAgICAgNDkpOyAvLyBFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uYFxuICAgICAgb3ZlcmxheXMgPSBvcHRpb25zLm92ZXJsYXlzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdmVybGF5cyA9IG5ldyBDb2xsZWN0aW9uKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRyb2xzOiBjb250cm9scyxcbiAgICBpbnRlcmFjdGlvbnM6IGludGVyYWN0aW9ucyxcbiAgICBrZXlib2FyZEV2ZW50VGFyZ2V0OiBrZXlib2FyZEV2ZW50VGFyZ2V0LFxuICAgIG92ZXJsYXlzOiBvdmVybGF5cyxcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9O1xuXG59XG5leHBvcnQgZGVmYXVsdCBQbHVnZ2FibGVNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBsdWdnYWJsZU1hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVxuICovXG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZWFzZUlufSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvVGlsZX0gZm9yIHRoZSB0aWxlIGFuZCBhXG4gKiBge3N0cmluZ31gIGZvciB0aGUgdXJsIGFzIGFyZ3VtZW50cy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL1RpbGUsIHN0cmluZyl9IExvYWRGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0byBnZXRcbiAqIHRoZSB1cmwgdGhhdCBwcm92aWRlcyBhIHRpbGUgZm9yIGEgZ2l2ZW4gdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBmb3IgdGhlIHRpbGVcbiAqIGNvb3JkaW5hdGUsIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHJhdGlvIGFuZCBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkLCBudW1iZXIsXG4gKiAgICAgICAgICAgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbik6IChzdHJpbmd8dW5kZWZpbmVkKX0gVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uPTI1MF0gQSBkdXJhdGlvbiBmb3IgdGlsZSBvcGFjaXR5XG4gKiB0cmFuc2l0aW9ucyBpbiBtaWxsaXNlY29uZHMuIEEgZHVyYXRpb24gb2YgMCBkaXNhYmxlcyB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciB0aWxlcy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAgKi9cbnZhciBUaWxlID0gKGZ1bmN0aW9uIChFdmVudFRhcmdldCkge1xuICBmdW5jdGlvbiBUaWxlKHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKSB7XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNvb3JkID0gdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIEFuIFwiaW50ZXJpbVwiIHRpbGUgZm9yIHRoaXMgdGlsZS4gVGhlIGludGVyaW0gdGlsZSBtYXkgYmUgdXNlZCB3aGlsZSB0aGlzXG4gICAgICogb25lIGlzIGxvYWRpbmcsIGZvciBcInNtb290aFwiIHRyYW5zaXRpb25zIHdoZW4gY2hhbmdpbmcgcGFyYW1zL2RpbWVuc2lvbnNcbiAgICAgKiBvbiB0aGUgc291cmNlLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX1cbiAgICAgKi9cbiAgICB0aGlzLmludGVyaW1UaWxlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEga2V5IGFzc2lnbmVkIHRvIHRoZSB0aWxlLiBUaGlzIGlzIHVzZWQgYnkgdGhlIHRpbGUgc291cmNlIHRvIGRldGVybWluZVxuICAgICAqIGlmIHRoaXMgdGlsZSBjYW4gZWZmZWN0aXZlbHkgYmUgdXNlZCwgb3IgaWYgYSBuZXcgdGlsZSBzaG91bGQgYmUgY3JlYXRlZFxuICAgICAqIGFuZCB0aGlzIG9uZSBiZSB1c2VkIGFzIGFuIGludGVyaW0gdGlsZSBmb3IgdGhpcyBuZXcgdGlsZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gZm9yIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25fID0gb3B0aW9ucy50cmFuc2l0aW9uID09PSB1bmRlZmluZWQgPyAyNTAgOiBvcHRpb25zLnRyYW5zaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBMb29rdXAgb2Ygc3RhcnQgdGltZXMgZm9yIHJlbmRlcmluZyB0cmFuc2l0aW9ucy4gIElmIHRoZSBzdGFydCB0aW1lIGlzXG4gICAgICogZXF1YWwgdG8gLTEsIHRoZSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBUaWxlLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBUaWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpbGU7XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiBjaGFuZ2VkICgpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXkgKyAnLycgKyB0aGlzLnRpbGVDb29yZDtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcmltIHRpbGUgbW9zdCBzdWl0YWJsZSBmb3IgcmVuZGVyaW5nIHVzaW5nIHRoZSBjaGFpbiBvZiBpbnRlcmltXG4gICAqIHRpbGVzLiBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSAgbW9zdCByZWNlbnQgdGlsZSB0aGF0IGhhcyBiZWVuIGxvYWRlZCwgaWYgbm9cbiAgICogc3VjaCB0aWxlIGV4aXN0cywgdGhlIG9yaWdpbmFsIHRpbGUgaXMgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvVGlsZX0gQmVzdCB0aWxlIGZvciByZW5kZXJpbmcuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5nZXRJbnRlcmltVGlsZSA9IGZ1bmN0aW9uIGdldEludGVyaW1UaWxlICgpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIC8vZW1wdHkgY2hhaW5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBsb2FkZWQgdGlsZSBhbmQgcmV0dXJuIGl0LiBTaW5jZSB0aGUgY2hhaW4gaXMgc29ydGVkIGluXG4gICAgLy8gZGVjcmVhc2luZyBvcmRlciBvZiBjcmVhdGlvbiB0aW1lLCB0aGVyZSBpcyBubyBuZWVkIHRvIHNlYXJjaCB0aGUgcmVtYWluZGVyXG4gICAgLy8gb2YgdGhlIGxpc3QgKGFsbCB0aG9zZSB0aWxlcyBjb3JyZXNwb25kIHRvIG9sZGVyIHJlcXVlc3RzIGFuZCB3aWxsIGJlXG4gICAgLy8gY2xlYW5lZCB1cCBieSByZWZyZXNoSW50ZXJpbUNoYWluKVxuICAgIGRvIHtcbiAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgIH1cbiAgICAgIHRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICAgIH0gd2hpbGUgKHRpbGUpO1xuXG4gICAgLy8gd2UgY2FuIG5vdCBmaW5kIGEgYmV0dGVyIHRpbGVcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogR29lcyB0aHJvdWdoIHRoZSBjaGFpbiBvZiBpbnRlcmltIHRpbGVzIGFuZCBkaXNjYXJkcyBzZWN0aW9ucyBvZiB0aGUgY2hhaW5cbiAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUucmVmcmVzaEludGVyaW1DaGFpbiA9IGZ1bmN0aW9uIHJlZnJlc2hJbnRlcmltQ2hhaW4gKCkge1xuICAgIGlmICghdGhpcy5pbnRlcmltVGlsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aWxlID0gdGhpcy5pbnRlcmltVGlsZTtcbiAgICB2YXIgcHJldiA9IHRoaXM7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgLy93ZSBoYXZlIGEgbG9hZGVkIHRpbGUsIHdlIGNhbiBkaXNjYXJkIHRoZSByZXN0IG9mIHRoZSBsaXN0XG4gICAgICAgIC8vd2Ugd291bGQgY291bGQgYWJvcnQgYW55IExPQURJTkcgdGlsZSByZXF1ZXN0XG4gICAgICAgIC8vb2xkZXIgdGhhbiB0aGlzIHRpbGUgKGkuZS4gYW55IExPQURJTkcgdGlsZSBmb2xsb3dpbmcgdGhpcyBlbnRyeSBpbiB0aGUgY2hhaW4pXG4gICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgIC8va2VlcCB0aGlzIExPQURJTkcgdGlsZSBhbnkgbG9hZGVkIHRpbGVzIGxhdGVyIGluIHRoZSBjaGFpbiBhcmVcbiAgICAgICAgLy9vbGRlciB0aGFuIHRoaXMgdGlsZSwgc28gd2UncmUgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGUgcmVxdWVzdFxuICAgICAgICBwcmV2ID0gdGlsZTtcbiAgICAgIH0gZWxzZSBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgIC8vdGhlIGhlYWQgb2YgdGhlIGxpc3QgaXMgdGhlIG1vc3QgY3VycmVudCB0aWxlLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vdG8gc3RhcnQgYW55IG90aGVyIHJlcXVlc3RzIGZvciB0aGlzIGNoYWluXG4gICAgICAgIHByZXYuaW50ZXJpbVRpbGUgPSB0aWxlLmludGVyaW1UaWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldiA9IHRpbGU7XG4gICAgICB9XG4gICAgICB0aWxlID0gcHJldi5pbnRlcmltVGlsZTtcbiAgICB9IHdoaWxlICh0aWxlKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoaXMgdGlsZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRoZSB0aWxlIGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldFRpbGVDb29yZCA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNvb3JkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVN0YXRlfSBTdGF0ZS5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGltYWdlIG9yIHJldHJ5IGlmIGxvYWRpbmcgcHJldmlvdXNseSBmYWlsZWQuXG4gICAqIExvYWRpbmcgaXMgdGFrZW4gY2FyZSBvZiBieSB0aGUgdGlsZSBxdWV1ZSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2QgaXNcbiAgICogb25seSBuZWVkZWQgZm9yIHByZWxvYWRpbmcgb3IgZm9yIHJlbG9hZGluZyBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQGFwaVxuICAgKi9cbiAgVGlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge307XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYWxwaGEgdmFsdWUgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRoZSByZW5kZXIgZnJhbWUgdGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5nZXRBbHBoYSA9IGZ1bmN0aW9uIGdldEFscGhhIChpZCwgdGltZSkge1xuICAgIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF07XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgc3RhcnQgPSB0aW1lO1xuICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSBzdGFydDtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgKDEwMDAgLyA2MCk7IC8vIGF2b2lkIHJlbmRlcmluZyBhdCAwXG4gICAgaWYgKGRlbHRhID49IHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZUluKGRlbHRhIC8gdGhpcy50cmFuc2l0aW9uXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHRpbGUgaXMgaW4gYW4gYWxwaGEgdHJhbnNpdGlvbi4gIEEgdGlsZSBpcyBjb25zaWRlcmVkIGluXG4gICAqIHRyYW5zaXRpb24gaWYgdGlsZS5nZXRBbHBoYSgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkIG9yIGhhcyBiZWVuIGNhbGxlZFxuICAgKiBhbmQgcmV0dXJuZWQgMS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkIEFuIGlkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0aWxlIGlzIGluIHRyYW5zaXRpb24uXG4gICAqL1xuICBUaWxlLnByb3RvdHlwZS5pblRyYW5zaXRpb24gPSBmdW5jdGlvbiBpblRyYW5zaXRpb24gKGlkKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXSAhPT0gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgYSB0cmFuc2l0aW9uIGFzIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICovXG4gIFRpbGUucHJvdG90eXBlLmVuZFRyYW5zaXRpb24gPSBmdW5jdGlvbiBlbmRUcmFuc2l0aW9uIChpZCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25fKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfW2lkXSA9IC0xO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGlsZTtcbn0oRXZlbnRUYXJnZXQpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlQ2FjaGVcbiAqL1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4vc3RydWN0cy9MUlVDYWNoZS5qcyc7XG5pbXBvcnQge2Zyb21LZXksIGdldEtleX0gZnJvbSAnLi90aWxlY29vcmQuanMnO1xuXG52YXIgVGlsZUNhY2hlID0gKGZ1bmN0aW9uIChMUlVDYWNoZSkge1xuICBmdW5jdGlvbiBUaWxlQ2FjaGUob3B0X2hpZ2hXYXRlck1hcmspIHtcblxuICAgIExSVUNhY2hlLmNhbGwodGhpcywgb3B0X2hpZ2hXYXRlck1hcmspO1xuXG4gIH1cblxuICBpZiAoIExSVUNhY2hlICkgVGlsZUNhY2hlLl9fcHJvdG9fXyA9IExSVUNhY2hlO1xuICBUaWxlQ2FjaGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTFJVQ2FjaGUgJiYgTFJVQ2FjaGUucHJvdG90eXBlICk7XG4gIFRpbGVDYWNoZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlQ2FjaGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvVGlsZVJhbmdlPn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqL1xuICBUaWxlQ2FjaGUucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24gZXhwaXJlQ2FjaGUgKHVzZWRUaWxlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgd2hpbGUgKHRoaXMuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgdmFyIHRpbGUgPSB0aGlzJDEucGVla0xhc3QoKTtcbiAgICAgIHZhciB6S2V5ID0gdGlsZS50aWxlQ29vcmRbMF0udG9TdHJpbmcoKTtcbiAgICAgIGlmICh6S2V5IGluIHVzZWRUaWxlcyAmJiB1c2VkVGlsZXNbektleV0uY29udGFpbnModGlsZS50aWxlQ29vcmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcyQxLnBvcCgpLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBydW5lIGFsbCB0aWxlcyBmcm9tIHRoZSBjYWNoZSB0aGF0IGRvbid0IGhhdmUgdGhlIHNhbWUgeiBhcyB0aGUgbmV3ZXN0IHRpbGUuXG4gICAqL1xuICBUaWxlQ2FjaGUucHJvdG90eXBlLnBydW5lRXhjZXB0TmV3ZXN0WiA9IGZ1bmN0aW9uIHBydW5lRXhjZXB0TmV3ZXN0WiAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0Q291bnQoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdGhpcy5wZWVrRmlyc3RLZXkoKTtcbiAgICB2YXIgdGlsZUNvb3JkID0gZnJvbUtleShrZXkpO1xuICAgIHZhciB6ID0gdGlsZUNvb3JkWzBdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih0aWxlKSB7XG4gICAgICBpZiAodGlsZS50aWxlQ29vcmRbMF0gIT09IHopIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoZ2V0S2V5KHRpbGUudGlsZUNvb3JkKSk7XG4gICAgICAgIHRpbGUuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBUaWxlQ2FjaGU7XG59KExSVUNhY2hlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUNhY2hlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlQ2FjaGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVRdWV1ZVxuICovXG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3Rlbn0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9UaWxlLCBzdHJpbmcsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUsIG51bWJlcik6IG51bWJlcn0gUHJpb3JpdHlGdW5jdGlvblxuICovXG5cblxudmFyIFRpbGVRdWV1ZSA9IChmdW5jdGlvbiAoUHJpb3JpdHlRdWV1ZSkge1xuICBmdW5jdGlvbiBUaWxlUXVldWUodGlsZVByaW9yaXR5RnVuY3Rpb24sIHRpbGVDaGFuZ2VDYWxsYmFjaykge1xuXG4gICAgUHJpb3JpdHlRdWV1ZS5jYWxsKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFByaW9yaXR5LlxuICAgICAgICovXG4gICAgICB0aGlzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aWxlUHJpb3JpdHlGdW5jdGlvbi5hcHBseShudWxsLCBlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX0gKi8gKGVsZW1lbnRbMF0pLmdldEtleSgpKTtcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oKTogP31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDaGFuZ2VDYWxsYmFja18gPSB0aWxlQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWxlc0xvYWRpbmdfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZyxib29sZWFuPn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfID0ge307XG5cbiAgfVxuXG4gIGlmICggUHJpb3JpdHlRdWV1ZSApIFRpbGVRdWV1ZS5fX3Byb3RvX18gPSBQcmlvcml0eVF1ZXVlO1xuICBUaWxlUXVldWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUHJpb3JpdHlRdWV1ZSAmJiBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZSApO1xuICBUaWxlUXVldWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZVF1ZXVlO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbWVudCkge1xuICAgIHZhciBhZGRlZCA9IFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICBpZiAoYWRkZWQpIHtcbiAgICAgIHZhciB0aWxlID0gZWxlbWVudFswXTtcbiAgICAgIGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHRpbGVzIGxvYWRpbmcuXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmdldFRpbGVzTG9hZGluZyA9IGZ1bmN0aW9uIGdldFRpbGVzTG9hZGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZXNMb2FkaW5nXztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZVF1ZXVlLnByb3RvdHlwZS5oYW5kbGVUaWxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlVGlsZUNoYW5nZSAoZXZlbnQpIHtcbiAgICB2YXIgdGlsZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV9ICovIChldmVudC50YXJnZXQpO1xuICAgIHZhciBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5MT0FERUQgfHwgc3RhdGUgPT09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICBzdGF0ZSA9PT0gVGlsZVN0YXRlLkVNUFRZIHx8IHN0YXRlID09PSBUaWxlU3RhdGUuQUJPUlQpIHtcbiAgICAgIHVubGlzdGVuKHRpbGUsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgICB2YXIgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBpZiAodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldO1xuICAgICAgICAtLXRoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgIH1cbiAgICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heFRvdGFsTG9hZGluZyBNYXhpbXVtIG51bWJlciB0aWxlcyB0byBsb2FkIHNpbXVsdGFuZW91c2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TmV3TG9hZHMgTWF4aW11bSBudW1iZXIgb2YgbmV3IHRpbGVzIHRvIGxvYWQuXG4gICAqL1xuICBUaWxlUXVldWUucHJvdG90eXBlLmxvYWRNb3JlVGlsZXMgPSBmdW5jdGlvbiBsb2FkTW9yZVRpbGVzIChtYXhUb3RhbExvYWRpbmcsIG1heE5ld0xvYWRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbmV3TG9hZHMgPSAwO1xuICAgIHZhciBhYm9ydGVkVGlsZXMgPSBmYWxzZTtcbiAgICB2YXIgc3RhdGUsIHRpbGUsIHRpbGVLZXk7XG4gICAgd2hpbGUgKHRoaXMudGlsZXNMb2FkaW5nXyA8IG1heFRvdGFsTG9hZGluZyAmJiBuZXdMb2FkcyA8IG1heE5ld0xvYWRzICYmXG4gICAgICAgICAgIHRoaXMuZ2V0Q291bnQoKSA+IDApIHtcbiAgICAgIHRpbGUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9UaWxlfSAqLyAodGhpcyQxLmRlcXVldWUoKVswXSk7XG4gICAgICB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXRlID09PSBUaWxlU3RhdGUuQUJPUlQpIHtcbiAgICAgICAgYWJvcnRlZFRpbGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5JRExFICYmICEodGlsZUtleSBpbiB0aGlzJDEudGlsZXNMb2FkaW5nS2V5c18pKSB7XG4gICAgICAgIHRoaXMkMS50aWxlc0xvYWRpbmdLZXlzX1t0aWxlS2V5XSA9IHRydWU7XG4gICAgICAgICsrdGhpcyQxLnRpbGVzTG9hZGluZ187XG4gICAgICAgICsrbmV3TG9hZHM7XG4gICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3TG9hZHMgPT09IDAgJiYgYWJvcnRlZFRpbGVzKSB7XG4gICAgICAvLyBEbyBub3Qgc3RvcCB0aGUgcmVuZGVyIGxvb3Agd2hlbiBhbGwgd2FudGVkIHRpbGVzIHdlcmUgYWJvcnRlZCBkdWUgdG9cbiAgICAgIC8vIGEgc21hbGwsIHNhdHVyYXRlZCB0aWxlIGNhY2hlLlxuICAgICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaWxlUXVldWU7XG59KFByaW9yaXR5UXVldWUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlUXVldWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVRdWV1ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZVJhbmdlXG4gKi9cblxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29udGlndW91cyBibG9jayBvZiB0aWxlcy4gIEEgdGlsZSByYW5nZSBpcyBzcGVjaWZpZWRcbiAqIGJ5IGl0cyBtaW4vbWF4IHRpbGUgY29vcmRpbmF0ZXMgYW5kIGlzIGluY2x1c2l2ZSBvZiBjb29yZGluYXRlcy5cbiAqL1xudmFyIFRpbGVSYW5nZSA9IGZ1bmN0aW9uIFRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblggPSBtaW5YO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5tYXhYID0gbWF4WDtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWluWSA9IG1pblk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1heFkgPSBtYXhZO1xuXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyB0aWxlIGNvb3JkaW5hdGUuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAodGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5zWFkodGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuY29udGFpbnNUaWxlUmFuZ2UgPSBmdW5jdGlvbiBjb250YWluc1RpbGVSYW5nZSAodGlsZVJhbmdlKSB7XG4gIHJldHVybiB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1pblggJiYgdGlsZVJhbmdlLm1heFggPD0gdGhpcy5tYXhYICYmXG4gICAgIHRoaXMubWluWSA8PSB0aWxlUmFuZ2UubWluWSAmJiB0aWxlUmFuZ2UubWF4WSA8PSB0aGlzLm1heFk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBjb29yZGluYXRlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zWFkgPSBmdW5jdGlvbiBjb250YWluc1hZICh4LCB5KSB7XG4gIHJldHVybiB0aGlzLm1pblggPD0geCAmJiB4IDw9IHRoaXMubWF4WCAmJiB0aGlzLm1pblkgPD0geSAmJiB5IDw9IHRoaXMubWF4WTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWFscy5cbiAqL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YID09IHRpbGVSYW5nZS5taW5YICYmIHRoaXMubWluWSA9PSB0aWxlUmFuZ2UubWluWSAmJlxuICAgICB0aGlzLm1heFggPT0gdGlsZVJhbmdlLm1heFggJiYgdGhpcy5tYXhZID09IHRpbGVSYW5nZS5tYXhZO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAodGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UubWluWCA8IHRoaXMubWluWCkge1xuICAgIHRoaXMubWluWCA9IHRpbGVSYW5nZS5taW5YO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWF4WCA+IHRoaXMubWF4WCkge1xuICAgIHRoaXMubWF4WCA9IHRpbGVSYW5nZS5tYXhYO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWluWSA8IHRoaXMubWluWSkge1xuICAgIHRoaXMubWluWSA9IHRpbGVSYW5nZS5taW5ZO1xuICB9XG4gIGlmICh0aWxlUmFuZ2UubWF4WSA+IHRoaXMubWF4WSkge1xuICAgIHRoaXMubWF4WSA9IHRpbGVSYW5nZS5tYXhZO1xuICB9XG59O1xuXG4vKipcbiogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4qL1xuVGlsZVJhbmdlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiBnZXRIZWlnaHQgKCkge1xuICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbn07XG5cbi8qKlxuKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBTaXplLlxuKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICByZXR1cm4gW3RoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG59O1xuXG4vKipcbiogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiovXG5UaWxlUmFuZ2UucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGggKCkge1xuICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuKiBAcmV0dXJuIHtib29sZWFufSBJbnRlcnNlY3RzLlxuKi9cblRpbGVSYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHRpbGVSYW5nZSkge1xuICByZXR1cm4gdGhpcy5taW5YIDw9IHRpbGVSYW5nZS5tYXhYICYmXG4gICAgIHRoaXMubWF4WCA+PSB0aWxlUmFuZ2UubWluWCAmJlxuICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgdGhpcy5tYXhZID49IHRpbGVSYW5nZS5taW5ZO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZT19IHRpbGVSYW5nZSBUaWxlUmFuZ2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWF4WCwgbWluWSwgbWF4WSwgdGlsZVJhbmdlKSB7XG4gIGlmICh0aWxlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRpbGVSYW5nZS5taW5YID0gbWluWDtcbiAgICB0aWxlUmFuZ2UubWF4WCA9IG1heFg7XG4gICAgdGlsZVJhbmdlLm1pblkgPSBtaW5ZO1xuICAgIHRpbGVSYW5nZS5tYXhZID0gbWF4WTtcbiAgICByZXR1cm4gdGlsZVJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVGlsZVJhbmdlKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVJhbmdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlUmFuZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIEVSUk9SOiAzLFxuICBFTVBUWTogNCxcbiAgQUJPUlQ6IDVcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVTdGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVmlld1xuICovXG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCB7VU5ERUZJTkVEfSBmcm9tICcuL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NyZWF0ZUV4dGVudCwgbm9uZSBhcyBjZW50ZXJOb25lfSBmcm9tICcuL2NlbnRlcmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IHtjcmVhdGVTbmFwVG9SZXNvbHV0aW9ucywgY3JlYXRlU25hcFRvUG93ZXJ9IGZyb20gJy4vcmVzb2x1dGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IHtjcmVhdGVTbmFwVG9aZXJvLCBjcmVhdGVTbmFwVG9OLCBub25lIGFzIHJvdGF0aW9uTm9uZSwgZGlzYWJsZX0gZnJvbSAnLi9yb3RhdGlvbmNvbnN0cmFpbnQuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IFZpZXdQcm9wZXJ0eSBmcm9tICcuL1ZpZXdQcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHthZGQgYXMgYWRkQ29vcmRpbmF0ZSwgcm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGUsIGVxdWFscyBhcyBjb29yZGluYXRlc0VxdWFsfSBmcm9tICcuL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtpbkFuZE91dH0gZnJvbSAnLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtnZXRGb3JWaWV3QW5kU2l6ZSwgZ2V0Q2VudGVyLCBnZXRIZWlnaHQsIGdldFdpZHRoLCBpc0VtcHR5fSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtmcm9tRXh0ZW50IGFzIHBvbHlnb25Gcm9tRXh0ZW50fSBmcm9tICcuL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5pbXBvcnQge2NyZWF0ZVByb2plY3Rpb24sIE1FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gW3NvdXJjZUNlbnRlcl1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gW3RhcmdldENlbnRlcl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUmVzb2x1dGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0UmVzb2x1dGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc291cmNlUm90YXRpb25dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RhcmdldFJvdGF0aW9uXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBbYW5jaG9yXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29tcGxldGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29sZWFuKX0gY2FsbGJhY2tcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NlbnRlcmNvbnN0cmFpbnR+VHlwZX0gY2VudGVyXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9yZXNvbHV0aW9uY29uc3RyYWludH5UeXBlfSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9yb3RhdGlvbmNvbnN0cmFpbnR+VHlwZX0gcm90YXRpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRml0T3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc2l6ZX5TaXplfSBbc2l6ZV0gVGhlIHNpemUgaW4gcGl4ZWxzIG9mIHRoZSBib3ggdG8gZml0XG4gKiB0aGUgZXh0ZW50IGludG8uIERlZmF1bHQgaXMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgZmlyc3QgbWFwIGluIHRoZSBET00gdGhhdFxuICogdXNlcyB0aGlzIHZpZXcsIG9yIGBbMTAwLCAxMDBdYCBpZiBubyBzdWNoIG1hcCBpcyBmb3VuZC5cbiAqIEBwcm9wZXJ0eSB7IUFycmF5LjxudW1iZXI+fSBbcGFkZGluZz1bMCwgMCwgMCwgMF1dIFBhZGRpbmcgKGluIHBpeGVscykgdG8gYmVcbiAqIGNsZWFyZWQgaW5zaWRlIHRoZSB2aWV3LiBWYWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnRcbiAqIHBhZGRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPXRydWVdIENvbnN0cmFpbiB0aGUgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25lYXJlc3Q9ZmFsc2VdIElmIGBjb25zdHJhaW5SZXNvbHV0aW9uYCBpcyBgdHJ1ZWAsIGdldFxuICogdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pfSBbY2FsbGJhY2tdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIGluXG4gKiBpdHMgZmluYWwgcG9zaXRpb24uIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uXG4gKiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYCBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBbY2VudGVyXSBUaGUgaW5pdGlhbCBjZW50ZXIgZm9yXG4gKiB0aGUgdmlldy4gVGhlIGNvb3JkaW5hdGUgc3lzdGVtIGZvciB0aGUgY2VudGVyIGlzIHNwZWNpZmllZCB3aXRoIHRoZVxuICogYHByb2plY3Rpb25gIG9wdGlvbi4gTGF5ZXIgc291cmNlcyB3aWxsIG5vdCBiZSBmZXRjaGVkIGlmIHRoaXMgaXMgbm90IHNldCxcbiAqIGJ1dCB0aGUgY2VudGVyIGNhbiBiZSBzZXQgbGF0ZXIgd2l0aCB7QGxpbmsgI3NldENlbnRlcn0uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58bnVtYmVyfSBbY29uc3RyYWluUm90YXRpb249dHJ1ZV0gUm90YXRpb24gY29uc3RyYWludC5cbiAqIGBmYWxzZWAgbWVhbnMgbm8gY29uc3RyYWludC4gYHRydWVgIG1lYW5zIG5vIGNvbnN0cmFpbnQsIGJ1dCBzbmFwIHRvIHplcm9cbiAqIG5lYXIgemVyby4gQSBudW1iZXIgY29uc3RyYWlucyB0aGUgcm90YXRpb24gdG8gdGhhdCBudW1iZXIgb2YgdmFsdWVzLiBGb3JcbiAqIGV4YW1wbGUsIGA0YCB3aWxsIGNvbnN0cmFpbiB0aGUgcm90YXRpb24gdG8gMCwgOTAsIDE4MCwgYW5kIDI3MCBkZWdyZWVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZW5hYmxlUm90YXRpb249dHJ1ZV0gRW5hYmxlIHJvdGF0aW9uLlxuICogSWYgYGZhbHNlYCwgYSByb3RhdGlvbiBjb25zdHJhaW50IHRoYXQgYWx3YXlzIHNldHMgdGhlIHJvdGF0aW9uIHRvIHplcm8gaXNcbiAqIHVzZWQuIFRoZSBgY29uc3RyYWluUm90YXRpb25gIG9wdGlvbiBoYXMgbm8gZWZmZWN0IGlmIGBlbmFibGVSb3RhdGlvbmAgaXNcbiAqIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBUaGUgZXh0ZW50IHRoYXQgY29uc3RyYWlucyB0aGVcbiAqIGNlbnRlciwgaW4gb3RoZXIgd29yZHMsIGNlbnRlciBjYW5ub3QgYmUgc2V0IG91dHNpZGUgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gdXNlZCB0byBkZXRlcm1pbmVcbiAqIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWluUmVzb2x1dGlvbmAgKG9yXG4gKiBgbWF4Wm9vbWApIGFuZCBgem9vbUZhY3RvcmAuIElmIHVuc3BlY2lmaWVkIGl0IGlzIGNhbGN1bGF0ZWQgaW4gc3VjaCBhIHdheVxuICogdGhhdCB0aGUgcHJvamVjdGlvbidzIHZhbGlkaXR5IGV4dGVudCBmaXRzIGluIGEgMjU2eDI1NiBweCB0aWxlLiBJZiB0aGVcbiAqIHByb2plY3Rpb24gaXMgU3BoZXJpY2FsIE1lcmNhdG9yICh0aGUgZGVmYXVsdCkgdGhlbiBgbWF4UmVzb2x1dGlvbmAgZGVmYXVsdHNcbiAqIHRvIGA0MDA3NTAxNi42ODU1Nzg0OSAvIDI1NiA9IDE1NjU0My4wMzM5MjgwNDA5N2AuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gdXNlZCB0byBkZXRlcm1pbmVcbiAqIHRoZSByZXNvbHV0aW9uIGNvbnN0cmFpbnQuICBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1heFJlc29sdXRpb25gIChvclxuICogYG1pblpvb21gKSBhbmQgYHpvb21GYWN0b3JgLiAgSWYgdW5zcGVjaWZpZWQgaXQgaXMgY2FsY3VsYXRlZCBhc3N1bWluZyAyOVxuICogem9vbSBsZXZlbHMgKHdpdGggYSBmYWN0b3Igb2YgMikuIElmIHRoZSBwcm9qZWN0aW9uIGlzIFNwaGVyaWNhbCBNZXJjYXRvclxuICogKHRoZSBkZWZhdWx0KSB0aGVuIGBtaW5SZXNvbHV0aW9uYCBkZWZhdWx0cyB0b1xuICogYDQwMDc1MDE2LjY4NTU3ODQ5IC8gMjU2IC8gTWF0aC5wb3coMiwgMjgpID0gMC4wMDA1ODMxNjgyNDU1ODM5MjUzYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbT0yOF0gVGhlIG1heGltdW0gem9vbSBsZXZlbCB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtaW5ab29tYCAob3JcbiAqIGBtYXhSZXNvbHV0aW9uYCkgYW5kIGB6b29tRmFjdG9yYC4gIE5vdGUgdGhhdCBpZiBgbWluUmVzb2x1dGlvbmAgaXMgYWxzb1xuICogcHJvdmlkZWQsIGl0IGlzIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBgbWF4Wm9vbWAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblpvb209MF0gVGhlIG1pbmltdW0gem9vbSBsZXZlbCB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtYXhab29tYCAob3JcbiAqIGBtaW5SZXNvbHV0aW9uYCkgYW5kIGB6b29tRmFjdG9yYC4gIE5vdGUgdGhhdCBpZiBgbWF4UmVzb2x1dGlvbmAgaXMgYWxzb1xuICogcHJvdmlkZWQsIGl0IGlzIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBgbWluWm9vbWAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gVGhlXG4gKiBwcm9qZWN0aW9uLiBUaGUgZGVmYXVsdCBpcyBTcGhlcmljYWwgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb25dIFRoZSBpbml0aWFsIHJlc29sdXRpb24gZm9yIHRoZSB2aWV3LiBUaGVcbiAqIHVuaXRzIGFyZSBgcHJvamVjdGlvbmAgdW5pdHMgcGVyIHBpeGVsIChlLmcuIG1ldGVycyBwZXIgcGl4ZWwpLiBBblxuICogYWx0ZXJuYXRpdmUgdG8gc2V0dGluZyB0aGlzIGlzIHRvIHNldCBgem9vbWAuIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmVcbiAqIGZldGNoZWQgaWYgbmVpdGhlciB0aGlzIG5vciBgem9vbWAgYXJlIGRlZmluZWQsIGJ1dCB0aGV5IGNhbiBiZSBzZXQgbGF0ZXJcbiAqIHdpdGgge0BsaW5rICNzZXRab29tfSBvciB7QGxpbmsgI3NldFJlc29sdXRpb259LlxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gW3Jlc29sdXRpb25zXSBSZXNvbHV0aW9ucyB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuIElmIHNldCB0aGUgYG1heFJlc29sdXRpb25gLCBgbWluUmVzb2x1dGlvbmAsXG4gKiBgbWluWm9vbWAsIGBtYXhab29tYCwgYW5kIGB6b29tRmFjdG9yYCBvcHRpb25zIGFyZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBUaGUgaW5pdGlhbCByb3RhdGlvbiBmb3IgdGhlIHZpZXcgaW4gcmFkaWFuc1xuICogKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSwgMCBtZWFucyBOb3J0aCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pvb21dIE9ubHkgdXNlZCBpZiBgcmVzb2x1dGlvbmAgaXMgbm90IGRlZmluZWQuIFpvb21cbiAqIGxldmVsIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsIHJlc29sdXRpb24gZm9yIHRoZSB2aWV3LiBUaGUgaW5pdGlhbFxuICogcmVzb2x1dGlvbiBpcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSB7QGxpbmsgI2NvbnN0cmFpblJlc29sdXRpb259IG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbUZhY3Rvcj0yXSBUaGUgem9vbSBmYWN0b3IgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiByZXNvbHV0aW9uIGNvbnN0cmFpbnQuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXx1bmRlZmluZWR9IGNlbnRlciBUaGUgY2VudGVyIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcnx1bmRlZmluZWR9IHpvb20gVGhlIHpvb20gbGV2ZWwgb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZiB0aGVcbiAqIGFuaW1hdGlvbi4gVGhpcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYHJlc29sdXRpb25gLlxuICogQHByb3BlcnR5IHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmRcbiAqIG9mIHRoZSBhbmltYXRpb24uICBJZiBgem9vbWAgaXMgYWxzbyBwcm92aWRlZCwgdGhpcyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgYXQgdGhlIGVuZCBvZlxuICogdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXx1bmRlZmluZWR9IGFuY2hvciBPcHRpb25hbCBhbmNob3IgdG8gcmVtYWluZWQgZml4ZWRcbiAqIGR1cmluZyBhIHJvdGF0aW9uIG9yIHJlc29sdXRpb24gYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDAwXSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbZWFzaW5nXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHVzZWRcbiAqIGR1cmluZyB0aGUgYW5pbWF0aW9uIChkZWZhdWx0cyB0byB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ35pbkFuZE91dH0pLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGZyYW1lIHdpdGggYSBudW1iZXIgcmVwcmVzZW50aW5nIGFcbiAqIGZyYWN0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyXG4gKiBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyB0b3dhcmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjZW50ZXJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb21cbiAqL1xuXG5cbi8qKlxuICogRGVmYXVsdCBtaW4gem9vbSBsZXZlbCBmb3IgdGhlIG1hcCB2aWV3LlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBWaWV3IG9iamVjdCByZXByZXNlbnRzIGEgc2ltcGxlIDJEIHZpZXcgb2YgdGhlIG1hcC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBvYmplY3QgdG8gYWN0IHVwb24gdG8gY2hhbmdlIHRoZSBjZW50ZXIsIHJlc29sdXRpb24sXG4gKiBhbmQgcm90YXRpb24gb2YgdGhlIG1hcC5cbiAqXG4gKiAjIyMgVGhlIHZpZXcgc3RhdGVzXG4gKlxuICogQW4gVmlldyBpcyBkZXRlcm1pbmVkIGJ5IHRocmVlIHN0YXRlczogYGNlbnRlcmAsIGByZXNvbHV0aW9uYCxcbiAqIGFuZCBgcm90YXRpb25gLiBFYWNoIHN0YXRlIGhhcyBhIGNvcnJlc3BvbmRpbmcgZ2V0dGVyIGFuZCBzZXR0ZXIsIGUuZy5cbiAqIGBnZXRDZW50ZXJgIGFuZCBgc2V0Q2VudGVyYCBmb3IgdGhlIGBjZW50ZXJgIHN0YXRlLlxuICpcbiAqIEFuIFZpZXcgaGFzIGEgYHByb2plY3Rpb25gLiBUaGUgcHJvamVjdGlvbiBkZXRlcm1pbmVzIHRoZVxuICogY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGNlbnRlciwgYW5kIGl0cyB1bml0cyBkZXRlcm1pbmUgdGhlIHVuaXRzIG9mIHRoZVxuICogcmVzb2x1dGlvbiAocHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwpLiBUaGUgZGVmYXVsdCBwcm9qZWN0aW9uIGlzXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKlxuICogIyMjIFRoZSBjb25zdHJhaW50c1xuICpcbiAqIGBzZXRDZW50ZXJgLCBgc2V0UmVzb2x1dGlvbmAgYW5kIGBzZXRSb3RhdGlvbmAgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZVxuICogc3RhdGVzIG9mIHRoZSB2aWV3LiBBbnkgdmFsdWUgY2FuIGJlIHBhc3NlZCB0byB0aGUgc2V0dGVycy4gQW5kIHRoZSB2YWx1ZVxuICogdGhhdCBpcyBwYXNzZWQgdG8gYSBzZXR0ZXIgd2lsbCBlZmZlY3RpdmVseSBiZSB0aGUgdmFsdWUgc2V0IGluIHRoZSB2aWV3LFxuICogYW5kIHJldHVybmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGdldHRlci5cbiAqXG4gKiBCdXQgYSBWaWV3IG9iamVjdCBhbHNvIGhhcyBhICpyZXNvbHV0aW9uIGNvbnN0cmFpbnQqLCBhXG4gKiAqcm90YXRpb24gY29uc3RyYWludCogYW5kIGEgKmNlbnRlciBjb25zdHJhaW50Ki5cbiAqXG4gKiBBcyBzYWlkIGFib3ZlLCBubyBjb25zdHJhaW50cyBhcmUgYXBwbGllZCB3aGVuIHRoZSBzZXR0ZXJzIGFyZSB1c2VkIHRvIHNldFxuICogbmV3IHN0YXRlcyBmb3IgdGhlIHZpZXcuIEFwcGx5aW5nIGNvbnN0cmFpbnRzIGlzIGRvbmUgZXhwbGljaXRseSB0aHJvdWdoXG4gKiB0aGUgdXNlIG9mIHRoZSBgY29uc3RyYWluKmAgZnVuY3Rpb25zIChgY29uc3RyYWluUmVzb2x1dGlvbmAgYW5kXG4gKiBgY29uc3RyYWluUm90YXRpb25gIGFuZCBgY29uc3RyYWluQ2VudGVyYCkuXG4gKlxuICogVGhlIG1haW4gdXNlcnMgb2YgdGhlIGNvbnN0cmFpbnRzIGFyZSB0aGUgaW50ZXJhY3Rpb25zIGFuZCB0aGVcbiAqIGNvbnRyb2xzLiBGb3IgZXhhbXBsZSwgZG91YmxlLWNsaWNraW5nIG9uIHRoZSBtYXAgY2hhbmdlcyB0aGUgdmlldyB0b1xuICogdGhlIFwibmV4dFwiIHJlc29sdXRpb24uIEFuZCByZWxlYXNpbmcgdGhlIGZpbmdlcnMgYWZ0ZXIgcGluY2gtem9vbWluZ1xuICogc25hcHMgdG8gdGhlIGNsb3Nlc3QgcmVzb2x1dGlvbiAod2l0aCBhbiBhbmltYXRpb24pLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyByZXNvbHV0aW9ucy4gSXQgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZyBvcHRpb25zOiBgcmVzb2x1dGlvbnNgLCBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWF4Wm9vbWAsIGFuZCBgem9vbUZhY3RvcmAuIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWVcbiAqIG9wdGlvbnMgYXJlIGlnbm9yZWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24uXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgdGhlIHJvdGF0aW9uIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSBjZW50ZXIgaXMgbm90IGNvbnN0cmFpbmVkIGF0IGFsbC5cbiAqXG4gICogQGFwaVxuICovXG52YXIgVmlldyA9IChmdW5jdGlvbiAoQmFzZU9iamVjdCkge1xuICBmdW5jdGlvbiBWaWV3KG9wdF9vcHRpb25zKSB7XG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdF9vcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvVmlld35BbmltYXRpb24+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XztcblxuICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uc18gPSB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuXG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgVmlldy5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBWaWV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWaWV3O1xuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvVmlld35WaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5hcHBseU9wdGlvbnNfID0gZnVuY3Rpb24gYXBwbHlPcHRpb25zXyAob3B0aW9ucykge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LkNFTlRFUl0gPSBvcHRpb25zLmNlbnRlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY2VudGVyIDogbnVsbDtcblxuICAgIHZhciByZXNvbHV0aW9uQ29uc3RyYWludEluZm8gPSBjcmVhdGVSZXNvbHV0aW9uQ29uc3RyYWludChvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heFJlc29sdXRpb25fID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLm1heFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5SZXNvbHV0aW9uXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5taW5SZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuem9vbUZhY3Rvcl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8uem9vbUZhY3RvcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5ab29tXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5taW5ab29tO1xuXG4gICAgdmFyIGNlbnRlckNvbnN0cmFpbnQgPSBjcmVhdGVDZW50ZXJDb25zdHJhaW50KG9wdGlvbnMpO1xuICAgIHZhciByZXNvbHV0aW9uQ29uc3RyYWludCA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5jb25zdHJhaW50O1xuICAgIHZhciByb3RhdGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvVmlld35Db25zdHJhaW50c31cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpbnRzXyA9IHtcbiAgICAgIGNlbnRlcjogY2VudGVyQ29uc3RyYWludCxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb25Db25zdHJhaW50LFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uQ29uc3RyYWludFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzLm1pblpvb21fKTtcblxuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7IC8vIGluIGNhc2UgbWFwIHpvb20gaXMgb3V0IG9mIG1pbi9tYXggem9vbSByYW5nZVxuICAgICAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSA9IGNsYW1wKFxuICAgICAgICAgIE51bWJlcih0aGlzLmdldFJlc29sdXRpb24oKSB8fCBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSksXG4gICAgICAgICAgdGhpcy5taW5SZXNvbHV0aW9uXywgdGhpcy5tYXhSZXNvbHV0aW9uXyk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJPVEFUSU9OXSA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9WaWV3flZpZXdPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uc18gPSBvcHRpb25zO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHZpZXcgb3B0aW9ucyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgdmlldy4gIFRoZVxuICAgKiBjdXJyZW50IHJlc29sdXRpb24gKG9yIHpvb20pLCBjZW50ZXIsIGFuZCByb3RhdGlvbiBhcmUgYXBwbGllZCB0byBhbnkgc3RvcmVkXG4gICAqIG9wdGlvbnMuICBUaGUgcHJvdmlkZWQgb3B0aW9ucyBjYW4gYmUgdXNlZCB0byBhcHBseSBuZXcgbWluL21heCB6b29tIG9yXG4gICAqIHJlc29sdXRpb24gbGltaXRzLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3flZpZXdPcHRpb25zfSBuZXdPcHRpb25zIE5ldyBvcHRpb25zIHRvIGJlIGFwcGxpZWQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9WaWV3flZpZXdPcHRpb25zfSBOZXcgb3B0aW9ucyB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgdmlldyBzdGF0ZS5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFVwZGF0ZWRPcHRpb25zXyA9IGZ1bmN0aW9uIGdldFVwZGF0ZWRPcHRpb25zXyAobmV3T3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIHByZXNlcnZlIHJlc29sdXRpb24gKG9yIHpvb20pXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy56b29tID0gdGhpcy5nZXRab29tKCk7XG4gICAgfVxuXG4gICAgLy8gcHJlc2VydmUgY2VudGVyXG4gICAgb3B0aW9ucy5jZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgLy8gcHJlc2VydmUgcm90YXRpb25cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIHZpZXcuICBUaGUgdmlldydzIGNlbnRlciwgem9vbSAob3IgcmVzb2x1dGlvbiksIGFuZCByb3RhdGlvblxuICAgKiBjYW4gYmUgYW5pbWF0ZWQgZm9yIHNtb290aCB0cmFuc2l0aW9ucyBiZXR3ZWVuIHZpZXcgc3RhdGVzLiAgRm9yIGV4YW1wbGUsXG4gICAqIHRvIGFuaW1hdGUgdGhlIHZpZXcgdG8gYSBuZXcgem9vbSBsZXZlbDpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogdmlldy5nZXRab29tKCkgKyAxfSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBhbmltYXRpb24gbGFzdHMgb25lIHNlY29uZCBhbmQgdXNlcyBpbi1hbmQtb3V0IGVhc2luZy4gIFlvdVxuICAgKiBjYW4gY3VzdG9taXplIHRoaXMgYmVoYXZpb3IgYnkgaW5jbHVkaW5nIGBkdXJhdGlvbmAgKGluIG1pbGxpc2Vjb25kcykgYW5kXG4gICAqIGBlYXNpbmdgIG9wdGlvbnMgKHNlZSB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ30pLlxuICAgKlxuICAgKiBUbyBjaGFpbiB0b2dldGhlciBtdWx0aXBsZSBhbmltYXRpb25zLCBjYWxsIHRoZSBtZXRob2Qgd2l0aCBtdWx0aXBsZVxuICAgKiBhbmltYXRpb24gb2JqZWN0cy4gIEZvciBleGFtcGxlLCB0byBmaXJzdCB6b29tIGFuZCB0aGVuIHBhbjpcbiAgICpcbiAgICogICAgIHZpZXcuYW5pbWF0ZSh7em9vbTogMTB9LCB7Y2VudGVyOiBbMCwgMF19KTtcbiAgICpcbiAgICogSWYgeW91IHByb3ZpZGUgYSBmdW5jdGlvbiBhcyB0aGUgbGFzdCBhcmd1bWVudCB0byB0aGUgYW5pbWF0ZSBtZXRob2QsIGl0XG4gICAqIHdpbGwgZ2V0IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbiBzZXJpZXMuICBUaGUgY2FsbGJhY2sgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2l0aCBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYFxuICAgKiBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICAgKlxuICAgKiBBbmltYXRpb25zIGFyZSBjYW5jZWxsZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgKGUuZy4gZHJhZ2dpbmcgdGhlIG1hcCkgb3IgYnlcbiAgICogY2FsbGluZyBgdmlldy5zZXRDZW50ZXIoKWAsIGB2aWV3LnNldFJlc29sdXRpb24oKWAsIG9yIGB2aWV3LnNldFJvdGF0aW9uKClgXG4gICAqIChvciBhbm90aGVyIG1ldGhvZCB0aGF0IGNhbGxzIG9uZSBvZiB0aGVzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uKG1vZHVsZTpvbC9WaWV3fkFuaW1hdGlvbk9wdGlvbnN8ZnVuY3Rpb24oYm9vbGVhbikpfSB2YXJfYXJncyBBbmltYXRpb25cbiAgICogICAgIG9wdGlvbnMuICBNdWx0aXBsZSBhbmltYXRpb25zIGNhbiBiZSBydW4gaW4gc2VyaWVzIGJ5IHBhc3NpbmcgbXVsdGlwbGVcbiAgICogICAgIG9wdGlvbnMgb2JqZWN0cy4gIFRvIHJ1biBtdWx0aXBsZSBhbmltYXRpb25zIGluIHBhcmFsbGVsLCBjYWxsIHRoZSBtZXRob2RcbiAgICogICAgIG11bHRpcGxlIHRpbWVzLiAgQW4gb3B0aW9uYWwgY2FsbGJhY2sgY2FuIGJlIHByb3ZpZGVkIGFzIGEgZmluYWxcbiAgICogICAgIGFyZ3VtZW50LiAgVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgICAgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZWQgd2l0aG91dCBiZWluZyBjYW5jZWxsZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlICh2YXJfYXJncykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhbmltYXRpb25Db3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGNhbGxiYWNrO1xuICAgIGlmIChhbmltYXRpb25Db3VudCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdO1xuICAgICAgLS1hbmltYXRpb25Db3VudDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRGVmKCkpIHtcbiAgICAgIC8vIGlmIHZpZXcgcHJvcGVydGllcyBhcmUgbm90IHlldCBzZXQsIHNob3J0Y3V0IHRvIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgdmFyIHN0YXRlID0gYXJndW1lbnRzW2FuaW1hdGlvbkNvdW50IC0gMV07XG4gICAgICBpZiAoc3RhdGUuY2VudGVyKSB7XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyKHN0YXRlLmNlbnRlcik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Wm9vbShzdGF0ZS56b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oc3RhdGUucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLnNsaWNlKCk7XG4gICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgdmFyIHNlcmllcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uQ291bnQ7ICsraSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9WaWV3fkFuaW1hdGlvbk9wdGlvbnN9ICovIChhcmd1bWVudHMkMVtpXSk7XG5cbiAgICAgIHZhciBhbmltYXRpb24gPSAvKiogQHR5cGUge21vZHVsZTpvbC9WaWV3fkFuaW1hdGlvbn0gKi8gKHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIGFuY2hvcjogb3B0aW9ucy5hbmNob3IsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwMCxcbiAgICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyB8fCBpbkFuZE91dFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmNlbnRlcikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlQ2VudGVyID0gY2VudGVyO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0Q2VudGVyID0gb3B0aW9ucy5jZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gdGhpcyQxLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgICAgdGhpcyQxLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzJDEubWluWm9vbV8sIDApO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVzb2x1dGlvbikge1xuICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgICAgICByZXNvbHV0aW9uID0gYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHZhciBkZWx0YSA9IG1vZHVsbyhvcHRpb25zLnJvdGF0aW9uIC0gcm90YXRpb24gKyBNYXRoLlBJLCAyICogTWF0aC5QSSkgLSBNYXRoLlBJO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gPSByb3RhdGlvbiArIGRlbHRhO1xuICAgICAgICByb3RhdGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHZpZXcgaXMgYmVpbmcgYW5pbWF0ZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldEFuaW1hdGluZyA9IGZ1bmN0aW9uIGdldEFuaW1hdGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10gPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0SW50ZXJhY3RpbmcgPSBmdW5jdGlvbiBnZXRJbnRlcmFjdGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbmNlbCBhbnkgb25nb2luZyBhbmltYXRpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jYW5jZWxBbmltYXRpb25zID0gZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9ucyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAtdGhpcy5oaW50c19bVmlld0hpbnQuQU5JTUFUSU5HXSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgc2VyaWVzID0gdGhpcyQxLmFuaW1hdGlvbnNfW2ldO1xuICAgICAgaWYgKHNlcmllc1swXS5jYWxsYmFjaykge1xuICAgICAgICBzZXJpZXNbMF0uY2FsbGJhY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhbGwgYW5pbWF0aW9ucy5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnVwZGF0ZUFuaW1hdGlvbnNfID0gZnVuY3Rpb24gdXBkYXRlQW5pbWF0aW9uc18gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8pO1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIG1vcmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5hbmltYXRpb25zXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNlcmllcyA9IHRoaXMkMS5hbmltYXRpb25zX1tpXTtcbiAgICAgIHZhciBzZXJpZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamogPSBzZXJpZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSBhbmltYXRpb24uc3RhcnQ7XG4gICAgICAgIHZhciBmcmFjdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbiA+IDAgPyBlbGFwc2VkIC8gYW5pbWF0aW9uLmR1cmF0aW9uIDogMTtcbiAgICAgICAgaWYgKGZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICBhbmltYXRpb24uY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIGZyYWN0aW9uID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IGFuaW1hdGlvbi5lYXNpbmcoZnJhY3Rpb24pO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZUNlbnRlcikge1xuICAgICAgICAgIHZhciB4MCA9IGFuaW1hdGlvbi5zb3VyY2VDZW50ZXJbMF07XG4gICAgICAgICAgdmFyIHkwID0gYW5pbWF0aW9uLnNvdXJjZUNlbnRlclsxXTtcbiAgICAgICAgICB2YXIgeDEgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyWzBdO1xuICAgICAgICAgIHZhciB5MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMV07XG4gICAgICAgICAgdmFyIHggPSB4MCArIHByb2dyZXNzICogKHgxIC0geDApO1xuICAgICAgICAgIHZhciB5ID0geTAgKyBwcm9ncmVzcyAqICh5MSAtIHkwKTtcbiAgICAgICAgICB0aGlzJDEuc2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIsIFt4LCB5XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uICYmIGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBwcm9ncmVzcyA9PT0gMSA/XG4gICAgICAgICAgICBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiA6XG4gICAgICAgICAgICBhbmltYXRpb24uc291cmNlUmVzb2x1dGlvbiArIHByb2dyZXNzICogKGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24pO1xuICAgICAgICAgIGlmIChhbmltYXRpb24uYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzJDEuc2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIsXG4gICAgICAgICAgICAgIHRoaXMkMS5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuaW1hdGlvbi5hbmNob3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcyQxLnNldChWaWV3UHJvcGVydHkuUkVTT0xVVElPTiwgcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHJvdGF0aW9uID0gcHJvZ3Jlc3MgPT09IDEgP1xuICAgICAgICAgICAgbW9kdWxvKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiArIE1hdGguUEksIDIgKiBNYXRoLlBJKSAtIE1hdGguUEkgOlxuICAgICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICsgcHJvZ3Jlc3MgKiAoYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcyQxLnNldChWaWV3UHJvcGVydHkuQ0VOVEVSLFxuICAgICAgICAgICAgICB0aGlzJDEuY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBhbmltYXRpb24uYW5jaG9yKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMkMS5zZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpZXNDb21wbGV0ZSkge1xuICAgICAgICB0aGlzJDEuYW5pbWF0aW9uc19baV0gPSBudWxsO1xuICAgICAgICB0aGlzJDEuc2V0SGludChWaWV3SGludC5BTklNQVRJTkcsIC0xKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gc2VyaWVzWzBdLmNhbGxiYWNrO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJ1bmUgY29tcGxldGVkIHNlcmllc1xuICAgIHRoaXMuYW5pbWF0aW9uc18gPSB0aGlzLmFuaW1hdGlvbnNfLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAobW9yZSAmJiB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQW5pbWF0aW9uc18pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRhcmdldCByb3RhdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmNob3IgUm90YXRpb24gYW5jaG9yLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByb3RhdGlvbiBhbmQgYW5jaG9yLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY2FsY3VsYXRlQ2VudGVyUm90YXRlID0gZnVuY3Rpb24gY2FsY3VsYXRlQ2VudGVyUm90YXRlIChyb3RhdGlvbiwgYW5jaG9yKSB7XG4gICAgdmFyIGNlbnRlcjtcbiAgICB2YXIgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gLSBhbmNob3JbMF0sIGN1cnJlbnRDZW50ZXJbMV0gLSBhbmNob3JbMV1dO1xuICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHJvdGF0aW9uIC0gdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmNob3IgWm9vbSBhbmNob3IuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJlc29sdXRpb24gYW5kIGFuY2hvci5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNhbGN1bGF0ZUNlbnRlclpvb20gPSBmdW5jdGlvbiBjYWxjdWxhdGVDZW50ZXJab29tIChyZXNvbHV0aW9uLCBhbmNob3IpIHtcbiAgICB2YXIgY2VudGVyO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcbiAgICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAoY3VycmVudENlbnRlciAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB4ID0gYW5jaG9yWzBdIC0gcmVzb2x1dGlvbiAqIChhbmNob3JbMF0gLSBjdXJyZW50Q2VudGVyWzBdKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHkgPSBhbmNob3JbMV0gLSByZXNvbHV0aW9uICogKGFuY2hvclsxXSAtIGN1cnJlbnRDZW50ZXJbMV0pIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjZW50ZXIgPSBbeCwgeV07XG4gICAgfVxuICAgIHJldHVybiBjZW50ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFZpZXdwb3J0IHNpemUgb3IgYFsxMDAsIDEwMF1gIHdoZW4gbm8gdmlld3BvcnQgaXMgZm91bmQuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRTaXplRnJvbVZpZXdwb3J0XyA9IGZ1bmN0aW9uIGdldFNpemVGcm9tVmlld3BvcnRfICgpIHtcbiAgICB2YXIgc2l6ZSA9IFsxMDAsIDEwMF07XG4gICAgdmFyIHNlbGVjdG9yID0gJy5vbC12aWV3cG9ydFtkYXRhLXZpZXc9XCInICsgZ2V0VWlkKHRoaXMpICsgJ1wiXSc7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG1ldHJpY3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgc2l6ZVswXSA9IHBhcnNlSW50KG1ldHJpY3Mud2lkdGgsIDEwKTtcbiAgICAgIHNpemVbMV0gPSBwYXJzZUludChtZXRyaWNzLmhlaWdodCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb25zdHJhaW5lZCBjZW50ZXIgb2YgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ29uc3RyYWluZWQgY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jb25zdHJhaW5DZW50ZXIgPSBmdW5jdGlvbiBjb25zdHJhaW5DZW50ZXIgKGNlbnRlcikge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5jZW50ZXIoY2VudGVyKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjb25zdHJhaW5lZCByZXNvbHV0aW9uIG9mIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RlbHRhIERlbHRhLiBEZWZhdWx0IGlzIGAwYC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIERpcmVjdGlvbi4gRGVmYXVsdCBpcyBgMGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IENvbnN0cmFpbmVkIHJlc29sdXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNvbnN0cmFpblJlc29sdXRpb24gPSBmdW5jdGlvbiBjb25zdHJhaW5SZXNvbHV0aW9uIChyZXNvbHV0aW9uLCBvcHRfZGVsdGEsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICB2YXIgZGVsdGEgPSBvcHRfZGVsdGEgfHwgMDtcbiAgICB2YXIgZGlyZWN0aW9uID0gb3B0X2RpcmVjdGlvbiB8fCAwO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5yZXNvbHV0aW9uKHJlc29sdXRpb24sIGRlbHRhLCBkaXJlY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIHJvdGF0aW9uIG9mIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGVsdGEgRGVsdGEuIERlZmF1bHQgaXMgYDBgLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBDb25zdHJhaW5lZCByb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuY29uc3RyYWluUm90YXRpb24gPSBmdW5jdGlvbiBjb25zdHJhaW5Sb3RhdGlvbiAocm90YXRpb24sIG9wdF9kZWx0YSkge1xuICAgIHZhciBkZWx0YSA9IG9wdF9kZWx0YSB8fCAwO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5yb3RhdGlvbihyb3RhdGlvbiwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgY2VudGVyLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gZ2V0Q2VudGVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5DRU5URVIpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9WaWV3fkNvbnN0cmFpbnRzfSBDb25zdHJhaW50cy5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldENvbnN0cmFpbnRzID0gZnVuY3Rpb24gZ2V0Q29uc3RyYWludHMgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9oaW50cyBEZXN0aW5hdGlvbiBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEhpbnQuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRIaW50cyA9IGZ1bmN0aW9uIGdldEhpbnRzIChvcHRfaGludHMpIHtcbiAgICBpZiAob3B0X2hpbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdF9oaW50c1swXSA9IHRoaXMuaGludHNfWzBdO1xuICAgICAgb3B0X2hpbnRzWzFdID0gdGhpcy5oaW50c19bMV07XG4gICAgICByZXR1cm4gb3B0X2hpbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oaW50c18uc2xpY2UoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXh0ZW50IGZvciB0aGUgY3VycmVudCB2aWV3IHN0YXRlIGFuZCB0aGUgcGFzc2VkIHNpemUuXG4gICAqIFRoZSBzaXplIGlzIHRoZSBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggaW50byB3aGljaCB0aGUgY2FsY3VsYXRlZCBleHRlbnRcbiAgICogc2hvdWxkIGZpdC4gSW4gbW9zdCBjYXNlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGV4dGVudCBvZiB0aGUgZW50aXJlIG1hcCxcbiAgICogdGhhdCBpcyBgbWFwLmdldFNpemUoKWAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF9zaXplIEJveCBwaXhlbCBzaXplLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBzaXplIG9mIHRoZVxuICAgKiBmaXJzdCBtYXAgdGhhdCB1c2VzIHRoaXMgdmlldyB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmNhbGN1bGF0ZUV4dGVudCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUV4dGVudCAob3B0X3NpemUpIHtcbiAgICB2YXIgc2l6ZSA9IG9wdF9zaXplIHx8IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHshbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gKi8gKHRoaXMuZ2V0Q2VudGVyKCkpO1xuICAgIGFzc2VydChjZW50ZXIsIDEpOyAvLyBUaGUgdmlldyBjZW50ZXIgaXMgbm90IGRlZmluZWRcbiAgICB2YXIgcmVzb2x1dGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICBhc3NlcnQocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkLCAyKTsgLy8gVGhlIHZpZXcgcmVzb2x1dGlvbiBpcyBub3QgZGVmaW5lZFxuICAgIHZhciByb3RhdGlvbiA9IC8qKiBAdHlwZSB7IW51bWJlcn0gKi8gKHRoaXMuZ2V0Um90YXRpb24oKSk7XG4gICAgYXNzZXJ0KHJvdGF0aW9uICE9PSB1bmRlZmluZWQsIDMpOyAvLyBUaGUgdmlldyByb3RhdGlvbiBpcyBub3QgZGVmaW5lZFxuXG4gICAgcmV0dXJuIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRNYXhSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0TWF4UmVzb2x1dGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4UmVzb2x1dGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldE1pblJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRNaW5SZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldE1heFpvb20gPSBmdW5jdGlvbiBnZXRNYXhab29tICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHRoaXMubWluUmVzb2x1dGlvbl8pKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IGEgbmV3IG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldE1heFpvb20gPSBmdW5jdGlvbiBzZXRNYXhab29tICh6b29tKSB7XG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKHRoaXMuZ2V0VXBkYXRlZE9wdGlvbnNfKHttYXhab29tOiB6b29tfSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0TWluWm9vbSA9IGZ1bmN0aW9uIGdldE1pblpvb20gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24odGhpcy5tYXhSZXNvbHV0aW9uXykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0TWluWm9vbSA9IGZ1bmN0aW9uIHNldE1pblpvb20gKHpvb20pIHtcbiAgICB0aGlzLmFwcGx5T3B0aW9uc18odGhpcy5nZXRVcGRhdGVkT3B0aW9uc18oe21pblpvb206IHpvb219KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBUaGUgcHJvamVjdGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbiA9IGZ1bmN0aW9uIGdldFByb2plY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3Rpb25fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04pKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9ucyBmb3IgdGhlIHZpZXcuIFRoaXMgcmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzb2x1dGlvbnNcbiAgICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgVmlldywgb3IgdW5kZWZpbmVkIGlmIG5vbmUgd2VyZSBnaXZlbi5cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfSBUaGUgcmVzb2x1dGlvbnMgb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9uIGZvciBhIHByb3ZpZGVkIGV4dGVudCAoaW4gbWFwIHVuaXRzKSBhbmQgc2l6ZSAoaW4gcGl4ZWxzKS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3NpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25Gb3JFeHRlbnQgPSBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uRm9yRXh0ZW50IChleHRlbnQsIG9wdF9zaXplKSB7XG4gICAgdmFyIHNpemUgPSBvcHRfc2l6ZSB8fCB0aGlzLmdldFNpemVGcm9tVmlld3BvcnRfKCk7XG4gICAgdmFyIHhSZXNvbHV0aW9uID0gZ2V0V2lkdGgoZXh0ZW50KSAvIHNpemVbMF07XG4gICAgdmFyIHlSZXNvbHV0aW9uID0gZ2V0SGVpZ2h0KGV4dGVudCkgLyBzaXplWzFdO1xuICAgIHJldHVybiBNYXRoLm1heCh4UmVzb2x1dGlvbiwgeVJlc29sdXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9wb3dlciBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbkZvclZhbHVlRnVuY3Rpb24gKG9wdF9wb3dlcikge1xuICAgIHZhciBwb3dlciA9IG9wdF9wb3dlciB8fCAyO1xuICAgIHZhciBtYXhSZXNvbHV0aW9uID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICB2YXIgbWluUmVzb2x1dGlvbiA9IHRoaXMubWluUmVzb2x1dGlvbl87XG4gICAgdmFyIG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHBvd2VyLCB2YWx1ZSAqIG1heCk7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uO1xuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHJlc29sdXRpb24gZm9yIGEgdmFsdWUgYmV0d2VlblxuICAgKiAwIGFuZCAxLiBFeHBvbmVudGlhbCBzY2FsaW5nIGlzIGFzc3VtZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3Bvd2VyIFBvd2VyLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbihudW1iZXIpOiBudW1iZXJ9IFZhbHVlIGZvciByZXNvbHV0aW9uIGZ1bmN0aW9uLlxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0VmFsdWVGb3JSZXNvbHV0aW9uRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbiAob3B0X3Bvd2VyKSB7XG4gICAgdmFyIHBvd2VyID0gb3B0X3Bvd2VyIHx8IDI7XG4gICAgdmFyIG1heFJlc29sdXRpb24gPSB0aGlzLm1heFJlc29sdXRpb25fO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uID0gdGhpcy5taW5SZXNvbHV0aW9uXztcbiAgICB2YXIgbWF4ID0gTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2cocG93ZXIpO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFZhbHVlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IChNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcikpIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOm9sL1ZpZXd+U3RhdGV9IFZpZXcgc3RhdGUuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlICgpIHtcbiAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSAqLyAodGhpcy5nZXRDZW50ZXIoKSk7XG4gICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXRSZXNvbHV0aW9uKCkpO1xuICAgIHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvVmlld35TdGF0ZX0gKi8gKHtcbiAgICAgICAgY2VudGVyOiBjZW50ZXIuc2xpY2UoKSxcbiAgICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gcHJvamVjdGlvbiA6IG51bGwsXG4gICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgICAgem9vbTogdGhpcy5nZXRab29tKClcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuICBJZiB5b3UgY29uZmlndXJlZCB5b3VyIHZpZXcgd2l0aCBhIHJlc29sdXRpb25zXG4gICAqIGFycmF5ICh0aGlzIGlzIHJhcmUpLCB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIG5vbi1pbnRlZ2VyIHpvb20gbGV2ZWxzIChzb1xuICAgKiB0aGUgem9vbSBsZXZlbCBpcyBub3Qgc2FmZSB0byB1c2UgYXMgYW4gaW5kZXggaW50byBhIHJlc29sdXRpb25zIGFycmF5KS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gWm9vbS5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Wm9vbSA9IGZ1bmN0aW9uIGdldFpvb20gKCkge1xuICAgIHZhciB6b29tO1xuICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgem9vbSA9IHRoaXMuZ2V0Wm9vbUZvclJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB6b29tO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHpvb20gbGV2ZWwgZm9yIGEgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSB6b29tIGxldmVsIGZvciB0aGUgcHJvdmlkZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuZ2V0Wm9vbUZvclJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRab29tRm9yUmVzb2x1dGlvbiAocmVzb2x1dGlvbikge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm1pblpvb21fIHx8IDA7XG4gICAgdmFyIG1heCwgem9vbUZhY3RvcjtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18pIHtcbiAgICAgIHZhciBuZWFyZXN0ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIDEpO1xuICAgICAgb2Zmc2V0ID0gbmVhcmVzdDtcbiAgICAgIG1heCA9IHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3RdO1xuICAgICAgaWYgKG5lYXJlc3QgPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMSkge1xuICAgICAgICB6b29tRmFjdG9yID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSBtYXggLyB0aGlzLnJlc29sdXRpb25zX1tuZWFyZXN0ICsgMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heCA9IHRoaXMubWF4UmVzb2x1dGlvbl87XG4gICAgICB6b29tRmFjdG9yID0gdGhpcy56b29tRmFjdG9yXztcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCArIE1hdGgubG9nKG1heCAvIHJlc29sdXRpb24pIC8gTWF0aC5sb2coem9vbUZhY3Rvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2aWV3IHJlc29sdXRpb24gZm9yIHRoZSBwcm92aWRlZCB6b29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5nZXRSZXNvbHV0aW9uRm9yWm9vbSA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25Gb3Jab29tICh6b29tKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgdGhpcy5tYXhSZXNvbHV0aW9uXywgem9vbSAtIHRoaXMubWluWm9vbV8sIDApKTtcbiAgfTtcblxuICAvKipcbiAgICogRml0IHRoZSBnaXZlbiBnZW9tZXRyeSBvciBleHRlbnQgYmFzZWQgb24gdGhlIGdpdmVuIG1hcCBzaXplIGFuZCBib3JkZXIuXG4gICAqIFRoZSBzaXplIGlzIHBpeGVsIGRpbWVuc2lvbnMgb2YgdGhlIGJveCB0byBmaXQgdGhlIGV4dGVudCBpbnRvLlxuICAgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIHdhbnQgdG8gdXNlIHRoZSBtYXAgc2l6ZSwgdGhhdCBpcyBgbWFwLmdldFNpemUoKWAuXG4gICAqIFRha2VzIGNhcmUgb2YgdGhlIG1hcCBhbmdsZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeXxtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZ2VvbWV0cnlPckV4dGVudCBUaGUgZ2VvbWV0cnkgb3JcbiAgICogICAgIGV4dGVudCB0byBmaXQgdGhlIHZpZXcgdG8uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1ZpZXd+Rml0T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uIGZpdCAoZ2VvbWV0cnlPckV4dGVudCwgb3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBzaXplID0gb3B0aW9ucy5zaXplO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi9cbiAgICB2YXIgZ2VvbWV0cnk7XG4gICAgaWYgKCEoZ2VvbWV0cnlPckV4dGVudCBpbnN0YW5jZW9mIFNpbXBsZUdlb21ldHJ5KSkge1xuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCksXG4gICAgICAgIDI0KTsgLy8gSW52YWxpZCBleHRlbnQgb3IgZ2VvbWV0cnkgcHJvdmlkZWQgYXMgYGdlb21ldHJ5YFxuICAgICAgYXNzZXJ0KCFpc0VtcHR5KGdlb21ldHJ5T3JFeHRlbnQpLFxuICAgICAgICAyNSk7IC8vIENhbm5vdCBmaXQgZW1wdHkgZXh0ZW50IHByb3ZpZGVkIGFzIGBnZW9tZXRyeWBcbiAgICAgIGdlb21ldHJ5ID0gcG9seWdvbkZyb21FeHRlbnQoZ2VvbWV0cnlPckV4dGVudCk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeU9yRXh0ZW50LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgICAgZ2VvbWV0cnlPckV4dGVudCA9IGdlb21ldHJ5T3JFeHRlbnQuZ2V0RXh0ZW50KCk7XG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGdlb21ldHJ5T3JFeHRlbnQpO1xuICAgICAgZ2VvbWV0cnkucm90YXRlKHRoaXMuZ2V0Um90YXRpb24oKSwgZ2V0Q2VudGVyKGdlb21ldHJ5T3JFeHRlbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyeU9yRXh0ZW50O1xuICAgIH1cblxuICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBhZGRpbmcgOiBbMCwgMCwgMCwgMF07XG4gICAgdmFyIGNvbnN0cmFpblJlc29sdXRpb24gPSBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gOiB0cnVlO1xuICAgIHZhciBuZWFyZXN0ID0gb3B0aW9ucy5uZWFyZXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5lYXJlc3QgOiBmYWxzZTtcbiAgICB2YXIgbWluUmVzb2x1dGlvbjtcbiAgICBpZiAob3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluUmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgICAgdGhpcy5tYXhSZXNvbHV0aW9uXywgb3B0aW9ucy5tYXhab29tIC0gdGhpcy5taW5ab29tXywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSAwO1xuICAgIH1cbiAgICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcm90YXRlZCBleHRlbnRcbiAgICB2YXIgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgdmFyIGNvc0FuZ2xlID0gTWF0aC5jb3MoLXJvdGF0aW9uKTtcbiAgICB2YXIgc2luQW5nbGUgPSBNYXRoLnNpbigtcm90YXRpb24pO1xuICAgIHZhciBtaW5Sb3RYID0gK0luZmluaXR5O1xuICAgIHZhciBtaW5Sb3RZID0gK0luZmluaXR5O1xuICAgIHZhciBtYXhSb3RYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhSb3RZID0gLUluZmluaXR5O1xuICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgcm90WCA9IGNvb3Jkc1tpXSAqIGNvc0FuZ2xlIC0gY29vcmRzW2kgKyAxXSAqIHNpbkFuZ2xlO1xuICAgICAgdmFyIHJvdFkgPSBjb29yZHNbaV0gKiBzaW5BbmdsZSArIGNvb3Jkc1tpICsgMV0gKiBjb3NBbmdsZTtcbiAgICAgIG1pblJvdFggPSBNYXRoLm1pbihtaW5Sb3RYLCByb3RYKTtcbiAgICAgIG1pblJvdFkgPSBNYXRoLm1pbihtaW5Sb3RZLCByb3RZKTtcbiAgICAgIG1heFJvdFggPSBNYXRoLm1heChtYXhSb3RYLCByb3RYKTtcbiAgICAgIG1heFJvdFkgPSBNYXRoLm1heChtYXhSb3RZLCByb3RZKTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzb2x1dGlvblxuICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uRm9yRXh0ZW50KFxuICAgICAgW21pblJvdFgsIG1pblJvdFksIG1heFJvdFgsIG1heFJvdFldLFxuICAgICAgW3NpemVbMF0gLSBwYWRkaW5nWzFdIC0gcGFkZGluZ1szXSwgc2l6ZVsxXSAtIHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdXSk7XG4gICAgcmVzb2x1dGlvbiA9IGlzTmFOKHJlc29sdXRpb24pID8gbWluUmVzb2x1dGlvbiA6XG4gICAgICBNYXRoLm1heChyZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uKTtcbiAgICBpZiAoY29uc3RyYWluUmVzb2x1dGlvbikge1xuICAgICAgdmFyIGNvbnN0cmFpbmVkUmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCAwLCAwKTtcbiAgICAgIGlmICghbmVhcmVzdCAmJiBjb25zdHJhaW5lZFJlc29sdXRpb24gPCByZXNvbHV0aW9uKSB7XG4gICAgICAgIGNvbnN0cmFpbmVkUmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgICAgICBjb25zdHJhaW5lZFJlc29sdXRpb24sIC0xLCAwKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdXRpb24gPSBjb25zdHJhaW5lZFJlc29sdXRpb247XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIGNlbnRlclxuICAgIHNpbkFuZ2xlID0gLXNpbkFuZ2xlOyAvLyBnbyBiYWNrIHRvIG9yaWdpbmFsIHJvdGF0aW9uXG4gICAgdmFyIGNlbnRlclJvdFggPSAobWluUm90WCArIG1heFJvdFgpIC8gMjtcbiAgICB2YXIgY2VudGVyUm90WSA9IChtaW5Sb3RZICsgbWF4Um90WSkgLyAyO1xuICAgIGNlbnRlclJvdFggKz0gKHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdKSAvIDIgKiByZXNvbHV0aW9uO1xuICAgIGNlbnRlclJvdFkgKz0gKHBhZGRpbmdbMF0gLSBwYWRkaW5nWzJdKSAvIDIgKiByZXNvbHV0aW9uO1xuICAgIHZhciBjZW50ZXJYID0gY2VudGVyUm90WCAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WSAqIHNpbkFuZ2xlO1xuICAgIHZhciBjZW50ZXJZID0gY2VudGVyUm90WSAqIGNvc0FuZ2xlICsgY2VudGVyUm90WCAqIHNpbkFuZ2xlO1xuICAgIHZhciBjZW50ZXIgPSBbY2VudGVyWCwgY2VudGVyWV07XG4gICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBVTkRFRklORUQ7XG5cbiAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmdcbiAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgICAgdGhpcy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh1bmRlZmluZWQsIHRydWUpLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENlbnRlciBvbiBjb29yZGluYXRlIGFuZCB2aWV3IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBzaXplIEJveCBwaXhlbCBzaXplLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcG9zaXRpb24gUG9zaXRpb24gb24gdGhlIHZpZXcgdG8gY2VudGVyIG9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5jZW50ZXJPbiA9IGZ1bmN0aW9uIGNlbnRlck9uIChjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbikge1xuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGVkIHBvc2l0aW9uXG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICB2YXIgcm90WCA9IGNvb3JkaW5hdGVbMF0gKiBjb3NBbmdsZSAtIGNvb3JkaW5hdGVbMV0gKiBzaW5BbmdsZTtcbiAgICB2YXIgcm90WSA9IGNvb3JkaW5hdGVbMV0gKiBjb3NBbmdsZSArIGNvb3JkaW5hdGVbMF0gKiBzaW5BbmdsZTtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHJvdFggKz0gKHNpemVbMF0gLyAyIC0gcG9zaXRpb25bMF0pICogcmVzb2x1dGlvbjtcbiAgICByb3RZICs9IChwb3NpdGlvblsxXSAtIHNpemVbMV0gLyAyKSAqIHJlc29sdXRpb247XG5cbiAgICAvLyBnbyBiYWNrIHRvIG9yaWdpbmFsIGFuZ2xlXG4gICAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgICB2YXIgY2VudGVyWCA9IHJvdFggKiBjb3NBbmdsZSAtIHJvdFkgKiBzaW5BbmdsZTtcbiAgICB2YXIgY2VudGVyWSA9IHJvdFkgKiBjb3NBbmdsZSArIHJvdFggKiBzaW5BbmdsZTtcblxuICAgIHRoaXMuc2V0Q2VudGVyKFtjZW50ZXJYLCBjZW50ZXJZXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGRlZmluZWQuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5pc0RlZiA9IGZ1bmN0aW9uIGlzRGVmICgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldENlbnRlcigpICYmIHRoaXMuZ2V0UmVzb2x1dGlvbigpICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgdmlldyBhcm91bmQgYSBnaXZlbiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gTmV3IHJvdGF0aW9uIHZhbHVlIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUgKHJvdGF0aW9uLCBvcHRfYW5jaG9yKSB7XG4gICAgaWYgKG9wdF9hbmNob3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2FsY3VsYXRlQ2VudGVyUm90YXRlKHJvdGF0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfVxuICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgVGhlIGNlbnRlciBvZiB0aGUgdmlldy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgVmlldy5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gc2V0Q2VudGVyIChjZW50ZXIpIHtcbiAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuQ0VOVEVSLCBjZW50ZXIpO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1ZpZXdIaW50fSBoaW50IEhpbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBOZXcgdmFsdWUuXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRIaW50ID0gZnVuY3Rpb24gc2V0SGludCAoaGludCwgZGVsdGEpIHtcbiAgICB0aGlzLmhpbnRzX1toaW50XSArPSBkZWx0YTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICByZXR1cm4gdGhpcy5oaW50c19baGludF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIFZpZXcucHJvdG90eXBlLnNldFJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRSZXNvbHV0aW9uIChyZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIHJlc29sdXRpb24pO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcm90YXRpb24gZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRoZSByb3RhdGlvbiBvZiB0aGUgdmlldyBpbiByYWRpYW5zLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICAgIHRoaXMuc2V0KFZpZXdQcm9wZXJ0eS5ST1RBVElPTiwgcm90YXRpb24pO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFpvb20gdG8gYSBzcGVjaWZpYyB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBWaWV3LnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24gc2V0Wm9vbSAoem9vbSkge1xuICAgIHRoaXMuc2V0UmVzb2x1dGlvbih0aGlzLmdldFJlc29sdXRpb25Gb3Jab29tKHpvb20pKTtcbiAgfTtcblxuICByZXR1cm4gVmlldztcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVmlld35WaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY2VudGVyY29uc3RyYWludH5UeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVFeHRlbnQob3B0aW9ucy5leHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZW50ZXJOb25lO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3flZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3tjb25zdHJhaW50OiBtb2R1bGU6b2wvcmVzb2x1dGlvbmNvbnN0cmFpbnR+VHlwZSwgbWF4UmVzb2x1dGlvbjogbnVtYmVyLFxuICogICAgIG1pblJlc29sdXRpb246IG51bWJlciwgbWluWm9vbTogbnVtYmVyLCB6b29tRmFjdG9yOiBudW1iZXJ9fSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgdmFyIHJlc29sdXRpb25Db25zdHJhaW50O1xuICB2YXIgbWF4UmVzb2x1dGlvbjtcbiAgdmFyIG1pblJlc29sdXRpb247XG5cbiAgLy8gVE9ETzogbW92ZSB0aGVzZSB0byBiZSBvbCBjb25zdGFudHNcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvaXNzdWVzLzIwNzZcbiAgdmFyIGRlZmF1bHRNYXhab29tID0gMjg7XG4gIHZhciBkZWZhdWx0Wm9vbUZhY3RvciA9IDI7XG5cbiAgdmFyIG1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5taW5ab29tIDogREVGQVVMVF9NSU5fWk9PTTtcblxuICB2YXIgbWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLm1heFpvb20gOiBkZWZhdWx0TWF4Wm9vbTtcblxuICB2YXIgem9vbUZhY3RvciA9IG9wdGlvbnMuem9vbUZhY3RvciAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLnpvb21GYWN0b3IgOiBkZWZhdWx0Wm9vbUZhY3RvcjtcblxuICBpZiAob3B0aW9ucy5yZXNvbHV0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlc29sdXRpb25zID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbbWluWm9vbV07XG4gICAgbWluUmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW21heFpvb21dICE9PSB1bmRlZmluZWQgP1xuICAgICAgcmVzb2x1dGlvbnNbbWF4Wm9vbV0gOiByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKFxuICAgICAgcmVzb2x1dGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVmYXVsdCBtaW4gYW5kIG1heCByZXNvbHV0aW9uXG4gICAgdmFyIHByb2plY3Rpb24gPSBjcmVhdGVQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbiwgJ0VQU0c6Mzg1NycpO1xuICAgIHZhciBleHRlbnQgPSBwcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuICAgIHZhciBzaXplID0gIWV4dGVudCA/XG4gICAgICAvLyB1c2UgYW4gZXh0ZW50IHRoYXQgY2FuIGZpdCB0aGUgd2hvbGUgd29ybGQgaWYgbmVlZCBiZVxuICAgICAgMzYwICogTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdIC9cbiAgICAgICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpIDpcbiAgICAgIE1hdGgubWF4KGdldFdpZHRoKGV4dGVudCksIGdldEhlaWdodChleHRlbnQpKTtcblxuICAgIHZhciBkZWZhdWx0TWF4UmVzb2x1dGlvbiA9IHNpemUgLyBERUZBVUxUX1RJTEVfU0laRSAvIE1hdGgucG93KFxuICAgICAgZGVmYXVsdFpvb21GYWN0b3IsIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgdmFyIGRlZmF1bHRNaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhcbiAgICAgIGRlZmF1bHRab29tRmFjdG9yLCBkZWZhdWx0TWF4Wm9vbSAtIERFRkFVTFRfTUlOX1pPT00pO1xuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtYXhSZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtYXhSZXNvbHV0aW9uID0gb3B0aW9ucy5tYXhSZXNvbHV0aW9uO1xuICAgIGlmIChtYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblpvb20gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhSZXNvbHV0aW9uID0gZGVmYXVsdE1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtaW5ab29tKTtcbiAgICB9XG5cbiAgICAvLyB1c2VyIHByb3ZpZGVkIG1pblJlc29sdXRpb24gdGFrZXMgcHJlY2VkZW5jZVxuICAgIG1pblJlc29sdXRpb24gPSBvcHRpb25zLm1pblJlc29sdXRpb247XG4gICAgaWYgKG1pblJlc29sdXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1heFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWluUmVzb2x1dGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBnaXZlbiBkaXNjcmV0ZSB6b29tIGxldmVscywgbWluUmVzb2x1dGlvbiBtYXkgYmUgZGlmZmVyZW50IHRoYW4gcHJvdmlkZWRcbiAgICBtYXhab29tID0gbWluWm9vbSArIE1hdGguZmxvb3IoXG4gICAgICBNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gbWluUmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKSk7XG4gICAgbWluUmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyh6b29tRmFjdG9yLCBtYXhab29tIC0gbWluWm9vbSk7XG5cbiAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Bvd2VyKFxuICAgICAgem9vbUZhY3RvciwgbWF4UmVzb2x1dGlvbiwgbWF4Wm9vbSAtIG1pblpvb20pO1xuICB9XG4gIHJldHVybiB7Y29uc3RyYWludDogcmVzb2x1dGlvbkNvbnN0cmFpbnQsIG1heFJlc29sdXRpb246IG1heFJlc29sdXRpb24sXG4gICAgbWluUmVzb2x1dGlvbjogbWluUmVzb2x1dGlvbiwgbWluWm9vbTogbWluWm9vbSwgem9vbUZhY3Rvcjogem9vbUZhY3Rvcn07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3flZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9yb3RhdGlvbmNvbnN0cmFpbnR+VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdGF0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIHZhciBlbmFibGVSb3RhdGlvbiA9IG9wdGlvbnMuZW5hYmxlUm90YXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5lbmFibGVSb3RhdGlvbiA6IHRydWU7XG4gIGlmIChlbmFibGVSb3RhdGlvbikge1xuICAgIHZhciBjb25zdHJhaW5Sb3RhdGlvbiA9IG9wdGlvbnMuY29uc3RyYWluUm90YXRpb247XG4gICAgaWYgKGNvbnN0cmFpblJvdGF0aW9uID09PSB1bmRlZmluZWQgfHwgY29uc3RyYWluUm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTbmFwVG9aZXJvKCk7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW5Sb3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByb3RhdGlvbk5vbmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWluUm90YXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU25hcFRvTihjb25zdHJhaW5Sb3RhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGlvbk5vbmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaXNhYmxlO1xuICB9XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVmlld35BbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGFuaW1hdGlvbiBpbnZvbHZlcyBubyB2aWV3IGNoYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9vcEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIgJiYgYW5pbWF0aW9uLnRhcmdldENlbnRlcikge1xuICAgIGlmICghY29vcmRpbmF0ZXNFcXVhbChhbmltYXRpb24uc291cmNlQ2VudGVyLCBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlldztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvVmlld0hpbnRcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQU5JTUFUSU5HOiAwLFxuICBJTlRFUkFDVElORzogMVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlld0hpbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBDRU5URVI6ICdjZW50ZXInLFxuICBSRVNPTFVUSU9OOiAncmVzb2x1dGlvbicsXG4gIFJPVEFUSU9OOiAncm90YXRpb24nXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3UHJvcGVydHkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2FycmF5XG4gKi9cblxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcHJvdmlkZWQgc29ydGVkIGxpc3QgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLiBJZiBpdCBjYW4ndCBiZSBmb3VuZCBpdCdsbCByZXR1cm4gLTEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9iaW5hcnktc2VhcmNoXG4gKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGhheXN0YWNrIEl0ZW1zIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIHsqfSBuZWVkbGUgVGhlIGl0ZW0gdG8gbG9vayBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X2NvbXBhcmF0b3IgQ29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLCAtMSBpZiBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgb3B0X2NvbXBhcmF0b3IpIHtcbiAgdmFyIG1pZCwgY21wO1xuICB2YXIgY29tcGFyYXRvciA9IG9wdF9jb21wYXJhdG9yIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIHZhciBsb3cgPSAwO1xuICB2YXIgaGlnaCA9IGhheXN0YWNrLmxlbmd0aDtcbiAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAvKiBOb3RlIHRoYXQgXCIobG93ICsgaGlnaCkgPj4+IDFcIiBtYXkgb3ZlcmZsb3csIGFuZCByZXN1bHRzIGluIGEgdHlwZWNhc3RcbiAgICAgKiB0byBkb3VibGUgKHdoaWNoIGdpdmVzIHRoZSB3cm9uZyByZXN1bHRzKS4gKi9cbiAgICBtaWQgPSBsb3cgKyAoaGlnaCAtIGxvdyA+PiAxKTtcbiAgICBjbXAgPSArY29tcGFyYXRvcihoYXlzdGFja1ttaWRdLCBuZWVkbGUpO1xuXG4gICAgaWYgKGNtcCA8IDAuMCkgeyAvKiBUb28gbG93LiAqL1xuICAgICAgbG93ID0gbWlkICsgMTtcblxuICAgIH0gZWxzZSB7IC8qIEtleSBmb3VuZCBvciB0b28gaGlnaCAqL1xuICAgICAgaGlnaCA9IG1pZDtcbiAgICAgIGZvdW5kID0gIWNtcDtcbiAgICB9XG4gIH1cblxuICAvKiBLZXkgbm90IGZvdW5kLiAqL1xuICByZXR1cm4gZm91bmQgPyBsb3cgOiB+bG93O1xufVxuXG5cbi8qKlxuICogQ29tcGFyZSBmdW5jdGlvbiBmb3IgYXJyYXkgc29ydCB0aGF0IGlzIHNhZmUgZm9yIG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEBwYXJhbSB7Kn0gYiBUaGUgc2Vjb25kIG9iamVjdCB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge251bWJlcn0gQSBuZWdhdGl2ZSBudW1iZXIsIHplcm8sIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGFzIHRoZSBmaXJzdFxuICogICAgIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cblxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGNvbnRhaW5zIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IGZvciB3aGljaCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIG9iaikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yob2JqKSA+PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyIEFycmF5LlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIDAgbWVhbnMgcmV0dXJuIHRoZSBuZWFyZXN0LCA+IDBcbiAqICAgIG1lYW5zIHJldHVybiB0aGUgbGFyZ2VzdCBuZWFyZXN0LCA8IDAgbWVhbnMgcmV0dXJuIHRoZVxuICogICAgc21hbGxlc3QgbmVhcmVzdC5cbiAqIEByZXR1cm4ge251bWJlcn0gSW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJGaW5kTmVhcmVzdChhcnIsIHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgaWYgKGFyclswXSA8PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICh0YXJnZXQgPD0gYXJyW24gLSAxXSkge1xuICAgIHJldHVybiBuIC0gMTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPD0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldID09IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgICAgIGlmIChhcnJbaSAtIDFdIC0gdGFyZ2V0IDwgdGFyZ2V0IC0gYXJyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbiAtIDE7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdWJBcnJheShhcnIsIGJlZ2luLCBlbmQpIHtcbiAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgdmFyIHRtcCA9IGFycltiZWdpbl07XG4gICAgYXJyW2JlZ2luXSA9IGFycltlbmRdO1xuICAgIGFycltlbmRdID0gdG1wO1xuICAgICsrYmVnaW47XG4gICAgLS1lbmQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPFZBTFVFPn0gYXJyIFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyFBcnJheS48VkFMVUU+fFZBTFVFfSBkYXRhIFRoZSBlbGVtZW50cyBvciBhcnJheXMgb2YgZWxlbWVudHMgdG8gYWRkIHRvIGFyci5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGFyciwgZGF0YSkge1xuICB2YXIgZXh0ZW5zaW9uID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XG4gIHZhciBsZW5ndGggPSBleHRlbnNpb24ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2Fyci5sZW5ndGhdID0gZXh0ZW5zaW9uW2ldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgdmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuICB2YXIgZm91bmQgPSBpID4gLTE7XG4gIGlmIChmb3VuZCkge1xuICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVkFMVUUsIG51bWJlciwgPykgOiBib29sZWFufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb21wYXJlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtWQUxVRXxudWxsfSBUaGUgZWxlbWVudCBmb3VuZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIGZ1bmMpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGggPj4+IDA7XG4gIHZhciB2YWx1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJbaV07XG4gICAgaWYgKGZ1bmModmFsdWUsIGksIGFycikpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIxIFRoZSBmaXJzdCBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheXxVaW50OENsYW1wZWRBcnJheX0gYXJyMiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0d28gYXJyYXlzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhcnIxLCBhcnIyKSB7XG4gIHZhciBsZW4xID0gYXJyMS5sZW5ndGg7XG4gIGlmIChsZW4xICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBUaGUgYXJyYXkgdG8gc29ydCAobW9kaWZpZXMgb3JpZ2luYWwpLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZUZuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIGNvbXBhcmVGbmMpIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIHZhciB0bXAgPSBBcnJheShhcnIubGVuZ3RoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHRtcFtpXSA9IHtpbmRleDogaSwgdmFsdWU6IGFycltpXX07XG4gIH1cbiAgdG1wLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlRm5jKGEudmFsdWUsIGIudmFsdWUpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KTtcbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXSA9IHRtcFtpXS52YWx1ZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBmdW5jKSB7XG4gIHZhciBpbmRleDtcbiAgdmFyIGZvdW5kID0gIWFyci5ldmVyeShmdW5jdGlvbihlbCwgaWR4KSB7XG4gICAgaW5kZXggPSBpZHg7XG4gICAgcmV0dXJuICFmdW5jKGVsLCBpZHgsIGFycik7XG4gIH0pO1xuICByZXR1cm4gZm91bmQgPyBpbmRleCA6IC0xO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFyciBUaGUgYXJyYXkgdG8gdGVzdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfZnVuYyBDb21wYXJpc29uIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3N0cmljdCBTdHJpY3RseSBzb3J0ZWQgKGRlZmF1bHQgZmFsc2UpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTb3J0ZWQoYXJyLCBvcHRfZnVuYywgb3B0X3N0cmljdCkge1xuICB2YXIgY29tcGFyZSA9IG9wdF9mdW5jIHx8IG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb247XG4gIHJldHVybiBhcnIuZXZlcnkoZnVuY3Rpb24oY3VycmVudFZhbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcmVzID0gY29tcGFyZShhcnJbaW5kZXggLSAxXSwgY3VycmVudFZhbCk7XG4gICAgcmV0dXJuICEocmVzID4gMCB8fCBvcHRfc3RyaWN0ICYmIHJlcyA9PT0gMCk7XG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGUgRXJyb3IgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvckNvZGUpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydHMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NlbnRlcmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXx1bmRlZmluZWQpKTogKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2NlbnRlcmNvbnN0cmFpbnR+VHlwZX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQoZXh0ZW50KSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPX0gY2VudGVyIENlbnRlci5cbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGNsYW1wKGNlbnRlclswXSwgZXh0ZW50WzBdLCBleHRlbnRbMl0pLFxuICAgICAgICAgIGNsYW1wKGNlbnRlclsxXSwgZXh0ZW50WzFdLCBleHRlbnRbM10pXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT19IGNlbnRlciBDZW50ZXIuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShjZW50ZXIpIHtcbiAgcmV0dXJuIGNlbnRlcjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2VudGVyY29uc3RyYWludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29sb3JcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuXG5cbi8qKlxuICogQSBjb2xvciByZXByZXNlbnRlZCBhcyBhIHNob3J0IGFycmF5IFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0uXG4gKiByZWQsIGdyZWVuLCBhbmQgYmx1ZSBzaG91bGQgYmUgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIDAuLjI1NSBpbmNsdXNpdmUuXG4gKiBhbHBoYSBzaG91bGQgYmUgYSBmbG9hdCBpbiB0aGUgcmFuZ2UgMC4uMSBpbmNsdXNpdmUuIElmIG5vIGFscGhhIHZhbHVlIGlzXG4gKiBnaXZlbiB0aGVuIGAxYCB3aWxsIGJlIHVzZWQuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IENvbG9yXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgUmVnRXhwIG1hdGNoZXMgIyBmb2xsb3dlZCBieSAzLCA0LCA2LCBvciA4IGhleCBkaWdpdHMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSEVYX0NPTE9SX1JFXyA9IC9eIyhbYS1mMC05XXszfXxbYS1mMC05XXs0fSg/OlthLWYwLTldezJ9KXswLDJ9KSQvaTtcblxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgcG90ZW50aWFsIG5hbWVkIGNvbG9yIHN0eWxlIHN0cmluZ3MuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTkFNRURfQ09MT1JfUkVfID0gL14oW2Etel0qKSQvaTtcblxuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb2xvcn5Db2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBSZ2JhIHN0cmluZy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gbmFtZWQgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgTmFtZWQgY29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZyb21OYW1lZChjb2xvcikge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZWwuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgaWYgKGVsLnN0eWxlLmNvbG9yICE9PSAnJykge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHZhciByZ2IgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5jb2xvcjtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmdiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBDb2xvci5cbiAqL1xuZXhwb3J0IHZhciBmcm9tU3RyaW5nID0gKFxuICBmdW5jdGlvbigpIHtcblxuICAgIC8vIFdlIG1haW50YWluIGEgc21hbGwgY2FjaGUgb2YgcGFyc2VkIHN0cmluZ3MuICBUbyBwcm92aWRlIGNoZWFwIExSVS1saWtlXG4gICAgLy8gc2VtYW50aWNzLCB3aGVuZXZlciB0aGUgY2FjaGUgZ3Jvd3MgdG9vIGxhcmdlIHdlIHNpbXBseSBkZWxldGUgYW5cbiAgICAvLyBhcmJpdHJhcnkgMjUlIG9mIHRoZSBlbnRyaWVzLlxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgTUFYX0NBQ0hFX1NJWkUgPSAxMDI0O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvY29sb3J+Q29sb3I+fVxuICAgICAqL1xuICAgIHZhciBjYWNoZSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB2YXIgY2FjaGVTaXplID0gMDtcblxuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAgICAgICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb2xvcn5Db2xvcn0gQ29sb3IuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgICBjb2xvciA9IGNhY2hlW3NdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWNoZVNpemUgPj0gTUFYX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICBpZiAoKGkrKyAmIDMpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgLS1jYWNoZVNpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29sb3IgPSBmcm9tU3RyaW5nSW50ZXJuYWxfKHMpO1xuICAgICAgICAgIGNhY2hlW3NdID0gY29sb3I7XG4gICAgICAgICAgKytjYWNoZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgfVxuICAgICk7XG5cbiAgfSkoKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbG9yIGFzIGFuIGFycmF5LiBUaGlzIGZ1bmN0aW9uIG1haW50YWlucyBhIGNhY2hlIG9mIGNhbGN1bGF0ZWRcbiAqIGFycmF5cyB3aGljaCBtZWFucyB0aGUgcmVzdWx0IHNob3VsZCBub3QgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb2xvcn5Db2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY29sb3IpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29sb3J+Q29sb3J9IENvbG9yLlxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nSW50ZXJuYWxfKHMpIHtcbiAgdmFyIHIsIGcsIGIsIGEsIGNvbG9yO1xuXG4gIGlmIChOQU1FRF9DT0xPUl9SRV8uZXhlYyhzKSkge1xuICAgIHMgPSBmcm9tTmFtZWQocyk7XG4gIH1cblxuICBpZiAoSEVYX0NPTE9SX1JFXy5leGVjKHMpKSB7IC8vIGhleFxuICAgIHZhciBuID0gcy5sZW5ndGggLSAxOyAvLyBudW1iZXIgb2YgaGV4IGRpZ2l0c1xuICAgIHZhciBkOyAvLyBudW1iZXIgb2YgZGlnaXRzIHBlciBjaGFubmVsXG4gICAgaWYgKG4gPD0gNCkge1xuICAgICAgZCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSAyO1xuICAgIH1cbiAgICB2YXIgaGFzQWxwaGEgPSBuID09PSA0IHx8IG4gPT09IDg7XG4gICAgciA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAwICogZCwgZCksIDE2KTtcbiAgICBnID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDEgKiBkLCBkKSwgMTYpO1xuICAgIGIgPSBwYXJzZUludChzLnN1YnN0cigxICsgMiAqIGQsIGQpLCAxNik7XG4gICAgaWYgKGhhc0FscGhhKSB7XG4gICAgICBhID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDMgKiBkLCBkKSwgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gMjU1O1xuICAgIH1cbiAgICBpZiAoZCA9PSAxKSB7XG4gICAgICByID0gKHIgPDwgNCkgKyByO1xuICAgICAgZyA9IChnIDw8IDQpICsgZztcbiAgICAgIGIgPSAoYiA8PCA0KSArIGI7XG4gICAgICBpZiAoaGFzQWxwaGEpIHtcbiAgICAgICAgYSA9IChhIDw8IDQpICsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sb3IgPSBbciwgZywgYiwgYSAvIDI1NV07XG4gIH0gZWxzZSBpZiAocy5pbmRleE9mKCdyZ2JhKCcpID09IDApIHsgLy8gcmdiYSgpXG4gICAgY29sb3IgPSBzLnNsaWNlKDUsIC0xKS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSBpZiAocy5pbmRleE9mKCdyZ2IoJykgPT0gMCkgeyAvLyByZ2IoKVxuICAgIGNvbG9yID0gcy5zbGljZSg0LCAtMSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICBjb2xvci5wdXNoKDEpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAxNCk7IC8vIEludmFsaWQgY29sb3JcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfSAqLyAoY29sb3IpXG4gICk7XG59XG5cblxuLyoqXG4gKiBUT0RPIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGluIHRoZSB0ZXN0LCB3ZSBwcm9iYWJseSBzaG91bGRuJ3QgZXhwb3J0IGl0XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb2xvcn5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29sb3J+Q29sb3J9IENsYW1wZWQgY29sb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoY29sb3IpIHtcbiAgY29sb3JbMF0gPSBjbGFtcCgoY29sb3JbMF0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMV0gPSBjbGFtcCgoY29sb3JbMV0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbMl0gPSBjbGFtcCgoY29sb3JbMl0gKyAwLjUpIHwgMCwgMCwgMjU1KTtcbiAgY29sb3JbM10gPSBjbGFtcChjb2xvclszXSwgMCwgMSk7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoY29sb3IpIHtcbiAgdmFyIHIgPSBjb2xvclswXTtcbiAgaWYgKHIgIT0gKHIgfCAwKSkge1xuICAgIHIgPSAociArIDAuNSkgfCAwO1xuICB9XG4gIHZhciBnID0gY29sb3JbMV07XG4gIGlmIChnICE9IChnIHwgMCkpIHtcbiAgICBnID0gKGcgKyAwLjUpIHwgMDtcbiAgfVxuICB2YXIgYiA9IGNvbG9yWzJdO1xuICBpZiAoYiAhPSAoYiB8IDApKSB7XG4gICAgYiA9IChiICsgMC41KSB8IDA7XG4gIH1cbiAgdmFyIGEgPSBjb2xvclszXSA9PT0gdW5kZWZpbmVkID8gMSA6IGNvbG9yWzNdO1xuICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvcmxpa2VcbiAqL1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnLi9jb2xvci5qcyc7XG5cblxuLyoqXG4gKiBBIHR5cGUgYWNjZXB0ZWQgYnkgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmZpbGxTdHlsZVxuICogb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnN0cm9rZVN0eWxlLlxuICogUmVwcmVzZW50cyBhIGNvbG9yLCBwYXR0ZXJuLCBvciBncmFkaWVudC4gVGhlIG9yaWdpbiBmb3IgcGF0dGVybnMgYW5kXG4gKiBncmFkaWVudHMgYXMgZmlsbCBzdHlsZSBpcyBhbiBpbmNyZW1lbnQgb2YgNTEyIGNzcyBwaXhlbHMgZnJvbSBtYXAgY29vcmRpbmF0ZVxuICogYFswLCAwXWAuIEZvciBzZWFtbGVzcyByZXBlYXQgcGF0dGVybnMsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHBhdHRlcm4gaW1hZ2VcbiAqIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xDYW52YXNQYXR0ZXJufENhbnZhc0dyYWRpZW50fSBDb2xvckxpa2VcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29sb3J+Q29sb3J8bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IFRoZSBjb2xvciBhcyBhbiB7QGxpbmsgb2wvY29sb3JsaWtlfkNvbG9yTGlrZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0NvbG9yTGlrZShjb2xvcikge1xuICBpZiAoaXNDb2xvckxpa2UoY29sb3IpKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7c3RyaW5nfENhbnZhc1BhdHRlcm58Q2FudmFzR3JhZGllbnR9ICovIChjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKC8qKiBAdHlwZSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfSAqLyAoY29sb3IpKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHs/fSBjb2xvciBUaGUgdmFsdWUgdGhhdCBpcyBwb3RlbnRpYWxseSBhbiB7QGxpbmsgb2wvY29sb3JsaWtlfkNvbG9yTGlrZX0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29sb3IgaXMgYW4ge0BsaW5rIG9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDb2xvckxpa2UoY29sb3IpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnIHx8XG4gICAgY29sb3IgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8XG4gICAgY29sb3IgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudFxuICApO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvcmxpa2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbnRyb2wvQXR0cmlidXRpb25cbiAqL1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCBDb250cm9sIGZyb20gJy4uL2NvbnRyb2wvQ29udHJvbC5qcyc7XG5pbXBvcnQge0NMQVNTX0NPTlRST0wsIENMQVNTX1VOU0VMRUNUQUJMRSwgQ0xBU1NfQ09MTEFQU0VEfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtyZW1vdmVDaGlsZHJlbiwgcmVwbGFjZU5vZGV9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3Zpc2libGVBdFJlc29sdXRpb259IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1hdHRyaWJ1dGlvbiddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91XG4gKiB3YW50IHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzXG4gKiB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxhcHNpYmxlPXRydWVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIGNhblxuICogYmUgY29sbGFwc2VkLiBJZiB5b3UgdXNlIGFuIE9TTSBzb3VyY2UsIHNob3VsZCBiZSBzZXQgdG8gYGZhbHNlYCDigJQgc2VlXG4gKiB7QGxpbmsgaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0IE9TTSBDb3B5cmlnaHR9IOKAlFxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2VkPXRydWVdIFNwZWNpZnkgaWYgYXR0cmlidXRpb25zIHNob3VsZFxuICogYmUgY29sbGFwc2VkIGF0IHN0YXJ0dXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RpcExhYmVsPSdBdHRyaWJ1dGlvbnMnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsPSdpJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZVxuICogY29sbGFwc2VkIGF0dHJpYnV0aW9ucyBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbY29sbGFwc2VMYWJlbD0nwrsnXSBUZXh0IGxhYmVsIHRvIHVzZVxuICogZm9yIHRoZSBleHBhbmRlZCBhdHRyaWJ1dGlvbnMgYnV0dG9uLlxuICogSW5zdGVhZCBvZiB0ZXh0LCBhbHNvIGFuIGVsZW1lbnQgKGUuZy4gYSBgc3BhbmAgZWxlbWVudCkgY2FuIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG1vZHVsZTpvbC9NYXBFdmVudCl9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250cm9sIHRvIHNob3cgYWxsIHRoZSBhdHRyaWJ1dGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsYXllciBzb3VyY2VzXG4gKiBpbiB0aGUgbWFwLiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGluY2x1ZGVkIGluIG1hcHMuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgc2hvdyBpbiB0aGUgYm90dG9tIHJpZ2h0IHBvcnRpb24gb2YgdGhlIG1hcCwgYnV0IHRoaXMgY2FuXG4gKiBiZSBjaGFuZ2VkIGJ5IHVzaW5nIGEgY3NzIHNlbGVjdG9yIGZvciBgLm9sLWF0dHJpYnV0aW9uYC5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBBdHRyaWJ1dGlvbiA9IChmdW5jdGlvbiAoQ29udHJvbCkge1xuICBmdW5jdGlvbiBBdHRyaWJ1dGlvbihvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBDb250cm9sLmNhbGwodGhpcywge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICByZW5kZXI6IG9wdGlvbnMucmVuZGVyIHx8IHJlbmRlcixcbiAgICAgIHRhcmdldDogb3B0aW9ucy50YXJnZXRcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudWxFbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2VkXyA9IG9wdGlvbnMuY29sbGFwc2VkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbGxhcHNlZCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29sbGFwc2libGVfID0gb3B0aW9ucy5jb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmNvbGxhcHNpYmxlXykge1xuICAgICAgdGhpcy5jb2xsYXBzZWRfID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsYXNzTmFtZSA6ICdvbC1hdHRyaWJ1dGlvbic7XG5cbiAgICB2YXIgdGlwTGFiZWwgPSBvcHRpb25zLnRpcExhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpcExhYmVsIDogJ0F0dHJpYnV0aW9ucyc7XG5cbiAgICB2YXIgY29sbGFwc2VMYWJlbCA9IG9wdGlvbnMuY29sbGFwc2VMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb2xsYXBzZUxhYmVsIDogJ1xcdTAwQkInO1xuXG4gICAgaWYgKHR5cGVvZiBjb2xsYXBzZUxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmNvbGxhcHNlTGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXy50ZXh0Q29udGVudCA9IGNvbGxhcHNlTGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbGFwc2VMYWJlbF8gPSBjb2xsYXBzZUxhYmVsO1xuICAgIH1cblxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGFiZWwgOiAnaSc7XG5cbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnc3RyaW5nJykge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICovXG4gICAgICB0aGlzLmxhYmVsXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIHRoaXMubGFiZWxfLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxfID0gbGFiZWw7XG4gICAgfVxuXG5cbiAgICB2YXIgYWN0aXZlTGFiZWwgPSAodGhpcy5jb2xsYXBzaWJsZV8gJiYgIXRoaXMuY29sbGFwc2VkXykgP1xuICAgICAgdGhpcy5jb2xsYXBzZUxhYmVsXyA6IHRoaXMubGFiZWxfO1xuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgIGJ1dHRvbi50aXRsZSA9IHRpcExhYmVsO1xuICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChhY3RpdmVMYWJlbCk7XG5cbiAgICBsaXN0ZW4oYnV0dG9uLCBFdmVudFR5cGUuQ0xJQ0ssIHRoaXMuaGFuZGxlQ2xpY2tfLCB0aGlzKTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0gY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTCArXG4gICAgICAgICh0aGlzLmNvbGxhcHNlZF8gJiYgdGhpcy5jb2xsYXBzaWJsZV8gPyAnICcgKyBDTEFTU19DT0xMQVBTRUQgOiAnJykgK1xuICAgICAgICAodGhpcy5jb2xsYXBzaWJsZV8gPyAnJyA6ICcgb2wtdW5jb2xsYXBzaWJsZScpO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMudWxFbGVtZW50Xyk7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChidXR0b24pO1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGN1cnJlbnRseSByZW5kZXJlZCByZXNvbHV0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkQXR0cmlidXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuXG4gIH1cblxuICBpZiAoIENvbnRyb2wgKSBBdHRyaWJ1dGlvbi5fX3Byb3RvX18gPSBDb250cm9sO1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb250cm9sICYmIENvbnRyb2wucHJvdG90eXBlICk7XG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF0dHJpYnV0aW9uO1xuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIHZpc2libGUgYXR0cmlidXRpb25zLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEF0dHJpYnV0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5nZXRTb3VyY2VBdHRyaWJ1dGlvbnNfID0gZnVuY3Rpb24gZ2V0U291cmNlQXR0cmlidXRpb25zXyAoZnJhbWVTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIGF0dHJpYnV0aW9uIGFscmVhZHkgZXhpc3RzLlxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHZhciBsb29rdXAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB2aXNpYmxlIGF0dHJpYnV0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgdmFyIHZpc2libGVBdHRyaWJ1dGlvbnMgPSBbXTtcblxuICAgIHZhciBsYXllclN0YXRlc0FycmF5ID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIHZhciByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNBcnJheVtpXTtcbiAgICAgIGlmICghdmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCByZXNvbHV0aW9uKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IGxheWVyU3RhdGUubGF5ZXIuZ2V0U291cmNlKCk7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0aW9uR2V0dGVyID0gc291cmNlLmdldEF0dHJpYnV0aW9ucygpO1xuICAgICAgaWYgKCFhdHRyaWJ1dGlvbkdldHRlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0aW9ucyA9IGF0dHJpYnV0aW9uR2V0dGVyKGZyYW1lU3RhdGUpO1xuICAgICAgaWYgKCFhdHRyaWJ1dGlvbnMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9ucykpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gYXR0cmlidXRpb25zLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBpZiAoIShhdHRyaWJ1dGlvbnNbal0gaW4gbG9va3VwKSkge1xuICAgICAgICAgICAgdmlzaWJsZUF0dHJpYnV0aW9ucy5wdXNoKGF0dHJpYnV0aW9uc1tqXSk7XG4gICAgICAgICAgICBsb29rdXBbYXR0cmlidXRpb25zW2pdXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShhdHRyaWJ1dGlvbnMgaW4gbG9va3VwKSkge1xuICAgICAgICAgIHZpc2libGVBdHRyaWJ1dGlvbnMucHVzaChhdHRyaWJ1dGlvbnMpO1xuICAgICAgICAgIGxvb2t1cFthdHRyaWJ1dGlvbnNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUF0dHJpYnV0aW9ucztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHs/bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKi9cbiAgQXR0cmlidXRpb24ucHJvdG90eXBlLnVwZGF0ZUVsZW1lbnRfID0gZnVuY3Rpb24gdXBkYXRlRWxlbWVudF8gKGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0aW9ucyA9IHRoaXMuZ2V0U291cmNlQXR0cmlidXRpb25zXyhmcmFtZVN0YXRlKTtcblxuICAgIHZhciB2aXNpYmxlID0gYXR0cmlidXRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXyAhPSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgaWYgKGVxdWFscyhhdHRyaWJ1dGlvbnMsIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMudWxFbGVtZW50Xyk7XG5cbiAgICAvLyBhcHBlbmQgdGhlIGF0dHJpYnV0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGF0dHJpYnV0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0xJJyk7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGF0dHJpYnV0aW9uc1tpXTtcbiAgICAgIHRoaXMkMS51bEVsZW1lbnRfLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWRBdHRyaWJ1dGlvbnNfID0gYXR0cmlidXRpb25zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5oYW5kbGVDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVDbGlja18gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmhhbmRsZVRvZ2dsZV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5oYW5kbGVUb2dnbGVfID0gZnVuY3Rpb24gaGFuZGxlVG9nZ2xlXyAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfQ09MTEFQU0VEKTtcbiAgICBpZiAodGhpcy5jb2xsYXBzZWRfKSB7XG4gICAgICByZXBsYWNlTm9kZSh0aGlzLmNvbGxhcHNlTGFiZWxfLCB0aGlzLmxhYmVsXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGxhY2VOb2RlKHRoaXMubGFiZWxfLCB0aGlzLmNvbGxhcHNlTGFiZWxfKTtcbiAgICB9XG4gICAgdGhpcy5jb2xsYXBzZWRfID0gIXRoaXMuY29sbGFwc2VkXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRpb24gaXMgY29sbGFwc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2libGUuXG4gICAqIEBhcGlcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5nZXRDb2xsYXBzaWJsZSA9IGZ1bmN0aW9uIGdldENvbGxhcHNpYmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsYXBzaWJsZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBhdHRyaWJ1dGlvbiBzaG91bGQgYmUgY29sbGFwc2libGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2libGUgVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIGNvbGxhcHNpYmxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuc2V0Q29sbGFwc2libGUgPSBmdW5jdGlvbiBzZXRDb2xsYXBzaWJsZSAoY29sbGFwc2libGUpIHtcbiAgICBpZiAodGhpcy5jb2xsYXBzaWJsZV8gPT09IGNvbGxhcHNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29sbGFwc2libGVfID0gY29sbGFwc2libGU7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ29sLXVuY29sbGFwc2libGUnKTtcbiAgICBpZiAoIWNvbGxhcHNpYmxlICYmIHRoaXMuY29sbGFwc2VkXykge1xuICAgICAgdGhpcy5oYW5kbGVUb2dnbGVfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDb2xsYXBzZSBvciBleHBhbmQgdGhlIGF0dHJpYnV0aW9uIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIHBhcmFtZXRlci4gV2lsbFxuICAgKiBub3QgZG8gYW55dGhpbmcgaWYgdGhlIGF0dHJpYnV0aW9uIGlzbid0IGNvbGxhcHNpYmxlIG9yIGlmIHRoZSBjdXJyZW50XG4gICAqIGNvbGxhcHNlZCBzdGF0ZSBpcyBhbHJlYWR5IHRoZSBvbmUgcmVxdWVzdGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNlZCBUcnVlIGlmIHRoZSB3aWRnZXQgaXMgY29sbGFwc2VkLlxuICAgKiBAYXBpXG4gICAqL1xuICBBdHRyaWJ1dGlvbi5wcm90b3R5cGUuc2V0Q29sbGFwc2VkID0gZnVuY3Rpb24gc2V0Q29sbGFwc2VkIChjb2xsYXBzZWQpIHtcbiAgICBpZiAoIXRoaXMuY29sbGFwc2libGVfIHx8IHRoaXMuY29sbGFwc2VkXyA9PT0gY29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVG9nZ2xlXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYHRydWVgIHdoZW4gdGhlIGF0dHJpYnV0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQgb3IgYGZhbHNlYFxuICAgKiBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHdpZGdldCBpcyBjb2xsYXBzZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIEF0dHJpYnV0aW9uLnByb3RvdHlwZS5nZXRDb2xsYXBzZWQgPSBmdW5jdGlvbiBnZXRDb2xsYXBzZWQgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZF87XG4gIH07XG5cbiAgcmV0dXJuIEF0dHJpYnV0aW9uO1xufShDb250cm9sKSk7XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGF0dHJpYnV0aW9uIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBFdmVudH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICogQHRoaXMge21vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufVxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKG1hcEV2ZW50KSB7XG4gIHRoaXMudXBkYXRlRWxlbWVudF8obWFwRXZlbnQuZnJhbWVTdGF0ZSk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQXR0cmlidXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF0dHJpYnV0aW9uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL0NvbnRyb2xcbiAqL1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4uL01hcEV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtyZW1vdmVOb2RlfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbZWxlbWVudF0gVGhlIGVsZW1lbnQgaXMgdGhlIGNvbnRyb2wnc1xuICogY29udGFpbmVyIGVsZW1lbnQuIFRoaXMgb25seSBuZWVkcyB0byBiZSBzcGVjaWZpZWQgaWYgeW91J3JlIGRldmVsb3BpbmdcbiAqIGEgY3VzdG9tIGNvbnRyb2wuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG1vZHVsZTpvbC9NYXBFdmVudCl9IFtyZW5kZXJdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuXG4gKiB0aGUgY29udHJvbCBzaG91bGQgYmUgcmUtcmVuZGVyZWQuIFRoaXMgaXMgY2FsbGVkIGluIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAqIGNhbGxiYWNrLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnRcbiAqIHRoZSBjb250cm9sIHRvIGJlIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNvbnRyb2wgaXMgYSB2aXNpYmxlIHdpZGdldCB3aXRoIGEgRE9NIGVsZW1lbnQgaW4gYSBmaXhlZCBwb3NpdGlvbiBvbiB0aGVcbiAqIHNjcmVlbi4gVGhleSBjYW4gaW52b2x2ZSB1c2VyIGlucHV0IChidXR0b25zKSwgb3IgYmUgaW5mb3JtYXRpb25hbCBvbmx5O1xuICogdGhlIHBvc2l0aW9uIGlzIGRldGVybWluZWQgdXNpbmcgQ1NTLiBCeSBkZWZhdWx0IHRoZXNlIGFyZSBwbGFjZWQgaW4gdGhlXG4gKiBjb250YWluZXIgd2l0aCBDU1MgY2xhc3MgbmFtZSBgb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnRgLCBidXQgY2FuIHVzZVxuICogYW55IG91dHNpZGUgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY29udHJvbHMuIFlvdSBjYW4gdXNlIGl0IGZvciBzaW1wbGUgY3VzdG9tXG4gKiBjb250cm9scyBieSBjcmVhdGluZyB0aGUgZWxlbWVudCB3aXRoIGxpc3RlbmVycywgY3JlYXRpbmcgYW4gaW5zdGFuY2U6XG4gKiBgYGBqc1xuICogdmFyIG15Q29udHJvbCA9IG5ldyBDb250cm9sKHtlbGVtZW50OiBteUVsZW1lbnR9KTtcbiAqIGBgYFxuICogYW5kIHRoZW4gYWRkaW5nIHRoaXMgdG8gdGhlIG1hcC5cbiAqXG4gKiBUaGUgbWFpbiBhZHZhbnRhZ2Ugb2YgaGF2aW5nIHRoaXMgYXMgYSBjb250cm9sIHJhdGhlciB0aGFuIGEgc2ltcGxlIHNlcGFyYXRlXG4gKiBET00gZWxlbWVudCBpcyB0aGF0IHByZXZlbnRpbmcgcHJvcGFnYXRpb24gaXMgaGFuZGxlZCBmb3IgeW91LiBDb250cm9sc1xuICogd2lsbCBhbHNvIGJlIG9iamVjdHMgaW4gYSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0sIHNvIHlvdSBjYW4gdXNlIHRoZWlyIG1ldGhvZHMuXG4gKlxuICogWW91IGNhbiBhbHNvIGV4dGVuZCB0aGlzIGJhc2UgZm9yIHlvdXIgb3duIGNvbnRyb2wgY2xhc3MuIFNlZVxuICogZXhhbXBsZXMvY3VzdG9tLWNvbnRyb2xzIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBkbyB0aGlzLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIENvbnRyb2wgPSAoZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gQ29udHJvbChvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCA/IG9wdGlvbnMuZWxlbWVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG1vZHVsZTpvbC9NYXBFdmVudCl9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlciA/IG9wdGlvbnMucmVuZGVyIDogVU5ERUZJTkVEO1xuXG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnNldFRhcmdldChvcHRpb25zLnRhcmdldCk7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBDb250cm9sLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIENvbnRyb2wucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBDb250cm9sLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRyb2w7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDb250cm9sLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHJlbW92ZU5vZGUodGhpcy5lbGVtZW50KTtcbiAgICBCYXNlT2JqZWN0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udHJvbC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBDb250cm9sLnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbiBnZXRNYXAgKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgY29udHJvbCBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG1hcCBNYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIENvbnRyb2wucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5tYXBfKSB7XG4gICAgICByZW1vdmVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRoaXMubGlzdGVuZXJLZXlzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcyQxLmxpc3RlbmVyS2V5c1tpXSk7XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJLZXlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldF8gP1xuICAgICAgICB0aGlzLnRhcmdldF8gOiBtYXAuZ2V0T3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudCgpO1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5yZW5kZXIgIT09IFVOREVGSU5FRCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyS2V5cy5wdXNoKGxpc3RlbihtYXAsXG4gICAgICAgICAgTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMucmVuZGVyLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICBtYXAucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gc2V0IGEgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBjb250cm9sLiBJdCBoYXMgbm9cbiAgICogZWZmZWN0IGlmIGl0IGlzIGNhbGxlZCBhZnRlciB0aGUgY29udHJvbCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgbWFwIChpLmUuXG4gICAqIGFmdGVyIGBzZXRNYXBgIGlzIGNhbGxlZCBvbiB0aGUgY29udHJvbCkuIElmIG5vIGB0YXJnZXRgIGlzIHNldCBpbiB0aGVcbiAgICogb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnRyb2wgY29uc3RydWN0b3IgYW5kIGlmIGBzZXRUYXJnZXRgIGlzIG5vdCBjYWxsZWRcbiAgICogdGhlbiB0aGUgY29udHJvbCBpcyBhZGRlZCB0byB0aGUgbWFwJ3Mgb3ZlcmxheSBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGFyZ2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBDb250cm9sLnByb3RvdHlwZS5zZXRUYXJnZXQgPSBmdW5jdGlvbiBzZXRUYXJnZXQgKHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0XyA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID9cbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOlxuICAgICAgdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBDb250cm9sO1xufShCYXNlT2JqZWN0KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC9Sb3RhdGVcbiAqL1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi4vY29udHJvbC9Db250cm9sLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfSElEREVOLCBDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtcm90YXRlJ10gQ1NTIGNsYXNzIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xhYmVsPSfih6cnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIHJvdGF0ZSBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGlwTGFiZWw9J1Jlc2V0IHJvdGF0aW9uJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSByb3RhdGUgdGlwLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvSGlkZT10cnVlXSBIaWRlIHRoZSBjb250cm9sIHdoZW4gcm90YXRpb24gaXMgMC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obW9kdWxlOm9sL01hcEV2ZW50KX0gW3JlbmRlcl0gRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgc2hvdWxkXG4gKiBiZSByZS1yZW5kZXJlZC4gVGhpcyBpcyBjYWxsZWQgaW4gYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKX0gW3Jlc2V0Tm9ydGhdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIGlzIGNsaWNrZWQuXG4gKiBUaGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYHJlc2V0Tm9ydGhgLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdIFNwZWNpZnkgYSB0YXJnZXQgaWYgeW91IHdhbnQgdGhlIGNvbnRyb2wgdG8gYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhlIG1hcCdzIHZpZXdwb3J0LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGJ1dHRvbiBjb250cm9sIHRvIHJlc2V0IHJvdGF0aW9uIHRvIDAuXG4gKiBUbyBzdHlsZSB0aGlzIGNvbnRyb2wgdXNlIGNzcyBzZWxlY3RvciBgLm9sLXJvdGF0ZWAuIEEgYC5vbC1oaWRkZW5gIGNzc1xuICogc2VsZWN0b3IgaXMgYWRkZWQgdG8gdGhlIGJ1dHRvbiB3aGVuIHRoZSByb3RhdGlvbiBpcyAwLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFJvdGF0ZSA9IChmdW5jdGlvbiAoQ29udHJvbCkge1xuICBmdW5jdGlvbiBSb3RhdGUob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgQ29udHJvbC5jYWxsKHRoaXMsIHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgcmVuZGVyOiBvcHRpb25zLnJlbmRlciB8fCByZW5kZXIsXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0XG4gICAgfSk7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXJvdGF0ZSc7XG5cbiAgICB2YXIgbGFiZWwgPSBvcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxhYmVsIDogJ1xcdTIxRTcnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYWJlbF8gPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubGFiZWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdGhpcy5sYWJlbF8uY2xhc3NOYW1lID0gJ29sLWNvbXBhc3MnO1xuICAgICAgdGhpcy5sYWJlbF8udGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbF8gPSBsYWJlbDtcbiAgICAgIHRoaXMubGFiZWxfLmNsYXNzTGlzdC5hZGQoJ29sLWNvbXBhc3MnKTtcbiAgICB9XG5cbiAgICB2YXIgdGlwTGFiZWwgPSBvcHRpb25zLnRpcExhYmVsID8gb3B0aW9ucy50aXBMYWJlbCA6ICdSZXNldCByb3RhdGlvbic7XG5cbiAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctcmVzZXQnO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgYnV0dG9uLnRpdGxlID0gdGlwTGFiZWw7XG4gICAgYnV0dG9uLmFwcGVuZENoaWxkKHRoaXMubGFiZWxfKTtcblxuICAgIGxpc3RlbihidXR0b24sIEV2ZW50VHlwZS5DTElDSywgdGhpcy5oYW5kbGVDbGlja18sIHRoaXMpO1xuXG4gICAgdmFyIGNzc0NsYXNzZXMgPSBjbGFzc05hbWUgKyAnICcgKyBDTEFTU19VTlNFTEVDVEFCTEUgKyAnICcgKyBDTEFTU19DT05UUk9MO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3NlcztcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICB0aGlzLmNhbGxSZXNldE5vcnRoXyA9IG9wdGlvbnMucmVzZXROb3J0aCA/IG9wdGlvbnMucmVzZXROb3J0aCA6IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYXV0b0hpZGVfID0gb3B0aW9ucy5hdXRvSGlkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hdXRvSGlkZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMuYXV0b0hpZGVfKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19ISURERU4pO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBDb250cm9sICkgUm90YXRlLl9fcHJvdG9fXyA9IENvbnRyb2w7XG4gIFJvdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb250cm9sICYmIENvbnRyb2wucHJvdG90eXBlICk7XG4gIFJvdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGU7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRvIGhhbmRsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUm90YXRlLnByb3RvdHlwZS5oYW5kbGVDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVDbGlja18gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAodGhpcy5jYWxsUmVzZXROb3J0aF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYWxsUmVzZXROb3J0aF8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNldE5vcnRoXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJvdGF0ZS5wcm90b3R5cGUucmVzZXROb3J0aF8gPSBmdW5jdGlvbiByZXNldE5vcnRoXyAoKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICghdmlldykge1xuICAgICAgLy8gdGhlIG1hcCBkb2VzIG5vdCBoYXZlIGEgdmlldywgc28gd2UgY2FuJ3QgYWN0XG4gICAgICAvLyB1cG9uIGl0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2aWV3LmdldFJvdGF0aW9uKCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuZHVyYXRpb25fID4gMCkge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFJvdGF0aW9uKDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUm90YXRlO1xufShDb250cm9sKSk7XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHJvdGF0ZSBjb250cm9sIGVsZW1lbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBFdmVudH0gbWFwRXZlbnQgTWFwIGV2ZW50LlxuICogQHRoaXMge21vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihtYXBFdmVudCkge1xuICB2YXIgZnJhbWVTdGF0ZSA9IG1hcEV2ZW50LmZyYW1lU3RhdGU7XG4gIGlmICghZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgaWYgKHJvdGF0aW9uICE9IHRoaXMucm90YXRpb25fKSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgIGlmICh0aGlzLmF1dG9IaWRlXykge1xuICAgICAgdmFyIGNvbnRhaW5zID0gdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19ISURERU4pO1xuICAgICAgaWYgKCFjb250YWlucyAmJiByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19ISURERU4pO1xuICAgICAgfSBlbHNlIGlmIChjb250YWlucyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19ISURERU4pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhYmVsXy5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLmxhYmVsXy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgdGhpcy5sYWJlbF8uc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG4gIHRoaXMucm90YXRpb25fID0gcm90YXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJvdGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um90YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9jb250cm9sL1pvb21cbiAqL1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IENvbnRyb2wgZnJvbSAnLi4vY29udHJvbC9Db250cm9sLmpzJztcbmltcG9ydCB7Q0xBU1NfQ09OVFJPTCwgQ0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtem9vbSddIENTUyBjbGFzcyBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFt6b29tSW5MYWJlbD0nKyddIFRleHQgbGFiZWwgdG8gdXNlIGZvciB0aGUgem9vbS1pblxuICogYnV0dG9uLiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbem9vbU91dExhYmVsPSctJ10gVGV4dCBsYWJlbCB0byB1c2UgZm9yIHRoZSB6b29tLW91dCBidXR0b24uXG4gKiBJbnN0ZWFkIG9mIHRleHQsIGFsc28gYW4gZWxlbWVudCAoZS5nLiBhIGBzcGFuYCBlbGVtZW50KSBjYW4gYmUgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbUluVGlwTGFiZWw9J1pvb20gaW4nXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb21PdXRUaXBMYWJlbD0nWm9vbSBvdXQnXSBUZXh0IGxhYmVsIHRvIHVzZSBmb3IgdGhlIGJ1dHRvbiB0aXAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBjbGljay5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBTcGVjaWZ5IGEgdGFyZ2V0IGlmIHlvdSB3YW50IHRoZSBjb250cm9sIHRvIGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBtYXAncyB2aWV3cG9ydC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb250cm9sIHdpdGggMiBidXR0b25zLCBvbmUgZm9yIHpvb20gaW4gYW5kIG9uZSBmb3Igem9vbSBvdXQuXG4gKiBUaGlzIGNvbnRyb2wgaXMgb25lIG9mIHRoZSBkZWZhdWx0IGNvbnRyb2xzIG9mIGEgbWFwLiBUbyBzdHlsZSB0aGlzIGNvbnRyb2xcbiAqIHVzZSBjc3Mgc2VsZWN0b3JzIGAub2wtem9vbS1pbmAgYW5kIGAub2wtem9vbS1vdXRgLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIFpvb20gPSAoZnVuY3Rpb24gKENvbnRyb2wpIHtcbiAgZnVuY3Rpb24gWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBDb250cm9sLmNhbGwodGhpcywge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0XG4gICAgfSk7XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gb3B0aW9ucy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xhc3NOYW1lIDogJ29sLXpvb20nO1xuXG4gICAgdmFyIGRlbHRhID0gb3B0aW9ucy5kZWx0YSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWx0YSA6IDE7XG5cbiAgICB2YXIgem9vbUluTGFiZWwgPSBvcHRpb25zLnpvb21JbkxhYmVsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb21JbkxhYmVsIDogJysnO1xuICAgIHZhciB6b29tT3V0TGFiZWwgPSBvcHRpb25zLnpvb21PdXRMYWJlbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56b29tT3V0TGFiZWwgOiAnXFx1MjIxMic7XG5cbiAgICB2YXIgem9vbUluVGlwTGFiZWwgPSBvcHRpb25zLnpvb21JblRpcExhYmVsICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy56b29tSW5UaXBMYWJlbCA6ICdab29tIGluJztcbiAgICB2YXIgem9vbU91dFRpcExhYmVsID0gb3B0aW9ucy56b29tT3V0VGlwTGFiZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnpvb21PdXRUaXBMYWJlbCA6ICdab29tIG91dCc7XG5cbiAgICB2YXIgaW5FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctaW4nO1xuICAgIGluRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYnV0dG9uJyk7XG4gICAgaW5FbGVtZW50LnRpdGxlID0gem9vbUluVGlwTGFiZWw7XG4gICAgaW5FbGVtZW50LmFwcGVuZENoaWxkKFxuICAgICAgdHlwZW9mIHpvb21JbkxhYmVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21JbkxhYmVsKSA6IHpvb21JbkxhYmVsXG4gICAgKTtcblxuICAgIGxpc3RlbihpbkVsZW1lbnQsIEV2ZW50VHlwZS5DTElDSywgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCBkZWx0YSkpO1xuXG4gICAgdmFyIG91dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctb3V0JztcbiAgICBvdXRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICBvdXRFbGVtZW50LnRpdGxlID0gem9vbU91dFRpcExhYmVsO1xuICAgIG91dEVsZW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICB0eXBlb2Ygem9vbU91dExhYmVsID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHpvb21PdXRMYWJlbCkgOiB6b29tT3V0TGFiZWxcbiAgICApO1xuXG4gICAgbGlzdGVuKG91dEVsZW1lbnQsIEV2ZW50VHlwZS5DTElDSywgdGhpcy5oYW5kbGVDbGlja18uYmluZCh0aGlzLCAtZGVsdGEpKTtcblxuICAgIHZhciBjc3NDbGFzc2VzID0gY2xhc3NOYW1lICsgJyAnICsgQ0xBU1NfVU5TRUxFQ1RBQkxFICsgJyAnICsgQ0xBU1NfQ09OVFJPTDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzZXM7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChpbkVsZW1lbnQpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQob3V0RWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gIH1cblxuICBpZiAoIENvbnRyb2wgKSBab29tLl9fcHJvdG9fXyA9IENvbnRyb2w7XG4gIFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29udHJvbCAmJiBDb250cm9sLnByb3RvdHlwZSApO1xuICBab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFpvb207XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBoYW5kbGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFpvb20ucHJvdG90eXBlLmhhbmRsZUNsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrXyAoZGVsdGEsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLnpvb21CeURlbHRhXyhkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBab29tIGRlbHRhLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgWm9vbS5wcm90b3R5cGUuem9vbUJ5RGVsdGFfID0gZnVuY3Rpb24gem9vbUJ5RGVsdGFfIChkZWx0YSkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgIC8vIHRoZSBtYXAgZG9lcyBub3QgaGF2ZSBhIHZpZXcsIHNvIHdlIGNhbid0IGFjdFxuICAgICAgLy8gdXBvbiBpdFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAoY3VycmVudFJlc29sdXRpb24pIHtcbiAgICAgIHZhciBuZXdSZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKGN1cnJlbnRSZXNvbHV0aW9uLCBkZWx0YSk7XG4gICAgICBpZiAodGhpcy5kdXJhdGlvbl8gPiAwKSB7XG4gICAgICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICAgICAgdmlldy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBuZXdSZXNvbHV0aW9uLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXyxcbiAgICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3LnNldFJlc29sdXRpb24obmV3UmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBab29tO1xufShDb250cm9sKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgWm9vbTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Wm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvY29udHJvbC91dGlsXG4gKi9cbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IEF0dHJpYnV0aW9uIGZyb20gJy4vQXR0cmlidXRpb24uanMnO1xuaW1wb3J0IFJvdGF0ZSBmcm9tICcuL1JvdGF0ZS5qcyc7XG5pbXBvcnQgWm9vbSBmcm9tICcuL1pvb20uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdHRyaWJ1dGlvbj10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvQXR0cmlidXRpb25+QXR0cmlidXRpb259LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29udHJvbC9BdHRyaWJ1dGlvbn5PcHRpb25zfSBbYXR0cmlidXRpb25PcHRpb25zXVxuICogT3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZT10cnVlXSBJbmNsdWRlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX0uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9jb250cm9sL1JvdGF0ZX5PcHRpb25zfSBbcm90YXRlT3B0aW9uc10gT3B0aW9uc1xuICogZm9yIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Sb3RhdGV+Um90YXRlfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3pvb21dIEluY2x1ZGUge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9jb250cm9sL1pvb21+T3B0aW9uc30gW3pvb21PcHRpb25zXSBPcHRpb25zIGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL1pvb21+Wm9vbX0uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFNldCBvZiBjb250cm9scyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFVubGVzcyBjb25maWd1cmVkIG90aGVyd2lzZSxcbiAqIHRoaXMgcmV0dXJucyBhIGNvbGxlY3Rpb24gY29udGFpbmluZyBhbiBpbnN0YW5jZSBvZiBlYWNoIG9mIHRoZSBmb2xsb3dpbmdcbiAqIGNvbnRyb2xzOlxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvUm90YXRlflJvdGF0ZX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9jb250cm9sL0F0dHJpYnV0aW9ufkF0dHJpYnV0aW9ufVxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2NvbnRyb2wvdXRpbH5EZWZhdWx0c09wdGlvbnM9fSBvcHRfb3B0aW9uc1xuICogRGVmYXVsdHMgb3B0aW9ucy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvY29udHJvbC9Db250cm9sPn1cbiAqIENvbnRyb2xzLlxuICogQGZ1bmN0aW9uIG1vZHVsZTpvbC9jb250cm9sLmRlZmF1bHRzXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0cyhvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gIHZhciBjb250cm9scyA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgdmFyIHpvb21Db250cm9sID0gb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb20gOiB0cnVlO1xuICBpZiAoem9vbUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBab29tKG9wdGlvbnMuem9vbU9wdGlvbnMpKTtcbiAgfVxuXG4gIHZhciByb3RhdGVDb250cm9sID0gb3B0aW9ucy5yb3RhdGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRlIDogdHJ1ZTtcbiAgaWYgKHJvdGF0ZUNvbnRyb2wpIHtcbiAgICBjb250cm9scy5wdXNoKG5ldyBSb3RhdGUob3B0aW9ucy5yb3RhdGVPcHRpb25zKSk7XG4gIH1cblxuICB2YXIgYXR0cmlidXRpb25Db250cm9sID0gb3B0aW9ucy5hdHRyaWJ1dGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLmF0dHJpYnV0aW9uIDogdHJ1ZTtcbiAgaWYgKGF0dHJpYnV0aW9uQ29udHJvbCkge1xuICAgIGNvbnRyb2xzLnB1c2gobmV3IEF0dHJpYnV0aW9uKG9wdGlvbnMuYXR0cmlidXRpb25PcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gY29udHJvbHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nvb3JkaW5hdGVcbiAqL1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3BhZE51bWJlcn0gZnJvbSAnLi9zdHJpbmcuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4geHkgY29vcmRpbmF0ZS4gRXhhbXBsZTogYFsxNiwgNDhdYC5cbiAqIEB0eXBlZGVmIHtBcnJheS48bnVtYmVyPn0gQ29vcmRpbmF0ZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYW5kXG4gKiB0cmFuc2Zvcm1zIGl0IGludG8gYSBge3N0cmluZ31gLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXx1bmRlZmluZWQpKTogc3RyaW5nfSBDb29yZGluYXRlRm9ybWF0XG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEFkZCBgZGVsdGFgIHRvIGBjb29yZGluYXRlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7YWRkfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgYWRkKGNvb3JkLCBbLTIsIDRdKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWzUuODUsIDUxLjk4MzMzM11cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUaGUgaW5wdXQgY29vcmRpbmF0ZSBhZGp1c3RlZCBieVxuICogdGhlIGdpdmVuIGRlbHRhLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvb3JkaW5hdGUsIGRlbHRhKSB7XG4gIGNvb3JkaW5hdGVbMF0gKz0gZGVsdGFbMF07XG4gIGNvb3JkaW5hdGVbMV0gKz0gZGVsdGFbMV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgb24gdGhlIHBhc3NlZCBjaXJjbGUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9DaXJjbGV9IGNpcmNsZSBUaGUgY2lyY2xlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ2xvc2VzdCBwb2ludCBvbiB0aGUgY2lyY3VtZmVyZW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPbkNpcmNsZShjb29yZGluYXRlLCBjaXJjbGUpIHtcbiAgdmFyIHIgPSBjaXJjbGUuZ2V0UmFkaXVzKCk7XG4gIHZhciBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIHZhciB4MCA9IGNlbnRlclswXTtcbiAgdmFyIHkwID0gY2VudGVyWzFdO1xuICB2YXIgeDEgPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeTEgPSBjb29yZGluYXRlWzFdO1xuXG4gIHZhciBkeCA9IHgxIC0geDA7XG4gIHZhciBkeSA9IHkxIC0geTA7XG4gIGlmIChkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgIGR4ID0gMTtcbiAgfVxuICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgdmFyIHggPSB4MCArIHIgKiBkeCAvIGQ7XG4gIHZhciB5ID0geTAgKyByICogZHkgLyBkO1xuXG4gIHJldHVybiBbeCwgeV07XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIHNlZ21lbnQuXG4gKiBUaGlzIGlzIHRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mIHRoZSBjb29yZGluYXRlIHRvIHRoZSBzZWdtZW50IHdoZW5cbiAqIHRoZSBmb290IGlzIG9uIHRoZSBzZWdtZW50LCBvciB0aGUgY2xvc2VzdCBzZWdtZW50IGNvb3JkaW5hdGUgd2hlbiB0aGUgZm9vdFxuICogaXMgb3V0c2lkZSB0aGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gc2VnbWVudCBUaGUgdHdvIGNvb3JkaW5hdGVzXG4gKiBvZiB0aGUgc2VnbWVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mXG4gKiB0aGUgY29vcmRpbmF0ZSB0byB0aGUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPblNlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkge1xuICB2YXIgeDAgPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeTAgPSBjb29yZGluYXRlWzFdO1xuICB2YXIgc3RhcnQgPSBzZWdtZW50WzBdO1xuICB2YXIgZW5kID0gc2VnbWVudFsxXTtcbiAgdmFyIHgxID0gc3RhcnRbMF07XG4gIHZhciB5MSA9IHN0YXJ0WzFdO1xuICB2YXIgeDIgPSBlbmRbMF07XG4gIHZhciB5MiA9IGVuZFsxXTtcbiAgdmFyIGR4ID0geDIgLSB4MTtcbiAgdmFyIGR5ID0geTIgLSB5MTtcbiAgdmFyIGFsb25nID0gKGR4ID09PSAwICYmIGR5ID09PSAwKSA/IDAgOlxuICAgICgoZHggKiAoeDAgLSB4MSkpICsgKGR5ICogKHkwIC0geTEpKSkgLyAoKGR4ICogZHggKyBkeSAqIGR5KSB8fCAwKTtcbiAgdmFyIHgsIHk7XG4gIGlmIChhbG9uZyA8PSAwKSB7XG4gICAgeCA9IHgxO1xuICAgIHkgPSB5MTtcbiAgfSBlbHNlIGlmIChhbG9uZyA+PSAxKSB7XG4gICAgeCA9IHgyO1xuICAgIHkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geDEgKyBhbG9uZyAqIGR4O1xuICAgIHkgPSB5MSArIGFsb25nICogZHk7XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZUZvcm1hdH0gZnVuY3Rpb24gdGhhdCBjYW4gYmVcbiAqIHVzZWQgdG8gZm9ybWF0XG4gKiBhIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB0byBhIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyB0aGUgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgc3RyaW5naWZ5RnVuYyA9IGNyZWF0ZVN0cmluZ1hZKCk7XG4gKiAgICAgdmFyIG91dCA9IHN0cmluZ2lmeUZ1bmMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzgsIDQ4J1xuICpcbiAqIEV4YW1wbGUgd2l0aCBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMiBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtjcmVhdGVTdHJpbmdYWX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBzdHJpbmdpZnlGdW5jID0gY3JlYXRlU3RyaW5nWFkoMik7XG4gKiAgICAgdmFyIG91dCA9IHN0cmluZ2lmeUZ1bmMoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzcuODUsIDQ3Ljk4J1xuICpcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IENvb3JkaW5hdGUgZm9ybWF0LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RyaW5nWFkob3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgWFkuXG4gICAgICovXG4gICAgZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgb3B0X2ZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVtaXNwaGVyZXMgSGVtaXNwaGVyZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyBEZWdyZWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzVG9TdHJpbmdIRE1TKGhlbWlzcGhlcmVzLCBkZWdyZWVzLCBvcHRfZnJhY3Rpb25EaWdpdHMpIHtcbiAgdmFyIG5vcm1hbGl6ZWREZWdyZWVzID0gbW9kdWxvKGRlZ3JlZXMgKyAxODAsIDM2MCkgLSAxODA7XG4gIHZhciB4ID0gTWF0aC5hYnMoMzYwMCAqIG5vcm1hbGl6ZWREZWdyZWVzKTtcbiAgdmFyIGRmbFByZWNpc2lvbiA9IG9wdF9mcmFjdGlvbkRpZ2l0cyB8fCAwO1xuICB2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIGRmbFByZWNpc2lvbik7XG5cbiAgdmFyIGRlZyA9IE1hdGguZmxvb3IoeCAvIDM2MDApO1xuICB2YXIgbWluID0gTWF0aC5mbG9vcigoeCAtIGRlZyAqIDM2MDApIC8gNjApO1xuICB2YXIgc2VjID0geCAtIChkZWcgKiAzNjAwKSAtIChtaW4gKiA2MCk7XG4gIHNlYyA9IE1hdGguY2VpbChzZWMgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXG4gIGlmIChzZWMgPj0gNjApIHtcbiAgICBzZWMgPSAwO1xuICAgIG1pbiArPSAxO1xuICB9XG5cbiAgaWYgKG1pbiA+PSA2MCkge1xuICAgIG1pbiA9IDA7XG4gICAgZGVnICs9IDE7XG4gIH1cblxuICByZXR1cm4gZGVnICsgJ1xcdTAwYjAgJyArIHBhZE51bWJlcihtaW4sIDIpICsgJ1xcdTIwMzIgJyArXG4gICAgcGFkTnVtYmVyKHNlYywgMiwgZGZsUHJlY2lzaW9uKSArICdcXHUyMDMzJyArXG4gICAgKG5vcm1hbGl6ZWREZWdyZWVzID09IDAgPyAnJyA6ICcgJyArIGhlbWlzcGhlcmVzLmNoYXJBdChub3JtYWxpemVkRGVncmVlcyA8IDAgPyAxIDogMCkpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRvIGEgc3RyaW5nXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIHRlbXBsYXRlLiBUaGUgc3RyaW5ncyBge3h9YCBhbmQgYHt5fWAgaW4gdGhlIHRlbXBsYXRlXG4gKiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICB2YXIgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoOHw0OCkuJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICB2YXIgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSwgMik7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoNy44NXw0Ny45OCkuJ1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIEEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYHt4fWAgYW5kIGB7eX1gIHBsYWNlaG9sZGVyc1xuICogICAgIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChjb29yZGluYXRlLCB0ZW1wbGF0ZSwgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgICAucmVwbGFjZSgne3h9JywgY29vcmRpbmF0ZVswXS50b0ZpeGVkKG9wdF9mcmFjdGlvbkRpZ2l0cykpXG4gICAgICAucmVwbGFjZSgne3l9JywgY29vcmRpbmF0ZVsxXS50b0ZpeGVkKG9wdF9mcmFjdGlvbkRpZ2l0cykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gY29vcmRpbmF0ZXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMikge1xuICB2YXIgZXF1YWxzID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IGNvb3JkaW5hdGUxLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUxW2ldICE9IGNvb3JkaW5hdGUyW2ldKSB7XG4gICAgICBlcXVhbHMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXF1YWxzO1xufVxuXG5cbi8qKlxuICogUm90YXRlIGBjb29yZGluYXRlYCBieSBgYW5nbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kXG4gKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtyb3RhdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgcm90YXRlUmFkaWFucyA9IE1hdGguUEkgLyAyOyAvLyA5MCBkZWdyZWVzXG4gKiAgICAgcm90YXRlKGNvb3JkLCByb3RhdGVSYWRpYW5zKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWy00Ny45ODMzMzMsIDcuODVdXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gcmFkaWFuLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShjb29yZGluYXRlLCBhbmdsZSkge1xuICB2YXIgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW5BbmdsZSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIHggPSBjb29yZGluYXRlWzBdICogY29zQW5nbGUgLSBjb29yZGluYXRlWzFdICogc2luQW5nbGU7XG4gIHZhciB5ID0gY29vcmRpbmF0ZVsxXSAqIGNvc0FuZ2xlICsgY29vcmRpbmF0ZVswXSAqIHNpbkFuZ2xlO1xuICBjb29yZGluYXRlWzBdID0geDtcbiAgY29vcmRpbmF0ZVsxXSA9IHk7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogU2NhbGUgYGNvb3JkaW5hdGVgIGJ5IGBzY2FsZWAuIGBjb29yZGluYXRlYCBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmQgcmV0dXJuZWRcbiAqIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge3NjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZX0gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBzY2FsZSA9IDEuMjtcbiAqICAgICBzY2FsZUNvb3JkaW5hdGUoY29vcmQsIHNjYWxlKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWzkuNDIsIDU3LjU3OTk5OTZdXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUgZmFjdG9yLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKGNvb3JkaW5hdGUsIHNjYWxlKSB7XG4gIGNvb3JkaW5hdGVbMF0gKj0gc2NhbGU7XG4gIGNvb3JkaW5hdGVbMV0gKj0gc2NhbGU7XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZDEgRmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmQyIFNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gY29vcmQxIGFuZCBjb29yZDIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoY29vcmQxLCBjb29yZDIpIHtcbiAgdmFyIGR4ID0gY29vcmQxWzBdIC0gY29vcmQyWzBdO1xuICB2YXIgZHkgPSBjb29yZDFbMV0gLSBjb29yZDJbMV07XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmQxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSk7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIGNvb3JkaW5hdGUgdG8gYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IHNlZ21lbnQgTGluZSBzZWdtZW50ICgyXG4gKiBjb29yZGluYXRlcykuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGUgcG9pbnQgdG8gdGhlIGxpbmUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChjb29yZGluYXRlLCBzZWdtZW50KSB7XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoY29vcmRpbmF0ZSxcbiAgICBjbG9zZXN0T25TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpKTtcbn1cblxuXG4vKipcbiAqIEZvcm1hdCBhIGdlb2dyYXBoaWMgY29vcmRpbmF0ZSB3aXRoIHRoZSBoZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzLCBhbmRcbiAqIHNlY29uZHMuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7dG9TdHJpbmdIRE1TfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nSERNUyhjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNDfCsCA1OOKAsiA2MOKAsyBOIDfCsCA1MOKAsiA2MOKAsyBFJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ0hETVN9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkLCAxKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N8KwIDU44oCyIDYwLjDigLMgTiA3wrAgNTDigLIgNjAuMOKAsyBFJ1xuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBIZW1pc3BoZXJlLCBkZWdyZWVzLCBtaW51dGVzIGFuZCBzZWNvbmRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdIRE1TKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiBkZWdyZWVzVG9TdHJpbmdIRE1TKCdOUycsIGNvb3JkaW5hdGVbMV0sIG9wdF9mcmFjdGlvbkRpZ2l0cykgKyAnICcgK1xuICAgICAgICBkZWdyZWVzVG9TdHJpbmdIRE1TKCdFVycsIGNvb3JkaW5hdGVbMF0sIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cblxuLyoqXG4gKiBGb3JtYXQgYSBjb29yZGluYXRlIGFzIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nWFkoY29vcmQpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzgsIDQ4J1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIDEgZnJhY3Rpb25hbCBkaWdpdDpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIG91dCA9IHRvU3RyaW5nWFkoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzcuOCwgNDguMCdcbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gWFkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gZm9ybWF0KGNvb3JkaW5hdGUsICd7eH0sIHt5fScsIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvb3JkaW5hdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nzc1xuICovXG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciBoaWRkZW4gZmVhdHVyZS5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRvIGhhdmUgdGhlbSBzZWxlY3RhYmxlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19TRUxFQ1RBQkxFID0gJ29sLXNlbGVjdGFibGUnO1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0byBoYXZlIHRoZW0gdW5zZWxlY3RhYmxlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19VTlNFTEVDVEFCTEUgPSAnb2wtdW5zZWxlY3RhYmxlJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIHVuc3VwcG9ydGVkIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIGNvbnRyb2xzLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19DT05UUk9MID0gJ29sLWNvbnRyb2wnO1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyB0aGF0IHdlJ2xsIGdpdmUgdGhlIERPTSBlbGVtZW50cyB0aGF0IGFyZSBjb2xsYXBzZWQsIGkuZS5cbiAqIHRvIHRob3NlIGVsZW1lbnRzIHdoaWNoIHVzdWFsbHkgY2FuIGJlIGV4cGFuZGVkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBDTEFTU19DT0xMQVBTRUQgPSAnb2wtY29sbGFwc2VkJztcblxuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiBmb250IGZhbWlsaWVzIGZyb20gYSBmb250IHNwZWMuICBOb3RlIHRoYXQgdGhpcyBkb2Vzbid0IHdvcmtcbiAqIGZvciBmb250IGZhbWlsaWVzIHRoYXQgaGF2ZSBjb21tYXMgaW4gdGhlbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZz59IFRoZSBmb250IGZhbWlsaWVzIChvciBudWxsIGlmIHRoZSBpbnB1dCBzcGVjIGlzIGludmFsaWQpLlxuICovXG5leHBvcnQgdmFyIGdldEZvbnRGYW1pbGllcyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnQpIHtcbiAgICBpZiAoIXN0eWxlKSB7XG4gICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICAgIH1cbiAgICBpZiAoIShmb250IGluIGNhY2hlKSkge1xuICAgICAgc3R5bGUuZm9udCA9IGZvbnQ7XG4gICAgICB2YXIgZmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgICAgIHN0eWxlLmZvbnQgPSAnJztcbiAgICAgIGlmICghZmFtaWx5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FjaGVbZm9udF0gPSBmYW1pbHkuc3BsaXQoLyxcXHM/Lyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtmb250XTtcbiAgfTtcbn0pKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZG9tXG4gKi9cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBodG1sIGNhbnZhcyBlbGVtZW50IGFuZCByZXR1cm5zIGl0cyAyZCBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfd2lkdGggQ2FudmFzIHdpZHRoLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGVpZ2h0IENhbnZhcyBoZWlnaHQuXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFRoZSBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dDJEKG9wdF93aWR0aCwgb3B0X2hlaWdodCkge1xuICB2YXIgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpKTtcbiAgaWYgKG9wdF93aWR0aCkge1xuICAgIGNhbnZhcy53aWR0aCA9IG9wdF93aWR0aDtcbiAgfVxuICBpZiAob3B0X2hlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRfaGVpZ2h0O1xuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi8gKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBjb21wdXRlZCB3aWR0aCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVyV2lkdGgodHJ1ZSlgLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgaGVpZ2h0ICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCk7XG5cbiAgcmV0dXJuIGhlaWdodDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgTm9kZSB0byByZXBsYWNlIG9sZCBub2RlXG4gKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgVGhlIG5vZGUgdG8gYmUgcmVwbGFjZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VOb2RlKG5ld05vZGUsIG9sZE5vZGUpIHtcbiAgdmFyIHBhcmVudCA9IG9sZE5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgb2xkTm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge05vZGV9IFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgPyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKSB7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZWFzaW5nXG4gKi9cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3cgYW5kIHNwZWVkIHVwLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZUluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KHQsIDMpO1xufVxuXG5cbi8qKlxuICogU3RhcnQgZmFzdCBhbmQgc2xvdyBkb3duLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFzZU91dCh0KSB7XG4gIHJldHVybiAxIC0gZWFzZUluKDEgLSB0KTtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgdGhlbiBzbG93IGRvd24gYWdhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbkFuZE91dCh0KSB7XG4gIHJldHVybiAzICogdCAqIHQgLSAyICogdCAqIHQgKiB0O1xufVxuXG5cbi8qKlxuICogTWFpbnRhaW4gYSBjb25zdGFudCBzcGVlZCBvdmVyIHRpbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXIodCkge1xuICByZXR1cm4gdDtcbn1cblxuXG4vKipcbiAqIFN0YXJ0IHNsb3csIHNwZWVkIHVwLCBhbmQgYXQgdGhlIHZlcnkgZW5kIHNsb3cgZG93biBhZ2Fpbi4gIFRoaXMgaGFzIHRoZVxuICogc2FtZSBnZW5lcmFsIGJlaGF2aW9yIGFzIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSwgYnV0IHRoZSBmaW5hbFxuICogc2xvd2Rvd24gaXMgZGVsYXllZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwQW5kRG93bih0KSB7XG4gIGlmICh0IDwgMC41KSB7XG4gICAgcmV0dXJuIGluQW5kT3V0KDIgKiB0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSAtIGluQW5kT3V0KDIgKiAodCAtIDAuNSkpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhc2luZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzXG4gKi9cbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEtleSB0byB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSN1bkJ5S2V5fS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50c0tleVxuICogQHByb3BlcnR5IHtPYmplY3R9IFtiaW5kVG9dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gW2JvdW5kTGlzdGVuZXJdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNhbGxPbmNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbGV0ZUluZGV4XVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fG1vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogTGlzdGVuZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LlxuICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBldmVudCBwcm9wYWdhdGlvbiB3aWxsIHN0b3AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9ldmVudHMvRXZlbnQpfGZ1bmN0aW9uKG1vZHVsZTpvbC9ldmVudHMvRXZlbnQpOiBib29sZWFufSBMaXN0ZW5lckZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGxpc3RlbmVyT2JqIExpc3RlbmVyIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gQm91bmQgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopIHtcbiAgdmFyIGJvdW5kTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lck9iai5saXN0ZW5lcjtcbiAgICB2YXIgYmluZFRvID0gbGlzdGVuZXJPYmouYmluZFRvIHx8IGxpc3RlbmVyT2JqLnRhcmdldDtcbiAgICBpZiAobGlzdGVuZXJPYmouY2FsbE9uY2UpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkobGlzdGVuZXJPYmopO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdGVuZXIuY2FsbChiaW5kVG8sIGV2dCk7XG4gIH07XG4gIGxpc3RlbmVyT2JqLmJvdW5kTGlzdGVuZXIgPSBib3VuZExpc3RlbmVyO1xuICByZXR1cm4gYm91bmRMaXN0ZW5lcjtcbn1cblxuXG4vKipcbiAqIEZpbmRzIHRoZSBtYXRjaGluZyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGluIHRoZSBnaXZlbiBsaXN0ZW5lclxuICogYXJyYXkuXG4gKlxuICogQHBhcmFtIHshQXJyYXk8IW1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIFRoZSBgdGhpc2AgdmFsdWUgaW5zaWRlIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zZXREZWxldGVJbmRleCBTZXQgdGhlIGRlbGV0ZUluZGV4IG9uIHRoZSBtYXRjaGluZ1xuICogICAgIGxpc3RlbmVyLCBmb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+dW5saXN0ZW5CeUtleX0uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXx1bmRlZmluZWR9IFRoZSBtYXRjaGluZyBsaXN0ZW5lciBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9zZXREZWxldGVJbmRleCkge1xuICB2YXIgbGlzdGVuZXJPYmo7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgbGlzdGVuZXJPYmogPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKGxpc3RlbmVyT2JqLmxpc3RlbmVyID09PSBsaXN0ZW5lciAmJlxuICAgICAgICBsaXN0ZW5lck9iai5iaW5kVG8gPT09IG9wdF90aGlzKSB7XG4gICAgICBpZiAob3B0X3NldERlbGV0ZUluZGV4KSB7XG4gICAgICAgIGxpc3RlbmVyT2JqLmRlbGV0ZUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaXN0ZW5lck9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pnx1bmRlZmluZWR9IExpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgdmFyIGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtO1xuICByZXR1cm4gbGlzdGVuZXJNYXAgPyBsaXN0ZW5lck1hcFt0eXBlXSA6IHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbG9va3VwIG9mIGxpc3RlbmVycy4gIElmIG9uZSBkb2VzIG5vdCBleGlzdCBvbiB0aGUgdGFyZ2V0LCBpdCBpc1xuICogY3JlYXRlZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcmV0dXJuIHshT2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT4+fSBNYXAgb2ZcbiAqICAgICBsaXN0ZW5lcnMgYnkgZXZlbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0KSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IHRhcmdldC5vbF9sbTtcbiAgaWYgKCFsaXN0ZW5lck1hcCkge1xuICAgIGxpc3RlbmVyTWFwID0gdGFyZ2V0Lm9sX2xtID0ge307XG4gIH1cbiAgcmV0dXJuIGxpc3RlbmVyTWFwO1xufVxuXG5cbi8qKlxuICogQ2xlYW4gdXAgYWxsIGxpc3RlbmVyIG9iamVjdHMgb2YgdGhlIGdpdmVuIHR5cGUuICBBbGwgcHJvcGVydGllcyBvbiB0aGVcbiAqIGxpc3RlbmVyIG9iamVjdHMgd2lsbCBiZSByZW1vdmVkLCBhbmQgaWYgbm8gbGlzdGVuZXJzIHJlbWFpbiBpbiB0aGUgbGlzdGVuZXJcbiAqIG1hcCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0uYm91bmRMaXN0ZW5lcik7XG4gICAgICBjbGVhcihsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB2YXIgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG07XG4gICAgaWYgKGxpc3RlbmVyTWFwKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJNYXBbdHlwZV07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJNYXApLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0Lm9sX2xtO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIHRvIGEgYHRoaXNgIG9iamVjdCwgYW5kIHJldHVybnNcbiAqIGEga2V5IGZvciB1c2Ugd2l0aCB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c351bmxpc3RlbkJ5S2V5fS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9vbmNlIElmIHRydWUsIGFkZCB0aGUgbGlzdGVuZXIgYXMgb25lLW9mZiBsaXN0ZW5lci5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fSBVbmlxdWUga2V5IGZvciB0aGUgbGlzdGVuZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIG9wdF9vbmNlKSB7XG4gIHZhciBsaXN0ZW5lck1hcCA9IGdldExpc3RlbmVyTWFwKHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5lck1hcFt0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lck1hcFt0eXBlXSA9IFtdO1xuICB9XG4gIHZhciBsaXN0ZW5lck9iaiA9IGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgZmFsc2UpO1xuICBpZiAobGlzdGVuZXJPYmopIHtcbiAgICBpZiAoIW9wdF9vbmNlKSB7XG4gICAgICAvLyBUdXJuIG9uZS1vZmYgbGlzdGVuZXIgaW50byBhIHBlcm1hbmVudCBvbmUuXG4gICAgICBsaXN0ZW5lck9iai5jYWxsT25jZSA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lck9iaiA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9ICovICh7XG4gICAgICBiaW5kVG86IG9wdF90aGlzLFxuICAgICAgY2FsbE9uY2U6ICEhb3B0X29uY2UsXG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopKTtcbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lck9iaik7XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJPYmo7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBvbmUtb2ZmIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudFRhcmdldH5FdmVudFRhcmdldExpa2V9IHRhcmdldCBFdmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzfkxpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IEtleSBmb3IgdW5saXN0ZW5CeUtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbk9uY2UodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMpIHtcbiAgcmV0dXJuIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUbyByZXR1cm4gYSBsaXN0ZW5lciwgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZVxuICogYXJndW1lbnRzIHRoYXQgd2VyZSB1c2VkIGZvciBhIHByZXZpb3VzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gY2FsbC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnRUYXJnZXR+RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X3RoaXMgT2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIGB0aGlzYCBrZXl3b3JkIGluIHRoZVxuICogICAgIGxpc3RlbmVyLiBEZWZhdWx0IGlzIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBsaXN0ZW5lck9iaiA9IGZpbmRMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyLCBvcHRfdGhpcywgdHJ1ZSk7XG4gICAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGxpc3RlbmVyT2JqKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIGtleSByZXR1cm5lZCBmcm9tXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IG9yIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbk9uY2V9LlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9IGtleSBUaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5CeUtleShrZXkpIHtcbiAgaWYgKGtleSAmJiBrZXkudGFyZ2V0KSB7XG4gICAga2V5LnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGtleS50eXBlLCBrZXkuYm91bmRMaXN0ZW5lcik7XG4gICAgdmFyIGxpc3RlbmVycyA9IGdldExpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdmFyIGkgPSAnZGVsZXRlSW5kZXgnIGluIGtleSA/IGtleS5kZWxldGVJbmRleCA6IGxpc3RlbmVycy5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsZWFyKGtleSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQWxsKHRhcmdldCkge1xuICB2YXIgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICBmb3IgKHZhciB0eXBlIGluIGxpc3RlbmVyTWFwKSB7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFN0cmlwcGVkIGRvd24gaW1wbGVtZW50YXRpb24gb2YgdGhlIFczQyBET00gTGV2ZWwgMiBFdmVudCBpbnRlcmZhY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtaW50ZXJmYWNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSBwcm92aWRlcyBgdHlwZWAgYW5kIGB0YXJnZXRgIHByb3BlcnRpZXMsIGFuZFxuICogYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgbWV0aG9kcy4gSXQgaXMgbWVhbnQgYXMgYmFzZSBjbGFzc1xuICogZm9yIGhpZ2hlciBsZXZlbCBldmVudHMgZGVmaW5lZCBpbiB0aGUgbGlicmFyeSwgYW5kIHdvcmtzIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fkV2ZW50VGFyZ2V0fS5cbiAqL1xudmFyIEV2ZW50ID0gZnVuY3Rpb24gRXZlbnQodHlwZSkge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkO1xuXG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvKipcbiAgICogVGhlIGV2ZW50IHRhcmdldC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGFwaVxuICAgKi9cbiAgdGhpcy50YXJnZXQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0ICgpIHtcbiAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24gKCkge1xuICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldnQpIHtcbiAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUYXJnZXRcbiAqL1xuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQge3VubGlzdGVuQWxsfSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtFdmVudFRhcmdldHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fSBFdmVudFRhcmdldExpa2VcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG52YXIgRXZlbnRUYXJnZXQgPSAoZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG5cbiAgICBEaXNwb3NhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5kaXNwYXRjaGluZ18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbj4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzXyA9IHt9O1xuXG4gIH1cblxuICBpZiAoIERpc3Bvc2FibGUgKSBFdmVudFRhcmdldC5fX3Byb3RvX18gPSBEaXNwb3NhYmxlO1xuICBFdmVudFRhcmdldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBEaXNwb3NhYmxlICYmIERpc3Bvc2FibGUucHJvdG90eXBlICk7XG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50VGFyZ2V0O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdID0gW107XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCBjYWxscyBhbGwgbGlzdGVuZXJzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAqIG9mIHRoaXMgdHlwZS4gVGhlIGV2ZW50IHBhcmFtZXRlciBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGFuXG4gICAqIE9iamVjdCB3aXRoIGEgYHR5cGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3t0eXBlOiBzdHJpbmcsXG4gICAqICAgICB0YXJnZXQ6IChFdmVudFRhcmdldHxtb2R1bGU6b2wvZXZlbnRzL0V2ZW50VGFyZ2V0fHVuZGVmaW5lZCl9fFxuICAgKiAgICAgbW9kdWxlOm9sL2V2ZW50cy9FdmVudHxzdHJpbmd9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IGBmYWxzZWAgaWYgYW55b25lIGNhbGxlZCBwcmV2ZW50RGVmYXVsdCBvbiB0aGVcbiAgICogICAgIGV2ZW50IG9iamVjdCBvciBpZiBhbnkgb2YgdGhlIGxpc3RlbmVycyByZXR1cm5lZCBmYWxzZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCAoZXZlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBldnQgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnID8gbmV3IEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICAgIHZhciB0eXBlID0gZXZ0LnR5cGU7XG4gICAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICB2YXIgcHJvcGFnYXRlO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5kaXNwYXRjaGluZ18pKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hpbmdfW3R5cGVdID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfW3R5cGVdID0gMDtcbiAgICAgIH1cbiAgICAgICsrdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmNhbGwodGhpcyQxLCBldnQpID09PSBmYWxzZSB8fCBldnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgcHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC0tdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICBpZiAodGhpcy5kaXNwYXRjaGluZ19bdHlwZV0gPT09IDApIHtcbiAgICAgICAgdmFyIHBlbmRpbmdSZW1vdmFscyA9IHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgICAgd2hpbGUgKHBlbmRpbmdSZW1vdmFscy0tKSB7XG4gICAgICAgICAgdGhpcyQxLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgVU5ERUZJTkVEKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGFnYXRlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHVubGlzdGVuQWxsKHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS4gTGlzdGVuZXJzIGFyZSByZXR1cm5lZCBpbiB0aGVcbiAgICogb3JkZXIgdGhhdCB0aGV5IHdpbGwgYmUgY2FsbGVkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL2V2ZW50c35MaXN0ZW5lckZ1bmN0aW9uPn0gTGlzdGVuZXJzLlxuICAgKi9cbiAgRXZlbnRUYXJnZXQucHJvdG90eXBlLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldExpc3RlbmVycyAodHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3R5cGUgVHlwZS4gSWYgbm90IHByb3ZpZGVkLFxuICAgKiAgICAgYHRydWVgIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhpcyBFdmVudFRhcmdldCBoYXMgYW55IGxpc3RlbmVycy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGxpc3RlbmVycy5cbiAgICovXG4gIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5oYXNMaXN0ZW5lciA9IGZ1bmN0aW9uIGhhc0xpc3RlbmVyIChvcHRfdHlwZSkge1xuICAgIHJldHVybiBvcHRfdHlwZSA/XG4gICAgICBvcHRfdHlwZSBpbiB0aGlzLmxpc3RlbmVyc18gOlxuICAgICAgT2JqZWN0LmtleXModGhpcy5saXN0ZW5lcnNfKS5sZW5ndGggPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHN+TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1t0eXBlXTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAodHlwZSBpbiB0aGlzLnBlbmRpbmdSZW1vdmFsc18pIHtcbiAgICAgICAgLy8gbWFrZSBsaXN0ZW5lciBhIG5vLW9wLCBhbmQgcmVtb3ZlIGxhdGVyIGluICNkaXNwYXRjaEV2ZW50KClcbiAgICAgICAgbGlzdGVuZXJzW2luZGV4XSA9IFVOREVGSU5FRDtcbiAgICAgICAgKyt0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBFdmVudFRhcmdldDtcbn0oRGlzcG9zYWJsZSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50VGFyZ2V0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFRhcmdldC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBHZW5lcmljIGNoYW5nZSBldmVudC4gVHJpZ2dlcmVkIHdoZW4gdGhlIHJldmlzaW9uIGNvdW50ZXIgaXMgaW5jcmVhc2VkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2V2ZW50cy9FdmVudH5FdmVudCNjaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgQ0hBTkdFOiAnY2hhbmdlJyxcblxuICBDTEVBUjogJ2NsZWFyJyxcbiAgQ09OVEVYVE1FTlU6ICdjb250ZXh0bWVudScsXG4gIENMSUNLOiAnY2xpY2snLFxuICBEQkxDTElDSzogJ2RibGNsaWNrJyxcbiAgRFJBR0VOVEVSOiAnZHJhZ2VudGVyJyxcbiAgRFJBR09WRVI6ICdkcmFnb3ZlcicsXG4gIERST1A6ICdkcm9wJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEtFWURPV046ICdrZXlkb3duJyxcbiAgS0VZUFJFU1M6ICdrZXlwcmVzcycsXG4gIExPQUQ6ICdsb2FkJyxcbiAgTU9VU0VET1dOOiAnbW91c2Vkb3duJyxcbiAgTU9VU0VNT1ZFOiAnbW91c2Vtb3ZlJyxcbiAgTU9VU0VPVVQ6ICdtb3VzZW91dCcsXG4gIE1PVVNFVVA6ICdtb3VzZXVwJyxcbiAgTU9VU0VXSEVFTDogJ21vdXNld2hlZWwnLFxuICBNU1BPSU5URVJET1dOOiAnTVNQb2ludGVyRG93bicsXG4gIFJFU0laRTogJ3Jlc2l6ZScsXG4gIFRPVUNIU1RBUlQ6ICd0b3VjaHN0YXJ0JyxcbiAgVE9VQ0hNT1ZFOiAndG91Y2htb3ZlJyxcbiAgVE9VQ0hFTkQ6ICd0b3VjaGVuZCcsXG4gIFdIRUVMOiAnd2hlZWwnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50cy9LZXlDb2RlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEVGVDogMzcsXG4gIFVQOiAzOCxcbiAgUklHSFQ6IDM5LFxuICBET1dOOiA0MFxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5Q29kZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL2NvbmRpdGlvblxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7VFJVRSwgRkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1dFQktJVCwgTUFDfSBmcm9tICcuLi9oYXMuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50KTogYm9vbGVhbn0gQ29uZGl0aW9uXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuXG4gKiBhZGRpdGlvbmFsbHkgdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgYWx0IGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGFsdEtleU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgcmV0dXJuIChcbiAgICBvcmlnaW5hbEV2ZW50LmFsdEtleSAmJlxuICAgICAgIShvcmlnaW5hbEV2ZW50Lm1ldGFLZXkgfHwgb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICAgIW9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgYWx0LWtleSBhbmQgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiAoZS5nLiB3aGVuIGFkZGl0aW9uYWxseSB0aGUgcGxhdGZvcm0tbW9kaWZpZXIta2V5IGlzIHByZXNzZWQpLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgYWx0U2hpZnRLZXlzT25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50O1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy4gVGhpcyBjb25kaXRpb24gcmVxdWlyZXMgYSBtYXAgdGFyZ2V0XG4gKiBlbGVtZW50IHdpdGggYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSwgZS5nLiBgPGRpdiBpZD1cIm1hcFwiIHRhYmluZGV4PVwiMVwiPmAuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBldmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBtYXAgaGFzIHRoZSBmb2N1cy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBmb2N1cyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50YXJnZXQuZ2V0VGFyZ2V0RWxlbWVudCgpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbHdheXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUuXG4gKiBAZnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBhbHdheXMgPSBUUlVFO1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBgY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgY2xpY2sgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuQ0xJQ0s7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFzIGFuIFwiYWN0aW9uXCItcHJvZHVjaW5nIG1vdXNlIGJ1dHRvbi5cbiAqXG4gKiBCeSBkZWZpbml0aW9uLCB0aGlzIGluY2x1ZGVzIGxlZnQtY2xpY2sgb24gd2luZG93cy9saW51eCwgYW5kIGxlZnQtY2xpY2tcbiAqIHdpdGhvdXQgdGhlIGN0cmwga2V5IG9uIE1hY3MuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0LlxuICovXG5leHBvcnQgdmFyIG1vdXNlQWN0aW9uQnV0dG9uID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gIHJldHVybiBvcmlnaW5hbEV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAhKFdFQktJVCAmJiBNQUMgJiYgb3JpZ2luYWxFdmVudC5jdHJsS2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYWx3YXlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UuXG4gKiBAZnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBuZXZlciA9IEZBTFNFO1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgYnJvd3NlciBldmVudCBpcyBhIGBwb2ludGVybW92ZWAgZXZlbnQsIGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHBvaW50ZXJNb3ZlID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSAncG9pbnRlcm1vdmUnO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBzaW5nbGVjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBzaW5nbGVDbGljayA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5TSU5HTEVDTElDSztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBpcyBhIG1hcCBgZGJsY2xpY2tgIGV2ZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgZG91YmxlQ2xpY2sgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0s7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBubyBtb2RpZmllciBrZXkgKGFsdC0sIHNoaWZ0LSBvciBwbGF0Zm9ybS1tb2RpZmllci1rZXkpIGlzXG4gKiBwcmVzc2VkLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZXJlIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgbm9Nb2RpZmllcktleXMgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG9yaWdpbmFsRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHlcbiAqIHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG9ubHkgdGhlIHBsYXRmb3JtIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHBsYXRmb3JtTW9kaWZpZXJLZXlPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gIHJldHVybiAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAoTUFDID8gb3JpZ2luYWxFdmVudC5tZXRhS2V5IDogb3JpZ2luYWxFdmVudC5jdHJsS2V5KSAmJlxuICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgb25seSB0aGUgc2hpZnQta2V5IGlzIHByZXNzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlIChlLmcuIHdoZW5cbiAqIGFkZGl0aW9uYWxseSB0aGUgYWx0LWtleSBpcyBwcmVzc2VkKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb25seSB0aGUgc2hpZnQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgc2hpZnRLZXlPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBvcmlnaW5hbEV2ZW50ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gIHJldHVybiAoXG4gICAgIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUsIGkuZS4gbm90IGEgYDxpbnB1dD5gLSxcbiAqIGA8c2VsZWN0PmAtIG9yIGA8dGV4dGFyZWE+YC1lbGVtZW50LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb25seSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHRhcmdldE5vdEVkaXRhYmxlID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudC50YXJnZXQ7XG4gIHZhciB0YWdOYW1lID0gdGFyZ2V0LnRhZ05hbWU7XG4gIHJldHVybiAoXG4gICAgdGFnTmFtZSAhPT0gJ0lOUFVUJyAmJlxuICAgICAgdGFnTmFtZSAhPT0gJ1NFTEVDVCcgJiZcbiAgICAgIHRhZ05hbWUgIT09ICdURVhUQVJFQScpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIG1vdXNlIGRldmljZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBtb3VzZU9ubHkgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgYXNzZXJ0KG1hcEJyb3dzZXJFdmVudC5wb2ludGVyRXZlbnQsIDU2KTsgLy8gbWFwQnJvd3NlckV2ZW50IG11c3Qgb3JpZ2luYXRlIGZyb20gYSBwb2ludGVyIGV2ZW50XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyN3aWRsLVBvaW50ZXJFdmVudC1wb2ludGVyVHlwZVxuICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudCkucG9pbnRlckV2ZW50LnBvaW50ZXJUeXBlID09ICdtb3VzZSdcbiAgKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIgaW5cbiAqIGNvbnRhY3Qgd2l0aCB0aGUgc3VyZmFjZSBvciBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC5cbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgcHJpbWFyeSBwb2ludGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHByaW1hcnlBY3Rpb24gPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHBvaW50ZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudC5wb2ludGVyRXZlbnQ7XG4gIHJldHVybiBwb2ludGVyRXZlbnQuaXNQcmltYXJ5ICYmIHBvaW50ZXJFdmVudC5idXR0b24gPT09IDA7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25kaXRpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGV4dGVudDogYFttaW54LCBtaW55LCBtYXh4LCBtYXh5XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IEV4dGVudFxuICogQGFwaVxuICovXG5cbi8qKlxuICogQnVpbGQgYW4gZXh0ZW50IHRoYXQgaW5jbHVkZXMgYWxsIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBCb3VuZGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcykge1xuICB2YXIgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHhzIFhzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0geXMgWXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZnVuY3Rpb24gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgb3B0X2V4dGVudCkge1xuICB2YXIgbWluWCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHhzKTtcbiAgdmFyIG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIHZhciBtYXhYID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeHMpO1xuICB2YXIgbWF4WSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHlzKTtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGV4dGVudCBpbmNyZWFzZWQgYnkgdGhlIHByb3ZpZGVkIHZhbHVlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYW1vdW50IGJ5IHdoaWNoIHRoZSBleHRlbnQgc2hvdWxkIGJlIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcihleHRlbnQsIHZhbHVlLCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXSAtIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzJdID0gZXh0ZW50WzJdICsgdmFsdWU7XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXSArIHZhbHVlO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICBleHRlbnRbMF0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsxXSAtIHZhbHVlLFxuICAgICAgZXh0ZW50WzJdICsgdmFsdWUsXG4gICAgICBleHRlbnRbM10gKyB2YWx1ZVxuICAgIF07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBhbiBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBUaGUgY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShleHRlbnQsIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gZXh0ZW50WzBdO1xuICAgIG9wdF9leHRlbnRbMV0gPSBleHRlbnRbMV07XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXTtcbiAgICBvcHRfZXh0ZW50WzNdID0gZXh0ZW50WzNdO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHRlbnQuc2xpY2UoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7bnVtYmVyfSBDbG9zZXN0IHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkoZXh0ZW50LCB4LCB5KSB7XG4gIHZhciBkeCwgZHk7XG4gIGlmICh4IDwgZXh0ZW50WzBdKSB7XG4gICAgZHggPSBleHRlbnRbMF0gLSB4O1xuICB9IGVsc2UgaWYgKGV4dGVudFsyXSA8IHgpIHtcbiAgICBkeCA9IHggLSBleHRlbnRbMl07XG4gIH0gZWxzZSB7XG4gICAgZHggPSAwO1xuICB9XG4gIGlmICh5IDwgZXh0ZW50WzFdKSB7XG4gICAgZHkgPSBleHRlbnRbMV0gLSB5O1xuICB9IGVsc2UgaWYgKGV4dGVudFszXSA8IHkpIHtcbiAgICBkeSA9IHkgLSBleHRlbnRbM107XG4gIH0gZWxzZSB7XG4gICAgZHkgPSAwO1xuICB9XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgb3Igb24gdGhlIGVkZ2Ugb2YgdGhlIGV4dGVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY29vcmRpbmF0ZSBpcyBjb250YWluZWQgaW4gdGhlIGV4dGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbn1cblxuXG4vKipcbiAqIENoZWNrIGlmIG9uZSBleHRlbnQgY29udGFpbnMgYW5vdGhlci5cbiAqXG4gKiBBbiBleHRlbnQgaXMgZGVlbWVkIGNvbnRhaW5lZCBpZiBpdCBsaWVzIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBvdGhlciBleHRlbnQsXG4gKiBpbmNsdWRpbmcgaWYgdGhleSBzaGFyZSBvbmUgb3IgbW9yZSBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlswXSAmJiBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlsxXSAmJiBleHRlbnQyWzNdIDw9IGV4dGVudDFbM107XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB4LCB5IHZhbHVlcyBhcmUgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1hZKGV4dGVudCwgeCwgeSkge1xuICByZXR1cm4gZXh0ZW50WzBdIDw9IHggJiYgeCA8PSBleHRlbnRbMl0gJiYgZXh0ZW50WzFdIDw9IHkgJiYgeSA8PSBleHRlbnRbM107XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGEgY29vcmRpbmF0ZSBhbmQgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50L1JlbGF0aW9uc2hpcH0gVGhlIHJlbGF0aW9uc2hpcCAoYml0d2lzZSBjb21wYXJlIHdpdGhcbiAqICAgICBtb2R1bGU6b2wvZXh0ZW50L1JlbGF0aW9uc2hpcH5SZWxhdGlvbnNoaXApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgdmFyIG1pblggPSBleHRlbnRbMF07XG4gIHZhciBtaW5ZID0gZXh0ZW50WzFdO1xuICB2YXIgbWF4WCA9IGV4dGVudFsyXTtcbiAgdmFyIG1heFkgPSBleHRlbnRbM107XG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdO1xuICB2YXIgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLlVOS05PV047XG4gIGlmICh4IDwgbWluWCkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5MRUZUO1xuICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLlJJR0hUO1xuICB9XG4gIGlmICh5IDwgbWluWSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5CRUxPVztcbiAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcCB8IFJlbGF0aW9uc2hpcC5BQk9WRTtcbiAgfVxuICBpZiAocmVsYXRpb25zaGlwID09PSBSZWxhdGlvbnNoaXAuVU5LTk9XTikge1xuICAgIHJlbGF0aW9uc2hpcCA9IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkc7XG4gIH1cbiAgcmV0dXJuIHJlbGF0aW9uc2hpcDtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbXB0eSBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRW1wdHkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpIHtcbiAgaWYgKG9wdF9leHRlbnQpIHtcbiAgICBvcHRfZXh0ZW50WzBdID0gbWluWDtcbiAgICBvcHRfZXh0ZW50WzFdID0gbWluWTtcbiAgICBvcHRfZXh0ZW50WzJdID0gbWF4WDtcbiAgICBvcHRfZXh0ZW50WzNdID0gbWF4WTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW21pblgsIG1pblksIG1heFgsIG1heFldO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW1wdHkgZXh0ZW50IG9yIG1ha2UgdGhlIHByb3ZpZGVkIG9uZSBlbXB0eS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgIEluZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHksIG9wdF9leHRlbnQpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlLCBvcHRfZXh0ZW50KSB7XG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoeCwgeSwgeCwgeSwgb3B0X2V4dGVudCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbVJpbmdzKHJpbmdzLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpO1xuICByZXR1cm4gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncyk7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBhcmUgZXF1aXZhbGVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhleHRlbnQxLCBleHRlbnQyKSB7XG4gIHJldHVybiBleHRlbnQxWzBdID09IGV4dGVudDJbMF0gJiYgZXh0ZW50MVsyXSA9PSBleHRlbnQyWzJdICYmXG4gICAgICBleHRlbnQxWzFdID09IGV4dGVudDJbMV0gJiYgZXh0ZW50MVszXSA9PSBleHRlbnQyWzNdO1xufVxuXG5cbi8qKlxuICogTW9kaWZ5IGFuIGV4dGVudCB0byBpbmNsdWRlIGFub3RoZXIgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MSBUaGUgZXh0ZW50IHRvIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBUaGUgZXh0ZW50IHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gQSByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IChleHRlbmRlZCkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgaWYgKGV4dGVudDJbMF0gPCBleHRlbnQxWzBdKSB7XG4gICAgZXh0ZW50MVswXSA9IGV4dGVudDJbMF07XG4gIH1cbiAgaWYgKGV4dGVudDJbMl0gPiBleHRlbnQxWzJdKSB7XG4gICAgZXh0ZW50MVsyXSA9IGV4dGVudDJbMl07XG4gIH1cbiAgaWYgKGV4dGVudDJbMV0gPCBleHRlbnQxWzFdKSB7XG4gICAgZXh0ZW50MVsxXSA9IGV4dGVudDJbMV07XG4gIH1cbiAgaWYgKGV4dGVudDJbM10gPiBleHRlbnQxWzNdKSB7XG4gICAgZXh0ZW50MVszXSA9IGV4dGVudDJbM107XG4gIH1cbiAgcmV0dXJuIGV4dGVudDE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBpZiAoY29vcmRpbmF0ZVswXSA8IGV4dGVudFswXSkge1xuICAgIGV4dGVudFswXSA9IGNvb3JkaW5hdGVbMF07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMF0gPiBleHRlbnRbMl0pIHtcbiAgICBleHRlbnRbMl0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzFdIDwgZXh0ZW50WzFdKSB7XG4gICAgZXh0ZW50WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA+IGV4dGVudFszXSkge1xuICAgIGV4dGVudFszXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEZsYXRDb29yZGluYXRlcyhleHRlbnQsIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgZXh0ZW5kWFkoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IHJpbmdzIFJpbmdzLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFJpbmdzKGV4dGVudCwgcmluZ3MpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmluZ3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGV4dGVuZENvb3JkaW5hdGVzKGV4dGVudCwgcmluZ3NbaV0pO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRYWShleHRlbnQsIHgsIHkpIHtcbiAgZXh0ZW50WzBdID0gTWF0aC5taW4oZXh0ZW50WzBdLCB4KTtcbiAgZXh0ZW50WzFdID0gTWF0aC5taW4oZXh0ZW50WzFdLCB5KTtcbiAgZXh0ZW50WzJdID0gTWF0aC5tYXgoZXh0ZW50WzJdLCB4KTtcbiAgZXh0ZW50WzNdID0gTWF0aC5tYXgoZXh0ZW50WzNdLCB5KTtcbn1cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYGNhbGxiYWNrYCBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXQgdmFsdWVcbiAqIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VCwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6IFN9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtUPX0gb3B0X3RoaXMgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7U3xib29sZWFufSBWYWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTLCBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoQ29ybmVyKGV4dGVudCwgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIHZhciB2YWw7XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldEJvdHRvbUxlZnQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldEJvdHRvbVJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRUb3BSaWdodChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0VG9wTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGV4dGVudCkge1xuICB2YXIgYXJlYSA9IDA7XG4gIGlmICghaXNFbXB0eShleHRlbnQpKSB7XG4gICAgYXJlYSA9IGdldFdpZHRoKGV4dGVudCkgKiBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIGxlZnQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQm90dG9tIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJvdHRvbUxlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBib3R0b20gcmlnaHQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQm90dG9tIHJpZ2h0IGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb3R0b21SaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0sIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGNlbnRlciBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDZW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIoZXh0ZW50KSB7XG4gIHJldHVybiBbKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDJdO1xufVxuXG5cbi8qKlxuICogR2V0IGEgY29ybmVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudC9Db3JuZXJ9IGNvcm5lciBDb3JuZXIuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb3JuZXIgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvcm5lcihleHRlbnQsIGNvcm5lcikge1xuICB2YXIgY29vcmRpbmF0ZTtcbiAgaWYgKGNvcm5lciA9PT0gQ29ybmVyLkJPVFRPTV9MRUZUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbUxlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5CT1RUT01fUklHSFQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5UT1BfTEVGVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuVE9QX1JJR0hUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAxMyk7IC8vIEludmFsaWQgY29ybmVyXG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKiogQHR5cGUgeyFtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSAqLyAoY29vcmRpbmF0ZSlcbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmxhcmdlZCBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5sYXJnZWRBcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgdmFyIG1pblggPSBNYXRoLm1pbihleHRlbnQxWzBdLCBleHRlbnQyWzBdKTtcbiAgdmFyIG1pblkgPSBNYXRoLm1pbihleHRlbnQxWzFdLCBleHRlbnQyWzFdKTtcbiAgdmFyIG1heFggPSBNYXRoLm1heChleHRlbnQxWzJdLCBleHRlbnQyWzJdKTtcbiAgdmFyIG1heFkgPSBNYXRoLm1heChleHRlbnQxWzNdLCBleHRlbnQyWzNdKTtcbiAgcmV0dXJuIChtYXhYIC0gbWluWCkgKiAobWF4WSAtIG1pblkpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGR4ID0gcmVzb2x1dGlvbiAqIHNpemVbMF0gLyAyO1xuICB2YXIgZHkgPSByZXNvbHV0aW9uICogc2l6ZVsxXSAvIDI7XG4gIHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgdmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4ocm90YXRpb24pO1xuICB2YXIgeENvcyA9IGR4ICogY29zUm90YXRpb247XG4gIHZhciB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgdmFyIHlDb3MgPSBkeSAqIGNvc1JvdGF0aW9uO1xuICB2YXIgeVNpbiA9IGR5ICogc2luUm90YXRpb247XG4gIHZhciB4ID0gY2VudGVyWzBdO1xuICB2YXIgeSA9IGNlbnRlclsxXTtcbiAgdmFyIHgwID0geCAtIHhDb3MgKyB5U2luO1xuICB2YXIgeDEgPSB4IC0geENvcyAtIHlTaW47XG4gIHZhciB4MiA9IHggKyB4Q29zIC0geVNpbjtcbiAgdmFyIHgzID0geCArIHhDb3MgKyB5U2luO1xuICB2YXIgeTAgPSB5IC0geFNpbiAtIHlDb3M7XG4gIHZhciB5MSA9IHkgLSB4U2luICsgeUNvcztcbiAgdmFyIHkyID0geSArIHhTaW4gKyB5Q29zO1xuICB2YXIgeTMgPSB5ICsgeFNpbiAtIHlDb3M7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksIE1hdGgubWF4KHkwLCB5MSwgeTIsIHkzKSxcbiAgICBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhlaWdodChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFszXSAtIGV4dGVudFsxXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnNlY3Rpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICB2YXIgaW50ZXJzZWN0aW9uID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIpO1xuICByZXR1cm4gZ2V0QXJlYShpbnRlcnNlY3Rpb24pO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGV4dGVudHMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IE9wdGlvbmFsIGV4dGVudCB0byBwb3B1bGF0ZSB3aXRoIGludGVyc2VjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIG9wdF9leHRlbnQpIHtcbiAgdmFyIGludGVyc2VjdGlvbiA9IG9wdF9leHRlbnQgPyBvcHRfZXh0ZW50IDogY3JlYXRlRW1wdHkoKTtcbiAgaWYgKGludGVyc2VjdHMoZXh0ZW50MSwgZXh0ZW50MikpIHtcbiAgICBpZiAoZXh0ZW50MVswXSA+IGV4dGVudDJbMF0pIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDFbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblswXSA9IGV4dGVudDJbMF07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzFdID4gZXh0ZW50MlsxXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzFdID0gZXh0ZW50MlsxXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMl0gPCBleHRlbnQyWzJdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQxWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMl0gPSBleHRlbnQyWzJdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVszXSA8IGV4dGVudDJbM10pIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDFbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblszXSA9IGV4dGVudDJbM107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoaW50ZXJzZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWFyZ2luLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFyZ2luKGV4dGVudCkge1xuICByZXR1cm4gZ2V0V2lkdGgoZXh0ZW50KSArIGdldEhlaWdodChleHRlbnQpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFRoZSBleHRlbnQgc2l6ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemUoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdIC0gZXh0ZW50WzBdLCBleHRlbnRbM10gLSBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUb3AgbGVmdCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wTGVmdChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMF0sIGV4dGVudFszXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUb3AgcmlnaHQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcFJpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSwgZXh0ZW50WzNdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaWR0aChleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSAtIGV4dGVudFswXTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBvbmUgZXh0ZW50IGludGVyc2VjdHMgYW5vdGhlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQyIEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBpbnRlcnNlY3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlsyXSAmJlxuICAgICAgZXh0ZW50MVsyXSA+PSBleHRlbnQyWzBdICYmXG4gICAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbM10gJiZcbiAgICAgIGV4dGVudDFbM10gPj0gZXh0ZW50MlsxXTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBleHRlbnQgaXMgZW1wdHkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzJdIDwgZXh0ZW50WzBdIHx8IGV4dGVudFszXSA8IGV4dGVudFsxXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuT3JVcGRhdGUoZXh0ZW50LCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICAgIG9wdF9leHRlbnRbMl0gPSBleHRlbnRbMl07XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVGcm9tQ2VudGVyKGV4dGVudCwgdmFsdWUpIHtcbiAgdmFyIGRlbHRhWCA9ICgoZXh0ZW50WzJdIC0gZXh0ZW50WzBdKSAvIDIpICogKHZhbHVlIC0gMSk7XG4gIHZhciBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gc3RhcnQgU2VnbWVudCBzdGFydCBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICB2YXIgc3RhcnRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgc3RhcnQpO1xuICB2YXIgZW5kUmVsID0gY29vcmRpbmF0ZVJlbGF0aW9uc2hpcChleHRlbnQsIGVuZCk7XG4gIGlmIChzdGFydFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORyB8fFxuICAgICAgZW5kUmVsID09PSBSZWxhdGlvbnNoaXAuSU5URVJTRUNUSU5HKSB7XG4gICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1pblggPSBleHRlbnRbMF07XG4gICAgdmFyIG1pblkgPSBleHRlbnRbMV07XG4gICAgdmFyIG1heFggPSBleHRlbnRbMl07XG4gICAgdmFyIG1heFkgPSBleHRlbnRbM107XG4gICAgdmFyIHN0YXJ0WCA9IHN0YXJ0WzBdO1xuICAgIHZhciBzdGFydFkgPSBzdGFydFsxXTtcbiAgICB2YXIgZW5kWCA9IGVuZFswXTtcbiAgICB2YXIgZW5kWSA9IGVuZFsxXTtcbiAgICB2YXIgc2xvcGUgPSAoZW5kWSAtIHN0YXJ0WSkgLyAoZW5kWCAtIHN0YXJ0WCk7XG4gICAgdmFyIHgsIHk7XG4gICAgaWYgKCEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkgJiZcbiAgICAgICAgIShzdGFydFJlbCAmIFJlbGF0aW9uc2hpcC5BQk9WRSkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgdG9wXG4gICAgICB4ID0gZW5kWCAtICgoZW5kWSAtIG1heFkpIC8gc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHggPj0gbWluWCAmJiB4IDw9IG1heFg7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuUklHSFQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHJpZ2h0XG4gICAgICB5ID0gZW5kWSAtICgoZW5kWCAtIG1heFgpICogc2xvcGUpO1xuICAgICAgaW50ZXJzZWN0cyA9IHkgPj0gbWluWSAmJiB5IDw9IG1heFk7XG4gICAgfVxuICAgIGlmICghaW50ZXJzZWN0cyAmJiAhIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQkVMT1cpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGJvdHRvbVxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtaW5ZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkxFRlQpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuTEVGVCkpIHtcbiAgICAgIC8vIHBvdGVudGlhbGx5IGludGVyc2VjdHMgbGVmdFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtaW5YKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cblxuICB9XG4gIHJldHVybiBpbnRlcnNlY3RzO1xufVxuXG5cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1Gbiwgb3B0X2V4dGVudCkge1xuICB2YXIgY29vcmRpbmF0ZXMgPSBbXG4gICAgZXh0ZW50WzBdLCBleHRlbnRbMV0sXG4gICAgZXh0ZW50WzBdLCBleHRlbnRbM10sXG4gICAgZXh0ZW50WzJdLCBleHRlbnRbMV0sXG4gICAgZXh0ZW50WzJdLCBleHRlbnRbM11cbiAgXTtcbiAgdHJhbnNmb3JtRm4oY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzLCAyKTtcbiAgdmFyIHhzID0gW2Nvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1syXSwgY29vcmRpbmF0ZXNbNF0sIGNvb3JkaW5hdGVzWzZdXTtcbiAgdmFyIHlzID0gW2Nvb3JkaW5hdGVzWzFdLCBjb29yZGluYXRlc1szXSwgY29vcmRpbmF0ZXNbNV0sIGNvb3JkaW5hdGVzWzddXTtcbiAgcmV0dXJuIF9ib3VuZGluZ0V4dGVudFhZcyh4cywgeXMsIG9wdF9leHRlbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHRlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudC9Db3JuZXJcbiAqL1xuXG4vKipcbiAqIEV4dGVudCBjb3JuZXIuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEJPVFRPTV9MRUZUOiAnYm90dG9tLWxlZnQnLFxuICBCT1RUT01fUklHSFQ6ICdib3R0b20tcmlnaHQnLFxuICBUT1BfTEVGVDogJ3RvcC1sZWZ0JyxcbiAgVE9QX1JJR0hUOiAndG9wLXJpZ2h0J1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29ybmVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9leHRlbnQvUmVsYXRpb25zaGlwXG4gKi9cblxuLyoqXG4gKiBSZWxhdGlvbnNoaXAgdG8gYW4gZXh0ZW50LlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBVTktOT1dOOiAwLFxuICBJTlRFUlNFQ1RJTkc6IDEsXG4gIEFCT1ZFOiAyLFxuICBSSUdIVDogNCxcbiAgQkVMT1c6IDgsXG4gIExFRlQ6IDE2XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWxhdGlvbnNoaXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ZlYXR1cmVsb2FkZXJcbiAqL1xuaW1wb3J0IHtVTkRFRklORUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBGb3JtYXRUeXBlIGZyb20gJy4vZm9ybWF0L0Zvcm1hdFR5cGUuanMnO1xuXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogbG9hZCBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gcmVwcmVzZW50aW5nIHRoZSBhcmVhIHRvIGJlIGxvYWRlZCxcbiAqIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHJlc29sdXRpb24gKG1hcCB1bml0cyBwZXIgcGl4ZWwpIGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiAgYXNcbiAqIGFyZ3VtZW50cy4gYHRoaXNgIHdpdGhpbiB0aGUgZnVuY3Rpb24gaXMgYm91bmQgdG8gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IGl0J3MgY2FsbGVkIGZyb20uXG4gKlxuICogVGhlIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIHRoZSBmZWF0dXJlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlXG4gKiBzb3VyY2UuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczptb2R1bGU6b2wvc291cmNlL1ZlY3RvciwgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQsIG51bWJlcixcbiAqICAgICAgICAgICAgICAgICAgICBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uKX0gRmVhdHVyZUxvYWRlclxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvXG4gKiBnZXQgdGhlIHVybCB0byBsb2FkIGZlYXR1cmVzIGZyb20uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHJlcHJlc2VudGluZyB0aGUgYXJlYVxuICogdG8gYmUgbG9hZGVkLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSByZXNvbHV0aW9uIChtYXAgdW5pdHMgcGVyIHBpeGVsKVxuICogYW5kIGFuIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgVVJMLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50LCBudW1iZXIsIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24pOiBzdHJpbmd9IEZlYXR1cmVVcmxGdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xtb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlVXJsRnVuY3Rpb259IHVybCBGZWF0dXJlIFVSTCBzZXJ2aWNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZm9ybWF0L0ZlYXR1cmV9IGZvcm1hdCBGZWF0dXJlIGZvcm1hdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczptb2R1bGU6b2wvVmVjdG9yVGlsZSwgQXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPiwgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbiwgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQpfGZ1bmN0aW9uKHRoaXM6bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IsIEFycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT4pfSBzdWNjZXNzXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBmZWF0dXJlcyBhbmQgb3B0aW9uYWxseSB3aXRoIHRoZSBkYXRhXG4gKiAgICAgcHJvamVjdGlvbi4gQ2FsbGVkIHdpdGggdGhlIHZlY3RvciB0aWxlIG9yIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6bW9kdWxlOm9sL1ZlY3RvclRpbGUpfGZ1bmN0aW9uKHRoaXM6bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IpfSBmYWlsdXJlXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9hZGluZyBmYWlsZWQuIENhbGxlZCB3aXRoIHRoZSB2ZWN0b3IgdGlsZSBvclxuICogICAgIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlTG9hZGVyfSBUaGUgZmVhdHVyZSBsb2FkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmVhdHVyZXNYaHIodXJsLCBmb3JtYXQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHRoaXMge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfG1vZHVsZTpvbC9WZWN0b3JUaWxlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGV4dGVudCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbikge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsXG4gICAgICAgIHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicgPyB1cmwoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSA6IHVybCxcbiAgICAgICAgdHJ1ZSk7XG4gICAgICBpZiAoZm9ybWF0LmdldFR5cGUoKSA9PSBGb3JtYXRUeXBlLkFSUkFZX0JVRkZFUikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gc3RhdHVzIHdpbGwgYmUgMCBmb3IgZmlsZTovLyB1cmxzXG4gICAgICAgIGlmICgheGhyLnN0YXR1cyB8fCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmb3JtYXQuZ2V0VHlwZSgpO1xuICAgICAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR8Tm9kZXxPYmplY3R8c3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgIGlmICh0eXBlID09IEZvcm1hdFR5cGUuSlNPTiB8fCB0eXBlID09IEZvcm1hdFR5cGUuVEVYVCkge1xuICAgICAgICAgICAgc291cmNlID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gRm9ybWF0VHlwZS5YTUwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBGb3JtYXRUeXBlLkFSUkFZX0JVRkZFUikge1xuICAgICAgICAgICAgc291cmNlID0gLyoqIEB0eXBlIHtBcnJheUJ1ZmZlcn0gKi8gKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzLCBmb3JtYXQucmVhZEZlYXR1cmVzKHNvdXJjZSxcbiAgICAgICAgICAgICAge2ZlYXR1cmVQcm9qZWN0aW9uOiBwcm9qZWN0aW9ufSksXG4gICAgICAgICAgICBmb3JtYXQucmVhZFByb2plY3Rpb24oc291cmNlKSwgZm9ybWF0LmdldExhc3RFeHRlbnQoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFpbHVyZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhaWx1cmUuY2FsbCh0aGlzKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIFhIUiBmZWF0dXJlIGxvYWRlciBmb3IgYSBgdXJsYCBhbmQgYGZvcm1hdGAuIFRoZSBmZWF0dXJlIGxvYWRlclxuICogbG9hZHMgZmVhdHVyZXMgKHdpdGggWEhSKSwgcGFyc2VzIHRoZSBmZWF0dXJlcywgYW5kIGFkZHMgdGhlbSB0byB0aGVcbiAqIHZlY3RvciBzb3VyY2UuXG4gKiBAcGFyYW0ge3N0cmluZ3xtb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlVXJsRnVuY3Rpb259IHVybCBGZWF0dXJlIFVSTCBzZXJ2aWNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZm9ybWF0L0ZlYXR1cmV9IGZvcm1hdCBGZWF0dXJlIGZvcm1hdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVMb2FkZXJ9IFRoZSBmZWF0dXJlIGxvYWRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhocih1cmwsIGZvcm1hdCkge1xuICByZXR1cm4gbG9hZEZlYXR1cmVzWGhyKHVybCwgZm9ybWF0LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gZmVhdHVyZXMgVGhlIGxvYWRlZCBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGRhdGFQcm9qZWN0aW9uIERhdGFcbiAgICAgKiBwcm9qZWN0aW9uLlxuICAgICAqIEB0aGlzIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihmZWF0dXJlcywgZGF0YVByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuICAgIH0sIC8qIEZJWE1FIGhhbmRsZSBlcnJvciAqLyBVTkRFRklORUQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWF0dXJlbG9hZGVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9mb3JtYXQvRm9ybWF0VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBUlJBWV9CVUZGRVI6ICdhcnJheWJ1ZmZlcicsXG4gIEpTT046ICdqc29uJyxcbiAgVEVYVDogJ3RleHQnLFxuICBYTUw6ICd4bWwnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JtYXRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSBOb3RoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gVU5ERUZJTkVEKCkge31cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnVuY3Rpb25zLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0NpcmNsZVxuICovXG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlLCBmb3JFYWNoQ29ybmVyLCBpbnRlcnNlY3RzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlfSBmcm9tICcuLi9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2lyY2xlIGdlb21ldHJ5LlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIENpcmNsZSA9IChmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gQ2lyY2xlKGNlbnRlciwgb3B0X3JhZGl1cywgb3B0X2xheW91dCkge1xuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfcmFkaXVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIGNlbnRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMgPSBvcHRfcmFkaXVzID8gb3B0X3JhZGl1cyA6IDA7XG4gICAgICB0aGlzLnNldENlbnRlckFuZFJhZGl1cyhjZW50ZXIsIHJhZGl1cywgb3B0X2xheW91dCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIENpcmNsZS5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgQ2lyY2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBDaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvZ2VvbS9DaXJjbGV9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB1bmRlZmluZWQsIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGR4ID0geCAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdHJpZGU7ICsraSkge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5nZXRSYWRpdXMoKSAvIE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICBjbG9zZXN0UG9pbnRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyBkZWx0YSAqIGR4O1xuICAgICAgICBjbG9zZXN0UG9pbnRbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbMV0gKyBkZWx0YSAqIGR5O1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPCB0aGlzLnN0cmlkZTsgKytpJDEpIHtcbiAgICAgICAgICBjbG9zZXN0UG9pbnRbaSQxXSA9IGZsYXRDb29yZGluYXRlc1tpJDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gdGhpcy5zdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGR4ID0geCAtIGZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZHkgPSB5IC0gZmxhdENvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8PSB0aGlzLmdldFJhZGl1c1NxdWFyZWRfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgYXMge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiBnZXRDZW50ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgwLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmNvbXB1dGVFeHRlbnQgPSBmdW5jdGlvbiBjb21wdXRlRXh0ZW50IChleHRlbnQpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIHJhZGl1cyA9IGZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZV0gLSBmbGF0Q29vcmRpbmF0ZXNbMF07XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzWzBdIC0gcmFkaXVzLCBmbGF0Q29vcmRpbmF0ZXNbMV0gLSByYWRpdXMsXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXMsIGZsYXRDb29yZGluYXRlc1sxXSArIHJhZGl1cyxcbiAgICAgIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIGdldFJhZGl1cyAoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmdldFJhZGl1c1NxdWFyZWRfKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJhZGl1cyBzcXVhcmVkLlxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5nZXRSYWRpdXNTcXVhcmVkXyA9IGZ1bmN0aW9uIGdldFJhZGl1c1NxdWFyZWRfICgpIHtcbiAgICB2YXIgZHggPSB0aGlzLmZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZHkgPSB0aGlzLmZsYXRDb29yZGluYXRlc1t0aGlzLnN0cmlkZSArIDFdIC0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLkNJUkNMRTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgQ2lyY2xlLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgdmFyIGNpcmNsZUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKGludGVyc2VjdHMoZXh0ZW50LCBjaXJjbGVFeHRlbnQpKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXIoKTtcblxuICAgICAgaWYgKGV4dGVudFswXSA8PSBjZW50ZXJbMF0gJiYgZXh0ZW50WzJdID49IGNlbnRlclswXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRlbnRbMV0gPD0gY2VudGVyWzFdICYmIGV4dGVudFszXSA+PSBjZW50ZXJbMV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JFYWNoQ29ybmVyKGV4dGVudCwgdGhpcy5pbnRlcnNlY3RzQ29vcmRpbmF0ZSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlIGFzIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIENpcmNsZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gc2V0Q2VudGVyIChjZW50ZXIpIHtcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgdmFyIHJhZGl1cyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzW3N0cmlkZV0gLSB0aGlzLmZsYXRDb29yZGluYXRlc1swXTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gY2VudGVyLnNsaWNlKCk7XG4gICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZV0gPSBmbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSArIGldID0gY2VudGVyW2ldO1xuICAgIH1cbiAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyh0aGlzLmxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjZW50ZXIgKGFzIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9KSBhbmQgdGhlIHJhZGl1cyAoYXNcbiAgICogbnVtYmVyKSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0geyFtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFJhZGl1cy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldENlbnRlckFuZFJhZGl1cyA9IGZ1bmN0aW9uIHNldENlbnRlckFuZFJhZGl1cyAoY2VudGVyLCByYWRpdXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjZW50ZXIsIDApO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBvZmZzZXQgPSBkZWZsYXRlQ29vcmRpbmF0ZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgY2VudGVyLCB0aGlzLnN0cmlkZSk7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGZsYXRDb29yZGluYXRlc1swXSArIHJhZGl1cztcbiAgICBmb3IgKHZhciBpID0gMSwgaWkgPSB0aGlzLnN0cmlkZTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgfVxuICAgIGZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBvZmZzZXQ7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge307XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7fTtcblxuICAvKipcbiAgICogU2V0IHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS4gVGhlIHJhZGl1cyBpcyBpbiB0aGUgdW5pdHMgb2YgdGhlIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBDaXJjbGUucHJvdG90eXBlLnNldFJhZGl1cyA9IGZ1bmN0aW9uIHNldFJhZGl1cyAocmFkaXVzKSB7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbdGhpcy5zdHJpZGVdID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF0gKyByYWRpdXM7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGNpcmNsZSBmcm9tIG9uZSBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1cbiAqIHRvIGFub3RoZXIuIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGNsb25lKCkgaXQgYW5kXG4gKiB0aGVuIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIHRoZSBjbG9uZS5cbiAqXG4gKiBJbnRlcm5hbGx5IGEgY2lyY2xlIGlzIGN1cnJlbnRseSByZXByZXNlbnRlZCBieSB0d28gcG9pbnRzOiB0aGUgY2VudGVyIG9mXG4gKiB0aGUgY2lyY2xlIGBbY3gsIGN5XWAsIGFuZCB0aGUgcG9pbnQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjaXJjbGVcbiAqIGBbY3ggKyByLCBjeV1gLiBUaGlzIGB0cmFuc2Zvcm1gIGZ1bmN0aW9uIGp1c3QgdHJhbnNmb3JtcyB0aGVzZSB0d28gcG9pbnRzLlxuICogU28gdGhlIHJlc3VsdGluZyBnZW9tZXRyeSBpcyBhbHNvIGEgY2lyY2xlLCBhbmQgdGhhdCBjaXJjbGUgZG9lcyBub3RcbiAqIGNvcnJlc3BvbmQgdG8gdGhlIHNoYXBlIHRoYXQgd291bGQgYmUgb2J0YWluZWQgYnkgdHJhbnNmb3JtaW5nIGV2ZXJ5IHBvaW50XG4gKiBvZiB0aGUgb3JpZ2luYWwgY2lyY2xlLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBUaGUgY3VycmVudCBwcm9qZWN0aW9uLiAgQ2FuIGJlIGFcbiAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIFRoZSBkZXNpcmVkIHByb2plY3Rpb24uICBDYW4gYmUgYVxuICogICAgIHN0cmluZyBpZGVudGlmaWVyIG9yIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb25+UHJvamVjdGlvbn0gb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSBUaGlzIGdlb21ldHJ5LiAgTm90ZSB0aGF0IG9yaWdpbmFsIGdlb21ldHJ5IGlzXG4gKiAgICAgbW9kaWZpZWQgaW4gcGxhY2UuXG4gKiBAZnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuQ2lyY2xlLnByb3RvdHlwZS50cmFuc2Zvcm07XG5leHBvcnQgZGVmYXVsdCBDaXJjbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNpcmNsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9HZW9tZXRyeVxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgZ2V0SGVpZ2h0LCByZXR1cm5PclVwZGF0ZX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb24sIGdldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX1cbiAqL1xudmFyIHRtcFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgdmVjdG9yIGdlb21ldHJpZXMuXG4gKlxuICogVG8gZ2V0IG5vdGlmaWVkIG9mIGNoYW5nZXMgdG8gdGhlIGdlb21ldHJ5LCByZWdpc3RlciBhIGxpc3RlbmVyIGZvciB0aGVcbiAqIGdlbmVyaWMgYGNoYW5nZWAgZXZlbnQgb24geW91ciBnZW9tZXRyeSBpbnN0YW5jZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xudmFyIEdlb21ldHJ5ID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xuXG4gICAgQmFzZU9iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnk+fVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICB9XG5cbiAgaWYgKCBCYXNlT2JqZWN0ICkgR2VvbWV0cnkuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW9tZXRyeTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBDbG9uZS5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHt9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7fTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjbG9zZXN0IHBvaW50IG9mIHRoZSBnZW9tZXRyeSB0byB0aGUgcGFzc2VkIHBvaW50IGFzXG4gICAqIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlIGNvb3JkaW5hdGV9LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU9fSBvcHRfY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENsb3Nlc3QgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5nZXRDbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnQgKHBvaW50LCBvcHRfY2xvc2VzdFBvaW50KSB7XG4gICAgdmFyIGNsb3Nlc3RQb2ludCA9IG9wdF9jbG9zZXN0UG9pbnQgPyBvcHRfY2xvc2VzdFBvaW50IDogW05hTiwgTmFOXTtcbiAgICB0aGlzLmNsb3Nlc3RQb2ludFhZKHBvaW50WzBdLCBwb2ludFsxXSwgY2xvc2VzdFBvaW50LCBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZ2VvbWV0cnkgaW5jbHVkZXMgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlLiBJZiB0aGVcbiAgICogY29vcmRpbmF0ZSBpcyBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGdlb21ldHJ5LCByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmludGVyc2VjdHNDb29yZGluYXRlID0gZnVuY3Rpb24gaW50ZXJzZWN0c0Nvb3JkaW5hdGUgKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluc1hZKGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlRXh0ZW50ID0gZnVuY3Rpb24gY29tcHV0ZUV4dGVudCAoZXh0ZW50KSB7fTtcblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gZ2V0RXh0ZW50IChvcHRfZXh0ZW50KSB7XG4gICAgaWYgKHRoaXMuZXh0ZW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5leHRlbnRfID0gdGhpcy5jb21wdXRlRXh0ZW50KHRoaXMuZXh0ZW50Xyk7XG4gICAgICB0aGlzLmV4dGVudFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybk9yVXBkYXRlKHRoaXMuZXh0ZW50Xywgb3B0X2V4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmNob3IgVGhlIHJvdGF0aW9uIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSAoYW5nbGUsIGFuY2hvcikge307XG5cbiAgLyoqXG4gICAqIFNjYWxlIHRoZSBnZW9tZXRyeSAod2l0aCBhbiBvcHRpb25hbCBvcmlnaW4pLiAgVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4LWRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc3kgVGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbiAoZGVmYXVsdHMgdG9cbiAgICogICAgIHN4KS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBUaGUgc2NhbGUgb3JpZ2luIChkZWZhdWx0cyB0byB0aGUgY2VudGVyXG4gICAqICAgICBvZiB0aGUgZ2VvbWV0cnkgZXh0ZW50KS5cbiAgICogQGFwaVxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUgKHN4LCBvcHRfc3ksIG9wdF9hbmNob3IpIHt9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIGdlb21ldHJ5LiBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggRGVsdGEgWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlIChkZWx0YVgsIGRlbHRhWSkge307XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5LiAgRm9yIGxpbmVzdHJpbmdzLCB0aGlzIHVzZXNcbiAgICogdGhlIHRoZSB7QGxpbmtcbiAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxuICAgKiBEb3VnbGFzIFBldWNrZXJ9IGFsZ29yaXRobS4gIEZvciBwb2x5Z29ucywgYSBxdWFudGl6YXRpb24tYmFzZWRcbiAgICogc2ltcGxpZmljYXRpb24gaXMgdXNlZCB0byBwcmVzZXJ2ZSB0b3BvbG9neS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZSBkaXN0YW5jZSBmb3Igc2ltcGxpZmljYXRpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBBIG5ldywgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBvcmlnaW5hbFxuICAgKiAgICAgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIEdlb21ldHJ5LnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5ICh0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkodG9sZXJhbmNlICogdG9sZXJhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoaXMgZ2VvbWV0cnkgdXNpbmcgdGhlIERvdWdsYXMgUGV1Y2tlclxuICAgKiBhbGdvcml0aG0uXG4gICAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lci1Eb3VnbGFzLVBldWNrZXJfYWxnb3JpdGhtLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeSAoc3F1YXJlZFRvbGVyYW5jZSkge307XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlUeXBlfSBHZW9tZXRyeSB0eXBlLlxuICAgKi9cbiAgR2VvbWV0cnkucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHt9O1xuXG4gIC8qKlxuICAgKiBBcHBseSBhIHRyYW5zZm9ybSBmdW5jdGlvbiB0byBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0uXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybSAodHJhbnNmb3JtRm4pIHt9O1xuXG4gIC8qKlxuICAgKiBUZXN0IGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIHBhc3NlZCBleHRlbnQgaW50ZXJzZWN0LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge307XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2VvbWV0cnkuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS4gIElmXG4gICAqIGluc3RlYWQgeW91IHdhbnQgYSBuZXcgZ2VvbWV0cnksIGZpcnN0IGBjbG9uZSgpYCB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlIChkZWx0YVgsIGRlbHRhWSkge307XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBlYWNoIGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5IGZyb20gb25lIGNvb3JkaW5hdGUgcmVmZXJlbmNlXG4gICAqIHN5c3RlbSB0byBhbm90aGVyLiBUaGUgZ2VvbWV0cnkgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqIEZvciBleGFtcGxlLCBhIGxpbmUgd2lsbCBiZSB0cmFuc2Zvcm1lZCB0byBhIGxpbmUgYW5kIGEgY2lyY2xlIHRvIGEgY2lyY2xlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgVGhlIGN1cnJlbnQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBHZW9tZXRyeS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgc291cmNlID0gZ2V0UHJvamVjdGlvbihzb3VyY2UpO1xuICAgIHZhciB0cmFuc2Zvcm1GbiA9IHNvdXJjZS5nZXRVbml0cygpID09IFVuaXRzLlRJTEVfUElYRUxTID9cbiAgICAgIGZ1bmN0aW9uKGluQ29vcmRpbmF0ZXMsIG91dENvb3JkaW5hdGVzLCBzdHJpZGUpIHtcbiAgICAgICAgdmFyIHBpeGVsRXh0ZW50ID0gc291cmNlLmdldEV4dGVudCgpO1xuICAgICAgICB2YXIgcHJvamVjdGVkRXh0ZW50ID0gc291cmNlLmdldFdvcmxkRXh0ZW50KCk7XG4gICAgICAgIHZhciBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sXG4gICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLCBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgc2NhbGUsIC1zY2FsZSwgMCxcbiAgICAgICAgICAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtMkQoaW5Db29yZGluYXRlcywgMCwgaW5Db29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgICAgICB0bXBUcmFuc2Zvcm0sIG91dENvb3JkaW5hdGVzKTtcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKShpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKTtcbiAgICAgIH0gOlxuICAgICAgZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBHZW9tZXRyeTtcbn0oQmFzZU9iamVjdCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbkdlb21ldHJ5LnByb3RvdHlwZS5jb250YWluc1hZID0gRkFMU0U7XG5cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5TGF5b3V0XG4gKi9cblxuLyoqXG4gKiBUaGUgY29vcmRpbmF0ZSBsYXlvdXQgZm9yIGdlb21ldHJpZXMsIGluZGljYXRpbmcgd2hldGhlciBhIDNyZCBvciA0dGggeiAoJ1onKVxuICogb3IgbWVhc3VyZSAoJ00nKSBjb29yZGluYXRlIGlzIGF2YWlsYWJsZS4gU3VwcG9ydGVkIHZhbHVlcyBhcmUgYCdYWSdgLFxuICogYCdYWVonYCwgYCdYWU0nYCwgYCdYWVpNJ2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFhZOiAnWFknLFxuICBYWVo6ICdYWVonLFxuICBYWU06ICdYWU0nLFxuICBYWVpNOiAnWFlaTSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlb21ldHJ5TGF5b3V0LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL0dlb21ldHJ5VHlwZVxuICovXG5cbi8qKlxuICogVGhlIGdlb21ldHJ5IHR5cGUuIE9uZSBvZiBgJ1BvaW50J2AsIGAnTGluZVN0cmluZydgLCBgJ0xpbmVhclJpbmcnYCxcbiAqIGAnUG9seWdvbidgLCBgJ011bHRpUG9pbnQnYCwgYCdNdWx0aUxpbmVTdHJpbmcnYCwgYCdNdWx0aVBvbHlnb24nYCxcbiAqIGAnR2VvbWV0cnlDb2xsZWN0aW9uJ2AsIGAnQ2lyY2xlJ2AuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5UOiAnUG9pbnQnLFxuICBMSU5FX1NUUklORzogJ0xpbmVTdHJpbmcnLFxuICBMSU5FQVJfUklORzogJ0xpbmVhclJpbmcnLFxuICBQT0xZR09OOiAnUG9seWdvbicsXG4gIE1VTFRJX1BPSU5UOiAnTXVsdGlQb2ludCcsXG4gIE1VTFRJX0xJTkVfU1RSSU5HOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgTVVMVElfUE9MWUdPTjogJ011bHRpUG9seWdvbicsXG4gIEdFT01FVFJZX0NPTExFQ1RJT046ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICBDSVJDTEU6ICdDaXJjbGUnXG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW9tZXRyeVR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZVN0cmluZ1xuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4uL2dlb20vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuLi9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVBvaW50LCBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmd9IGZyb20gJy4uL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZVN0cmluZ0xlbmd0aH0gZnJvbSAnLi4vZ2VvbS9mbGF0L2xlbmd0aC5qcyc7XG5pbXBvcnQge2ZvckVhY2ggYXMgZm9yRWFjaFNlZ21lbnR9IGZyb20gJy4uL2dlb20vZmxhdC9zZWdtZW50cy5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTGluZVN0cmluZyA9IChmdW5jdGlvbiAoU2ltcGxlR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gTGluZVN0cmluZyhjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5mbGF0TWlkcG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCk7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIFNpbXBsZUdlb21ldHJ5ICkgTGluZVN0cmluZy5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW1wbGVHZW9tZXRyeSAmJiBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBjb29yZGluYXRlIHRvIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmFwcGVuZENvb3JkaW5hdGUgPSBmdW5jdGlvbiBhcHBlbmRDb29yZGluYXRlIChjb29yZGluYXRlKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBjb29yZGluYXRlLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgY29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRYWSA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFhZICh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQobWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIGZhbHNlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIHNlZ21lbnQsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICAgKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0XG4gICAqIHZhbHVlIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAgICogICAgIGNhbGxlZCBmb3IgZWFjaCBzZWdtZW50LlxuICAgKiBAcmV0dXJuIHtUfGJvb2xlYW59IFZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVCxTXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmZvckVhY2hTZWdtZW50ID0gZnVuY3Rpb24gZm9yRWFjaFNlZ21lbnQkMSAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZm9yRWFjaFNlZ21lbnQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCBgbWAgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24sIG9yIGBudWxsYCBpZiBub1xuICAgKiBzdWNoIGNvb3JkaW5hdGUgZXhpc3RzLlxuICAgKlxuICAgKiBgb3B0X2V4dHJhcG9sYXRlYCBjb250cm9scyBleHRyYXBvbGF0aW9uIGJleW9uZCB0aGUgcmFuZ2Ugb2YgTXMgaW4gdGhlXG4gICAqIE11bHRpTGluZVN0cmluZy4gSWYgYG9wdF9leHRyYXBvbGF0ZWAgaXMgYHRydWVgIHRoZW4gTXMgbGVzcyB0aGFuIHRoZSBmaXJzdFxuICAgKiBNIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjb29yZGluYXRlIGFuZCBNcyBncmVhdGVyIHRoYW4gdGhlIGxhc3QgTSB3aWxsXG4gICAqIHJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZUF0TSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVBdE0gKG0sIG9wdF9leHRyYXBvbGF0ZSkge1xuICAgIGlmICh0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWU0gJiZcbiAgICAgICAgdGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBleHRyYXBvbGF0ZSA9IG9wdF9leHRyYXBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2V4dHJhcG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgbSwgZXh0cmFwb2xhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlIGF0IHRoZSBwcm92aWRlZCBmcmFjdGlvbiBhbG9uZyB0aGUgbGluZXN0cmluZy5cbiAgICogVGhlIGBmcmFjdGlvbmAgaXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLCB3aGVyZSAwIGlzIHRoZSBzdGFydCBvZiB0aGVcbiAgICogbGluZXN0cmluZyBhbmQgMSBpcyB0aGUgZW5kLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJhY3Rpb24gRnJhY3Rpb24uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT19IG9wdF9kZXN0IE9wdGlvbmFsIGNvb3JkaW5hdGUgd2hvc2UgdmFsdWVzIHdpbGxcbiAgICogICAgIGJlIG1vZGlmaWVkLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IGNvb3JkaW5hdGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBvZiB0aGUgaW50ZXJwb2xhdGVkIHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlQXQgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQXQgKGZyYWN0aW9uLCBvcHRfZGVzdCkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICBmcmFjdGlvbiwgb3B0X2Rlc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgbGluZXN0cmluZyBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiBsaW5lU3RyaW5nTGVuZ3RoKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gRmxhdCBtaWRwb2ludC5cbiAgICovXG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEZsYXRNaWRwb2ludCA9IGZ1bmN0aW9uIGdldEZsYXRNaWRwb2ludCAoKSB7XG4gICAgaWYgKHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5mbGF0TWlkcG9pbnRfID0gdGhpcy5nZXRDb29yZGluYXRlQXQoMC41LCB0aGlzLmZsYXRNaWRwb2ludF8pO1xuICAgICAgdGhpcy5mbGF0TWlkcG9pbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRNaWRwb2ludF87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsIChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgdmFyIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcoc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHshQXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZVN0cmluZy5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIExpbmVTdHJpbmc7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluZVN0cmluZztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVN0cmluZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9MaW5lYXJSaW5nXG4gKi9cbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4uL2dlb20vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmcgYXMgbGluZWFyUmluZ0FyZWF9IGZyb20gJy4uL2dlb20vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4uL2dlb20vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuLi9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlcn0gZnJvbSAnLi4vZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMaW5lYXIgcmluZyBnZW9tZXRyeS4gT25seSB1c2VkIGFzIHBhcnQgb2YgcG9seWdvbjsgY2Fubm90IGJlIHJlbmRlcmVkXG4gKiBvbiBpdHMgb3duLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIExpbmVhclJpbmcgPSAoZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIExpbmVhclJpbmcoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcblxuICAgIFNpbXBsZUdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgY29vcmRpbmF0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBMaW5lYXJSaW5nLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbXBsZUdlb21ldHJ5ICYmIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclJpbmc7XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC9nZW9tL0xpbmVhclJpbmd9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChtYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgdHJ1ZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIGxpbmVhciByaW5nIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdBcmVhKHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCk7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7fTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZWFyIHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIExpbmVhclJpbmcucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBMaW5lYXJSaW5nO1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IExpbmVhclJpbmc7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpbmVhclJpbmcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlMaW5lU3RyaW5nXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuLi9nZW9tL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi4vZ2VvbS9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdEFycmF5UG9pbnQsIGFycmF5TWF4U3F1YXJlZERlbHRhfSBmcm9tICcuLi9nZW9tL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnQsIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlckFycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLWxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTXVsdGlMaW5lU3RyaW5nID0gKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBNdWx0aUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQsIG9wdF9lbmRzKSB7XG5cbiAgICBTaW1wbGVHZW9tZXRyeS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pKSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgY29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5lbmRzXyA9IG9wdF9lbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRMYXlvdXQoKTtcbiAgICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lU3RyaW5nID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbGF5b3V0ID0gbGluZVN0cmluZy5nZXRMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQoZmxhdENvb3JkaW5hdGVzLCBsaW5lU3RyaW5nLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgZW5kcy5wdXNoKGZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMobGF5b3V0LCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5lbmRzXyA9IGVuZHM7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIFNpbXBsZUdlb21ldHJ5ICkgTXVsdGlMaW5lU3RyaW5nLl9fcHJvdG9fXyA9IFNpbXBsZUdlb21ldHJ5O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aUxpbmVTdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGxpbmVzdHJpbmcgdG8gdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfSBsaW5lU3RyaW5nIExpbmVTdHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuYXBwZW5kTGluZVN0cmluZyA9IGZ1bmN0aW9uIGFwcGVuZExpbmVTdHJpbmcgKGxpbmVTdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGxpbmVTdHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBsaW5lU3RyaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCkpO1xuICAgIH1cbiAgICB0aGlzLmVuZHNfLnB1c2godGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshbW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQsIHRoaXMuZW5kc18uc2xpY2UoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgZmFsc2UsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCBgbWAgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24sIG9yIGBudWxsYCBpZiBub1xuICAgKiBzdWNoIGNvb3JkaW5hdGUgZXhpc3RzLlxuICAgKlxuICAgKiBgb3B0X2V4dHJhcG9sYXRlYCBjb250cm9scyBleHRyYXBvbGF0aW9uIGJleW9uZCB0aGUgcmFuZ2Ugb2YgTXMgaW4gdGhlXG4gICAqIE11bHRpTGluZVN0cmluZy4gSWYgYG9wdF9leHRyYXBvbGF0ZWAgaXMgYHRydWVgIHRoZW4gTXMgbGVzcyB0aGFuIHRoZSBmaXJzdFxuICAgKiBNIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjb29yZGluYXRlIGFuZCBNcyBncmVhdGVyIHRoYW4gdGhlIGxhc3QgTSB3aWxsXG4gICAqIHJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBgb3B0X2ludGVycG9sYXRlYCBjb250cm9scyBpbnRlcnBvbGF0aW9uIGJldHdlZW4gY29uc2VjdXRpdmUgTGluZVN0cmluZ3NcbiAgICogd2l0aGluIHRoZSBNdWx0aUxpbmVTdHJpbmcuIElmIGBvcHRfaW50ZXJwb2xhdGVgIGlzIGB0cnVlYCB0aGUgY29vcmRpbmF0ZXNcbiAgICogd2lsbCBiZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgYmV0d2VlbiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIG9uZSBMaW5lU3RyaW5nXG4gICAqIGFuZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSBvZiB0aGUgbmV4dCBMaW5lU3RyaW5nLiAgSWYgYG9wdF9pbnRlcnBvbGF0ZWAgaXNcbiAgICogYGZhbHNlYCB0aGVuIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBgbnVsbGAgZm9yIE1zIGZhbGxpbmcgYmV0d2VlblxuICAgKiBMaW5lU3RyaW5ncy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2V4dHJhcG9sYXRlIEV4dHJhcG9sYXRlLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pbnRlcnBvbGF0ZSBJbnRlcnBvbGF0ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVBdE0gPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQXRNIChtLCBvcHRfZXh0cmFwb2xhdGUsIG9wdF9pbnRlcnBvbGF0ZSkge1xuICAgIGlmICgodGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlNICYmXG4gICAgICAgICB0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWVpNKSB8fFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZXh0cmFwb2xhdGUgPSBvcHRfZXh0cmFwb2xhdGUgIT09IHVuZGVmaW5lZCA/IG9wdF9leHRyYXBvbGF0ZSA6IGZhbHNlO1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IG9wdF9pbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2ludGVycG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TSh0aGlzLmZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEVuZHMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEVuZHMgPSBmdW5jdGlvbiBnZXRFbmRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lc3RyaW5nIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ30gTGluZVN0cmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMaW5lU3RyaW5nID0gZnVuY3Rpb24gZ2V0TGluZVN0cmluZyAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgaW5kZXggPT09IDAgPyAwIDogdGhpcy5lbmRzX1tpbmRleCAtIDFdLCB0aGlzLmVuZHNfW2luZGV4XSksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lc3RyaW5ncyBvZiB0aGlzIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmc+fSBMaW5lU3RyaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMaW5lU3RyaW5ncyA9IGZ1bmN0aW9uIGdldExpbmVTdHJpbmdzICgpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGVuZHMgPSB0aGlzLmVuZHNfO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAvKiogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nPn0gKi9cbiAgICB2YXIgbGluZVN0cmluZ3MgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgICAgdmFyIGxpbmVTdHJpbmcgPSBuZXcgTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLCBsYXlvdXQpO1xuICAgICAgbGluZVN0cmluZ3MucHVzaChsaW5lU3RyaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gRmxhdCBtaWRwb2ludHMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEZsYXRNaWRwb2ludHMgPSBmdW5jdGlvbiBnZXRGbGF0TWlkcG9pbnRzICgpIHtcbiAgICB2YXIgbWlkcG9pbnRzID0gW107XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzXztcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciBtaWRwb2ludCA9IGludGVycG9sYXRlUG9pbnQoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgMC41KTtcbiAgICAgIGV4dGVuZChtaWRwb2ludHMsIG1pZHBvaW50KTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG1pZHBvaW50cztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbCAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHZhciBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgdmFyIHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZLCBzaW1wbGlmaWVkRW5kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZVN0cmluZ0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEBwYXJhbSB7IUFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSwgdGhpcy5lbmRzXyk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBNdWx0aUxpbmVTdHJpbmc7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlMaW5lU3RyaW5nO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aUxpbmVTdHJpbmcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlQb2ludFxuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFksIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9nZW9tL1BvaW50LmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuLi9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZER4fSBmcm9tICcuLi9tYXRoLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBNdWx0aS1wb2ludCBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBNdWx0aVBvaW50ID0gKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBNdWx0aVBvaW50KGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcbiAgICBpZiAob3B0X2xheW91dCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIE11bHRpUG9pbnQuX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2ludDtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgcG9pbnQgdG8gdGhpcyBtdWx0aXBvaW50LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1BvaW50fSBwb2ludCBQb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuYXBwZW5kUG9pbnQgPSBmdW5jdGlvbiBhcHBlbmRQb2ludCAocG9pbnQpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IHBvaW50LmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgcG9pbnQuZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshbW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludH0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KFxuICAgICAgICB4LCB5LCBmbGF0Q29vcmRpbmF0ZXNbaV0sIGZsYXRDb29yZGluYXRlc1tpICsgMV0pO1xuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgICAgICBjbG9zZXN0UG9pbnRbal0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdO1xuICAgICAgICB9XG4gICAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9pbnQuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvaW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vUG9pbnR9IFBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uIGdldFBvaW50IChpbmRleCkge1xuICAgIHZhciBuID0gIXRoaXMuZmxhdENvb3JkaW5hdGVzID8gMCA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHRoaXMuc3RyaWRlO1xuICAgIGlmIChpbmRleCA8IDAgfHwgbiA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICBpbmRleCAqIHRoaXMuc3RyaWRlLCAoaW5kZXggKyAxKSAqIHRoaXMuc3RyaWRlKSwgdGhpcy5sYXlvdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvaW50cyBvZiB0aGlzIG11bHRpcG9pbnQuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZ2VvbS9Qb2ludD59IFBvaW50cy5cbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzICgpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAvKiogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZ2VvbS9Qb2ludD59ICovXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIHN0cmlkZSksIGxheW91dCk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2YXIgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHZhciB5ID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGlmIChjb250YWluc1hZKGV4dGVudCwgeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlwb2ludC5cbiAgICogQHBhcmFtIHshQXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpUG9pbnQ7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgTXVsdGlQb2ludDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TXVsdGlQb2ludC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9NdWx0aVBvbHlnb25cbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4uL2dlb20vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgTXVsdGlQb2ludCBmcm9tICcuLi9nZW9tL011bHRpUG9pbnQuanMnO1xuaW1wb3J0IFBvbHlnb24gZnJvbSAnLi4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0FyZWF9IGZyb20gJy4uL2dlb20vZmxhdC9hcmVhLmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzIGFzIGxpbmVhclJpbmdzc0NlbnRlcn0gZnJvbSAnLi4vZ2VvbS9mbGF0L2NlbnRlci5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RNdWx0aUFycmF5UG9pbnQsIG11bHRpQXJyYXlNYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4uL2dlb20vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NzQ29udGFpbnNYWX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2NvbnRhaW5zLmpzJztcbmltcG9ydCB7ZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2dldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0FyZU9yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc0FycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvb3JpZW50LmpzJztcbmltcG9ydCB7cXVhbnRpemVNdWx0aUFycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLXBvbHlnb24gZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgTXVsdGlQb2x5Z29uID0gKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBNdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQsIG9wdF9lbmRzcykge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbmRzc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c1JldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAoIW9wdF9lbmRzcyAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldExheW91dCgpO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgICAgdmFyIGVuZHNzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbGF5b3V0ID0gcG9seWdvbi5nZXRMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGVuZHMgPSBwb2x5Z29uLmdldEVuZHMoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgZW5kc1tqXSArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIGVuZHNzLnB1c2goZW5kcyk7XG4gICAgICB9XG4gICAgICBvcHRfbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgY29vcmRpbmF0ZXMgPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBvcHRfZW5kc3MgPSBlbmRzcztcbiAgICB9XG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kc3MpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzKTtcbiAgICAgIHRoaXMuZW5kc3NfID0gb3B0X2VuZHNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBNdWx0aVBvbHlnb24uX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW1wbGVHZW9tZXRyeSAmJiBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9seWdvbjtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgcG9seWdvbiB0byB0aGlzIG11bHRpcG9seWdvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSBwb2x5Z29uIFBvbHlnb24uXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuYXBwZW5kUG9seWdvbiA9IGZ1bmN0aW9uIGFwcGVuZFBvbHlnb24gKHBvbHlnb24pIHtcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciBlbmRzO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgZW5kcyA9IHBvbHlnb24uZ2V0RW5kcygpLnNsaWNlKCk7XG4gICAgICB0aGlzLmVuZHNzXy5wdXNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgICAgZW5kcyA9IHBvbHlnb24uZ2V0RW5kcygpLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZW5kc1tpXSArPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kc3NfLnB1c2goZW5kcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC9nZW9tL011bHRpUG9seWdvbn0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxlbiA9IHRoaXMuZW5kc3NfLmxlbmd0aDtcbiAgICB2YXIgbmV3RW5kc3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBuZXdFbmRzc1tpXSA9IHRoaXMkMS5lbmRzc19baV0uc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0LCBuZXdFbmRzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIHRydWUsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NzQ29udGFpbnNYWSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSwgeCwgeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXJlYSBvZiB0aGUgbXVsdGlwb2x5Z29uIG9uIHByb2plY3RlZCBwbGFuZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NzQXJlYSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29vcmRpbmF0ZSBhcnJheSBmb3IgdGhpcyBnZW9tZXRyeS4gIFRoaXMgYXJyYXkgaGFzIHRoZSBzdHJ1Y3R1cmVcbiAgICogb2YgYSBHZW9KU09OIGNvb3JkaW5hdGUgYXJyYXkgZm9yIG11bHRpLXBvbHlnb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgT3JpZW50IGNvb3JkaW5hdGVzIGFjY29yZGluZyB0byB0aGUgcmlnaHQtaGFuZFxuICAgKiAgICAgcnVsZSAoY291bnRlci1jbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIElmIGBmYWxzZWAsIGNvb3JkaW5hdGVzIHdpbGwgYmUgb3JpZW50ZWQgYWNjb3JkaW5nIHRvIHRoZSBsZWZ0LWhhbmQgcnVsZVxuICAgKiAgICAgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNvdW50ZXItY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBCeSBkZWZhdWx0LCBjb29yZGluYXRlIG9yaWVudGF0aW9uIHdpbGwgZGVwZW5kIG9uIGhvdyB0aGUgZ2VvbWV0cnkgd2FzXG4gICAqICAgICBjb25zdHJ1Y3RlZC5cbiAgICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+Pn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKG9wdF9yaWdodCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCBvcHRfcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gRW5kc3MuXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEVuZHNzID0gZnVuY3Rpb24gZ2V0RW5kc3MgKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNzXztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEZsYXQgaW50ZXJpb3IgcG9pbnRzLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRGbGF0SW50ZXJpb3JQb2ludHMgPSBmdW5jdGlvbiBnZXRGbGF0SW50ZXJpb3JQb2ludHMgKCkge1xuICAgIGlmICh0aGlzLmZsYXRJbnRlcmlvclBvaW50c1JldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHZhciBmbGF0Q2VudGVycyA9IGxpbmVhclJpbmdzc0NlbnRlcihcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXJzKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGludGVyaW9yIHBvaW50cyBhcyB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludCBtdWx0aXBvaW50fS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludH0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpc1xuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnRzID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludHMgKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50cygpLnNsaWNlKCksIEdlb21ldHJ5TGF5b3V0LlhZTSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBPcmllbnRlZCBmbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzICgpIHtcbiAgICBpZiAodGhpcy5vcmllbnRlZFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICAgIGlmIChsaW5lYXJSaW5nc0FyZU9yaWVudGVkKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSkpIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXy5sZW5ndGggPVxuICAgICAgICAgICAgb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18sIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHZhciBzaW1wbGlmaWVkRW5kc3MgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IHF1YW50aXplTXVsdGlBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsXG4gICAgICBNYXRoLnNxcnQoc3F1YXJlZFRvbGVyYW5jZSksXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwLCBzaW1wbGlmaWVkRW5kc3MpO1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZLCBzaW1wbGlmaWVkRW5kc3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvbHlnb24gYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSBQb2x5Z29uLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldFBvbHlnb24gPSBmdW5jdGlvbiBnZXRQb2x5Z29uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5lbmRzc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG9mZnNldDtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2RW5kcyA9IHRoaXMuZW5kc3NfW2luZGV4IC0gMV07XG4gICAgICBvZmZzZXQgPSBwcmV2RW5kc1twcmV2RW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgdmFyIGVuZHMgPSB0aGlzLmVuZHNzX1tpbmRleF0uc2xpY2UoKTtcbiAgICB2YXIgZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBlbmRzW2ldIC09IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgdGhpcy5sYXlvdXQsIGVuZHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBvbHlnb25zIG9mIHRoaXMgbXVsdGlwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL2dlb20vUG9seWdvbj59IFBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldFBvbHlnb25zID0gZnVuY3Rpb24gZ2V0UG9seWdvbnMgKCkge1xuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIGVuZHNzID0gdGhpcy5lbmRzc187XG4gICAgdmFyIHBvbHlnb25zID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGVuZHMgPSBlbmRzc1tpXS5zbGljZSgpO1xuICAgICAgdmFyIGVuZCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgZW5kc1tqXSAtPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgbGF5b3V0LCBlbmRzKTtcbiAgICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBwb2x5Z29ucztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmludGVyc2VjdHNFeHRlbnQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzRXh0ZW50IChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPEFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMyk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdmFyIGVuZHNzID0gZGVmbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUsIHRoaXMuZW5kc3NfKTtcbiAgICBpZiAoZW5kc3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGFzdEVuZHMgPSBlbmRzc1tlbmRzcy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGxhc3RFbmRzLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIDAgOiBsYXN0RW5kc1tsYXN0RW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIE11bHRpUG9seWdvbjtcbn0oU2ltcGxlR2VvbWV0cnkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aVBvbHlnb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpUG9seWdvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUsIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2dlb20vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9pbnQgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG52YXIgUG9pbnQgPSAoZnVuY3Rpb24gKFNpbXBsZUdlb21ldHJ5KSB7XG4gIGZ1bmN0aW9uIFBvaW50KGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KTtcbiAgfVxuXG4gIGlmICggU2ltcGxlR2VvbWV0cnkgKSBQb2ludC5fX3Byb3RvX18gPSBTaW1wbGVHZW9tZXRyeTtcbiAgUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvZ2VvbS9Qb2ludH0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY2xvc2VzdFBvaW50WFkgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRYWSAoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCBmbGF0Q29vcmRpbmF0ZXNbMF0sIGZsYXRDb29yZGluYXRlc1sxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiAhdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPyBbXSA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuUE9JTlQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFBvaW50LnByb3RvdHlwZS5pbnRlcnNlY3RzRXh0ZW50ID0gZnVuY3Rpb24gaW50ZXJzZWN0c0V4dGVudCAoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zWFkoZXh0ZW50LCB0aGlzLmZsYXRDb29yZGluYXRlc1swXSwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBQb2ludC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMCk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGUoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnQ7XG59KFNpbXBsZUdlb21ldHJ5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvbHlnb25cbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBnZXRDZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBMaW5lYXJSaW5nIGZyb20gJy4uL2dlb20vTGluZWFyUmluZy5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge29mZnNldCBhcyBzcGhlcmVPZmZzZXR9IGZyb20gJy4uL3NwaGVyZS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzIGFzIGxpbmVhclJpbmdzQXJlYX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0QXJyYXlQb2ludCwgYXJyYXlNYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4uL2dlb20vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuLi9nZW9tL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtnZXRJbnRlcmlvclBvaW50T2ZBcnJheX0gZnJvbSAnLi4vZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnQuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5fSBmcm9tICcuLi9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdJc09yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc30gZnJvbSAnLi4vZ2VvbS9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge3F1YW50aXplQXJyYXl9IGZyb20gJy4uL2dlb20vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9seWdvbiBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBQb2x5Z29uID0gKGZ1bmN0aW9uIChTaW1wbGVHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBQb2x5Z29uKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0LCBvcHRfZW5kcykge1xuXG4gICAgU2ltcGxlR2VvbWV0cnkuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdF9lbmRzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCBjb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmVuZHNfID0gb3B0X2VuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKCBTaW1wbGVHZW9tZXRyeSApIFBvbHlnb24uX19wcm90b19fID0gU2ltcGxlR2VvbWV0cnk7XG4gIFBvbHlnb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2ltcGxlR2VvbWV0cnkgJiYgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcblxuICAvKipcbiAgICogQXBwZW5kIHRoZSBwYXNzZWQgbGluZWFyIHJpbmcgdG8gdGhpcyBwb2x5Z29uLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0xpbmVhclJpbmd9IGxpbmVhclJpbmcgTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmFwcGVuZExpbmVhclJpbmcgPSBmdW5jdGlvbiBhcHBlbmRMaW5lYXJSaW5nIChsaW5lYXJSaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgUG9seWdvbih0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgdGhpcy5lbmRzXy5zbGljZSgpKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb3Nlc3RQb2ludFhZID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50WFkgKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdEFycmF5UG9pbnQoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgdHJ1ZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnNYWSA9IGZ1bmN0aW9uIGNvbnRhaW5zWFkgKHgsIHkpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NDb250YWluc1hZKHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIHgsIHkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NBcmVhKHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBwb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKG9wdF9yaWdodCkge1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBvcHRfcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEVuZHMuXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRFbmRzID0gZnVuY3Rpb24gZ2V0RW5kcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBJbnRlcmlvciBwb2ludC5cbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEZsYXRJbnRlcmlvclBvaW50ID0gZnVuY3Rpb24gZ2V0RmxhdEludGVyaW9yUG9pbnQgKCkge1xuICAgIGlmICh0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdmFyIGZsYXRDZW50ZXIgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50XyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KFxuICAgICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLFxuICAgICAgICBmbGF0Q2VudGVyLCAwKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZsYXRJbnRlcmlvclBvaW50XztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGFuIGludGVyaW9yIHBvaW50IG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9Qb2ludH0gSW50ZXJpb3IgcG9pbnQgYXMgWFlNIGNvb3JkaW5hdGUsIHdoZXJlIE0gaXMgdGhlXG4gICAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0SW50ZXJpb3JQb2ludCA9IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnQgKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5nZXRGbGF0SW50ZXJpb3JQb2ludCgpLCBHZW9tZXRyeUxheW91dC5YWU0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiByaW5ncyBvZiB0aGUgcG9seWdvbiwgIHRoaXMgaW5jbHVkZXMgdGhlIGV4dGVyaW9yXG4gICAqIHJpbmcgYW5kIGFueSBpbnRlcmlvciByaW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgcmluZ3MuXG4gICAqIEBhcGlcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldExpbmVhclJpbmdDb3VudCA9IGZ1bmN0aW9uIGdldExpbmVhclJpbmdDb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc18ubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIE50aCBsaW5lYXIgcmluZyBvZiB0aGUgcG9seWdvbiBnZW9tZXRyeS4gUmV0dXJuIGBudWxsYCBpZiB0aGVcbiAgICogZ2l2ZW4gaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgKiBUaGUgZXh0ZXJpb3IgbGluZWFyIHJpbmcgaXMgYXZhaWxhYmxlIGF0IGluZGV4IGAwYCBhbmQgdGhlIGludGVyaW9yIHJpbmdzXG4gICAqIGF0IGluZGV4IGAxYCBhbmQgYmV5b25kLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9nZW9tL0xpbmVhclJpbmd9IExpbmVhciByaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRMaW5lYXJSaW5nID0gZnVuY3Rpb24gZ2V0TGluZWFyUmluZyAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgaW5kZXggPT09IDAgPyAwIDogdGhpcy5lbmRzX1tpbmRleCAtIDFdLCB0aGlzLmVuZHNfW2luZGV4XSksIHRoaXMubGF5b3V0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lYXIgcmluZ3Mgb2YgdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZ2VvbS9MaW5lYXJSaW5nPn0gTGluZWFyIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRMaW5lYXJSaW5ncyA9IGZ1bmN0aW9uIGdldExpbmVhclJpbmdzICgpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIHZhciBlbmRzID0gdGhpcy5lbmRzXztcbiAgICB2YXIgbGluZWFyUmluZ3MgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgICAgdmFyIGxpbmVhclJpbmcgPSBuZXcgTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBlbmQpLCBsYXlvdXQpO1xuICAgICAgbGluZWFyUmluZ3MucHVzaChsaW5lYXJSaW5nKTtcbiAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMgKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgICAgaWYgKGxpbmVhclJpbmdJc09yaWVudGVkKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKSkge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLmxlbmd0aCA9XG4gICAgICAgICAgICBvcmllbnRMaW5lYXJSaW5ncyhcbiAgICAgICAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18sIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvbHlnb24ucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHZhciBzaW1wbGlmaWVkRW5kcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gcXVhbnRpemVBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSxcbiAgICAgIE1hdGguc3FydChzcXVhcmVkVG9sZXJhbmNlKSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDAsIHNpbXBsaWZpZWRFbmRzKTtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIHNpbXBsaWZpZWRFbmRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeVR5cGUuUE9MWUdPTjtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUG9seWdvbi5wcm90b3R5cGUuaW50ZXJzZWN0c0V4dGVudCA9IGZ1bmN0aW9uIGludGVyc2VjdHNFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgZXh0ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBQb2x5Z29uLnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzIChjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB2YXIgZW5kcyA9IGRlZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSwgdGhpcy5lbmRzXyk7XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZW5kcy5sZW5ndGggPT09IDAgPyAwIDogZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBQb2x5Z29uO1xufShTaW1wbGVHZW9tZXRyeSkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFBvbHlnb247XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXBwcm94aW1hdGlvbiBvZiBhIGNpcmNsZSBvbiB0aGUgc3VyZmFjZSBvZiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0b1xuICogICAgIHRoZSBwb2x5Z29uIHZlcnRpY2VzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbiBPcHRpb25hbCBudW1iZXIgb2YgdmVydGljZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAqICAgICBwb2x5Z29uLiBEZWZhdWx0IGlzIGAzMmAuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9zcGhlcmVSYWRpdXMgT3B0aW9uYWwgcmFkaXVzIGZvciB0aGUgc3BoZXJlIChkZWZhdWx0cyB0b1xuICogICAgIHRoZSBFYXJ0aCdzIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQpLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vUG9seWdvbn0gVGhlIFwiY2lyY3VsYXJcIiBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY3VsYXIoY2VudGVyLCByYWRpdXMsIG9wdF9uLCBvcHRfc3BoZXJlUmFkaXVzKSB7XG4gIHZhciBuID0gb3B0X24gPyBvcHRfbiA6IDMyO1xuICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgc3BoZXJlT2Zmc2V0KGNlbnRlciwgcmFkaXVzLCAyICogTWF0aC5QSSAqIGkgLyBuLCBvcHRfc3BoZXJlUmFkaXVzKSk7XG4gIH1cbiAgZmxhdENvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhbiBleHRlbnQuIFRoZSBsYXlvdXQgdXNlZCBpcyBgWFlgLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSBUaGUgcG9seWdvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FeHRlbnQoZXh0ZW50KSB7XG4gIHZhciBtaW5YID0gZXh0ZW50WzBdO1xuICB2YXIgbWluWSA9IGV4dGVudFsxXTtcbiAgdmFyIG1heFggPSBleHRlbnRbMl07XG4gIHZhciBtYXhZID0gZXh0ZW50WzNdO1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgIFttaW5YLCBtaW5ZLCBtaW5YLCBtYXhZLCBtYXhYLCBtYXhZLCBtYXhYLCBtaW5ZLCBtaW5YLCBtaW5ZXTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIHBvbHlnb24gZnJvbSBhIGNpcmNsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSBjaXJjbGUgQ2lyY2xlIGdlb21ldHJ5LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfc2lkZXMgTnVtYmVyIG9mIHNpZGVzIG9mIHRoZSBwb2x5Z29uLiBEZWZhdWx0IGlzIDMyLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfYW5nbGUgU3RhcnQgYW5nbGUgZm9yIHRoZSBmaXJzdCB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gaW5cbiAqICAgICByYWRpYW5zLiBEZWZhdWx0IGlzIDAuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSBQb2x5Z29uIGdlb21ldHJ5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNpcmNsZShjaXJjbGUsIG9wdF9zaWRlcywgb3B0X2FuZ2xlKSB7XG4gIHZhciBzaWRlcyA9IG9wdF9zaWRlcyA/IG9wdF9zaWRlcyA6IDMyO1xuICB2YXIgc3RyaWRlID0gY2lyY2xlLmdldFN0cmlkZSgpO1xuICB2YXIgbGF5b3V0ID0gY2lyY2xlLmdldExheW91dCgpO1xuICB2YXIgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICB2YXIgYXJyYXlMZW5ndGggPSBzdHJpZGUgKiAoc2lkZXMgKyAxKTtcbiAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG5ldyBBcnJheShhcnJheUxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW2ldID0gMDtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdID0gMDtcbiAgICBmb3IgKHZhciBqID0gMjsgaiA8IHN0cmlkZTsgaisrKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbaSArIGpdID0gY2VudGVyW2pdO1xuICAgIH1cbiAgfVxuICB2YXIgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgdmFyIHBvbHlnb24gPSBuZXcgUG9seWdvbihmbGF0Q29vcmRpbmF0ZXMsIGxheW91dCwgZW5kcyk7XG4gIG1ha2VSZWd1bGFyKHBvbHlnb24sIGNlbnRlciwgY2lyY2xlLmdldFJhZGl1cygpLCBvcHRfYW5nbGUpO1xuICByZXR1cm4gcG9seWdvbjtcbn1cblxuXG4vKipcbiAqIE1vZGlmeSB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2x5Z29uIHRvIG1ha2UgaXQgYSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1BvbHlnb259IHBvbHlnb24gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciBvZiB0aGUgcmVndWxhciBwb2x5Z29uLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2FuZ2xlIFN0YXJ0IGFuZ2xlIGZvciB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGluXG4gKiAgICAgcmFkaWFucy4gRGVmYXVsdCBpcyAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCByYWRpdXMsIG9wdF9hbmdsZSkge1xuICB2YXIgZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIHN0cmlkZSA9IHBvbHlnb24uZ2V0U3RyaWRlKCk7XG4gIHZhciBzaWRlcyA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGggLyBzdHJpZGUgLSAxO1xuICB2YXIgc3RhcnRBbmdsZSA9IG9wdF9hbmdsZSA/IG9wdF9hbmdsZSA6IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHNpZGVzOyArK2kpIHtcbiAgICB2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZTtcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgKG1vZHVsbyhpLCBzaWRlcykgKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSA9IGNlbnRlclswXSArIChyYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSA9IGNlbnRlclsxXSArIChyYWRpdXMgKiBNYXRoLnNpbihhbmdsZSkpO1xuICB9XG4gIHBvbHlnb24uY2hhbmdlZCgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1NpbXBsZUdlb21ldHJ5XG4gKi9cbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcywgZ2V0Q2VudGVyfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL2dlb20vR2VvbWV0cnkuanMnO1xuaW1wb3J0IEdlb21ldHJ5TGF5b3V0IGZyb20gJy4uL2dlb20vR2VvbWV0cnlMYXlvdXQuanMnO1xuaW1wb3J0IHtyb3RhdGUsIHNjYWxlLCB0cmFuc2xhdGUsIHRyYW5zZm9ybTJEfSBmcm9tICcuLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzOyBkbyBub3QgaW5zdGFudGlhdGVcbiAqIGluIGFwcHMsIGFzIGNhbm5vdCBiZSByZW5kZXJlZC5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xudmFyIFNpbXBsZUdlb21ldHJ5ID0gKGZ1bmN0aW9uIChHZW9tZXRyeSkge1xuICBmdW5jdGlvbiBTaW1wbGVHZW9tZXRyeSgpIHtcblxuICAgIEdlb21ldHJ5LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5TGF5b3V0fVxuICAgICAqL1xuICAgIHRoaXMubGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0cmlkZSA9IDI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSApIFNpbXBsZUdlb21ldHJ5Ll9fcHJvdG9fXyA9IEdlb21ldHJ5O1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSAmJiBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2ltcGxlR2VvbWV0cnk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUV4dGVudCA9IGZ1bmN0aW9uIGNvbXB1dGVFeHRlbnQgKGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXModGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXl9IENvb3JkaW5hdGVzLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge307XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3QgY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRGaXJzdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRGaXJzdENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgwLCB0aGlzLnN0cmlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldEZsYXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldEZsYXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IExhc3QgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5nZXRMYXN0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldExhc3RDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UodGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gdGhpcy5zdHJpZGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dH5HZW9tZXRyeUxheW91dCBsYXlvdXR9IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXR9IExheW91dC5cbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldExheW91dCA9IGZ1bmN0aW9uIGdldExheW91dCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFNpbXBsaWZpZWRHZW9tZXRyeSAoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGlmICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY2xlYXIodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZSk7XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSAwO1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgLy8gSWYgc3F1YXJlZFRvbGVyYW5jZSBpcyBuZWdhdGl2ZSBvciBpZiB3ZSBrbm93IHRoYXQgc2ltcGxpZmljYXRpb24gd2lsbCBub3RcbiAgICAvLyBoYXZlIGFueSBlZmZlY3QgdGhlbiBqdXN0IHJldHVybiB0aGlzLlxuICAgIGlmIChzcXVhcmVkVG9sZXJhbmNlIDwgMCB8fFxuICAgICAgICAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlICE9PSAwICYmXG4gICAgICAgICBzcXVhcmVkVG9sZXJhbmNlIDw9IHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIga2V5ID0gc3F1YXJlZFRvbGVyYW5jZS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaW1wbGlmaWVkR2VvbWV0cnkgPVxuICAgICAgICAgIHRoaXMuZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSk7XG4gICAgICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IHNpbXBsaWZpZWRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGlmIChzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA8IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlW2tleV0gPSBzaW1wbGlmaWVkR2VvbWV0cnk7XG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkR2VvbWV0cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW1wbGlmaWNhdGlvbiBkaWQgbm90IGFjdHVhbGx5IHJlbW92ZSBhbnkgY29vcmRpbmF0ZXMuICBXZSBub3cga25vd1xuICAgICAgICAvLyB0aGF0IGFueSBjYWxscyB0byBnZXRTaW1wbGlmaWVkR2VvbWV0cnkgd2l0aCBhIHNxdWFyZWRUb2xlcmFuY2UgbGVzc1xuICAgICAgICAvLyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHNxdWFyZWRUb2xlcmFuY2Ugd2lsbCBhbHNvIG5vdCBoYXZlIGFueVxuICAgICAgICAvLyBlZmZlY3QuICBUaGlzIGFsbG93cyB1cyB0byBzaG9ydCBjaXJjdWl0IHNpbXBsaWZpY2F0aW9uIChzYXZpbmcgQ1BVXG4gICAgICAgIC8vIGN5Y2xlcykgYW5kIHByZXZlbnRzIHRoZSBjYWNoZSBvZiBzaW1wbGlmaWVkIGdlb21ldHJpZXMgZnJvbSBmaWxsaW5nXG4gICAgICAgIC8vIHVwIHdpdGggdXNlbGVzcyBpZGVudGljYWwgY29waWVzIG9mIHRoaXMgZ2VvbWV0cnkgKHNhdmluZyBtZW1vcnkpLlxuICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSBzcXVhcmVkVG9sZXJhbmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gU2ltcGxpZmllZCBnZW9tZXRyeS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsID0gZnVuY3Rpb24gZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwgKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBTdHJpZGUuXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuZ2V0U3RyaWRlID0gZnVuY3Rpb24gZ2V0U3RyaWRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpZGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5zZXRGbGF0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRGbGF0Q29vcmRpbmF0ZXMgKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5zdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGZsYXRDb29yZGluYXRlcztcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7IUFycmF5fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dHx1bmRlZmluZWR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmVzdGluZyBOZXN0aW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuc2V0TGF5b3V0ID0gZnVuY3Rpb24gc2V0TGF5b3V0IChsYXlvdXQsIGNvb3JkaW5hdGVzLCBuZXN0aW5nKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB2YXIgc3RyaWRlO1xuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgIHN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3Rpbmc7ICsraSkge1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcyQxLmxheW91dCA9IEdlb21ldHJ5TGF5b3V0LlhZO1xuICAgICAgICAgIHRoaXMkMS5zdHJpZGUgPSAyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7QXJyYXl9ICovIChjb29yZGluYXRlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmlkZSA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGxheW91dCA9IGdldExheW91dEZvclN0cmlkZShzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0gKHRyYW5zZm9ybUZuKSB7XG4gICAgaWYgKHRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0cmFuc2Zvcm1Gbih0aGlzLmZsYXRDb29yZGluYXRlcywgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgU2ltcGxlR2VvbWV0cnkucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSQxIChhbmdsZSwgYW5jaG9yKSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgdmFyIHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICByb3RhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBTaW1wbGVHZW9tZXRyeS5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSQxIChzeCwgb3B0X3N5LCBvcHRfYW5jaG9yKSB7XG4gICAgdmFyIHN5ID0gb3B0X3N5O1xuICAgIGlmIChzeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzeSA9IHN4O1xuICAgIH1cbiAgICB2YXIgYW5jaG9yID0gb3B0X2FuY2hvcjtcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgYW5jaG9yID0gZ2V0Q2VudGVyKHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgIH1cbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHNjYWxlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIHN0cmlkZSwgc3gsIHN5LCBhbmNob3IsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUkMSAoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHRyYW5zbGF0ZShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsXG4gICAgICAgIGRlbHRhWCwgZGVsdGFZLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTaW1wbGVHZW9tZXRyeTtcbn0oR2VvbWV0cnkpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgdmFyIGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDMpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVo7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDQpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVpNO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUxheW91dH0gKi8gKGxheW91dClcbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpIHtcbiAgdmFyIHN0cmlkZTtcbiAgaWYgKGxheW91dCA9PSBHZW9tZXRyeUxheW91dC5YWSkge1xuICAgIHN0cmlkZSA9IDI7XG4gIH0gZWxzZSBpZiAobGF5b3V0ID09IEdlb21ldHJ5TGF5b3V0LlhZWiB8fCBsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlNKSB7XG4gICAgc3RyaWRlID0gMztcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgIHN0cmlkZSA9IDQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc3RyaWRlKTtcbn1cblxuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblNpbXBsZUdlb21ldHJ5LnByb3RvdHlwZS5jb250YWluc1hZID0gRkFMU0U7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSBzaW1wbGVHZW9tZXRyeSBTaW1wbGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRyYW5zZm9ybWVkIGZsYXQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1HZW9tMkQoc2ltcGxlR2VvbWV0cnksIHRyYW5zZm9ybSwgb3B0X2Rlc3QpIHtcbiAgdmFyIGZsYXRDb29yZGluYXRlcyA9IHNpbXBsZUdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICBpZiAoIWZsYXRDb29yZGluYXRlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHJpZGUgPSBzaW1wbGVHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgIHRyYW5zZm9ybSwgb3B0X2Rlc3QpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXBsZUdlb21ldHJ5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVHZW9tZXRyeS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2FyZWFcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB2YXIgdHdpY2VBcmVhID0gMDtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB0d2ljZUFyZWEgKz0geTEgKiB4MiAtIHgxICogeTI7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiB0d2ljZUFyZWEgLyAyO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSkge1xuICB2YXIgYXJlYSA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIGFyZWEgKz0gbGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUpIHtcbiAgdmFyIGFyZWEgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJlYS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2NlbnRlclxuICovXG5pbXBvcnQge2NyZWF0ZUVtcHR5LCBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEZsYXQgY2VudGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICB2YXIgZmxhdENlbnRlcnMgPSBbXTtcbiAgdmFyIGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRnJvbUZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlKTtcbiAgICBmbGF0Q2VudGVycy5wdXNoKChleHRlbnRbMF0gKyBleHRlbnRbMl0pIC8gMiwgKGV4dGVudFsxXSArIGV4dGVudFszXSkgLyAyKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZsYXRDZW50ZXJzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZW50ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jbG9zZXN0XG4gKi9cbmltcG9ydCB7bGVycCwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgMkQgbGluZSBzZWdtZW50IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXSB0b1xuICogZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgKHgsIHkpLiAgRXh0cmFcbiAqIGRpbWVuc2lvbnMgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldDEgT2Zmc2V0IDEuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MiBPZmZzZXQgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqL1xuZnVuY3Rpb24gYXNzaWduQ2xvc2VzdChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldDEsIG9mZnNldDIsIHN0cmlkZSwgeCwgeSwgY2xvc2VzdFBvaW50KSB7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDEgKyAxXTtcbiAgdmFyIGR4ID0gZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIC0geDE7XG4gIHZhciBkeSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgMV0gLSB5MTtcbiAgdmFyIG9mZnNldDtcbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGxlcnAoZmxhdENvb3JkaW5hdGVzW29mZnNldDEgKyBpXSxcbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MiArIGldLCB0KTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldDE7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHN0cmlkZTsgKytpJDEpIHtcbiAgICBjbG9zZXN0UG9pbnRbaSQxXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpJDFdO1xuICB9XG4gIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNxdWFyZWQgb2YgdGhlIGxhcmdlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbnkgcGFpciBvZiBjb25zZWN1dGl2ZVxuICogY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KSB7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHZhciBzcXVhcmVkRGVsdGEgPSBzcXVhcmVkRHgoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChzcXVhcmVkRGVsdGEgPiBtYXgpIHtcbiAgICAgIG1heCA9IHNxdWFyZWREZWx0YTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCBzcXVhcmVkIGRlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggc3F1YXJlZCBkZWx0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5TWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG1heCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICBtYXggPSBtYXhTcXVhcmVkRGVsdGEoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggc3F1YXJlZCBkZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHNxdWFyZWQgZGVsdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBtYXgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgbWF4ID0gYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtYXgpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWF4O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfdG1wUG9pbnQgVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdFBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gIHN0cmlkZSwgbWF4RGVsdGEsIGlzUmluZywgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIG9wdF90bXBQb2ludCkge1xuICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gIH1cbiAgdmFyIGksIHNxdWFyZWREaXN0YW5jZTtcbiAgaWYgKG1heERlbHRhID09PSAwKSB7XG4gICAgLy8gQWxsIHBvaW50cyBhcmUgaWRlbnRpY2FsLCBzbyBqdXN0IHRlc3QgdGhlIGZpcnN0IHBvaW50LlxuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeChcbiAgICAgIHgsIHksIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcFBvaW50ID0gb3B0X3RtcFBvaW50ID8gb3B0X3RtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgdmFyIGluZGV4ID0gb2Zmc2V0ICsgc3RyaWRlO1xuICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICBhc3NpZ25DbG9zZXN0KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBpbmRleCAtIHN0cmlkZSwgaW5kZXgsIHN0cmlkZSwgeCwgeSwgdG1wUG9pbnQpO1xuICAgIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREeCh4LCB5LCB0bXBQb2ludFswXSwgdG1wUG9pbnRbMV0pO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSB0bXBQb2ludFtpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICBpbmRleCArPSBzdHJpZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNraXAgYWhlYWQgbXVsdGlwbGUgcG9pbnRzLCBiZWNhdXNlIHdlIGtub3cgdGhhdCBhbGwgdGhlIHNraXBwZWRcbiAgICAgIC8vIHBvaW50cyBjYW5ub3QgYmUgYW55IGNsb3NlciB0aGFuIHRoZSBjbG9zZXN0IHBvaW50IHdlIGhhdmUgZm91bmQgc29cbiAgICAgIC8vIGZhci4gIFdlIGtub3cgdGhpcyBiZWNhdXNlIHdlIGtub3cgaG93IGNsb3NlIHRoZSBjdXJyZW50IHBvaW50IGlzLCBob3dcbiAgICAgIC8vIGNsb3NlIHRoZSBjbG9zZXN0IHBvaW50IHdlIGhhdmUgZm91bmQgc28gZmFyIGlzLCBhbmQgdGhlIG1heGltdW1cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgcG9pbnRzLiAgRm9yIGV4YW1wbGUsIGlmIHdlJ3JlIGN1cnJlbnRseVxuICAgICAgLy8gYXQgZGlzdGFuY2UgMTAsIHRoZSBiZXN0IHdlJ3ZlIGZvdW5kIHNvIGZhciBpcyAzLCBhbmQgdGhhdCB0aGUgbWF4aW11bVxuICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBwb2ludHMgaXMgMiwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNraXAgYXRcbiAgICAgIC8vIGxlYXN0ICgxMCAtIDMpIC8gMiA9PSAzIChyb3VuZGVkIGRvd24pIHBvaW50cyB0byBoYXZlIGFueSBjaGFuY2Ugb2ZcbiAgICAgIC8vIGZpbmRpbmcgYSBjbG9zZXIgcG9pbnQuICBXZSB1c2UgTWF0aC5tYXgoLi4uLCAxKSB0byBlbnN1cmUgdGhhdCB3ZVxuICAgICAgLy8gYWx3YXlzIGFkdmFuY2UgYXQgbGVhc3Qgb25lIHBvaW50LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgaW5kZXggKz0gc3RyaWRlICogTWF0aC5tYXgoXG4gICAgICAgICgoTWF0aC5zcXJ0KHNxdWFyZWREaXN0YW5jZSkgLVxuICAgICAgICAgICAgTWF0aC5zcXJ0KG1pblNxdWFyZWREaXN0YW5jZSkpIC8gbWF4RGVsdGEpIHwgMCwgMSk7XG4gICAgfVxuICB9XG4gIGlmIChpc1JpbmcpIHtcbiAgICAvLyBDaGVjayB0aGUgY2xvc2luZyBzZWdtZW50LlxuICAgIGFzc2lnbkNsb3Nlc3QoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIGVuZCAtIHN0cmlkZSwgb2Zmc2V0LCBzdHJpZGUsIHgsIHksIHRtcFBvaW50KTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblNxdWFyZWREaXN0YW5jZSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X3RtcFBvaW50IFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLFxuICBzdHJpZGUsIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLFxuICBvcHRfdG1wUG9pbnQpIHtcbiAgdmFyIHRtcFBvaW50ID0gb3B0X3RtcFBvaW50ID8gb3B0X3RtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgbWluU3F1YXJlZERpc3RhbmNlID0gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLFxuICAgICAgbWF4RGVsdGEsIGlzUmluZywgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UsIHRtcFBvaW50KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfdG1wUG9pbnQgVGVtcG9yYXJ5IHBvaW50IG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCxcbiAgZW5kc3MsIHN0cmlkZSwgbWF4RGVsdGEsIGlzUmluZywgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UsXG4gIG9wdF90bXBQb2ludCkge1xuICB2YXIgdG1wUG9pbnQgPSBvcHRfdG1wUG9pbnQgPyBvcHRfdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsXG4gICAgICBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSwgdG1wUG9pbnQpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9zZXN0LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY29udGFpbnNcbiAqL1xuaW1wb3J0IHtmb3JFYWNoQ29ybmVyfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgZXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIHZhciBvdXRzaWRlID0gZm9yRWFjaENvcm5lcihleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgKHgsIHkpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiAhbGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdKTtcbiAgICB9KTtcbiAgcmV0dXJuICFvdXRzaWRlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgeCwgeSkge1xuICAvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwMy1faW5jbHVzaW9uLmh0bWxcbiAgLy8gQ29weXJpZ2h0IDIwMDAgc29mdFN1cmZlciwgMjAxMiBEYW4gU3VuZGF5XG4gIC8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuICAvLyBwcm92aWRpbmcgdGhhdCB0aGlzIGNvcHlyaWdodCBub3RpY2UgaXMgaW5jbHVkZWQgd2l0aCBpdC5cbiAgLy8gU29mdFN1cmZlciBtYWtlcyBubyB3YXJyYW50eSBmb3IgdGhpcyBjb2RlLCBhbmQgY2Fubm90IGJlIGhlbGRcbiAgLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbiAgLy8gVXNlcnMgb2YgdGhpcyBjb2RlIG11c3QgdmVyaWZ5IGNvcnJlY3RuZXNzIGZvciB0aGVpciBhcHBsaWNhdGlvbi5cbiAgdmFyIHduID0gMDtcbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBpZiAoeTEgPD0geSkge1xuICAgICAgaWYgKHkyID4geSAmJiAoKHgyIC0geDEpICogKHkgLSB5MSkpIC0gKCh4IC0geDEpICogKHkyIC0geTEpKSA+IDApIHtcbiAgICAgICAgd24rKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHkyIDw9IHkgJiYgKCh4MiAtIHgxKSAqICh5IC0geTEpKSAtICgoeCAtIHgxKSAqICh5MiAtIHkxKSkgPCAwKSB7XG4gICAgICB3bi0tO1xuICAgIH1cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIHduICE9PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkge1xuICBpZiAoZW5kcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCB4LCB5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMSwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBlbmRzW2kgLSAxXSwgZW5kc1tpXSwgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIHgsIHkpIHtcbiAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpZiAobGluZWFyUmluZ3NDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHgsIHkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGFpbnMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9kZWZsYXRlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGUsIHN0cmlkZSkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0KytdID0gY29vcmRpbmF0ZVtpXTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZUNvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlcywgc3RyaWRlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBjb29yZGluYXRlW2pdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzcyBDb29yZGluYXRlc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfZW5kcyBFbmRzLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEVuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzLCBzdHJpZGUsIG9wdF9lbmRzKSB7XG4gIHZhciBlbmRzID0gb3B0X2VuZHMgPyBvcHRfZW5kcyA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgdmFyIGVuZCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3Nbal0sIHN0cmlkZSk7XG4gICAgZW5kc1tpKytdID0gZW5kO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICBlbmRzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+Pn0gY29vcmRpbmF0ZXNzcyBDb29yZGluYXRlc3NzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj49fSBvcHRfZW5kc3MgRW5kc3MuXG4gKiBAcmV0dXJuIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBFbmRzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGNvb3JkaW5hdGVzc3MsIHN0cmlkZSwgb3B0X2VuZHNzKSB7XG4gIHZhciBlbmRzcyA9IG9wdF9lbmRzcyA/IG9wdF9lbmRzcyA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIHZhciBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzc1tqXSwgc3RyaWRlLCBlbmRzc1tpXSk7XG4gICAgZW5kc3NbaSsrXSA9IGVuZHM7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVuZHNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBlbmRzcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2luZmxhdGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj19IG9wdF9jb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlQ29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBvcHRfY29vcmRpbmF0ZXMpIHtcbiAgdmFyIGNvb3JkaW5hdGVzID0gb3B0X2Nvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgPyBvcHRfY29vcmRpbmF0ZXMgOiBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIGNvb3JkaW5hdGVzW2krK10gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaiwgaiArIHN0cmlkZSk7XG4gIH1cbiAgY29vcmRpbmF0ZXMubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGNvb3JkaW5hdGVzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+Pj19IG9wdF9jb29yZGluYXRlc3MgQ29vcmRpbmF0ZXNzLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj59IENvb3JkaW5hdGVzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVDb29yZGluYXRlc0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG9wdF9jb29yZGluYXRlc3MpIHtcbiAgdmFyIGNvb3JkaW5hdGVzcyA9IG9wdF9jb29yZGluYXRlc3MgIT09IHVuZGVmaW5lZCA/IG9wdF9jb29yZGluYXRlc3MgOiBbXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gMCwgamogPSBlbmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICB2YXIgZW5kID0gZW5kc1tqXTtcbiAgICBjb29yZGluYXRlc3NbaSsrXSA9IGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY29vcmRpbmF0ZXNzW2ldKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgY29vcmRpbmF0ZXNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3M7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj4+PX0gb3B0X2Nvb3JkaW5hdGVzc3NcbiAqICAgICBDb29yZGluYXRlc3NzLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+Pn0gQ29vcmRpbmF0ZXNzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9jb29yZGluYXRlc3NzKSB7XG4gIHZhciBjb29yZGluYXRlc3NzID0gb3B0X2Nvb3JkaW5hdGVzc3MgIT09IHVuZGVmaW5lZCA/IG9wdF9jb29yZGluYXRlc3NzIDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IDAsIGpqID0gZW5kc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIHZhciBlbmRzID0gZW5kc3Nbal07XG4gICAgY29vcmRpbmF0ZXNzc1tpKytdID0gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBjb29yZGluYXRlc3NzW2ldKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgY29vcmRpbmF0ZXNzcy5sZW5ndGggPSBpO1xuICByZXR1cm4gY29vcmRpbmF0ZXNzcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2ludGVyaW9ycG9pbnRcbiAqL1xuaW1wb3J0IHtudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9ufSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQ29udGFpbnNYWX0gZnJvbSAnLi4vZmxhdC9jb250YWlucy5qcyc7XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgcG9pbnQgdGhhdCBpcyBsaWtlbHkgdG8gbGllIGluIHRoZSBpbnRlcmlvciBvZiB0aGUgbGluZWFyIHJpbmdzLlxuICogSW5zcGlyZWQgYnkgSlRTJ3MgY29tLnZpdmlkc29sdXRpb25zLmp0cy5nZW9tLkdlb21ldHJ5I2dldEludGVyaW9yUG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q2VudGVycyBGbGF0IGNlbnRlcnMuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhdENlbnRlcnNPZmZzZXQgRmxhdCBjZW50ZXIgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IERlc3RpbmF0aW9uIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHMsIHN0cmlkZSwgZmxhdENlbnRlcnMsIGZsYXRDZW50ZXJzT2Zmc2V0LCBvcHRfZGVzdCkge1xuICB2YXIgaSwgaWksIHgsIHgxLCB4MiwgeTEsIHkyO1xuICB2YXIgeSA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0ICsgMV07XG4gIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGhvcml6b250YWwgbGluZVxuICBmb3IgKHZhciByID0gMCwgcnIgPSBlbmRzLmxlbmd0aDsgciA8IHJyOyArK3IpIHtcbiAgICB2YXIgZW5kID0gZW5kc1tyXTtcbiAgICB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICAgIHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKCh5IDw9IHkxICYmIHkyIDw9IHkpIHx8ICh5MSA8PSB5ICYmIHkgPD0geTIpKSB7XG4gICAgICAgIHggPSAoeSAtIHkxKSAvICh5MiAtIHkxKSAqICh4MiAtIHgxKSArIHgxO1xuICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goeCk7XG4gICAgICB9XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCB0aGUgbG9uZ2VzdCBzZWdtZW50IG9mIHRoZSBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludFxuICAvLyBpbnNpZGUgdGhlIGxpbmVhciByaW5nLlxuICB2YXIgcG9pbnRYID0gTmFOO1xuICB2YXIgbWF4U2VnbWVudExlbmd0aCA9IC1JbmZpbml0eTtcbiAgaW50ZXJzZWN0aW9ucy5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuICB4MSA9IGludGVyc2VjdGlvbnNbMF07XG4gIGZvciAoaSA9IDEsIGlpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgeDIgPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gTWF0aC5hYnMoeDIgLSB4MSk7XG4gICAgaWYgKHNlZ21lbnRMZW5ndGggPiBtYXhTZWdtZW50TGVuZ3RoKSB7XG4gICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgICAgcG9pbnRYID0geDtcbiAgICAgICAgbWF4U2VnbWVudExlbmd0aCA9IHNlZ21lbnRMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHgxID0geDI7XG4gIH1cbiAgaWYgKGlzTmFOKHBvaW50WCkpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludCBpbnNpZGUgdGhlIGxpbmVhclxuICAgIC8vIHJpbmcuICBVc2UgdGhlIGNlbnRlciBvZiB0aGUgdGhlIGxpbmVhciByaW5nJ3MgZXh0ZW50LlxuICAgIHBvaW50WCA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0XTtcbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdC5wdXNoKHBvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aCk7XG4gICAgcmV0dXJuIG9wdF9kZXN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDZW50ZXJzIEZsYXQgY2VudGVycy5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBJbnRlcmlvciBwb2ludHMgYXMgWFlNIGNvb3JkaW5hdGVzLCB3aGVyZSBNIGlzIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBob3Jpem9udGFsIGludGVyc2VjdGlvbiB0aGF0IHRoZSBwb2ludCBiZWxvbmdzIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIGZsYXRDZW50ZXJzKSB7XG4gIHZhciBpbnRlcmlvclBvaW50cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpbnRlcmlvclBvaW50cyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCwgZW5kcywgc3RyaWRlLCBmbGF0Q2VudGVycywgMiAqIGksIGludGVyaW9yUG9pbnRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGludGVyaW9yUG9pbnRzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmlvcnBvaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvaW50ZXJwb2xhdGVcbiAqL1xuaW1wb3J0IHtiaW5hcnlTZWFyY2h9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7bGVycH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcmFjdGlvbiBGcmFjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBEZXN0aW5hdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlUG9pbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmcmFjdGlvbiwgb3B0X2Rlc3QpIHtcbiAgdmFyIHBvaW50WCA9IE5hTjtcbiAgdmFyIHBvaW50WSA9IE5hTjtcbiAgdmFyIG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPT09IDEpIHtcbiAgICBwb2ludFggPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBwb2ludFkgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSBpZiAobiA9PSAyKSB7XG4gICAgcG9pbnRYID0gKDEgLSBmcmFjdGlvbikgKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSArXG4gICAgICAgIGZyYWN0aW9uICogZmxhdENvb3JkaW5hdGVzW29mZnNldCArIHN0cmlkZV07XG4gICAgcG9pbnRZID0gKDEgLSBmcmFjdGlvbikgKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gK1xuICAgICAgICBmcmFjdGlvbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgKyAxXTtcbiAgfSBlbHNlIGlmIChuICE9PSAwKSB7XG4gICAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIHZhciBsZW5ndGggPSAwO1xuICAgIHZhciBjdW11bGF0aXZlTGVuZ3RocyA9IFswXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgdmFyIHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICAgIGN1bXVsYXRpdmVMZW5ndGhzLnB1c2gobGVuZ3RoKTtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0ID0gZnJhY3Rpb24gKiBsZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gYmluYXJ5U2VhcmNoKGN1bXVsYXRpdmVMZW5ndGhzLCB0YXJnZXQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHZhciB0ID0gKHRhcmdldCAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKSAvXG4gICAgICAgICAgKGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDFdIC0gY3VtdWxhdGl2ZUxlbmd0aHNbLWluZGV4IC0gMl0pO1xuICAgICAgdmFyIG8gPSBvZmZzZXQgKyAoLWluZGV4IC0gMikgKiBzdHJpZGU7XG4gICAgICBwb2ludFggPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb10sIGZsYXRDb29yZGluYXRlc1tvICsgc3RyaWRlXSwgdCk7XG4gICAgICBwb2ludFkgPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbbyArIDFdLCBmbGF0Q29vcmRpbmF0ZXNbbyArIHN0cmlkZSArIDFdLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRYID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGluZGV4ICogc3RyaWRlXTtcbiAgICAgIHBvaW50WSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpbmRleCAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdFswXSA9IHBvaW50WDtcbiAgICBvcHRfZGVzdFsxXSA9IHBvaW50WTtcbiAgICByZXR1cm4gb3B0X2Rlc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtwb2ludFgsIHBvaW50WV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSkge1xuICBpZiAoZW5kID09IG9mZnNldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBjb29yZGluYXRlO1xuICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmxhdENvb3JkaW5hdGVzW2VuZCAtIDFdIDwgbSkge1xuICAgIGlmIChleHRyYXBvbGF0ZSkge1xuICAgICAgY29vcmRpbmF0ZSA9IGZsYXRDb29yZGluYXRlcy5zbGljZShlbmQgLSBzdHJpZGUsIGVuZCk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gRklYTUUgdXNlIE8oMSkgc2VhcmNoXG4gIGlmIChtID09IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgIHJldHVybiBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpO1xuICB9XG4gIHZhciBsbyA9IG9mZnNldCAvIHN0cmlkZTtcbiAgdmFyIGhpID0gZW5kIC8gc3RyaWRlO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1sobWlkICsgMSkgKiBzdHJpZGUgLSAxXSkge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgdmFyIG0wID0gZmxhdENvb3JkaW5hdGVzW2xvICogc3RyaWRlIC0gMV07XG4gIGlmIChtID09IG0wKSB7XG4gICAgcmV0dXJuIGZsYXRDb29yZGluYXRlcy5zbGljZSgobG8gLSAxKSAqIHN0cmlkZSwgKGxvIC0gMSkgKiBzdHJpZGUgKyBzdHJpZGUpO1xuICB9XG4gIHZhciBtMSA9IGZsYXRDb29yZGluYXRlc1sobG8gKyAxKSAqIHN0cmlkZSAtIDFdO1xuICB2YXIgdCA9IChtIC0gbTApIC8gKG0xIC0gbTApO1xuICBjb29yZGluYXRlID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaWRlIC0gMTsgKytpKSB7XG4gICAgY29vcmRpbmF0ZS5wdXNoKGxlcnAoZmxhdENvb3JkaW5hdGVzWyhsbyAtIDEpICogc3RyaWRlICsgaV0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbbG8gKiBzdHJpZGUgKyBpXSwgdCkpO1xuICB9XG4gIGNvb3JkaW5hdGUucHVzaChtKTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICogQHBhcmFtIHtib29sZWFufSBleHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW50ZXJwb2xhdGUgSW50ZXJwb2xhdGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ3NDb29yZGluYXRlQXRNKFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbZW5kcy5sZW5ndGggLSAxXSwgc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSk7XG4gIH1cbiAgdmFyIGNvb3JkaW5hdGU7XG4gIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSAtIDFdKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKDAsIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGZsYXRDb29yZGluYXRlc1tmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0gPCBtKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGZsYXRDb29yZGluYXRlcy5sZW5ndGggLSBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobSA8PSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gMV0pIHtcbiAgICAgIHJldHVybiBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBtLCBmYWxzZSk7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJwb2xhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50XG4gKi9cbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGNyZWF0ZUVtcHR5LCBleHRlbmRGbGF0Q29vcmRpbmF0ZXMsIGludGVyc2VjdHMsIGludGVyc2VjdHNTZWdtZW50fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nQ29udGFpbnNYWSwgbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50fSBmcm9tICcuLi9mbGF0L2NvbnRhaW5zLmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi4vZmxhdC9zZWdtZW50cy5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkge1xuICB2YXIgY29vcmRpbmF0ZXNFeHRlbnQgPSBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgY3JlYXRlRW1wdHkoKSwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgaWYgKCFpbnRlcnNlY3RzKGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0V4dGVudChleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFswXSA+PSBleHRlbnRbMF0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzJdIDw9IGV4dGVudFsyXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFsxXSA+PSBleHRlbnRbMV0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzNdIDw9IGV4dGVudFszXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmb3JFYWNoU2VnbWVudChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwb2ludDEgU3RhcnQgcG9pbnQuXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwb2ludDIgRW5kIHBvaW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc2VnbWVudCBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QsXG4gICAgICogICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0c1NlZ21lbnQoZXh0ZW50LCBwb2ludDEsIHBvaW50Mik7XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBleHRlbnQpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKGludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbaV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpIHtcbiAgaWYgKGludGVyc2VjdHNMaW5lU3RyaW5nKFxuICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudFswXSwgZXh0ZW50WzFdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudFswXSwgZXh0ZW50WzNdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudFsyXSwgZXh0ZW50WzFdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudFsyXSwgZXh0ZW50WzNdKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGV4dGVudCkge1xuICBpZiAoIWludGVyc2VjdHNMaW5lYXJSaW5nKFxuICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzWzBdLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDEsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKGxpbmVhclJpbmdDb250YWluc0V4dGVudChmbGF0Q29vcmRpbmF0ZXMsIGVuZHNbaSAtIDFdLCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nTXVsdGlBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyc2VjdHNleHRlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9sZW5ndGhcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHZhciBsZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgIHZhciB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBQZXJpbWV0ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICB2YXIgcGVyaW1ldGVyID0gbGluZVN0cmluZ0xlbmd0aChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICB2YXIgZHggPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXSAtIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICB2YXIgZHkgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV0gLSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIHBlcmltZXRlciArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gcGVyaW1ldGVyO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5ndGguanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9vcmllbnRcbiAqL1xuaW1wb3J0IHtjb29yZGluYXRlcyBhcyByZXZlcnNlQ29vcmRpbmF0ZXN9IGZyb20gJy4uL2ZsYXQvcmV2ZXJzZS5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGNsb2Nrd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgLy8gaHR0cDovL3Rpbnl1cmwuY29tL2Nsb2Nrd2lzZS1tZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi90cnVuay9nZGFsL29nci9vZ3JsaW5lYXJyaW5nLmNwcFxuICB2YXIgZWRnZSA9IDA7XG4gIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICB2YXIgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB2YXIgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICB2YXIgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgZWRnZSArPSAoeDIgLSB4MSkgKiAoeTIgKyB5MSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBlZGdlID4gMDtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbGluZWFyIHJpbmdzIGFyZSBvcmllbnRlZC4gIEJ5IGRlZmF1bHQsIGxlZnQtaGFuZCBvcmllbnRhdGlvblxuICogaXMgdGVzdGVkIChmaXJzdCByaW5nIG11c3QgYmUgY2xvY2t3aXNlLCByZW1haW5pbmcgcmluZ3MgY291bnRlci1jbG9ja3dpc2UpLlxuICogVG8gdGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvbiwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBBcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNPcmllbnRlZChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBvcHRfcmlnaHQpIHtcbiAgdmFyIHJpZ2h0ID0gb3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQgPyBvcHRfcmlnaHQgOiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgdmFyIGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaWYgKChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChyaWdodCAmJiAhaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBsaW5lYXIgcmluZ3MgYXJlIG9yaWVudGVkLiAgQnkgZGVmYXVsdCwgbGVmdC1oYW5kIG9yaWVudGF0aW9uXG4gKiBpcyB0ZXN0ZWQgKGZpcnN0IHJpbmcgbXVzdCBiZSBjbG9ja3dpc2UsIHJlbWFpbmluZyByaW5ncyBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKiBUbyB0ZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uLCB1c2UgdGhlIGBvcHRfcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGVuZHNzIEFycmF5IG9mIGFycmF5IG9mIGVuZCBpbmRleGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgVGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvblxuICogICAgIChjb3VudGVyLWNsb2Nrd2lzZSBleHRlcmlvciByaW5nIGFuZCBjbG9ja3dpc2UgaW50ZXJpb3IgcmluZ3MpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmluZ3MgYXJlIGNvcnJlY3RseSBvcmllbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKCFsaW5lYXJSaW5nSXNPcmllbnRlZChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzc1tpXSwgc3RyaWRlLCBvcHRfcmlnaHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogT3JpZW50IGNvb3JkaW5hdGVzIGluIGEgZmxhdCBhcnJheSBvZiBsaW5lYXIgcmluZ3MuICBCeSBkZWZhdWx0LCByaW5nc1xuICogYXJlIG9yaWVudGVkIGZvbGxvd2luZyB0aGUgbGVmdC1oYW5kIHJ1bGUgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgVG8gb3JpZW50IGFjY29yZGluZyB0byB0aGVcbiAqIHJpZ2h0LWhhbmQgcnVsZSwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgRm9sbG93IHRoZSByaWdodC1oYW5kIHJ1bGUgZm9yIG9yaWVudGF0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcmllbnRMaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBvcHRfcmlnaHQpIHtcbiAgdmFyIHJpZ2h0ID0gb3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQgPyBvcHRfcmlnaHQgOiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgdmFyIGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICB2YXIgcmV2ZXJzZSA9IGkgPT09IDAgP1xuICAgICAgKHJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgOlxuICAgICAgKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgb2Zmc2V0ID0gb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSwgb3B0X3JpZ2h0KTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmllbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9yZXZlcnNlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQgLSBzdHJpZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICB2YXIgdG1wID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldO1xuICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGldID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIGldO1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIGldID0gdG1wO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGVuZCAtPSBzdHJpZGU7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV2ZXJzZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3NlZ21lbnRzXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYGNhbGxiYWNrYCBmb3IgZWFjaCBzZWdtZW50IG9mIHRoZSBmbGF0IGNvb3JkaW5hdGVzXG4gKiBhcnJheS4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIGZ1bmN0aW9uIHJldHVybnMgdGhhdFxuICogdmFsdWUgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBUfSBjYWxsYmFjayBGdW5jdGlvblxuICogICAgIGNhbGxlZCBmb3IgZWFjaCBzZWdtZW50LlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byBiZSB1c2VkIGFzIHRoZSB2YWx1ZSBvZiAndGhpcydcbiAqICAgICB3aXRoaW4gY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtUfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFQsU1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICB2YXIgcG9pbnQxID0gW2ZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV1dO1xuICB2YXIgcG9pbnQyID0gW107XG4gIHZhciByZXQ7XG4gIGZvciAoOyAob2Zmc2V0ICsgc3RyaWRlKSA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHBvaW50MlswXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGVdO1xuICAgIHBvaW50MlsxXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgKyAxXTtcbiAgICByZXQgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBwb2ludDEsIHBvaW50Mik7XG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcG9pbnQxWzBdID0gcG9pbnQyWzBdO1xuICAgIHBvaW50MVsxXSA9IHBvaW50MlsxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlZ21lbnRzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2ltcGxpZnlcbiAqL1xuLy8gQmFzZWQgb24gc2ltcGxpZnktanMgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvc2ltcGxpZnktanNcbi8vIENvcHlyaWdodCAoYykgMjAxMiwgVmxhZGltaXIgQWdhZm9ua2luXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vL1xuLy8gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuLy8gICAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuLy8gQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Vcbi8vIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1Jcbi8vIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4vLyBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1Ncbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4vLyBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuLy8gQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbi8vIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge3NxdWFyZWRTZWdtZW50RGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZX0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtib29sZWFufSBoaWdoUXVhbGl0eSBIaWdoZXN0IHF1YWxpdHkuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gU2ltcGxpZmllZCBsaW5lIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5TGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsIGhpZ2hRdWFsaXR5LCBvcHRfc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcykge1xuICB2YXIgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IG9wdF9zaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdF9zaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIDogW107XG4gIGlmICghaGlnaFF1YWxpdHkpIHtcbiAgICBlbmQgPSByYWRpYWxEaXN0YW5jZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICAgICAgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCk7XG4gICAgZmxhdENvb3JkaW5hdGVzID0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcztcbiAgICBvZmZzZXQgPSAwO1xuICAgIHN0cmlkZSA9IDI7XG4gIH1cbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlcihcbiAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCk7XG4gIHJldHVybiBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlcihmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpIHtcbiAgdmFyIG4gPSAoZW5kIC0gb2Zmc2V0KSAvIHN0cmlkZTtcbiAgaWYgKG4gPCAzKSB7XG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICB2YXIgbWFya2VycyA9IG5ldyBBcnJheShuKTtcbiAgbWFya2Vyc1swXSA9IDE7XG4gIG1hcmtlcnNbbiAtIDFdID0gMTtcbiAgLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cbiAgdmFyIHN0YWNrID0gW29mZnNldCwgZW5kIC0gc3RyaWRlXTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBtYXhTcXVhcmVkRGlzdGFuY2UgPSAwO1xuICAgIHZhciB4MSA9IGZsYXRDb29yZGluYXRlc1tmaXJzdF07XG4gICAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0ICsgMV07XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2xhc3RdO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tsYXN0ICsgMV07XG4gICAgZm9yICh2YXIgaSA9IGZpcnN0ICsgc3RyaWRlOyBpIDwgbGFzdDsgaSArPSBzdHJpZGUpIHtcbiAgICAgIHZhciB4ID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgdmFyIHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWRTZWdtZW50RGlzdGFuY2UoXG4gICAgICAgIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPiBtYXhTcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBtYXhTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXhTcXVhcmVkRGlzdGFuY2UgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICBtYXJrZXJzWyhpbmRleCAtIG9mZnNldCkgLyBzdHJpZGVdID0gMTtcbiAgICAgIGlmIChmaXJzdCArIHN0cmlkZSA8IGluZGV4KSB7XG4gICAgICAgIHN0YWNrLnB1c2goZmlyc3QsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCArIHN0cmlkZSA8IGxhc3QpIHtcbiAgICAgICAgc3RhY2sucHVzaChpbmRleCwgbGFzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG47ICsraSQxKSB7XG4gICAgaWYgKG1hcmtlcnNbaSQxXSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgaSQxICogc3RyaWRlXTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkkMSAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHMsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCk7XG4gICAgc2ltcGxpZmllZEVuZHMucHVzaChzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHNpbXBsaWZpZWRFbmRzcyBTaW1wbGlmaWVkIGVuZHNzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyTXVsdGlBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXJBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFsRGlzdGFuY2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KSB7XG4gIGlmIChlbmQgPD0gb2Zmc2V0ICsgc3RyaWRlKSB7XG4gICAgLy8gemVybyBvciBvbmUgcG9pbnQsIG5vIHNpbXBsaWZpY2F0aW9uIHBvc3NpYmxlLCBzbyBjb3B5IGFuZCByZXR1cm5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICB2YXIgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgdmFyIHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAvLyBjb3B5IGZpcnN0IHBvaW50XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgdmFyIHgyID0geDE7XG4gIHZhciB5MiA9IHkxO1xuICBmb3IgKG9mZnNldCArPSBzdHJpZGU7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5MikgPiBzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgICAvLyBjb3B5IHBvaW50IGF0IG9mZnNldFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgIH1cbiAgfVxuICBpZiAoeDIgIT0geDEgfHwgeTIgIT0geTEpIHtcbiAgICAvLyBjb3B5IGxhc3QgcG9pbnRcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bnVtYmVyfSBSb3VuZGVkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc25hcCh2YWx1ZSwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiB0b2xlcmFuY2UgKiBNYXRoLnJvdW5kKHZhbHVlIC8gdG9sZXJhbmNlKTtcbn1cblxuXG4vKipcbiAqIFNpbXBsaWZpZXMgYSBsaW5lIHN0cmluZyB1c2luZyBhbiBhbGdvcml0aG0gZGVzaWduZWQgYnkgVGltIFNjaGF1Yi5cbiAqIENvb3JkaW5hdGVzIGFyZSBzbmFwcGVkIHRvIHRoZSBuZWFyZXN0IHZhbHVlIGluIGEgdmlydHVhbCBncmlkIGFuZFxuICogY29uc2VjdXRpdmUgZHVwbGljYXRlIGNvb3JkaW5hdGVzIGFyZSBkaXNjYXJkZWQuICBUaGlzIGVmZmVjdGl2ZWx5IHByZXNlcnZlc1xuICogdG9wb2xvZ3kgYXMgdGhlIHNpbXBsaWZpY2F0aW9uIG9mIGFueSBzdWJzZWN0aW9uIG9mIGEgbGluZSBzdHJpbmcgaXNcbiAqIGluZGVwZW5kZW50IG9mIHRoZSByZXN0IG9mIHRoZSBsaW5lIHN0cmluZy4gIFRoaXMgbWVhbnMgdGhhdCwgZm9yIGV4YW1wbGVzLFxuICogdGhlIGNvbW1vbiBlZGdlIGJldHdlZW4gdHdvIHBvbHlnb25zIHdpbGwgYmUgc2ltcGxpZmllZCB0byB0aGUgc2FtZSBsaW5lXG4gKiBzdHJpbmcgaW5kZXBlbmRlbnRseSBpbiBib3RoIHBvbHlnb25zLiAgVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIGEgc2luZ2xlXG4gKiBwYXNzIG92ZXIgdGhlIGNvb3JkaW5hdGVzIGFuZCBlbGltaW5hdGVzIGludGVybWVkaWF0ZSBjb2xsaW5lYXIgcG9pbnRzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsXG4gIHRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCkge1xuICAvLyBkbyBub3RoaW5nIGlmIHRoZSBsaW5lIGlzIGVtcHR5XG4gIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gIH1cbiAgLy8gc25hcCB0aGUgZmlyc3QgY29vcmRpbmF0ZSAoUDEpXG4gIHZhciB4MSA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gIHZhciB5MSA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICBvZmZzZXQgKz0gc3RyaWRlO1xuICAvLyBhZGQgdGhlIGZpcnN0IGNvb3JkaW5hdGUgdG8gdGhlIG91dHB1dFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MTtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTE7XG4gIC8vIGZpbmQgdGhlIG5leHQgY29vcmRpbmF0ZSB0aGF0IGRvZXMgbm90IHNuYXAgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGZpcnN0XG4gIC8vIGNvb3JkaW5hdGUgKFAyKVxuICB2YXIgeDIsIHkyO1xuICBkbyB7XG4gICAgeDIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICAgIHkyID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBpZiAob2Zmc2V0ID09IGVuZCkge1xuICAgICAgLy8gYWxsIGNvb3JkaW5hdGVzIHNuYXAgdG8gdGhlIHNhbWUgdmFsdWUsIHRoZSBsaW5lIGNvbGxhcHNlcyB0byBhIHBvaW50XG4gICAgICAvLyBwdXNoIHRoZSBsYXN0IHNuYXBwZWQgdmFsdWUgYW55d2F5IHRvIGVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgY29udGFpbnNcbiAgICAgIC8vIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICAgIC8vIEZJWE1FIHNob3VsZCB3ZSByZWFsbHkgcmV0dXJuIGF0IGxlYXN0IHR3byBwb2ludHMgYW55d2F5P1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICAgIH1cbiAgfSB3aGlsZSAoeDIgPT0geDEgJiYgeTIgPT0geTEpO1xuICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgLy8gc25hcCB0aGUgbmV4dCBjb29yZGluYXRlIChQMylcbiAgICB2YXIgeDMgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCB0b2xlcmFuY2UpO1xuICAgIHZhciB5MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgLy8gc2tpcCBQMyBpZiBpdCBpcyBlcXVhbCB0byBQMlxuICAgIGlmICh4MyA9PSB4MiAmJiB5MyA9PSB5Mikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMSBhbmQgUDJcbiAgICB2YXIgZHgxID0geDIgLSB4MTtcbiAgICB2YXIgZHkxID0geTIgLSB5MTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGRlbHRhIGJldHdlZW4gUDMgYW5kIFAxXG4gICAgdmFyIGR4MiA9IHgzIC0geDE7XG4gICAgdmFyIGR5MiA9IHkzIC0geTE7XG4gICAgLy8gaWYgUDEsIFAyLCBhbmQgUDMgYXJlIGNvbGluZWFyIGFuZCBQMyBpcyBmdXJ0aGVyIGZyb20gUDEgdGhhbiBQMiBpcyBmcm9tXG4gICAgLy8gUDEgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIHRoZW4gUDIgaXMgb24gdGhlIHN0cmFpZ2h0IGxpbmUgYmV0d2VlbiBQMSBhbmRcbiAgICAvLyBQM1xuICAgIGlmICgoZHgxICogZHkyID09IGR5MSAqIGR4MikgJiZcbiAgICAgICAgKChkeDEgPCAwICYmIGR4MiA8IGR4MSkgfHwgZHgxID09IGR4MiB8fCAoZHgxID4gMCAmJiBkeDIgPiBkeDEpKSAmJlxuICAgICAgICAoKGR5MSA8IDAgJiYgZHkyIDwgZHkxKSB8fCBkeTEgPT0gZHkyIHx8IChkeTEgPiAwICYmIGR5MiA+IGR5MSkpKSB7XG4gICAgICAvLyBkaXNjYXJkIFAyIGFuZCBzZXQgUDIgPSBQM1xuICAgICAgeDIgPSB4MztcbiAgICAgIHkyID0geTM7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gZWl0aGVyIFAxLCBQMiwgYW5kIFAzIGFyZSBub3QgY29saW5lYXIsIG9yIHRoZXkgYXJlIGNvbGluZWFyIGJ1dCBQMyBpc1xuICAgIC8vIGJldHdlZW4gUDMgYW5kIFAxIG9yIG9uIHRoZSBvcHBvc2l0ZSBoYWxmIG9mIHRoZSBsaW5lIHRvIFAyLiAgYWRkIFAyLFxuICAgIC8vIGFuZCBjb250aW51ZSB3aXRoIFAxID0gUDIgYW5kIFAyID0gUDNcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgPSB4MztcbiAgICB5MiA9IHkzO1xuICB9XG4gIC8vIGFkZCB0aGUgbGFzdCBwb2ludCAoUDIpXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MjtcbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHNpbXBsaWZpZWRFbmRzIFNpbXBsaWZpZWQgZW5kcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBlbmQgPSBlbmRzW2ldO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBxdWFudGl6ZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAgIHRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBzaW1wbGlmaWVkRW5kc3MgU2ltcGxpZmllZCBlbmRzcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZU11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzcykge1xuICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGVuZHMgPSBlbmRzc1tpXTtcbiAgICB2YXIgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gcXVhbnRpemVBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsXG4gICAgICB0b2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxpZnkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zdHJhaWdodGNodW5rXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXhpbXVtIGFjY2VwdGFibGUgYW5nbGUgZGVsdGEgYmV0d2VlbiBzZWdtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFN0YXJ0IGFuZCBlbmQgb2YgdGhlIGZpcnN0IHN1aXRhYmxlIGNodW5rIG9mIHRoZVxuICogZ2l2ZW4gYGZsYXRDb29yZGluYXRlc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGluZ0NodW5rKG1heEFuZ2xlLCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgdmFyIGNodW5rU3RhcnQgPSBvZmZzZXQ7XG4gIHZhciBjaHVua0VuZCA9IG9mZnNldDtcbiAgdmFyIGNodW5rTSA9IDA7XG4gIHZhciBtID0gMDtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xuICB2YXIgYWNvcywgaSwgbTEyLCBtMjMsIHgxLCB5MSwgeDEyLCB5MTIsIHgyMywgeTIzO1xuICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgaWYgKHgxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHgyMyA9IHgyIC0geDE7XG4gICAgICB5MjMgPSB5MiAtIHkxO1xuICAgICAgbTIzID0gTWF0aC5zcXJ0KHgyMyAqIHgyMyArIHkyMyAqIHkyMyk7XG4gICAgICBpZiAoeDEyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbSArPSBtMTI7XG4gICAgICAgIGFjb3MgPSBNYXRoLmFjb3MoKHgxMiAqIHgyMyArIHkxMiAqIHkyMykgLyAobTEyICogbTIzKSk7XG4gICAgICAgIGlmIChhY29zID4gbWF4QW5nbGUpIHtcbiAgICAgICAgICBpZiAobSA+IGNodW5rTSkge1xuICAgICAgICAgICAgY2h1bmtNID0gbTtcbiAgICAgICAgICAgIGNodW5rU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNodW5rRW5kID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgc3RhcnQgPSBpIC0gc3RyaWRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtMTIgPSBtMjM7XG4gICAgICB4MTIgPSB4MjM7XG4gICAgICB5MTIgPSB5MjM7XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICBtICs9IG0yMztcbiAgcmV0dXJuIG0gPiBjaHVua00gPyBbc3RhcnQsIGldIDogW2NodW5rU3RhcnQsIGNodW5rRW5kXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyYWlnaHRjaHVuay5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3RleHRwYXRoXG4gKi9cbmltcG9ydCB7bGVycH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgUGF0aCB0byBwdXQgdGV4dCBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU3RhcnQgb2Zmc2V0IG9mIHRoZSBgZmxhdENvb3JkaW5hdGVzYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGxhY2Ugb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6bnVtYmVyfSBtZWFzdXJlIE1lYXN1cmUgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZVxuICogd2lkdGggb2YgdGhlIGNoYXJhY3RlciBwYXNzZWQgYXMgMXN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0TSBtIGFsb25nIHRoZSBwYXRoIHdoZXJlIHRoZSB0ZXh0IHN0YXJ0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXggYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFycyBpbiByYWRpYW5zLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj59IFRoZSByZXN1bHQgYXJyYXkgb2YgbnVsbCBpZiBgbWF4QW5nbGVgIHdhc1xuICogZXhjZWVkZWQuIEVudHJpZXMgb2YgdGhlIGFycmF5IGFyZSB4LCB5LCBhbmNob3JYLCBhbmdsZSwgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3VGV4dE9uUGF0aChcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0ZXh0LCBtZWFzdXJlLCBzdGFydE0sIG1heEFuZ2xlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBLZWVwIHRleHQgdXByaWdodFxuICB2YXIgcmV2ZXJzZSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdID4gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG5cbiAgdmFyIG51bUNoYXJzID0gdGV4dC5sZW5ndGg7XG5cbiAgdmFyIHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHZhciB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgdmFyIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIHZhciB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgdmFyIHNlZ21lbnRNID0gMDtcbiAgdmFyIHNlZ21lbnRMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSk7XG5cbiAgdmFyIGNodW5rID0gJyc7XG4gIHZhciBjaHVua0xlbmd0aCA9IDA7XG4gIHZhciBkYXRhLCBpbmRleCwgcHJldmlvdXNBbmdsZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DaGFyczsgKytpKSB7XG4gICAgaW5kZXggPSByZXZlcnNlID8gbnVtQ2hhcnMgLSBpIC0gMSA6IGk7XG4gICAgdmFyIGNoYXIgPSB0ZXh0LmNoYXJBdChpbmRleCk7XG4gICAgY2h1bmsgPSByZXZlcnNlID8gY2hhciArIGNodW5rIDogY2h1bmsgKyBjaGFyO1xuICAgIHZhciBjaGFyTGVuZ3RoID0gbWVhc3VyZShjaHVuaykgLSBjaHVua0xlbmd0aDtcbiAgICBjaHVua0xlbmd0aCArPSBjaGFyTGVuZ3RoO1xuICAgIHZhciBjaGFyTSA9IHN0YXJ0TSArIGNoYXJMZW5ndGggLyAyO1xuICAgIHdoaWxlIChvZmZzZXQgPCBlbmQgLSBzdHJpZGUgJiYgc2VnbWVudE0gKyBzZWdtZW50TGVuZ3RoIDwgY2hhck0pIHtcbiAgICAgIHgxID0geDI7XG4gICAgICB5MSA9IHkyO1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICAgIHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICAgIHNlZ21lbnRNICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgICBzZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpO1xuICAgIH1cbiAgICB2YXIgc2VnbWVudFBvcyA9IGNoYXJNIC0gc2VnbWVudE07XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgYW5nbGUgKz0gYW5nbGUgPiAwID8gLU1hdGguUEkgOiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGVsdGEgPSBhbmdsZSAtIHByZXZpb3VzQW5nbGU7XG4gICAgICBkZWx0YSArPSAoZGVsdGEgPiBNYXRoLlBJKSA/IC0yICogTWF0aC5QSSA6IChkZWx0YSA8IC1NYXRoLlBJKSA/IDIgKiBNYXRoLlBJIDogMDtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBtYXhBbmdsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVycG9sYXRlID0gc2VnbWVudFBvcyAvIHNlZ21lbnRMZW5ndGg7XG4gICAgdmFyIHggPSBsZXJwKHgxLCB4MiwgaW50ZXJwb2xhdGUpO1xuICAgIHZhciB5ID0gbGVycCh5MSwgeTIsIGludGVycG9sYXRlKTtcbiAgICBpZiAocHJldmlvdXNBbmdsZSA9PSBhbmdsZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgZGF0YVswXSA9IHg7XG4gICAgICAgIGRhdGFbMV0gPSB5O1xuICAgICAgICBkYXRhWzJdID0gY2hhckxlbmd0aCAvIDI7XG4gICAgICB9XG4gICAgICBkYXRhWzRdID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rID0gY2hhcjtcbiAgICAgIGNodW5rTGVuZ3RoID0gY2hhckxlbmd0aDtcbiAgICAgIGRhdGEgPSBbeCwgeSwgY2hhckxlbmd0aCAvIDIsIGFuZ2xlLCBjaHVua107XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXN1bHQudW5zaGlmdChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmdsZSA9IGFuZ2xlO1xuICAgIH1cbiAgICBzdGFydE0gKz0gY2hhckxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0cGF0aC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3RyYW5zZm9ybVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0yRChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHRyYW5zZm9ybSwgb3B0X2Rlc3QpIHtcbiAgdmFyIGRlc3QgPSBvcHRfZGVzdCA/IG9wdF9kZXN0IDogW107XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICB2YXIgeCA9IGZsYXRDb29yZGluYXRlc1tqXTtcbiAgICB2YXIgeSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVsyXSAqIHkgKyB0cmFuc2Zvcm1bNF07XG4gICAgZGVzdFtpKytdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbmdsZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFuY2hvciBSb3RhdGlvbiBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBvcHRfZGVzdCkge1xuICB2YXIgZGVzdCA9IG9wdF9kZXN0ID8gb3B0X2Rlc3QgOiBbXTtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIGFuY2hvclggPSBhbmNob3JbMF07XG4gIHZhciBhbmNob3JZID0gYW5jaG9yWzFdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgdmFyIGRlbHRhWCA9IGZsYXRDb29yZGluYXRlc1tqXSAtIGFuY2hvclg7XG4gICAgdmFyIGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBkZWx0YVggKiBjb3MgLSBkZWx0YVkgKiBzaW47XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIGRlbHRhWCAqIHNpbiArIGRlbHRhWSAqIGNvcztcbiAgICBmb3IgKHZhciBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBTY2FsZSB0aGUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgaW4gdGhlIHgtZGlyZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHN5IFNjYWxlIGZhY3RvciBpbiB0aGUgeS1kaXJlY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhbmNob3IgU2NhbGUgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBzeCwgc3ksIGFuY2hvciwgb3B0X2Rlc3QpIHtcbiAgdmFyIGRlc3QgPSBvcHRfZGVzdCA/IG9wdF9kZXN0IDogW107XG4gIHZhciBhbmNob3JYID0gYW5jaG9yWzBdO1xuICB2YXIgYW5jaG9yWSA9IGFuY2hvclsxXTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKHZhciBqID0gb2Zmc2V0OyBqIDwgZW5kOyBqICs9IHN0cmlkZSkge1xuICAgIHZhciBkZWx0YVggPSBmbGF0Q29vcmRpbmF0ZXNbal0gLSBhbmNob3JYO1xuICAgIHZhciBkZWx0YVkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdIC0gYW5jaG9yWTtcbiAgICBkZXN0W2krK10gPSBhbmNob3JYICsgc3ggKiBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIHN5ICogZGVsdGFZO1xuICAgIGZvciAodmFyIGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBEZWx0YSBZLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZGVsdGFYLCBkZWx0YVksIG9wdF9kZXN0KSB7XG4gIHZhciBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICB2YXIgaSA9IDA7XG4gIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2pdICsgZGVsdGFYO1xuICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gKyBkZWx0YVk7XG4gICAgZm9yICh2YXIgayA9IGogKyAyOyBrIDwgaiArIHN0cmlkZTsgKytrKSB7XG4gICAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNba107XG4gICAgfVxuICB9XG4gIGlmIChvcHRfZGVzdCAmJiBkZXN0Lmxlbmd0aCAhPSBpKSB7XG4gICAgZGVzdC5sZW5ndGggPSBpO1xuICB9XG4gIHJldHVybiBkZXN0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2hhc1xuICovXG5cbnZhciB1YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID9cbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIEZpcmVmb3ggYXMgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIEZJUkVGT1ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBTYWZhcmkgYXMgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIFNBRkFSSSA9IHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdjaHJvbScpID09IC0xO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIFdlYktpdCBlbmdpbmUuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBXRUJLSVQgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignZWRnZScpID09IC0xO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIE1hYyBhcyBwbGF0Zm9ybS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIE1BQyA9IHVhLmluZGV4T2YoJ21hY2ludG9zaCcpICE9PSAtMTtcblxuXG4vKipcbiAqIFRoZSByYXRpbyBiZXR3ZWVuIHBoeXNpY2FsIHBpeGVscyBhbmQgZGV2aWNlLWluZGVwZW5kZW50IHBpeGVsc1xuICogKGRpcHMpIG9uIHRoZSBkZXZpY2UgKGB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb2ApLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIERFVklDRV9QSVhFTF9SQVRJTyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBicm93c2VyJ3MgQ2FudmFzIGltcGxlbWVudGF0aW9uIGltcGxlbWVudHMge2dldCxzZXR9TGluZURhc2guXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBDQU5WQVNfTElORV9EQVNIID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYXMgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBoYXMgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpLmdldENvbnRleHQoJzJkJykuc2V0TGluZURhc2g7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwYXNzXG4gIH1cbiAgcmV0dXJuIGhhcztcbn0oKTtcblxuXG4vKipcbiAqIElzIEhUTUw1IGdlb2xvY2F0aW9uIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyP1xuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBHRU9MT0NBVElPTiA9ICdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yO1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIHRvdWNoIGV2ZW50cy5cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCB2YXIgVE9VQ0ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgcG9pbnRlciBldmVudHMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIFBPSU5URVIgPSAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3c7XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgbXMgcG9pbnRlciBldmVudHMgKElFIDEwKS5cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCB2YXIgTVNQT0lOVEVSID0gISEobmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpO1xuXG5cbmV4cG9ydCB7SEFTIGFzIFdFQkdMfSBmcm9tICcuL3dlYmdsLmpzJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvblxuICovXG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IEtpbmV0aWMgZnJvbSAnLi9LaW5ldGljLmpzJztcbmltcG9ydCBEb3VibGVDbGlja1pvb20gZnJvbSAnLi9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanMnO1xuaW1wb3J0IERyYWdQYW4gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzJztcbmltcG9ydCBEcmFnUm90YXRlIGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZS5qcyc7XG5pbXBvcnQgRHJhZ1pvb20gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyc7XG5pbXBvcnQgS2V5Ym9hcmRQYW4gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbi5qcyc7XG5pbXBvcnQgS2V5Ym9hcmRab29tIGZyb20gJy4vaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tLmpzJztcbmltcG9ydCBNb3VzZVdoZWVsWm9vbSBmcm9tICcuL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tLmpzJztcbmltcG9ydCBQaW5jaFJvdGF0ZSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlLmpzJztcbmltcG9ydCBQaW5jaFpvb20gZnJvbSAnLi9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanMnO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgRG91YmxlQ2xpY2tab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ0FuZERyb3B9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3AuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdCb3h9IGZyb20gJy4vaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhZ1Bhbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnUm90YXRlfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGUuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERyYWdSb3RhdGVBbmRab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBEcmFnWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgRHJhd30gZnJvbSAnLi9pbnRlcmFjdGlvbi9EcmF3LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFeHRlbnR9IGZyb20gJy4vaW50ZXJhY3Rpb24vRXh0ZW50LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBJbnRlcmFjdGlvbn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgS2V5Ym9hcmRQYW59IGZyb20gJy4vaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEtleWJvYXJkWm9vbX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1vZGlmeX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9Nb2RpZnkuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIE1vdXNlV2hlZWxab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQaW5jaFJvdGF0ZX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUGluY2hab29tfSBmcm9tICcuL2ludGVyYWN0aW9uL1BpbmNoWm9vbS5qcyc7XG5leHBvcnQge2RlZmF1bHQgYXMgUG9pbnRlcn0gZnJvbSAnLi9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTZWxlY3R9IGZyb20gJy4vaW50ZXJhY3Rpb24vU2VsZWN0LmpzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBTbmFwfSBmcm9tICcuL2ludGVyYWN0aW9uL1NuYXAuanMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFRyYW5zbGF0ZX0gZnJvbSAnLi9pbnRlcmFjdGlvbi9UcmFuc2xhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGVmYXVsdHNPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHRTaGlmdERyYWdSb3RhdGU9dHJ1ZV0gV2hldGhlciBBbHQtU2hpZnQtZHJhZyByb3RhdGUgaXNcbiAqIGRlc2lyZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBab29tIHRvIHRoZSBjbG9zZXN0IGludGVnZXJcbiAqIHpvb20gbGV2ZWwgYWZ0ZXIgdGhlIHdoZWVsL3RyYWNrcGFkIG9yIHBpbmNoIGdlc3R1cmUgZW5kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvdWJsZUNsaWNrWm9vbT10cnVlXSBXaGV0aGVyIGRvdWJsZSBjbGljayB6b29tIGlzXG4gKiBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBba2V5Ym9hcmQ9dHJ1ZV0gV2hldGhlciBrZXlib2FyZCBpbnRlcmFjdGlvbiBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbW91c2VXaGVlbFpvb209dHJ1ZV0gV2hldGhlciBtb3VzZXdoZWVsIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NoaWZ0RHJhZ1pvb209dHJ1ZV0gV2hldGhlciBTaGlmdC1kcmFnIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RyYWdQYW49dHJ1ZV0gV2hldGhlciBkcmFnIHBhbiBpcyBkZXNpcmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcGluY2hSb3RhdGU9dHJ1ZV0gV2hldGhlciBwaW5jaCByb3RhdGUgaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BpbmNoWm9vbT10cnVlXSBXaGV0aGVyIHBpbmNoIHpvb20gaXMgZGVzaXJlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbURlbHRhXSBab29tIGxldmVsIGRlbHRhIHdoZW4gdXNpbmcga2V5Ym9hcmQgb3JcbiAqIG1vdXNld2hlZWwgem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbUR1cmF0aW9uXSBEdXJhdGlvbiBvZiB0aGUgem9vbSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG5cbi8qKlxuICogU2V0IG9mIGludGVyYWN0aW9ucyBpbmNsdWRlZCBpbiBtYXBzIGJ5IGRlZmF1bHQuIFNwZWNpZmljIGludGVyYWN0aW9ucyBjYW4gYmVcbiAqIGV4Y2x1ZGVkIGJ5IHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIG9wdGlvbiB0byBmYWxzZSBpbiB0aGUgY29uc3RydWN0b3JcbiAqIG9wdGlvbnMsIGJ1dCB0aGUgb3JkZXIgb2YgdGhlIGludGVyYWN0aW9ucyBpcyBmaXhlZC4gIElmIHlvdSB3YW50IHRvIHNwZWNpZnlcbiAqIGEgZGlmZmVyZW50IG9yZGVyIGZvciBpbnRlcmFjdGlvbnMsIHlvdSB3aWxsIG5lZWQgdG8gY3JlYXRlIHlvdXIgb3duXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9ufSBpbnN0YW5jZXMgYW5kIGluc2VydFxuICogdGhlbSBpbnRvIGEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufSBpbiB0aGUgb3JkZXIgeW91IHdhbnRcbiAqIGJlZm9yZSBjcmVhdGluZyB5b3VyIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH0gaW5zdGFuY2UuIFRoZSBkZWZhdWx0IHNldCBvZlxuICogaW50ZXJhY3Rpb25zLCBpbiBzZXF1ZW5jZSwgaXM6XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZX5EcmFnUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbX5Eb3VibGVDbGlja1pvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn5EcmFnUGFufVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlflBpbmNoUm90YXRlfVxuICogKiB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbX5QaW5jaFpvb219XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59XG4gKiAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbX5Nb3VzZVdoZWVsWm9vbX1cbiAqICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbX5EcmFnWm9vbX1cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbn5EZWZhdWx0c09wdGlvbnM9fSBvcHRfb3B0aW9uc1xuICogRGVmYXVsdHMgb3B0aW9ucy5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24+fVxuICogQSBjb2xsZWN0aW9uIG9mIGludGVyYWN0aW9ucyB0byBiZSB1c2VkIHdpdGggdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcH1cbiAqIGNvbnN0cnVjdG9yJ3MgYGludGVyYWN0aW9uc2Agb3B0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdHMob3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IENvbGxlY3Rpb24oKTtcblxuICB2YXIga2luZXRpYyA9IG5ldyBLaW5ldGljKC0wLjAwNSwgMC4wNSwgMTAwKTtcblxuICB2YXIgYWx0U2hpZnREcmFnUm90YXRlID0gb3B0aW9ucy5hbHRTaGlmdERyYWdSb3RhdGUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5hbHRTaGlmdERyYWdSb3RhdGUgOiB0cnVlO1xuICBpZiAoYWx0U2hpZnREcmFnUm90YXRlKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IERyYWdSb3RhdGUoKSk7XG4gIH1cblxuICB2YXIgZG91YmxlQ2xpY2tab29tID0gb3B0aW9ucy5kb3VibGVDbGlja1pvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5kb3VibGVDbGlja1pvb20gOiB0cnVlO1xuICBpZiAoZG91YmxlQ2xpY2tab29tKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IERvdWJsZUNsaWNrWm9vbSh7XG4gICAgICBkZWx0YTogb3B0aW9ucy56b29tRGVsdGEsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICB2YXIgZHJhZ1BhbiA9IG9wdGlvbnMuZHJhZ1BhbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnUGFuIDogdHJ1ZTtcbiAgaWYgKGRyYWdQYW4pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1Bhbih7XG4gICAgICBraW5ldGljOiBraW5ldGljXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIHBpbmNoUm90YXRlID0gb3B0aW9ucy5waW5jaFJvdGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5waW5jaFJvdGF0ZSA6XG4gICAgdHJ1ZTtcbiAgaWYgKHBpbmNoUm90YXRlKSB7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IFBpbmNoUm90YXRlKCkpO1xuICB9XG5cbiAgdmFyIHBpbmNoWm9vbSA9IG9wdGlvbnMucGluY2hab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBpbmNoWm9vbSA6IHRydWU7XG4gIGlmIChwaW5jaFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgUGluY2hab29tKHtcbiAgICAgIGNvbnN0cmFpblJlc29sdXRpb246IG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbixcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLnpvb21EdXJhdGlvblxuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5Ym9hcmQgOiB0cnVlO1xuICBpZiAoa2V5Ym9hcmQpIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgS2V5Ym9hcmRQYW4oKSk7XG4gICAgaW50ZXJhY3Rpb25zLnB1c2gobmV3IEtleWJvYXJkWm9vbSh7XG4gICAgICBkZWx0YTogb3B0aW9ucy56b29tRGVsdGEsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy56b29tRHVyYXRpb25cbiAgICB9KSk7XG4gIH1cblxuICB2YXIgbW91c2VXaGVlbFpvb20gPSBvcHRpb25zLm1vdXNlV2hlZWxab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMubW91c2VXaGVlbFpvb20gOiB0cnVlO1xuICBpZiAobW91c2VXaGVlbFpvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgTW91c2VXaGVlbFpvb20oe1xuICAgICAgY29uc3RyYWluUmVzb2x1dGlvbjogb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgdmFyIHNoaWZ0RHJhZ1pvb20gPSBvcHRpb25zLnNoaWZ0RHJhZ1pvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy5zaGlmdERyYWdab29tIDogdHJ1ZTtcbiAgaWYgKHNoaWZ0RHJhZ1pvb20pIHtcbiAgICBpbnRlcmFjdGlvbnMucHVzaChuZXcgRHJhZ1pvb20oe1xuICAgICAgZHVyYXRpb246IG9wdGlvbnMuem9vbUR1cmF0aW9uXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGludGVyYWN0aW9ucztcblxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmFjdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tXG4gKi9cbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4uL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MjUwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBkZWx0YSBhcHBsaWVkIG9uIGVhY2ggZG91YmxlIGNsaWNrLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSBieSBkb3VibGUtY2xpY2tpbmcgb24gdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xudmFyIERvdWJsZUNsaWNrWm9vbSA9IChmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRG91YmxlQ2xpY2tab29tKG9wdF9vcHRpb25zKSB7XG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gb3B0aW9ucy5kZWx0YSA/IG9wdGlvbnMuZGVsdGEgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDI1MDtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIERvdWJsZUNsaWNrWm9vbS5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgRG91YmxlQ2xpY2tab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEb3VibGVDbGlja1pvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG91YmxlQ2xpY2tab29tO1xuXG4gIHJldHVybiBEb3VibGVDbGlja1pvb207XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhXG4gKiBkb3VibGVjbGljaykgYW5kIGV2ZW50dWFsbHkgem9vbXMgdGhlIG1hcC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgc3RvcEV2ZW50ID0gZmFsc2U7XG4gIHZhciBicm93c2VyRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuREJMQ0xJQ0spIHtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgYW5jaG9yID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgdmFyIGRlbHRhID0gYnJvd3NlckV2ZW50LnNoaWZ0S2V5ID8gLXRoaXMuZGVsdGFfIDogdGhpcy5kZWx0YV87XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBhbmNob3IsIHRoaXMuZHVyYXRpb25fKTtcbiAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICB9XG4gIHJldHVybiAhc3RvcEV2ZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBEb3VibGVDbGlja1pvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURvdWJsZUNsaWNrWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3BcbiAqL1xuLy8gRklYTUUgc2hvdWxkIGhhbmRsZSBhbGwgZ2VvLXJlZmVyZW5jZWQgZGF0YSwgbm90IGp1c3QgdmVjdG9yIGRhdGFcblxuaW1wb3J0IHtUUlVFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24gZnJvbSAnLi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbn0gZnJvbSAnLi4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5LjxmdW5jdGlvbihuZXc6IG1vZHVsZTpvbC9mb3JtYXQvRmVhdHVyZSk+fSBbZm9ybWF0Q29uc3RydWN0b3JzXSBGb3JtYXQgY29uc3RydWN0b3JzLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gW3NvdXJjZV0gT3B0aW9uYWwgdmVjdG9yIHNvdXJjZSB3aGVyZSBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkLiAgSWYgYSBzb3VyY2UgaXMgcHJvdmlkZWRcbiAqIGFsbCBleGlzdGluZyBmZWF0dXJlcyB3aWxsIGJlIHJlbW92ZWQgYW5kIG5ldyBmZWF0dXJlcyB3aWxsIGJlIGFkZGVkIHdoZW5cbiAqIHRoZXkgYXJlIGRyb3BwZWQgb24gdGhlIHRhcmdldC4gIElmIHlvdSB3YW50IHRvIGFkZCBmZWF0dXJlcyB0byBhIHZlY3RvclxuICogc291cmNlIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGV4aXN0aW5nIGZlYXR1cmVzIChhcHBlbmQgb25seSksIGluc3RlYWQgb2ZcbiAqIHByb3ZpZGluZyB0aGUgc291cmNlIG9wdGlvbiBsaXN0ZW4gZm9yIHRoZSBcImFkZGZlYXR1cmVzXCIgZXZlbnQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gVGFyZ2V0IHByb2plY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBtYXAncyB2aWV3J3MgcHJvamVjdGlvbiBpcyB1c2VkLlxuICogQHByb3BlcnR5IHtFbGVtZW50fSBbdGFyZ2V0XSBUaGUgZWxlbWVudCB0aGF0IGlzIHVzZWQgYXMgdGhlIGRyb3AgdGFyZ2V0LCBkZWZhdWx0IGlzIHRoZSB2aWV3cG9ydCBlbGVtZW50LlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRHJhZ0FuZERyb3BFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBmZWF0dXJlcyBhcmUgYWRkZWRcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcH5EcmFnQW5kRHJvcEV2ZW50I2FkZGZlYXR1cmVzXG4gICAqIEBhcGlcbiAgICovXG4gIEFERF9GRUFUVVJFUzogJ2FkZGZlYXR1cmVzJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0FuZERyb3B+RHJhZ0FuZERyb3B9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzXG4gKiBvZiB0aGlzIHR5cGUuXG4gKi9cbnZhciBEcmFnQW5kRHJvcEV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBEcmFnQW5kRHJvcEV2ZW50KHR5cGUsIGZpbGUsIG9wdF9mZWF0dXJlcywgb3B0X3Byb2plY3Rpb24pIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZXMgcGFyc2VkIGZyb20gZHJvcHBlZCBkYXRhLlxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL0ZlYXR1cmU+fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlcyA9IG9wdF9mZWF0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcm9wcGVkIGZpbGUuXG4gICAgICogQHR5cGUge0ZpbGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZSBwcm9qZWN0aW9uLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gb3B0X3Byb2plY3Rpb247XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBEcmFnQW5kRHJvcEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBEcmFnQW5kRHJvcEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBEcmFnQW5kRHJvcEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdBbmREcm9wRXZlbnQ7XG5cbiAgcmV0dXJuIERyYWdBbmREcm9wRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIYW5kbGVzIGlucHV0IG9mIHZlY3RvciBkYXRhIGJ5IGRyYWcgYW5kIGRyb3AuXG4gKiBAYXBpXG4gKlxuICogQGZpcmVzIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQW5kRHJvcH5EcmFnQW5kRHJvcEV2ZW50XG4gKi9cbnZhciBEcmFnQW5kRHJvcCA9IChmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ0FuZERyb3Aob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogVFJVRVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPGZ1bmN0aW9uKG5ldzogbW9kdWxlOm9sL2Zvcm1hdC9GZWF0dXJlKT59XG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRDb25zdHJ1Y3RvcnNfID0gb3B0aW9ucy5mb3JtYXRDb25zdHJ1Y3RvcnMgP1xuICAgICAgb3B0aW9ucy5mb3JtYXRDb25zdHJ1Y3RvcnMgOiBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uXyA9IG9wdGlvbnMucHJvamVjdGlvbiA/XG4gICAgICBnZXRQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbikgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBvcHRpb25zLnNvdXJjZSB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0ID8gb3B0aW9ucy50YXJnZXQgOiBudWxsO1xuXG4gIH1cblxuICBpZiAoIEludGVyYWN0aW9uICkgRHJhZ0FuZERyb3AuX19wcm90b19fID0gSW50ZXJhY3Rpb247XG4gIERyYWdBbmREcm9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVyYWN0aW9uICYmIEludGVyYWN0aW9uLnByb3RvdHlwZSApO1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnQW5kRHJvcDtcblxuICAvKipcbiAgICogQHBhcmFtIHtGaWxlfSBmaWxlIEZpbGUuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IExvYWQgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUuaGFuZGxlUmVzdWx0XyA9IGZ1bmN0aW9uIGhhbmRsZVJlc3VsdF8gKGZpbGUsIGV2ZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVzdWx0ID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbl87XG4gICAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBwcm9qZWN0aW9uID0gdmlldy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdENvbnN0cnVjdG9ycyA9IHRoaXMuZm9ybWF0Q29uc3RydWN0b3JzXztcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmb3JtYXRDb25zdHJ1Y3RvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgLyoqXG4gICAgICAgKiBBdm9pZCBcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzc1wiIGVycm9yLlxuICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICovXG4gICAgICB2YXIgZm9ybWF0Q29uc3RydWN0b3IgPSBmb3JtYXRDb25zdHJ1Y3RvcnNbaV07XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZm9ybWF0L0ZlYXR1cmV9XG4gICAgICAgKi9cbiAgICAgIHZhciBmb3JtYXQgPSBuZXcgZm9ybWF0Q29uc3RydWN0b3IoKTtcbiAgICAgIGZlYXR1cmVzID0gdGhpcyQxLnRyeVJlYWRGZWF0dXJlc18oZm9ybWF0LCByZXN1bHQsIHtcbiAgICAgICAgZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIHRoaXMuc291cmNlXy5jbGVhcigpO1xuICAgICAgdGhpcy5zb3VyY2VfLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IERyYWdBbmREcm9wRXZlbnQoXG4gICAgICAgIERyYWdBbmREcm9wRXZlbnRUeXBlLkFERF9GRUFUVVJFUywgZmlsZSxcbiAgICAgICAgZmVhdHVyZXMsIHByb2plY3Rpb24pKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYWdBbmREcm9wLnByb3RvdHlwZS5yZWdpc3Rlckxpc3RlbmVyc18gPSBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyc18gKCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXApIHtcbiAgICAgIHZhciBkcm9wQXJlYSA9IHRoaXMudGFyZ2V0ID8gdGhpcy50YXJnZXQgOiBtYXAuZ2V0Vmlld3BvcnQoKTtcbiAgICAgIHRoaXMuZHJvcExpc3RlbktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oZHJvcEFyZWEsIEV2ZW50VHlwZS5EUk9QLCBoYW5kbGVEcm9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJBR0VOVEVSLCBoYW5kbGVTdG9wLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGRyb3BBcmVhLCBFdmVudFR5cGUuRFJBR09WRVIsIGhhbmRsZVN0b3AsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oZHJvcEFyZWEsIEV2ZW50VHlwZS5EUk9QLCBoYW5kbGVTdG9wLCB0aGlzKVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gc2V0QWN0aXZlIChhY3RpdmUpIHtcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlLmNhbGwodGhpcywgYWN0aXZlKTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnNfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhZ0FuZERyb3AucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICAgIGlmICh0aGlzLmdldEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzXygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZm9ybWF0L0ZlYXR1cmV9IGZvcm1hdCBGb3JtYXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Zvcm1hdC9GZWF0dXJlflJlYWRPcHRpb25zfSBvcHRpb25zIFJlYWQgb3B0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gRmVhdHVyZXMuXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUudHJ5UmVhZEZlYXR1cmVzXyA9IGZ1bmN0aW9uIHRyeVJlYWRGZWF0dXJlc18gKGZvcm1hdCwgdGV4dCwgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0LnJlYWRGZWF0dXJlcyh0ZXh0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmFnQW5kRHJvcC5wcm90b3R5cGUudW5yZWdpc3Rlckxpc3RlbmVyc18gPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzXyAoKSB7XG4gICAgaWYgKHRoaXMuZHJvcExpc3RlbktleXNfKSB7XG4gICAgICB0aGlzLmRyb3BMaXN0ZW5LZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgICAgdGhpcy5kcm9wTGlzdGVuS2V5c18gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRHJhZ0FuZERyb3A7XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0RyYWdFdmVudH0gZXZlbnQgRXZlbnQuXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdBbmREcm9wfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcm9wKGV2ZW50KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBmaWxlcyA9IGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcztcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmlsZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBmaWxlID0gZmlsZXMuaXRlbShpKTtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuTE9BRCwgdGhpcyQxLmhhbmRsZVJlc3VsdF8uYmluZCh0aGlzJDEsIGZpbGUpKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtEcmFnRXZlbnR9IGV2ZW50IEV2ZW50LlxuICovXG5mdW5jdGlvbiBoYW5kbGVTdG9wKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5Jztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQW5kRHJvcDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ0FuZERyb3AuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdCb3hcbiAqL1xuLy8gRklYTUUgZHJhdyBkcmFnIGJveFxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2Fsd2F5cywgbW91c2VPbmx5LCBtb3VzZUFjdGlvbkJ1dHRvbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi4vaW50ZXJhY3Rpb24vUG9pbnRlci5qcyc7XG5pbXBvcnQgUmVuZGVyQm94IGZyb20gJy4uL3JlbmRlci9Cb3guanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGFuZCB0d29cbiAqIHtAbGluayBtb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9cyBhbmQgcmV0dXJucyBhIGB7Ym9vbGVhbn1gLiBJZiB0aGUgY29uZGl0aW9uIGlzIG1ldCxcbiAqIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6ID8sIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQsIG1vZHVsZTpvbC9waXhlbH5QaXhlbCwgbW9kdWxlOm9sL3BpeGVsflBpeGVsKTpib29sZWFufSBFbmRDb25kaXRpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLWRyYWdib3gnXSBDU1MgY2xhc3MgbmFtZSBmb3Igc3R5bGluZyB0aGUgYm94LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICogdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgb2wvZXZlbnRzL2NvbmRpdGlvbn5hbHdheXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5BcmVhPTY0XSBUaGUgbWluaW11bSBhcmVhIG9mIHRoZSBib3ggaW4gcGl4ZWwsIHRoaXMgdmFsdWUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICogYGJveEVuZENvbmRpdGlvbmAgZnVuY3Rpb24uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fkVuZENvbmRpdGlvbn0gW2JveEVuZENvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgdHdvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3BpeGVsflBpeGVsfXMgdG8gaW5kaWNhdGUgd2hldGhlciBhIGBib3hlbmRgIGV2ZW50IHNob3VsZCBiZSBmaXJlZC5cbiAqIERlZmF1bHQgaXMgYHRydWVgIGlmIHRoZSBhcmVhIG9mIHRoZSBib3ggaXMgYmlnZ2VyIHRoYW4gdGhlIGBtaW5BcmVhYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHRoaXM6bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdCb3gsIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQpfSBvbkJveEVuZCBDb2RlIHRvIGV4ZWN1dGUganVzdFxuICogYmVmb3JlIGBib3hlbmRgIGlzIGZpcmVkLlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgRHJhZ0JveEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IHN0YXJ0LlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdCb3h+RHJhZ0JveEV2ZW50I2JveHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIEJPWFNUQVJUOiAnYm94c3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgb24gZHJhZyB3aGVuIGJveCBpcyBhY3RpdmUuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5EcmFnQm94RXZlbnQjYm94ZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBCT1hEUkFHOiAnYm94ZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGVuZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fkRyYWdCb3hFdmVudCNib3hlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRU5EOiAnYm94ZW5kJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5EcmFnQm94fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG52YXIgRHJhZ0JveEV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBEcmFnQm94RXZlbnQodHlwZSwgY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBkcmFnIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50ID0gbWFwQnJvd3NlckV2ZW50O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgRHJhZ0JveEV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBEcmFnQm94RXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIERyYWdCb3hFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnQm94RXZlbnQ7XG5cbiAgcmV0dXJuIERyYWdCb3hFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBkcmF3IGEgdmVjdG9yIGJveCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgc2hpZnQgb3Igb3RoZXIga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSxcbiAqIGZvciB6b29taW5nIHRvIGEgc3BlY2lmaWMgYXJlYSBvZiB0aGUgbWFwXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX0pLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKlxuICogQGZpcmVzIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fkRyYWdCb3hFdmVudFxuICogQGFwaVxuICovXG52YXIgRHJhZ0JveCA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIERyYWdCb3gob3B0X29wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZURvd25FdmVudDogaGFuZGxlRG93bkV2ZW50LFxuICAgICAgaGFuZGxlRHJhZ0V2ZW50OiBoYW5kbGVEcmFnRXZlbnQsXG4gICAgICBoYW5kbGVVcEV2ZW50OiBoYW5kbGVVcEV2ZW50XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvQm94fVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuYm94XyA9IG5ldyBSZW5kZXJCb3gob3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWdib3gnKTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLm1pbkFyZWFfID0gb3B0aW9ucy5taW5BcmVhICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pbkFyZWEgOiA2NDtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGV4ZWN1dGUganVzdCBiZWZvcmUgYG9uYm94ZW5kYCBpcyBmaXJlZFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbih0aGlzOm1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94LCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50KX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMub25Cb3hFbmRfID0gb3B0aW9ucy5vbkJveEVuZCA/IG9wdGlvbnMub25Cb3hFbmQgOiBVTkRFRklORUQ7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5FbmRDb25kaXRpb259XG4gICAgKi9cbiAgICB0aGlzLmJveEVuZENvbmRpdGlvbl8gPSBvcHRpb25zLmJveEVuZENvbmRpdGlvbiA/XG4gICAgICBvcHRpb25zLmJveEVuZENvbmRpdGlvbiA6IGRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIERyYWdCb3guX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBEcmFnQm94LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERyYWdCb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRHJhZ0JveDtcblxuICAvKipcbiAgKiBSZXR1cm5zIGdlb21ldHJ5IG9mIGxhc3QgZHJhd24gYm94LlxuICAqIEByZXR1cm4ge21vZHVsZTpvbC9nZW9tL1BvbHlnb259IEdlb21ldHJ5LlxuICAqIEBhcGlcbiAgKi9cbiAgRHJhZ0JveC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm94Xy5nZXRHZW9tZXRyeSgpO1xuICB9O1xuXG4gIHJldHVybiBEcmFnQm94O1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNvbmRpdGlvbiBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgYm94ZW5kIGV2ZW50XG4gKiBzaG91bGQgZmlyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IFRoZSBvcmlnaW5hdGluZyBNYXBCcm93c2VyRXZlbnRcbiAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9IHN0YXJ0UGl4ZWwgVGhlIHN0YXJ0aW5nIHBpeGVsIG9mIHRoZSBib3guXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gZW5kUGl4ZWwgVGhlIGVuZCBwaXhlbCBvZiB0aGUgYm94LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIGJveGVuZCBjb25kaXRpb24gc2hvdWxkIGJlIGZpcmVkLlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fVxuICovXG5mdW5jdGlvbiBkZWZhdWx0Qm94RW5kQ29uZGl0aW9uKG1hcEJyb3dzZXJFdmVudCwgc3RhcnRQaXhlbCwgZW5kUGl4ZWwpIHtcbiAgdmFyIHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICB2YXIgaGVpZ2h0ID0gZW5kUGl4ZWxbMV0gLSBzdGFydFBpeGVsWzFdO1xuICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnQm94fVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmJveF8uc2V0UGl4ZWxzKHRoaXMuc3RhcnRQaXhlbF8sIG1hcEJyb3dzZXJFdmVudC5waXhlbCk7XG5cbiAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgIG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlLCBtYXBCcm93c2VyRXZlbnQpKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0b3AgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5ib3hfLnNldE1hcChudWxsKTtcblxuICBpZiAodGhpcy5ib3hFbmRDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCwgdGhpcy5zdGFydFBpeGVsXywgbWFwQnJvd3NlckV2ZW50LnBpeGVsKSkge1xuICAgIHRoaXMub25Cb3hFbmRfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hFTkQsXG4gICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RhcnQgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG1vdXNlQWN0aW9uQnV0dG9uKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB0aGlzLmJveF8uc2V0TWFwKG1hcEJyb3dzZXJFdmVudC5tYXApO1xuICAgIHRoaXMuYm94Xy5zZXRQaXhlbHModGhpcy5zdGFydFBpeGVsXywgdGhpcy5zdGFydFBpeGVsXyk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5jb29yZGluYXRlLCBtYXBCcm93c2VyRXZlbnQpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQm94O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnQm94LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnUGFuXG4gKi9cbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge3NjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZSwgcm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGUsIGFkZCBhcyBhZGRDb29yZGluYXRlfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXN9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtjZW50cm9pZCBhcyBjZW50cm9pZEZyb21Qb2ludGVyc30gZnJvbSAnLi4vaW50ZXJhY3Rpb24vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5ub01vZGlmaWVyS2V5c30uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9LaW5ldGljfSBba2luZXRpY10gS2luZXRpYyBpbmVydGlhIHRvIGFwcGx5IHRvIHRoZSBwYW4uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCBieSBkcmFnZ2luZyB0aGUgbWFwLlxuICogQGFwaVxuICovXG52YXIgRHJhZ1BhbiA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIERyYWdQYW4ob3B0X29wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZURvd25FdmVudDogaGFuZGxlRG93bkV2ZW50LFxuICAgICAgaGFuZGxlRHJhZ0V2ZW50OiBoYW5kbGVEcmFnRXZlbnQsXG4gICAgICBoYW5kbGVVcEV2ZW50OiBoYW5kbGVVcEV2ZW50LFxuICAgICAgc3RvcERvd246IEZBTFNFXG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9LaW5ldGljfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmtpbmV0aWNfID0gb3B0aW9ucy5raW5ldGljO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9waXhlbH5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBvaW50ZXJzQ291bnRfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBub01vZGlmaWVyS2V5cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ub0tpbmV0aWNfID0gZmFsc2U7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhZ1Bhbi5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYWdQYW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ1Bhbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnUGFuO1xuXG4gIHJldHVybiBEcmFnUGFuO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgdGFyZ2V0UG9pbnRlcnMgPSB0aGlzLnRhcmdldFBvaW50ZXJzO1xuICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZEZyb21Qb2ludGVycyh0YXJnZXRQb2ludGVycyk7XG4gIGlmICh0YXJnZXRQb2ludGVycy5sZW5ndGggPT0gdGhpcy5sYXN0UG9pbnRlcnNDb3VudF8pIHtcbiAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgdGhpcy5raW5ldGljXy51cGRhdGUoY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFzdENlbnRyb2lkKSB7XG4gICAgICB2YXIgZGVsdGFYID0gdGhpcy5sYXN0Q2VudHJvaWRbMF0gLSBjZW50cm9pZFswXTtcbiAgICAgIHZhciBkZWx0YVkgPSBjZW50cm9pZFsxXSAtIHRoaXMubGFzdENlbnRyb2lkWzFdO1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2YXIgY2VudGVyID0gW2RlbHRhWCwgZGVsdGFZXTtcbiAgICAgIHNjYWxlQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoY2VudGVyLCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgICAgYWRkQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0Q2VudGVyKCkpO1xuICAgICAgY2VudGVyID0gdmlldy5jb25zdHJhaW5DZW50ZXIoY2VudGVyKTtcbiAgICAgIHZpZXcuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAvLyByZXNldCBzbyB3ZSBkb24ndCBvdmVyZXN0aW1hdGUgdGhlIGtpbmV0aWMgZW5lcmd5IGFmdGVyXG4gICAgLy8gYWZ0ZXIgb25lIGZpbmdlciBkb3duLCB0aW55IGRyYWcsIHNlY29uZCBmaW5nZXIgZG93blxuICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgfVxuICB0aGlzLmxhc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICB0aGlzLmxhc3RQb2ludGVyc0NvdW50XyA9IHRhcmdldFBvaW50ZXJzLmxlbmd0aDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0b3AgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKCF0aGlzLm5vS2luZXRpY18gJiYgdGhpcy5raW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfLmVuZCgpKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmtpbmV0aWNfLmdldERpc3RhbmNlKCk7XG4gICAgICB2YXIgYW5nbGUgPSB0aGlzLmtpbmV0aWNfLmdldEFuZ2xlKCk7XG4gICAgICB2YXIgY2VudGVyID0gLyoqIEB0eXBlIHshbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gKi8gKHZpZXcuZ2V0Q2VudGVyKCkpO1xuICAgICAgdmFyIGNlbnRlcnB4ID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2VudGVyKTtcbiAgICAgIHZhciBkZXN0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoW1xuICAgICAgICBjZW50ZXJweFswXSAtIGRpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjZW50ZXJweFsxXSAtIGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICBdKTtcbiAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgIGNlbnRlcjogdmlldy5jb25zdHJhaW5DZW50ZXIoZGVzdCksXG4gICAgICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgfSk7XG4gICAgfVxuICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5raW5ldGljXykge1xuICAgICAgLy8gcmVzZXQgc28gd2UgZG9uJ3Qgb3ZlcmVzdGltYXRlIHRoZSBraW5ldGljIGVuZXJneSBhZnRlclxuICAgICAgLy8gYWZ0ZXIgb25lIGZpbmdlciB1cCwgdGlueSBkcmFnLCBzZWNvbmQgZmluZ2VyIHVwXG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RhcnQgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbn1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAwICYmIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICB9XG4gICAgLy8gc3RvcCBhbnkgY3VycmVudCBhbmltYXRpb25cbiAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdmlldy5zZXRDZW50ZXIobWFwQnJvd3NlckV2ZW50LmZyYW1lU3RhdGUudmlld1N0YXRlLmNlbnRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICB0aGlzLmtpbmV0aWNfLmJlZ2luKCk7XG4gICAgfVxuICAgIC8vIE5vIGtpbmV0aWMgYXMgc29vbiBhcyBtb3JlIHRoYW4gb25lIHBvaW50ZXIgb24gdGhlIHNjcmVlbiBpc1xuICAgIC8vIGRldGVjdGVkLiBUaGlzIGlzIHRvIHByZXZlbnQgbmFzdHkgcGFucyBhZnRlciBwaW5jaC5cbiAgICB0aGlzLm5vS2luZXRpY18gPSB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDE7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1BhbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhZ1Bhbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZVxuICovXG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHthbHRTaGlmdEtleXNPbmx5LCBtb3VzZU9ubHksIG1vdXNlQWN0aW9uQnV0dG9ufSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7RkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge3JvdGF0ZSwgcm90YXRlV2l0aG91dENvbnN0cmFpbnRzfSBmcm9tICcuLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4uL2ludGVyYWN0aW9uL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsdFNoaWZ0S2V5c09ubHl9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgYWx0IGFuZCBzaGlmdCBrZXlzIGFyZSBoZWxkIGRvd24uXG4gKlxuICogVGhpcyBpbnRlcmFjdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbW91c2UgZGV2aWNlcy5cbiAqIEBhcGlcbiAqL1xudmFyIERyYWdSb3RhdGUgPSAoZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmFnUm90YXRlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZURvd25FdmVudDogaGFuZGxlRG93bkV2ZW50LFxuICAgICAgaGFuZGxlRHJhZ0V2ZW50OiBoYW5kbGVEcmFnRXZlbnQsXG4gICAgICBoYW5kbGVVcEV2ZW50OiBoYW5kbGVVcEV2ZW50LFxuICAgICAgc3RvcERvd246IEZBTFNFXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsdFNoaWZ0S2V5c09ubHk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuZ2xlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhZ1JvdGF0ZS5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYWdSb3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhZ1JvdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmFnUm90YXRlO1xuXG4gIHJldHVybiBEcmFnUm90YXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgaWYgKHZpZXcuZ2V0Q29uc3RyYWludHMoKS5yb3RhdGlvbiA9PT0gZGlzYWJsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2l6ZSA9IG1hcC5nZXRTaXplKCk7XG4gIHZhciBvZmZzZXQgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gIHZhciB0aGV0YSA9XG4gICAgICBNYXRoLmF0YW4yKHNpemVbMV0gLyAyIC0gb2Zmc2V0WzFdLCBvZmZzZXRbMF0gLSBzaXplWzBdIC8gMik7XG4gIGlmICh0aGlzLmxhc3RBbmdsZV8gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBkZWx0YSA9IHRoZXRhIC0gdGhpcy5sYXN0QW5nbGVfO1xuICAgIHZhciByb3RhdGlvbiA9IHZpZXcuZ2V0Um90YXRpb24oKTtcbiAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24gLSBkZWx0YSk7XG4gIH1cbiAgdGhpcy5sYXN0QW5nbGVfID0gdGhldGE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdG9wIGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGV9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICB2YXIgcm90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gIHJvdGF0ZSh2aWV3LCByb3RhdGlvbiwgdW5kZWZpbmVkLCB0aGlzLmR1cmF0aW9uXyk7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0YXJ0IGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGV9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChtb3VzZUFjdGlvbkJ1dHRvbihtYXBCcm93c2VyRXZlbnQpICYmIHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgbWFwLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdSb3RhdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdSb3RhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tXG4gKi9cbmltcG9ydCB7ZGlzYWJsZX0gZnJvbSAnLi4vcm90YXRpb25jb25zdHJhaW50LmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge3NoaWZ0S2V5T25seSwgbW91c2VPbmx5fSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7cm90YXRlLCByb3RhdGVXaXRob3V0Q29uc3RyYWludHMsIHpvb20sIHpvb21XaXRob3V0Q29uc3RyYWludHN9IGZyb20gJy4uL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24gZnJvbSAnLi4vaW50ZXJhY3Rpb24vUG9pbnRlci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2hpZnRLZXlPbmx5fS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSBhbmQgcm90YXRlIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nXG4gKiBvbiB0aGUgbWFwLiAgQnkgZGVmYXVsdCwgdGhpcyBpbnRlcmFjdGlvbiBpcyBsaW1pdGVkIHRvIHdoZW4gdGhlIHNoaWZ0XG4gKiBrZXkgaXMgaGVsZCBkb3duLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKlxuICogQW5kIHRoaXMgaW50ZXJhY3Rpb24gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBkZWZhdWx0IGludGVyYWN0aW9ucy5cbiAqIEBhcGlcbiAqL1xudmFyIERyYWdSb3RhdGVBbmRab29tID0gKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gRHJhZ1JvdGF0ZUFuZFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgaGFuZGxlRG93bkV2ZW50OiBoYW5kbGVEb3duRXZlbnQsXG4gICAgICBoYW5kbGVEcmFnRXZlbnQ6IGhhbmRsZURyYWdFdmVudCxcbiAgICAgIGhhbmRsZVVwRXZlbnQ6IGhhbmRsZVVwRXZlbnRcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGFzdE1hZ25pdHVkZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDQwMDtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBEcmFnUm90YXRlQW5kWm9vbS5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYWdSb3RhdGVBbmRab29tLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIERyYWdSb3RhdGVBbmRab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdSb3RhdGVBbmRab29tO1xuXG4gIHJldHVybiBEcmFnUm90YXRlQW5kWm9vbTtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgdmFyIHNpemUgPSBtYXAuZ2V0U2l6ZSgpO1xuICB2YXIgb2Zmc2V0ID0gbWFwQnJvd3NlckV2ZW50LnBpeGVsO1xuICB2YXIgZGVsdGFYID0gb2Zmc2V0WzBdIC0gc2l6ZVswXSAvIDI7XG4gIHZhciBkZWx0YVkgPSBzaXplWzFdIC8gMiAtIG9mZnNldFsxXTtcbiAgdmFyIHRoZXRhID0gTWF0aC5hdGFuMihkZWx0YVksIGRlbHRhWCk7XG4gIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKTtcbiAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICBpZiAodmlldy5nZXRDb25zdHJhaW50cygpLnJvdGF0aW9uICE9PSBkaXNhYmxlICYmIHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFuZ2xlRGVsdGEgPSB0aGV0YSAtIHRoaXMubGFzdEFuZ2xlXztcbiAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgdmlldy5nZXRSb3RhdGlvbigpIC0gYW5nbGVEZWx0YSk7XG4gIH1cbiAgdGhpcy5sYXN0QW5nbGVfID0gdGhldGE7XG4gIGlmICh0aGlzLmxhc3RNYWduaXR1ZGVfICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMubGFzdE1hZ25pdHVkZV8gKiAodmlldy5nZXRSZXNvbHV0aW9uKCkgLyBtYWduaXR1ZGUpO1xuICAgIHpvb21XaXRob3V0Q29uc3RyYWludHModmlldywgcmVzb2x1dGlvbik7XG4gIH1cbiAgaWYgKHRoaXMubGFzdE1hZ25pdHVkZV8gIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gdGhpcy5sYXN0TWFnbml0dWRlXyAvIG1hZ25pdHVkZTtcbiAgfVxuICB0aGlzLmxhc3RNYWduaXR1ZGVfID0gbWFnbml0dWRlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RvcCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKCFtb3VzZU9ubHkobWFwQnJvd3NlckV2ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gIHZhciBkaXJlY3Rpb24gPSB0aGlzLmxhc3RTY2FsZURlbHRhXyAtIDE7XG4gIHJvdGF0ZSh2aWV3LCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICB6b29tKHZpZXcsIHZpZXcuZ2V0UmVzb2x1dGlvbigpLCB1bmRlZmluZWQsIHRoaXMuZHVyYXRpb25fLCBkaXJlY3Rpb24pO1xuICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0YXJ0IGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYWdSb3RhdGVBbmRab29tfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICBtYXBCcm93c2VyRXZlbnQubWFwLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYXN0TWFnbml0dWRlXyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1JvdGF0ZUFuZFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdSb3RhdGVBbmRab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbVxuICovXG5pbXBvcnQge2Vhc2VPdXR9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQge3NoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzLCBnZXRCb3R0b21MZWZ0LCBnZXRDZW50ZXIsIGdldFRvcFJpZ2h0LCBzY2FsZUZyb21DZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgRHJhZ0JveCBmcm9tICcuLi9pbnRlcmFjdGlvbi9EcmFnQm94LmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xhc3NOYW1lPSdvbC1kcmFnem9vbSddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZVxuICogYm94LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNoaWZ0S2V5T25seX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dD1mYWxzZV0gVXNlIGludGVyYWN0aW9uIGZvciB6b29taW5nIG91dC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiBhIGtleSwgc2hpZnQgYnkgZGVmYXVsdCwgaXMgaGVsZCBkb3duLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIGJveCwgdXNlIENTUyBhbmQgdGhlIGAub2wtZHJhZ3pvb21gIHNlbGVjdG9yLCBvclxuICogeW91ciBjdXN0b20gb25lIGNvbmZpZ3VyZWQgd2l0aCBgY2xhc3NOYW1lYC5cbiAqIEBhcGlcbiAqL1xudmFyIERyYWdab29tID0gKGZ1bmN0aW9uIChEcmFnQm94KSB7XG4gIGZ1bmN0aW9uIERyYWdab29tKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICB2YXIgY29uZGl0aW9uID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIERyYWdCb3guY2FsbCh0aGlzLCB7XG4gICAgICBjb25kaXRpb246IGNvbmRpdGlvbixcbiAgICAgIGNsYXNzTmFtZTogb3B0aW9ucy5jbGFzc05hbWUgfHwgJ29sLWRyYWd6b29tJyxcbiAgICAgIG9uQm94RW5kOiBvbkJveEVuZFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDIwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdXRfID0gb3B0aW9ucy5vdXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3V0IDogZmFsc2U7XG4gIH1cblxuICBpZiAoIERyYWdCb3ggKSBEcmFnWm9vbS5fX3Byb3RvX18gPSBEcmFnQm94O1xuICBEcmFnWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBEcmFnQm94ICYmIERyYWdCb3gucHJvdG90eXBlICk7XG4gIERyYWdab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYWdab29tO1xuXG4gIHJldHVybiBEcmFnWm9vbTtcbn0oRHJhZ0JveCkpO1xuXG5cbi8qKlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnWm9vbX1cbiAqL1xuZnVuY3Rpb24gb25Cb3hFbmQoKSB7XG4gIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICB2YXIgdmlldyA9IC8qKiBAdHlwZSB7IW1vZHVsZTpvbC9WaWV3fSAqLyAobWFwLmdldFZpZXcoKSk7XG4gIHZhciBzaXplID0gLyoqIEB0eXBlIHshbW9kdWxlOm9sL3NpemV+U2l6ZX0gKi8gKG1hcC5nZXRTaXplKCkpO1xuICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRHZW9tZXRyeSgpLmdldEV4dGVudCgpO1xuXG4gIGlmICh0aGlzLm91dF8pIHtcbiAgICB2YXIgbWFwRXh0ZW50ID0gdmlldy5jYWxjdWxhdGVFeHRlbnQoc2l6ZSk7XG4gICAgdmFyIGJveFBpeGVsRXh0ZW50ID0gY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMoW1xuICAgICAgbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoZ2V0Qm90dG9tTGVmdChleHRlbnQpKSxcbiAgICAgIG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKGdldFRvcFJpZ2h0KGV4dGVudCkpXSk7XG4gICAgdmFyIGZhY3RvciA9IHZpZXcuZ2V0UmVzb2x1dGlvbkZvckV4dGVudChib3hQaXhlbEV4dGVudCwgc2l6ZSk7XG5cbiAgICBzY2FsZUZyb21DZW50ZXIobWFwRXh0ZW50LCAxIC8gZmFjdG9yKTtcbiAgICBleHRlbnQgPSBtYXBFeHRlbnQ7XG4gIH1cblxuICB2YXIgcmVzb2x1dGlvbiA9IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICB2aWV3LmdldFJlc29sdXRpb25Gb3JFeHRlbnQoZXh0ZW50LCBzaXplKSk7XG5cbiAgdmFyIGNlbnRlciA9IGdldENlbnRlcihleHRlbnQpO1xuICBjZW50ZXIgPSB2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpO1xuXG4gIHZpZXcuYW5pbWF0ZSh7XG4gICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl8sXG4gICAgZWFzaW5nOiBlYXNlT3V0XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IERyYWdab29tO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRHJhd1xuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnLi4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyUG9pbnRlckV2ZW50IGZyb20gJy4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge3NxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge25vTW9kaWZpZXJLZXlzLCBhbHdheXMsIHNoaWZ0S2V5T25seX0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge2JvdW5kaW5nRXh0ZW50LCBnZXRCb3R0b21MZWZ0LCBnZXRCb3R0b21SaWdodCwgZ2V0VG9wTGVmdCwgZ2V0VG9wUmlnaHR9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUUsIEZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IENpcmNsZSBmcm9tICcuLi9nZW9tL0NpcmNsZS5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aVBvaW50IGZyb20gJy4uL2dlb20vTXVsdGlQb2ludC5qcyc7XG5pbXBvcnQgTXVsdGlQb2x5Z29uIGZyb20gJy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzJztcbmltcG9ydCB7UE9JTlRFUl9UWVBFfSBmcm9tICcuLi9wb2ludGVyL01vdXNlU291cmNlLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9nZW9tL1BvaW50LmpzJztcbmltcG9ydCBQb2x5Z29uLCB7ZnJvbUNpcmNsZSwgbWFrZVJlZ3VsYXJ9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7aGFuZGxlRXZlbnQgYXMgaGFuZGxlUG9pbnRlckV2ZW50fSBmcm9tICcuLi9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvblByb3BlcnR5IGZyb20gJy4uL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yLmpzJztcbmltcG9ydCB7Y3JlYXRlRWRpdGluZ1N0eWxlfSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5VHlwZX0gdHlwZSBHZW9tZXRyeSB0eXBlIG9mXG4gKiB0aGUgZ2VvbWV0cmllcyBiZWluZyBkcmF3biB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NsaWNrVG9sZXJhbmNlPTZdIFRoZSBtYXhpbXVtIGRpc3RhbmNlIGluIHBpeGVscyBiZXR3ZWVuXG4gKiBcImRvd25cIiBhbmQgXCJ1cFwiIGZvciBhIFwidXBcIiBldmVudCB0byBiZSBjb25zaWRlcmVkIGEgXCJjbGlja1wiIGV2ZW50IGFuZFxuICogYWN0dWFsbHkgYWRkIGEgcG9pbnQvdmVydGV4IHRvIHRoZSBnZW9tZXRyeSBiZWluZyBkcmF3bi4gIFRoZSBkZWZhdWx0IG9mIGA2YFxuICogd2FzIGNob3NlbiBmb3IgdGhlIGRyYXcgaW50ZXJhY3Rpb24gdG8gYmVoYXZlIGNvcnJlY3RseSBvbiBtb3VzZSBhcyB3ZWxsIGFzXG4gKiBvbiB0b3VjaCBkZXZpY2VzLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fSBbZmVhdHVyZXNdXG4gKiBEZXN0aW5hdGlvbiBjb2xsZWN0aW9uIGZvciB0aGUgZHJhd24gZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBbc291cmNlXSBEZXN0aW5hdGlvbiBzb3VyY2UgZm9yXG4gKiB0aGUgZHJhd24gZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RyYWdWZXJ0ZXhEZWxheT01MDBdIERlbGF5IGluIG1pbGxpc2Vjb25kcyBhZnRlciBwb2ludGVyZG93blxuICogYmVmb3JlIHRoZSBjdXJyZW50IHZlcnRleCBjYW4gYmUgZHJhZ2dlZCB0byBpdHMgZXhhY3QgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NuYXBUb2xlcmFuY2U9MTJdIFBpeGVsIGRpc3RhbmNlIGZvciBzbmFwcGluZyB0byB0aGVcbiAqIGRyYXdpbmcgZmluaXNoLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3RvcENsaWNrPWZhbHNlXSBTdG9wIGNsaWNrLCBzaW5nbGVjbGljaywgYW5kXG4gKiBkb3VibGVjbGljayBldmVudHMgZnJvbSBmaXJpbmcgZHVyaW5nIGRyYXdpbmcuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFBvaW50c10gVGhlIG51bWJlciBvZiBwb2ludHMgdGhhdCBjYW4gYmUgZHJhd24gYmVmb3JlXG4gKiBhIHBvbHlnb24gcmluZyBvciBsaW5lIHN0cmluZyBpcyBmaW5pc2hlZC4gQnkgZGVmYXVsdCB0aGVyZSBpcyBub1xuICogcmVzdHJpY3Rpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblBvaW50c10gVGhlIG51bWJlciBvZiBwb2ludHMgdGhhdCBtdXN0IGJlIGRyYXduXG4gKiBiZWZvcmUgYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmcgY2FuIGJlIGZpbmlzaGVkLiBEZWZhdWx0IGlzIGAzYCBmb3JcbiAqIHBvbHlnb24gcmluZ3MgYW5kIGAyYCBmb3IgbGluZSBzdHJpbmdzLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtmaW5pc2hDb25kaXRpb25dIEEgZnVuY3Rpb25cbiAqIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIGRyYXdpbmcgY2FuIGJlIGZpbmlzaGVkLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3R5bGV8QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT58bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFtzdHlsZV1cbiAqIFN0eWxlIGZvciBza2V0Y2ggZmVhdHVyZXMuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkdlb21ldHJ5RnVuY3Rpb259IFtnZW9tZXRyeUZ1bmN0aW9uXVxuICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGdlb21ldHJ5J3MgY29vcmRpbmF0ZXMgYXJlIHVwZGF0ZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dlb21ldHJ5TmFtZV0gR2VvbWV0cnkgbmFtZSB0byB1c2UgZm9yIGZlYXR1cmVzIGNyZWF0ZWRcbiAqIGJ5IHRoZSBkcmF3IGludGVyYWN0aW9uLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIEJ5IGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5vTW9kaWZpZXJLZXlzfSwgaS5lLiBhIGNsaWNrLFxuICogYWRkcyBhIHZlcnRleCBvciBkZWFjdGl2YXRlcyBmcmVlaGFuZCBkcmF3aW5nLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZnJlZWhhbmQ9ZmFsc2VdIE9wZXJhdGUgaW4gZnJlZWhhbmQgbW9kZSBmb3IgbGluZXMsXG4gKiBwb2x5Z29ucywgYW5kIGNpcmNsZXMuICBUaGlzIG1ha2VzIHRoZSBpbnRlcmFjdGlvbiBhbHdheXMgb3BlcmF0ZSBpbiBmcmVlaGFuZFxuICogbW9kZSBhbmQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFueSBgZnJlZWhhbmRDb25kaXRpb25gIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbZnJlZWhhbmRDb25kaXRpb25dXG4gKiBDb25kaXRpb24gdGhhdCBhY3RpdmF0ZXMgZnJlZWhhbmQgZHJhd2luZyBmb3IgbGluZXMgYW5kIHBvbHlnb25zLiBUaGlzXG4gKiBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZFxuICogcmV0dXJucyBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGVcbiAqIGRlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNoaWZ0S2V5T25seX0sIG1lYW5pbmcgdGhhdCB0aGVcbiAqIFNoaWZ0IGtleSBhY3RpdmF0ZXMgZnJlZWhhbmQgZHJhd2luZy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPWZhbHNlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkgb24gdGhlIHNrZXRjaFxuICogb3ZlcmxheS5cbiAqL1xuXG5cbi8qKlxuICogRnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBhcnJheSBvZiBjb29yZGluYXRlcyBhbmQgYW4gb3B0aW9uYWwgZXhpc3RpbmcgZ2VvbWV0cnkgYXNcbiAqIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBnZW9tZXRyeS4gVGhlIG9wdGlvbmFsIGV4aXN0aW5nIGdlb21ldHJ5IGlzIHRoZVxuICogZ2VvbWV0cnkgdGhhdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aG91dCBhIHNlY29uZFxuICogYXJndW1lbnQuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oIUFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPiwgbW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnk9KTpcbiAqICAgICBtb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gR2VvbWV0cnlGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBEcmF3IG1vZGUuICBUaGlzIGNvbGxhcHNlcyBtdWx0aS1wYXJ0IGdlb21ldHJ5IHR5cGVzIHdpdGggdGhlaXIgc2luZ2xlLXBhcnRcbiAqIGNvdXNpbnMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgTW9kZSA9IHtcbiAgUE9JTlQ6ICdQb2ludCcsXG4gIExJTkVfU1RSSU5HOiAnTGluZVN0cmluZycsXG4gIFBPTFlHT046ICdQb2x5Z29uJyxcbiAgQ0lSQ0xFOiAnQ2lyY2xlJ1xufTtcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBEcmF3RXZlbnRUeXBlID0ge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHVwb24gZmVhdHVyZSBkcmF3IHN0YXJ0XG4gICAqIEBldmVudCBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3RXZlbnQjZHJhd3N0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIERSQVdTVEFSVDogJ2RyYXdzdGFydCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIGRyYXcgZW5kXG4gICAqIEBldmVudCBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3RXZlbnQjZHJhd2VuZFxuICAgKiBAYXBpXG4gICAqL1xuICBEUkFXRU5EOiAnZHJhd2VuZCdcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd+RHJhd30gaW5zdGFuY2VzIGFyZVxuICogaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xudmFyIERyYXdFdmVudCA9IChmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRHJhd0V2ZW50KHR5cGUsIGZlYXR1cmUpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmVhdHVyZSBiZWluZyBkcmF3bi5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBEcmF3RXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIERyYXdFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgRHJhd0V2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERyYXdFdmVudDtcblxuICByZXR1cm4gRHJhd0V2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW50ZXJhY3Rpb24gZm9yIGRyYXdpbmcgZmVhdHVyZSBnZW9tZXRyaWVzLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIERyYXcgPSAoZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBEcmF3KG9wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZURvd25FdmVudDogaGFuZGxlRG93bkV2ZW50LFxuICAgICAgaGFuZGxlRXZlbnQ6IGhhbmRsZUV2ZW50LFxuICAgICAgaGFuZGxlVXBFdmVudDogaGFuZGxlVXBFdmVudCxcbiAgICAgIHN0b3BEb3duOiBGQUxTRVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZEhhbmRsZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25QeF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvd25UaW1lb3V0XztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sYXN0RHJhZ1RpbWVfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZyZWVoYW5kXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IHNvdXJjZSBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgY29sbGVjdGlvbiBmb3IgZHJhd24gZmVhdHVyZXMuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IG9wdGlvbnMuZmVhdHVyZXMgPyBvcHRpb25zLmZlYXR1cmVzIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBpeGVsIGRpc3RhbmNlIGZvciBzbmFwcGluZy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwVG9sZXJhbmNlXyA9IG9wdGlvbnMuc25hcFRvbGVyYW5jZSA/IG9wdGlvbnMuc25hcFRvbGVyYW5jZSA6IDEyO1xuXG4gICAgLyoqXG4gICAgICogR2VvbWV0cnkgdHlwZS5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlUeXBlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50eXBlXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlUeXBlfSAqLyAob3B0aW9ucy50eXBlKTtcblxuICAgIC8qKlxuICAgICAqIERyYXdpbmcgbW9kZSAoZGVyaXZlZCBmcm9tIGdlb21ldHJ5IHR5cGUuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fk1vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gZ2V0TW9kZSh0aGlzLnR5cGVfKTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgY2xpY2ssIHNpbmdsZWNsaWNrLCBhbmQgZG91YmxlY2xpY2sgZXZlbnRzIGZyb20gZmlyaW5nIGR1cmluZyBkcmF3aW5nLlxuICAgICAqIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc3RvcENsaWNrXyA9ICEhb3B0aW9ucy5zdG9wQ2xpY2s7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IG11c3QgYmUgZHJhd24gYmVmb3JlIGEgcG9seWdvbiByaW5nIG9yIGxpbmVcbiAgICAgKiBzdHJpbmcgY2FuIGJlIGZpbmlzaGVkLiAgVGhlIGRlZmF1bHQgaXMgMyBmb3IgcG9seWdvbiByaW5ncyBhbmQgMiBmb3JcbiAgICAgKiBsaW5lIHN0cmluZ3MuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWluUG9pbnRzXyA9IG9wdGlvbnMubWluUG9pbnRzID9cbiAgICAgIG9wdGlvbnMubWluUG9pbnRzIDpcbiAgICAgICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04gPyAzIDogMik7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHBvaW50cyB0aGF0IGNhbiBiZSBkcmF3biBiZWZvcmUgYSBwb2x5Z29uIHJpbmcgb3IgbGluZSBzdHJpbmdcbiAgICAgKiBpcyBmaW5pc2hlZC4gVGhlIGRlZmF1bHQgaXMgbm8gcmVzdHJpY3Rpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF4UG9pbnRzXyA9IG9wdGlvbnMubWF4UG9pbnRzID8gb3B0aW9ucy5tYXhQb2ludHMgOiBJbmZpbml0eTtcblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdG8gZGVjaWRlIGlmIGEgcG90ZW50aWFsIGZpbmlzaCBjb29yZGluYXRlIGlzIHBlcm1pc3NpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZmluaXNoQ29uZGl0aW9uXyA9IG9wdGlvbnMuZmluaXNoQ29uZGl0aW9uID8gb3B0aW9ucy5maW5pc2hDb25kaXRpb24gOiBUUlVFO1xuXG4gICAgdmFyIGdlb21ldHJ5RnVuY3Rpb24gPSBvcHRpb25zLmdlb21ldHJ5RnVuY3Rpb247XG4gICAgaWYgKCFnZW9tZXRyeUZ1bmN0aW9uKSB7XG4gICAgICBpZiAodGhpcy50eXBlXyA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlc1xuICAgICAgICAgKiAgICAgVGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5PX0gb3B0X2dlb21ldHJ5IE9wdGlvbmFsIGdlb21ldHJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gQSBnZW9tZXRyeS5cbiAgICAgICAgICovXG4gICAgICAgIGdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbihjb29yZGluYXRlcywgb3B0X2dlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGNpcmNsZSA9IG9wdF9nZW9tZXRyeSA/IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSAqLyAob3B0X2dlb21ldHJ5KSA6XG4gICAgICAgICAgICBuZXcgQ2lyY2xlKFtOYU4sIE5hTl0pO1xuICAgICAgICAgIHZhciBzcXVhcmVkTGVuZ3RoID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZShcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSk7XG4gICAgICAgICAgY2lyY2xlLnNldENlbnRlckFuZFJhZGl1cyhjb29yZGluYXRlc1swXSwgTWF0aC5zcXJ0KHNxdWFyZWRMZW5ndGgpKTtcbiAgICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZV87XG4gICAgICAgIGlmIChtb2RlID09PSBNb2RlLlBPSU5UKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBQb2ludDtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSBNb2RlLkxJTkVfU1RSSU5HKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gUG9seWdvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBjb29yZGluYXRlc1xuICAgICAgICAgKiAgICAgVGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5PX0gb3B0X2dlb21ldHJ5IE9wdGlvbmFsIGdlb21ldHJ5LlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gQSBnZW9tZXRyeS5cbiAgICAgICAgICovXG4gICAgICAgIGdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbihjb29yZGluYXRlcywgb3B0X2dlb21ldHJ5KSB7XG4gICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb3B0X2dlb21ldHJ5O1xuICAgICAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgICAgICAgICBpZiAoY29vcmRpbmF0ZXNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgY2xvc2luZyBjb29yZGluYXRlIHRvIG1hdGNoIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKFtjb29yZGluYXRlc1swXS5jb25jYXQoW2Nvb3JkaW5hdGVzWzBdWzBdXSldKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdlb21ldHJ5LnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgQ29uc3RydWN0b3IoY29vcmRpbmF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkdlb21ldHJ5RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZ2VvbWV0cnlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8gPSBvcHRpb25zLmRyYWdWZXJ0ZXhEZWxheSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcmFnVmVydGV4RGVsYXkgOiA1MDA7XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggY29vcmRpbmF0ZSBmb3IgdGhlIGZlYXR1cmUgKGZpcnN0IHBvaW50IGZvciBwb2x5Z29ucywgbGFzdCBwb2ludCBmb3JcbiAgICAgKiBsaW5lc3RyaW5ncykuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBmZWF0dXJlLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoRmVhdHVyZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIHBvaW50LlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBjb29yZGluYXRlcy4gVXNlZCB3aGVuIGRyYXdpbmcgYSBsaW5lIG9yIHBvbHlnb24uXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV8QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fEFycmF5LjxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5za2V0Y2hDb29yZHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNrZXRjaCBsaW5lLiBVc2VkIHdoZW4gZHJhd2luZyBwb2x5Z29uLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoTGluZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2tldGNoIGxpbmUgY29vcmRpbmF0ZXMuIFVzZWQgd2hlbiBkcmF3aW5nIGEgcG9seWdvbiBvciBjaXJjbGUuXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2tldGNoTGluZUNvb3Jkc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU3F1YXJlZCB0b2xlcmFuY2UgZm9yIGhhbmRsaW5nIHVwIGV2ZW50cy4gIElmIHRoZSBzcXVhcmVkIGRpc3RhbmNlXG4gICAgICogYmV0d2VlbiBhIGRvd24gYW5kIHVwIGV2ZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGlzIHRvbGVyYW5jZSwgdXAgZXZlbnRzXG4gICAgICogd2lsbCBub3QgYmUgaGFuZGxlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfID0gb3B0aW9ucy5jbGlja1RvbGVyYW5jZSA/XG4gICAgICBvcHRpb25zLmNsaWNrVG9sZXJhbmNlICogb3B0aW9ucy5jbGlja1RvbGVyYW5jZSA6IDM2O1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBvdmVybGF5IHdoZXJlIG91ciBza2V0Y2ggZmVhdHVyZXMgYXJlIGRyYXduLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vdmVybGF5XyA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCA/IG9wdGlvbnMud3JhcFggOiBmYWxzZVxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSA/IG9wdGlvbnMuc3R5bGUgOlxuICAgICAgICBnZXREZWZhdWx0U3R5bGVGdW5jdGlvbigpLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlIGZvciBuZXdseSBjcmVhdGVkIGZlYXR1cmVzLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gb3B0aW9ucy5nZW9tZXRyeU5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IG5vTW9kaWZpZXJLZXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZnJlZWhhbmRDb25kaXRpb25fO1xuICAgIGlmIChvcHRpb25zLmZyZWVoYW5kKSB7XG4gICAgICB0aGlzLmZyZWVoYW5kQ29uZGl0aW9uXyA9IGFsd2F5cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mcmVlaGFuZENvbmRpdGlvbl8gPSBvcHRpb25zLmZyZWVoYW5kQ29uZGl0aW9uID9cbiAgICAgICAgb3B0aW9ucy5mcmVlaGFuZENvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcbiAgICB9XG5cbiAgICBsaXN0ZW4odGhpcyxcbiAgICAgIGdldENoYW5nZUV2ZW50VHlwZShJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSksXG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgRHJhdy5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIERyYXcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgRHJhdy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEcmF3O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZV8oKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIG1vdmUgZXZlbnRzLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGV2ZW50IEEgbW92ZSBldmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUGFzcyB0aGUgZXZlbnQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmVfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmVfIChldmVudCkge1xuICAgIGlmICh0aGlzLmRvd25QeF8gJiZcbiAgICAgICAgKCghdGhpcy5mcmVlaGFuZF8gJiYgdGhpcy5zaG91bGRIYW5kbGVfKSB8fFxuICAgICAgICAodGhpcy5mcmVlaGFuZF8gJiYgIXRoaXMuc2hvdWxkSGFuZGxlXykpKSB7XG4gICAgICB2YXIgZG93blB4ID0gdGhpcy5kb3duUHhfO1xuICAgICAgdmFyIGNsaWNrUHggPSBldmVudC5waXhlbDtcbiAgICAgIHZhciBkeCA9IGRvd25QeFswXSAtIGNsaWNrUHhbMF07XG4gICAgICB2YXIgZHkgPSBkb3duUHhbMV0gLSBjbGlja1B4WzFdO1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgdGhpcy5zaG91bGRIYW5kbGVfID0gdGhpcy5mcmVlaGFuZF8gP1xuICAgICAgICBzcXVhcmVkRGlzdGFuY2UgPiB0aGlzLnNxdWFyZWRDbGlja1RvbGVyYW5jZV8gOlxuICAgICAgICBzcXVhcmVkRGlzdGFuY2UgPD0gdGhpcy5zcXVhcmVkQ2xpY2tUb2xlcmFuY2VfO1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZV8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8pIHtcbiAgICAgIHRoaXMubW9kaWZ5RHJhd2luZ18oZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlU2tldGNoUG9pbnRfKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhbiBldmVudCBpcyB3aXRoaW4gdGhlIHNuYXBwaW5nIHRvbGVyYW5jZSBvZiB0aGUgc3RhcnQgY29vcmQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBldmVudCBpcyB3aXRoaW4gdGhlIHNuYXBwaW5nIHRvbGVyYW5jZSBvZiB0aGUgc3RhcnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBEcmF3LnByb3RvdHlwZS5hdEZpbmlzaF8gPSBmdW5jdGlvbiBhdEZpbmlzaF8gKGV2ZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgdmFyIHBvdGVudGlhbGx5RG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbdGhpcy5maW5pc2hDb29yZGluYXRlX107XG4gICAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgICBwb3RlbnRpYWxseURvbmUgPSB0aGlzLnNrZXRjaENvb3Jkc18ubGVuZ3RoID4gdGhpcy5taW5Qb2ludHNfO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgICAgcG90ZW50aWFsbHlEb25lID0gdGhpcy5za2V0Y2hDb29yZHNfWzBdLmxlbmd0aCA+XG4gICAgICAgICAgICB0aGlzLm1pblBvaW50c187XG4gICAgICAgIHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXMgPSBbdGhpcy5za2V0Y2hDb29yZHNfWzBdWzBdLFxuICAgICAgICAgIHRoaXMuc2tldGNoQ29vcmRzX1swXVt0aGlzLnNrZXRjaENvb3Jkc19bMF0ubGVuZ3RoIC0gMl1dO1xuICAgICAgfVxuICAgICAgaWYgKHBvdGVudGlhbGx5RG9uZSkge1xuICAgICAgICB2YXIgbWFwID0gZXZlbnQubWFwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb3RlbnRpYWxseUZpbmlzaENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmluaXNoQ29vcmRpbmF0ZSA9IHBvdGVudGlhbGx5RmluaXNoQ29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgdmFyIGZpbmlzaFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoZmluaXNoQ29vcmRpbmF0ZSk7XG4gICAgICAgICAgdmFyIHBpeGVsID0gZXZlbnQucGl4ZWw7XG4gICAgICAgICAgdmFyIGR4ID0gcGl4ZWxbMF0gLSBmaW5pc2hQaXhlbFswXTtcbiAgICAgICAgICB2YXIgZHkgPSBwaXhlbFsxXSAtIGZpbmlzaFBpeGVsWzFdO1xuICAgICAgICAgIHZhciBzbmFwVG9sZXJhbmNlID0gdGhpcyQxLmZyZWVoYW5kXyA/IDEgOiB0aGlzJDEuc25hcFRvbGVyYW5jZV87XG4gICAgICAgICAgYXQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIDw9IHNuYXBUb2xlcmFuY2U7XG4gICAgICAgICAgaWYgKGF0KSB7XG4gICAgICAgICAgICB0aGlzJDEuZmluaXNoQ29vcmRpbmF0ZV8gPSBmaW5pc2hDb29yZGluYXRlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlU2tldGNoUG9pbnRfID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTa2V0Y2hQb2ludF8gKGV2ZW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZXZlbnQuY29vcmRpbmF0ZS5zbGljZSgpO1xuICAgIGlmICghdGhpcy5za2V0Y2hQb2ludF8pIHtcbiAgICAgIHRoaXMuc2tldGNoUG9pbnRfID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KGNvb3JkaW5hdGVzKSk7XG4gICAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tldGNoUG9pbnRHZW9tID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9Qb2ludH0gKi8gKHRoaXMuc2tldGNoUG9pbnRfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoUG9pbnRHZW9tLnNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBkcmF3aW5nLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuc3RhcnREcmF3aW5nXyA9IGZ1bmN0aW9uIHN0YXJ0RHJhd2luZ18gKGV2ZW50KSB7XG4gICAgdmFyIHN0YXJ0ID0gZXZlbnQuY29vcmRpbmF0ZTtcbiAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gc3RhcnQ7XG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9JTlQpIHtcbiAgICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IHN0YXJ0LnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIHRoaXMuc2tldGNoQ29vcmRzXyA9IFtbc3RhcnQuc2xpY2UoKSwgc3RhcnQuc2xpY2UoKV1dO1xuICAgICAgdGhpcy5za2V0Y2hMaW5lQ29vcmRzXyA9IHRoaXMuc2tldGNoQ29vcmRzX1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5za2V0Y2hDb29yZHNfID0gW3N0YXJ0LnNsaWNlKCksIHN0YXJ0LnNsaWNlKCldO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykge1xuICAgICAgdGhpcy5za2V0Y2hMaW5lXyA9IG5ldyBGZWF0dXJlKFxuICAgICAgICBuZXcgTGluZVN0cmluZyh0aGlzLnNrZXRjaExpbmVDb29yZHNfKSk7XG4gICAgfVxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8odGhpcy5za2V0Y2hDb29yZHNfKTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gbmV3IEZlYXR1cmUoKTtcbiAgICBpZiAodGhpcy5nZW9tZXRyeU5hbWVfKSB7XG4gICAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdlb21ldHJ5TmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhd0V2ZW50KERyYXdFdmVudFR5cGUuRFJBV1NUQVJULCB0aGlzLnNrZXRjaEZlYXR1cmVfKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSB0aGUgZHJhd2luZy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIERyYXcucHJvdG90eXBlLm1vZGlmeURyYXdpbmdfID0gZnVuY3Rpb24gbW9kaWZ5RHJhd2luZ18gKGV2ZW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGUgPSBldmVudC5jb29yZGluYXRlO1xuICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBjb29yZGluYXRlcywgbGFzdDtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5QT0lOVCkge1xuICAgICAgbGFzdCA9IHRoaXMuc2tldGNoQ29vcmRzXztcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnNrZXRjaENvb3Jkc19bMF07XG4gICAgICBsYXN0ID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAodGhpcy5hdEZpbmlzaF8oZXZlbnQpKSB7XG4gICAgICAgIC8vIHNuYXAgdG8gZmluaXNoXG4gICAgICAgIGNvb3JkaW5hdGUgPSB0aGlzLmZpbmlzaENvb3JkaW5hdGVfLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgICAgbGFzdCA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBsYXN0WzBdID0gY29vcmRpbmF0ZVswXTtcbiAgICBsYXN0WzFdID0gY29vcmRpbmF0ZVsxXTtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKC8qKiBAdHlwZSB7IUFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gKi8gKHRoaXMuc2tldGNoQ29vcmRzXyksIGdlb21ldHJ5KTtcbiAgICBpZiAodGhpcy5za2V0Y2hQb2ludF8pIHtcbiAgICAgIHZhciBza2V0Y2hQb2ludEdlb20gPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvaW50fSAqLyAodGhpcy5za2V0Y2hQb2ludF8uZ2V0R2VvbWV0cnkoKSk7XG4gICAgICBza2V0Y2hQb2ludEdlb20uc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZSk7XG4gICAgfVxuICAgIHZhciBza2V0Y2hMaW5lR2VvbTtcbiAgICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2x5Z29uICYmXG4gICAgICAgIHRoaXMubW9kZV8gIT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgaWYgKCF0aGlzLnNrZXRjaExpbmVfKSB7XG4gICAgICAgIHRoaXMuc2tldGNoTGluZV8gPSBuZXcgRmVhdHVyZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJpbmcgPSBnZW9tZXRyeS5nZXRMaW5lYXJSaW5nKDApO1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgaWYgKCFza2V0Y2hMaW5lR2VvbSkge1xuICAgICAgICBza2V0Y2hMaW5lR2VvbSA9IG5ldyBMaW5lU3RyaW5nKHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCksIHJpbmcuZ2V0TGF5b3V0KCkpO1xuICAgICAgICB0aGlzLnNrZXRjaExpbmVfLnNldEdlb21ldHJ5KHNrZXRjaExpbmVHZW9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNrZXRjaExpbmVHZW9tLnNldEZsYXRDb29yZGluYXRlcyhcbiAgICAgICAgICByaW5nLmdldExheW91dCgpLCByaW5nLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgICAgc2tldGNoTGluZUdlb20uY2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5za2V0Y2hMaW5lQ29vcmRzXykge1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoTGluZUdlb20uc2V0Q29vcmRpbmF0ZXModGhpcy5za2V0Y2hMaW5lQ29vcmRzXyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2tldGNoRmVhdHVyZXNfKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBjb29yZGluYXRlIHRvIHRoZSBkcmF3aW5nLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuYWRkVG9EcmF3aW5nXyA9IGZ1bmN0aW9uIGFkZFRvRHJhd2luZ18gKGV2ZW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGUgPSBldmVudC5jb29yZGluYXRlO1xuICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBkb25lO1xuICAgIHZhciBjb29yZGluYXRlcztcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGNvb3JkaW5hdGUuc2xpY2UoKTtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA+PSB0aGlzLm1heFBvaW50c18pIHtcbiAgICAgICAgaWYgKHRoaXMuZnJlZWhhbmRfKSB7XG4gICAgICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvb3JkaW5hdGVzLnB1c2goY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnNrZXRjaENvb3Jkc19bMF07XG4gICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID49IHRoaXMubWF4UG9pbnRzXykge1xuICAgICAgICBpZiAodGhpcy5mcmVlaGFuZF8pIHtcbiAgICAgICAgICBjb29yZGluYXRlcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29vcmRpbmF0ZXMucHVzaChjb29yZGluYXRlLnNsaWNlKCkpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgdGhpcy5maW5pc2hDb29yZGluYXRlXyA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyh0aGlzLnNrZXRjaENvb3Jkc18sIGdlb21ldHJ5KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTa2V0Y2hGZWF0dXJlc18oKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgdGhpcy5maW5pc2hEcmF3aW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGFzdCBwb2ludCBvZiB0aGUgZmVhdHVyZSBjdXJyZW50bHkgYmVpbmcgZHJhd24uXG4gICAqIEBhcGlcbiAgICovXG4gIERyYXcucHJvdG90eXBlLnJlbW92ZUxhc3RQb2ludCA9IGZ1bmN0aW9uIHJlbW92ZUxhc3RQb2ludCAoKSB7XG4gICAgaWYgKCF0aGlzLnNrZXRjaEZlYXR1cmVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovICh0aGlzLnNrZXRjaEZlYXR1cmVfLmdldEdlb21ldHJ5KCkpO1xuICAgIHZhciBjb29yZGluYXRlcywgc2tldGNoTGluZUdlb207XG4gICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuTElORV9TVFJJTkcpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5za2V0Y2hDb29yZHNfO1xuICAgICAgY29vcmRpbmF0ZXMuc3BsaWNlKC0yLCAxKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8oY29vcmRpbmF0ZXMsIGdlb21ldHJ5KTtcbiAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPj0gMikge1xuICAgICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMl0uc2xpY2UoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9MWUdPTikge1xuICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLnNrZXRjaENvb3Jkc19bMF07XG4gICAgICBjb29yZGluYXRlcy5zcGxpY2UoLTIsIDEpO1xuICAgICAgc2tldGNoTGluZUdlb20gPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd9ICovICh0aGlzLnNrZXRjaExpbmVfLmdldEdlb21ldHJ5KCkpO1xuICAgICAgc2tldGNoTGluZUdlb20uc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyh0aGlzLnNrZXRjaENvb3Jkc18sIGdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmZpbmlzaENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIGRyYXdpbmcgYW5kIGFkZCB0aGUgc2tldGNoIGZlYXR1cmUgdG8gdGhlIHRhcmdldCBsYXllci5cbiAgICogVGhlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35EcmF3RXZlbnRUeXBlLkRSQVdFTkR9IGV2ZW50IGlzXG4gICAqIGRpc3BhdGNoZWQgYmVmb3JlIGluc2VydGluZyB0aGUgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuZmluaXNoRHJhd2luZyA9IGZ1bmN0aW9uIGZpbmlzaERyYXdpbmcgKCkge1xuICAgIHZhciBza2V0Y2hGZWF0dXJlID0gdGhpcy5hYm9ydERyYXdpbmdfKCk7XG4gICAgaWYgKCFza2V0Y2hGZWF0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb29yZGluYXRlcyA9IHRoaXMuc2tldGNoQ29vcmRzXztcbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoc2tldGNoRmVhdHVyZS5nZXRHZW9tZXRyeSgpKTtcbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5MSU5FX1NUUklORykge1xuICAgICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgbGFzdCBwb2ludFxuICAgICAgY29vcmRpbmF0ZXMucG9wKCk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVfID09PSBNb2RlLlBPTFlHT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcmVkdW5kYW50IGxhc3QgcG9pbnQgaW4gcmluZ1xuICAgICAgY29vcmRpbmF0ZXNbMF0ucG9wKCk7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fKGNvb3JkaW5hdGVzLCBnZW9tZXRyeSk7XG4gICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBtdWx0aS1wYXJ0IGdlb21ldHJpZXNcbiAgICBpZiAodGhpcy50eXBlXyA9PT0gR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlLnNldEdlb21ldHJ5KG5ldyBNdWx0aVBvaW50KFtjb29yZGluYXRlc10pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgc2tldGNoRmVhdHVyZS5zZXRHZW9tZXRyeShuZXcgTXVsdGlMaW5lU3RyaW5nKFtjb29yZGluYXRlc10pKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZV8gPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICBza2V0Y2hGZWF0dXJlLnNldEdlb21ldHJ5KG5ldyBNdWx0aVBvbHlnb24oW2Nvb3JkaW5hdGVzXSkpO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGRpc3BhdGNoIGV2ZW50IHRvIGFsbG93IGZ1bGwgc2V0IHVwIG9mIGZlYXR1cmVcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IERyYXdFdmVudChEcmF3RXZlbnRUeXBlLkRSQVdFTkQsIHNrZXRjaEZlYXR1cmUpKTtcblxuICAgIC8vIFRoZW4gaW5zZXJ0IGZlYXR1cmVcbiAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNfLnB1c2goc2tldGNoRmVhdHVyZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNvdXJjZV8pIHtcbiAgICAgIHRoaXMuc291cmNlXy5hZGRGZWF0dXJlKHNrZXRjaEZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBkcmF3aW5nIHdpdGhvdXQgYWRkaW5nIHRoZSBza2V0Y2ggZmVhdHVyZSB0byB0aGUgdGFyZ2V0IGxheWVyLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvRmVhdHVyZX0gVGhlIHNrZXRjaCBmZWF0dXJlIChvciBudWxsIGlmIG5vbmUpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUuYWJvcnREcmF3aW5nXyA9IGZ1bmN0aW9uIGFib3J0RHJhd2luZ18gKCkge1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuICAgIHZhciBza2V0Y2hGZWF0dXJlID0gdGhpcy5za2V0Y2hGZWF0dXJlXztcbiAgICBpZiAoc2tldGNoRmVhdHVyZSkge1xuICAgICAgdGhpcy5za2V0Y2hGZWF0dXJlXyA9IG51bGw7XG4gICAgICB0aGlzLnNrZXRjaFBvaW50XyA9IG51bGw7XG4gICAgICB0aGlzLnNrZXRjaExpbmVfID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkuY2xlYXIodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBza2V0Y2hGZWF0dXJlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlbmQgYW4gZXhpc3RpbmcgZ2VvbWV0cnkgYnkgYWRkaW5nIGFkZGl0aW9uYWwgcG9pbnRzLiBUaGlzIG9ubHkgd29ya3NcbiAgICogb24gZmVhdHVyZXMgd2l0aCBgTGluZVN0cmluZ2AgZ2VvbWV0cmllcywgd2hlcmUgdGhlIGludGVyYWN0aW9uIHdpbGxcbiAgICogZXh0ZW5kIGxpbmVzIGJ5IGFkZGluZyBwb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgY29vcmRpbmF0ZXMgYXJyYXkuXG4gICAqIEBwYXJhbSB7IW1vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUgdG8gYmUgZXh0ZW5kZWQuXG4gICAqIEBhcGlcbiAgICovXG4gIERyYXcucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoZmVhdHVyZSkge1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICB2YXIgbGluZVN0cmluZyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KTtcbiAgICB0aGlzLnNrZXRjaEZlYXR1cmVfID0gZmVhdHVyZTtcbiAgICB0aGlzLnNrZXRjaENvb3Jkc18gPSBsaW5lU3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIGxhc3QgPSB0aGlzLnNrZXRjaENvb3Jkc19bdGhpcy5za2V0Y2hDb29yZHNfLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBsYXN0LnNsaWNlKCk7XG4gICAgdGhpcy5za2V0Y2hDb29yZHNfLnB1c2gobGFzdC5zbGljZSgpKTtcbiAgICB0aGlzLnVwZGF0ZVNrZXRjaEZlYXR1cmVzXygpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhd0V2ZW50KERyYXdFdmVudFR5cGUuRFJBV1NUQVJULCB0aGlzLnNrZXRjaEZlYXR1cmVfKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZHJhdyB0aGUgc2tldGNoIGZlYXR1cmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUudXBkYXRlU2tldGNoRmVhdHVyZXNfID0gZnVuY3Rpb24gdXBkYXRlU2tldGNoRmVhdHVyZXNfICgpIHtcbiAgICB2YXIgc2tldGNoRmVhdHVyZXMgPSBbXTtcbiAgICBpZiAodGhpcy5za2V0Y2hGZWF0dXJlXykge1xuICAgICAgc2tldGNoRmVhdHVyZXMucHVzaCh0aGlzLnNrZXRjaEZlYXR1cmVfKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2tldGNoTGluZV8pIHtcbiAgICAgIHNrZXRjaEZlYXR1cmVzLnB1c2godGhpcy5za2V0Y2hMaW5lXyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNrZXRjaFBvaW50Xykge1xuICAgICAgc2tldGNoRmVhdHVyZXMucHVzaCh0aGlzLnNrZXRjaFBvaW50Xyk7XG4gICAgfVxuICAgIHZhciBvdmVybGF5U291cmNlID0gdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKTtcbiAgICBvdmVybGF5U291cmNlLmNsZWFyKHRydWUpO1xuICAgIG92ZXJsYXlTb3VyY2UuYWRkRmVhdHVyZXMoc2tldGNoRmVhdHVyZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgRHJhdy5wcm90b3R5cGUudXBkYXRlU3RhdGVfID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVfICgpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICBpZiAoIW1hcCB8fCAhYWN0aXZlKSB7XG4gICAgICB0aGlzLmFib3J0RHJhd2luZ18oKTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5Xy5zZXRNYXAoYWN0aXZlID8gbWFwIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIERyYXc7XG59KFBvaW50ZXJJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCldO1xuICB9O1xufVxuXG5cbi8qKlxuICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgYWN0dWFsbHlcbiAqIGRyYXcgb3IgZmluaXNoIHRoZSBkcmF3aW5nLlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBldmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5DT05URVhUTUVOVSkge1xuICAgIC8vIEF2b2lkIGNvbnRleHQgbWVudSBmb3IgbG9uZyB0YXBzIHdoZW4gZHJhd2luZyBvbiBtb2JpbGVcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHRoaXMuZnJlZWhhbmRfID0gdGhpcy5tb2RlXyAhPT0gTW9kZS5QT0lOVCAmJiB0aGlzLmZyZWVoYW5kQ29uZGl0aW9uXyhldmVudCk7XG4gIHZhciBtb3ZlID0gZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRTtcbiAgdmFyIHBhc3MgPSB0cnVlO1xuICBpZiAodGhpcy5sYXN0RHJhZ1RpbWVfICYmIGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RHJhZ1RpbWVfID49IHRoaXMuZHJhZ1ZlcnRleERlbGF5Xykge1xuICAgICAgdGhpcy5kb3duUHhfID0gZXZlbnQucGl4ZWw7XG4gICAgICB0aGlzLnNob3VsZEhhbmRsZV8gPSAhdGhpcy5mcmVlaGFuZF87XG4gICAgICBtb3ZlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0RHJhZ1RpbWVfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRIYW5kbGVfICYmIHRoaXMuZG93blRpbWVvdXRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3duVGltZW91dF8pO1xuICAgICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLmZyZWVoYW5kXyAmJlxuICAgICAgZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRyAmJlxuICAgICAgdGhpcy5za2V0Y2hGZWF0dXJlXyAhPT0gbnVsbCkge1xuICAgIHRoaXMuYWRkVG9EcmF3aW5nXyhldmVudCk7XG4gICAgcGFzcyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHRoaXMuZnJlZWhhbmRfICYmXG4gICAgICBldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgcGFzcyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICBwYXNzID0gZXZlbnQudHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRTtcbiAgICBpZiAocGFzcyAmJiB0aGlzLmZyZWVoYW5kXykge1xuICAgICAgcGFzcyA9IHRoaXMuaGFuZGxlUG9pbnRlck1vdmVfKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX1RZUEUgfHxcbiAgICAgICAgKGV2ZW50LnR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcgJiYgIXRoaXMuZG93blRpbWVvdXRfKSkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8oZXZlbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLKSB7XG4gICAgcGFzcyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZVBvaW50ZXJFdmVudC5jYWxsKHRoaXMsIGV2ZW50KSAmJiBwYXNzO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gZXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdGFydCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fVxuICovXG5mdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQoZXZlbnQpIHtcbiAgdGhpcy5zaG91bGRIYW5kbGVfID0gIXRoaXMuZnJlZWhhbmRfO1xuXG4gIGlmICh0aGlzLmZyZWVoYW5kXykge1xuICAgIHRoaXMuZG93blB4XyA9IGV2ZW50LnBpeGVsO1xuICAgIGlmICghdGhpcy5maW5pc2hDb29yZGluYXRlXykge1xuICAgICAgdGhpcy5zdGFydERyYXdpbmdfKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5jb25kaXRpb25fKGV2ZW50KSkge1xuICAgIHRoaXMubGFzdERyYWdUaW1lXyA9IERhdGUubm93KCk7XG4gICAgdGhpcy5kb3duVGltZW91dF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8obmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsIGV2ZW50Lm1hcCwgZXZlbnQucG9pbnRlckV2ZW50LCBldmVudC5mcmFtZVN0YXRlKSk7XG4gICAgfS5iaW5kKHRoaXMpLCB0aGlzLmRyYWdWZXJ0ZXhEZWxheV8pO1xuICAgIHRoaXMuZG93blB4XyA9IGV2ZW50LnBpeGVsO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gZXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdG9wIGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQoZXZlbnQpIHtcbiAgdmFyIHBhc3MgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmRvd25UaW1lb3V0Xykge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmRvd25UaW1lb3V0Xyk7XG4gICAgdGhpcy5kb3duVGltZW91dF8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhldmVudCk7XG5cbiAgdmFyIGNpcmNsZU1vZGUgPSB0aGlzLm1vZGVfID09PSBNb2RlLkNJUkNMRTtcblxuICBpZiAodGhpcy5zaG91bGRIYW5kbGVfKSB7XG4gICAgaWYgKCF0aGlzLmZpbmlzaENvb3JkaW5hdGVfKSB7XG4gICAgICB0aGlzLnN0YXJ0RHJhd2luZ18oZXZlbnQpO1xuICAgICAgaWYgKHRoaXMubW9kZV8gPT09IE1vZGUuUE9JTlQpIHtcbiAgICAgICAgdGhpcy5maW5pc2hEcmF3aW5nKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmZyZWVoYW5kXyB8fCBjaXJjbGVNb2RlKSB7XG4gICAgICB0aGlzLmZpbmlzaERyYXdpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXRGaW5pc2hfKGV2ZW50KSkge1xuICAgICAgaWYgKHRoaXMuZmluaXNoQ29uZGl0aW9uXyhldmVudCkpIHtcbiAgICAgICAgdGhpcy5maW5pc2hEcmF3aW5nKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVG9EcmF3aW5nXyhldmVudCk7XG4gICAgfVxuICAgIHBhc3MgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh0aGlzLmZyZWVoYW5kXykge1xuICAgIHRoaXMuZmluaXNoQ29vcmRpbmF0ZV8gPSBudWxsO1xuICAgIHRoaXMuYWJvcnREcmF3aW5nXygpO1xuICB9XG4gIGlmICghcGFzcyAmJiB0aGlzLnN0b3BDbGlja18pIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICByZXR1cm4gcGFzcztcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIGBnZW9tZXRyeUZ1bmN0aW9uYCBmb3IgYHR5cGU6ICdDaXJjbGUnYCB0aGF0IHdpbGwgY3JlYXRlIGEgcmVndWxhclxuICogcG9seWdvbiB3aXRoIGEgdXNlciBzcGVjaWZpZWQgbnVtYmVyIG9mIHNpZGVzIGFuZCBzdGFydCBhbmdsZSBpbnN0ZWFkIG9mIGFuXG4gKiBgbW9kdWxlOm9sL2dlb20vQ2lyY2xlfkNpcmNsZWAgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9zaWRlcyBOdW1iZXIgb2Ygc2lkZXMgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi4gRGVmYXVsdCBpc1xuICogICAgIDMyLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfYW5nbGUgQW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IGluIHJhZGlhbnMuIDAgbWVhbnMgRWFzdC5cbiAqICAgICBEZWZhdWx0IGlzIHRoZSBhbmdsZSBkZWZpbmVkIGJ5IHRoZSBoZWFkaW5nIGZyb20gdGhlIGNlbnRlciBvZiB0aGVcbiAqICAgICByZWd1bGFyIHBvbHlnb24gdG8gdGhlIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmF3fkdlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgZHJhd3MgYVxuICogICAgIHBvbHlnb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWd1bGFyUG9seWdvbihvcHRfc2lkZXMsIG9wdF9hbmdsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29vcmRpbmF0ZXMsIG9wdF9nZW9tZXRyeSkge1xuICAgIHZhciBjZW50ZXIgPSBjb29yZGluYXRlc1swXTtcbiAgICB2YXIgZW5kID0gY29vcmRpbmF0ZXNbMV07XG4gICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydChcbiAgICAgIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoY2VudGVyLCBlbmQpKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBvcHRfZ2VvbWV0cnkgPyAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvbHlnb259ICovIChvcHRfZ2VvbWV0cnkpIDpcbiAgICAgIGZyb21DaXJjbGUobmV3IENpcmNsZShjZW50ZXIpLCBvcHRfc2lkZXMpO1xuICAgIHZhciBhbmdsZSA9IG9wdF9hbmdsZSA/IG9wdF9hbmdsZSA6XG4gICAgICBNYXRoLmF0YW4oKGVuZFsxXSAtIGNlbnRlclsxXSkgLyAoZW5kWzBdIC0gY2VudGVyWzBdKSk7XG4gICAgbWFrZVJlZ3VsYXIoZ2VvbWV0cnksIGNlbnRlciwgcmFkaXVzLCBhbmdsZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9O1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgYGdlb21ldHJ5RnVuY3Rpb25gIHRoYXQgd2lsbCBjcmVhdGUgYSBib3gtc2hhcGVkIHBvbHlnb24gKGFsaWduZWRcbiAqIHdpdGggdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGF4ZXMpLiAgVXNlIHRoaXMgd2l0aCB0aGUgZHJhdyBpbnRlcmFjdGlvbiBhbmRcbiAqIGB0eXBlOiAnQ2lyY2xlJ2AgdG8gcmV0dXJuIGEgYm94IGluc3RlYWQgb2YgYSBjaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhd35HZW9tZXRyeUZ1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGRyYXdzIGEgYm94LXNoYXBlZCBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQm94KCkge1xuICByZXR1cm4gKFxuICAgIGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBvcHRfZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBleHRlbnQgPSBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcyk7XG4gICAgICB2YXIgYm94Q29vcmRpbmF0ZXMgPSBbW1xuICAgICAgICBnZXRCb3R0b21MZWZ0KGV4dGVudCksXG4gICAgICAgIGdldEJvdHRvbVJpZ2h0KGV4dGVudCksXG4gICAgICAgIGdldFRvcFJpZ2h0KGV4dGVudCksXG4gICAgICAgIGdldFRvcExlZnQoZXh0ZW50KSxcbiAgICAgICAgZ2V0Qm90dG9tTGVmdChleHRlbnQpXG4gICAgICBdXTtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG9wdF9nZW9tZXRyeTtcbiAgICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhib3hDb29yZGluYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tZXRyeSA9IG5ldyBQb2x5Z29uKGJveENvb3JkaW5hdGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRyYXdpbmcgbW9kZS4gIFRoZSBtb2RlIGZvciBtdWx0LXBhcnQgZ2VvbWV0cmllcyBpcyB0aGUgc2FtZSBhcyBmb3JcbiAqIHRoZWlyIHNpbmdsZS1wYXJ0IGNvdXNpbnMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5VHlwZX0gdHlwZSBHZW9tZXRyeSB0eXBlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd+TW9kZX0gRHJhd2luZyBtb2RlLlxuICovXG5mdW5jdGlvbiBnZXRNb2RlKHR5cGUpIHtcbiAgdmFyIG1vZGU7XG4gIGlmICh0eXBlID09PSBHZW9tZXRyeVR5cGUuUE9JTlQgfHxcbiAgICAgIHR5cGUgPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVCkge1xuICAgIG1vZGUgPSBNb2RlLlBPSU5UO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORyB8fFxuICAgICAgdHlwZSA9PT0gR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSB7XG4gICAgbW9kZSA9IE1vZGUuTElORV9TVFJJTkc7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gR2VvbWV0cnlUeXBlLlBPTFlHT04gfHxcbiAgICAgIHR5cGUgPT09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgbW9kZSA9IE1vZGUuUE9MWUdPTjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHZW9tZXRyeVR5cGUuQ0lSQ0xFKSB7XG4gICAgbW9kZSA9IE1vZGUuQ0lSQ0xFO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHshbW9kdWxlOm9sL2ludGVyYWN0aW9uL0RyYXd+TW9kZX0gKi8gKG1vZGUpXG4gICk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRHJhdztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RHJhdy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRXh0ZW50XG4gKi9cbmltcG9ydCBGZWF0dXJlIGZyb20gJy4uL0ZlYXR1cmUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi4vTWFwQnJvd3NlckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlclBvaW50ZXJFdmVudCBmcm9tICcuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlVG9TZWdtZW50LCBjbG9zZXN0T25TZWdtZW50LCBkaXN0YW5jZSBhcyBjb29yZGluYXRlRGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZSBhcyBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlfSBmcm9tICcuLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgZ2V0QXJlYX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFBvaW50IGZyb20gJy4uL2dlb20vUG9pbnQuanMnO1xuaW1wb3J0IHtmcm9tRXh0ZW50IGFzIHBvbHlnb25Gcm9tRXh0ZW50fSBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge2hhbmRsZUV2ZW50IGFzIGhhbmRsZVBvaW50ZXJFdmVudH0gZnJvbSAnLi4vaW50ZXJhY3Rpb24vUG9pbnRlci5qcyc7XG5pbXBvcnQgVmVjdG9yTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvVmVjdG9yLmpzJztcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gSW5pdGlhbCBleHRlbnQuIERlZmF1bHRzIHRvIG5vXG4gKiBpbml0aWFsIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+fG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufSBbYm94U3R5bGVdXG4gKiBTdHlsZSBmb3IgdGhlIGRyYXduIGV4dGVudCBib3guIERlZmF1bHRzIHRvXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlfmNyZWF0ZUVkaXRpbmcoKVsnUG9seWdvbiddfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaXhlbFRvbGVyYW5jZT0xMF0gUGl4ZWwgdG9sZXJhbmNlIGZvciBjb25zaWRlcmluZyB0aGVcbiAqIHBvaW50ZXIgY2xvc2UgZW5vdWdoIHRvIGEgc2VnbWVudCBvciB2ZXJ0ZXggZm9yIGVkaXRpbmcuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zdHlsZS9TdHlsZXxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn0gW3BvaW50ZXJTdHlsZV1cbiAqIFN0eWxlIGZvciB0aGUgY3Vyc29yIHVzZWQgdG8gZHJhdyB0aGUgZXh0ZW50LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5jcmVhdGVFZGl0aW5nKClbJ1BvaW50J119XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV0gV3JhcCB0aGUgZHJhd24gZXh0ZW50IGFjcm9zcyBtdWx0aXBsZSBtYXBzXG4gKiBpbiB0aGUgWCBkaXJlY3Rpb24/IE9ubHkgYWZmZWN0cyB2aXN1YWxzLCBub3QgZnVuY3Rpb25hbGl0eS5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIEV4dGVudEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgZXh0ZW50IGlzIGNoYW5nZWRcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50RXZlbnRUeXBlI2V4dGVudGNoYW5nZWRcbiAgICogQGFwaVxuICAgKi9cbiAgRVhURU5UQ0hBTkdFRDogJ2V4dGVudGNoYW5nZWQnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50fSBpbnN0YW5jZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG52YXIgRXh0ZW50SW50ZXJhY3Rpb25FdmVudCA9IChmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gRXh0ZW50SW50ZXJhY3Rpb25FdmVudChleHRlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIEV4dGVudEV2ZW50VHlwZS5FWFRFTlRDSEFOR0VEKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGV4dGVudC5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50O1xuICB9XG5cbiAgaWYgKCBFdmVudCApIEV4dGVudEludGVyYWN0aW9uRXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIEV4dGVudEludGVyYWN0aW9uRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIEV4dGVudEludGVyYWN0aW9uRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0ZW50SW50ZXJhY3Rpb25FdmVudDtcblxuICByZXR1cm4gRXh0ZW50SW50ZXJhY3Rpb25FdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBkcmF3IGEgdmVjdG9yIGJveCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcC5cbiAqIE9uY2UgZHJhd24sIHRoZSB2ZWN0b3IgYm94IGNhbiBiZSBtb2RpZmllZCBieSBkcmFnZ2luZyBpdHMgdmVydGljZXMgb3IgZWRnZXMuXG4gKiBUaGlzIGludGVyYWN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtb3VzZSBkZXZpY2VzLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRXh0ZW50fkV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBFeHRlbnRJbnRlcmFjdGlvbiA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEV4dGVudEludGVyYWN0aW9uKG9wdF9vcHRpb25zKSB7XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVEb3duRXZlbnQ6IGhhbmRsZURvd25FdmVudCxcbiAgICAgIGhhbmRsZURyYWdFdmVudDogaGFuZGxlRHJhZ0V2ZW50LFxuICAgICAgaGFuZGxlRXZlbnQ6IGhhbmRsZUV2ZW50LFxuICAgICAgaGFuZGxlVXBFdmVudDogaGFuZGxlVXBFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgZHJhd24gYm94XG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yIHBvaW50ZXIgbW92ZSBldmVudHNcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24gKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudHxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGl4ZWwgdGhyZXNob2xkIHRvIHNuYXAgdG8gZXh0ZW50XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID0gb3B0aW9ucy5waXhlbFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwb2ludGVyIHNuYXBwZWQgdG8gYW4gZXh0ZW50IHZlcnRleFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGZWF0dXJlIGZvciBkaXNwbGF5aW5nIHRoZSB2aXNpYmxlIGV4dGVudFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50RmVhdHVyZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRmVhdHVyZSBmb3IgZGlzcGxheWluZyB0aGUgdmlzaWJsZSBwb2ludGVyXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9GZWF0dXJlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG5cbiAgICBpZiAoIW9wdF9vcHRpb25zKSB7XG4gICAgICBvcHRfb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExheWVyIGZvciB0aGUgZXh0ZW50RmVhdHVyZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5leHRlbnRPdmVybGF5XyA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICB3cmFwWDogISFvcHRfb3B0aW9ucy53cmFwWFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0X29wdGlvbnMuYm94U3R5bGUgPyBvcHRfb3B0aW9ucy5ib3hTdHlsZSA6IGdldERlZmF1bHRFeHRlbnRTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIExheWVyIGZvciB0aGUgdmVydGV4RmVhdHVyZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhPdmVybGF5XyA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICB3cmFwWDogISFvcHRfb3B0aW9ucy53cmFwWFxuICAgICAgfSksXG4gICAgICBzdHlsZTogb3B0X29wdGlvbnMucG9pbnRlclN0eWxlID8gb3B0X29wdGlvbnMucG9pbnRlclN0eWxlIDogZ2V0RGVmYXVsdFBvaW50ZXJTdHlsZUZ1bmN0aW9uKCksXG4gICAgICB1cGRhdGVXaGlsZUFuaW1hdGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChvcHRfb3B0aW9ucy5leHRlbnQpIHtcbiAgICAgIHRoaXMuc2V0RXh0ZW50KG9wdF9vcHRpb25zLmV4dGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBFeHRlbnRJbnRlcmFjdGlvbi5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvaW50ZXJJbnRlcmFjdGlvbiAmJiBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dGVudEludGVyYWN0aW9uO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgY3Vyc29yIGxvY2F0aW9uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gbWFwIG1hcFxuICAgKiBAcmV0dXJucyB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXxudWxsfSBzbmFwcGVkIHZlcnRleCBvbiBleHRlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5zbmFwVG9WZXJ0ZXhfID0gZnVuY3Rpb24gc25hcFRvVmVydGV4XyAocGl4ZWwsIG1hcCkge1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGUgPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChwaXhlbCk7XG4gICAgdmFyIHNvcnRCeURpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudChwaXhlbENvb3JkaW5hdGUsIGEpIC1cbiAgICAgICAgICBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQocGl4ZWxDb29yZGluYXRlLCBiKTtcbiAgICB9O1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIGlmIChleHRlbnQpIHtcbiAgICAgIC8vY29udmVydCBleHRlbnRzIHRvIGxpbmUgc2VnbWVudHMgYW5kIGZpbmQgdGhlIHNlZ21lbnQgY2xvc2VzdCB0byBwaXhlbENvb3JkaW5hdGVcbiAgICAgIHZhciBzZWdtZW50cyA9IGdldFNlZ21lbnRzKGV4dGVudCk7XG4gICAgICBzZWdtZW50cy5zb3J0KHNvcnRCeURpc3RhbmNlKTtcbiAgICAgIHZhciBjbG9zZXN0U2VnbWVudCA9IHNlZ21lbnRzWzBdO1xuXG4gICAgICB2YXIgdmVydGV4ID0gKGNsb3Nlc3RPblNlZ21lbnQocGl4ZWxDb29yZGluYXRlLFxuICAgICAgICBjbG9zZXN0U2VnbWVudCkpO1xuICAgICAgdmFyIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcblxuICAgICAgLy9pZiB0aGUgZGlzdGFuY2UgaXMgd2l0aGluIHRvbGVyYW5jZSwgc25hcCB0byB0aGUgc2VnbWVudFxuICAgICAgaWYgKGNvb3JkaW5hdGVEaXN0YW5jZShwaXhlbCwgdmVydGV4UGl4ZWwpIDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgIC8vdGVzdCBpZiB3ZSBzaG91bGQgZnVydGhlciBzbmFwIHRvIGEgdmVydGV4XG4gICAgICAgIHZhciBwaXhlbDEgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFswXSk7XG4gICAgICAgIHZhciBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgIHZhciBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDEpO1xuICAgICAgICB2YXIgc3F1YXJlZERpc3QyID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwyKTtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgaWYgKHRoaXMuc25hcHBlZFRvVmVydGV4Xykge1xuICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/XG4gICAgICAgICAgICBjbG9zZXN0U2VnbWVudFsxXSA6IGNsb3Nlc3RTZWdtZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBwb2ludGVyIG1vdmUgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5oYW5kbGVQb2ludGVyTW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZV8gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHZhciBwaXhlbCA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcblxuICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnNuYXBUb1ZlcnRleF8ocGl4ZWwsIG1hcCk7XG4gICAgaWYgKCF2ZXJ0ZXgpIHtcbiAgICAgIHZlcnRleCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyh2ZXJ0ZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgZXh0ZW50XG4gICAqIEByZXR1cm5zIHttb2R1bGU6b2wvRmVhdHVyZX0gZXh0ZW50IGFzIGZlYXRydWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZUV4dGVudEZlYXR1cmVfID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFeHRlbnRGZWF0dXJlXyAoZXh0ZW50KSB7XG4gICAgdmFyIGV4dGVudEZlYXR1cmUgPSB0aGlzLmV4dGVudEZlYXR1cmVfO1xuXG4gICAgaWYgKCFleHRlbnRGZWF0dXJlKSB7XG4gICAgICBpZiAoIWV4dGVudCkge1xuICAgICAgICBleHRlbnRGZWF0dXJlID0gbmV3IEZlYXR1cmUoe30pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW50RmVhdHVyZSA9IG5ldyBGZWF0dXJlKHBvbHlnb25Gcm9tRXh0ZW50KGV4dGVudCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5leHRlbnRGZWF0dXJlXyA9IGV4dGVudEZlYXR1cmU7XG4gICAgICB0aGlzLmV4dGVudE92ZXJsYXlfLmdldFNvdXJjZSgpLmFkZEZlYXR1cmUoZXh0ZW50RmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZXh0ZW50KSB7XG4gICAgICAgIGV4dGVudEZlYXR1cmUuc2V0R2VvbWV0cnkodW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVudEZlYXR1cmUuc2V0R2VvbWV0cnkocG9seWdvbkZyb21FeHRlbnQoZXh0ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbnRGZWF0dXJlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHZlcnRleCBsb2NhdGlvbiBvZiBmZWF0dXJlXG4gICAqIEByZXR1cm5zIHttb2R1bGU6b2wvRmVhdHVyZX0gdmVydGV4IGFzIGZlYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVBvaW50ZXJGZWF0dXJlXyA9IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlUG9pbnRlckZlYXR1cmVfICh2ZXJ0ZXgpIHtcbiAgICB2YXIgdmVydGV4RmVhdHVyZSA9IHRoaXMudmVydGV4RmVhdHVyZV87XG4gICAgaWYgKCF2ZXJ0ZXhGZWF0dXJlKSB7XG4gICAgICB2ZXJ0ZXhGZWF0dXJlID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KHZlcnRleCkpO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IHZlcnRleEZlYXR1cmU7XG4gICAgICB0aGlzLnZlcnRleE92ZXJsYXlfLmdldFNvdXJjZSgpLmFkZEZlYXR1cmUodmVydGV4RmVhdHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vUG9pbnR9ICovICh2ZXJ0ZXhGZWF0dXJlLmdldEdlb21ldHJ5KCkpO1xuICAgICAgZ2VvbWV0cnkuc2V0Q29vcmRpbmF0ZXModmVydGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnRleEZlYXR1cmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBFeHRlbnRJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB0aGlzLmV4dGVudE92ZXJsYXlfLnNldE1hcChtYXApO1xuICAgIHRoaXMudmVydGV4T3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRyYXduIGV4dGVudCBpbiB0aGUgdmlldyBwcm9qZWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBEcmF3biBleHRlbnQgaW4gdGhlIHZpZXcgcHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgRXh0ZW50SW50ZXJhY3Rpb24ucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfTtcblxuICAvKipcbiAgICogTWFudWFsbHkgc2V0cyB0aGUgZHJhd24gZXh0ZW50LCB1c2luZyB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50XG4gICAqIEBhcGlcbiAgICovXG4gIEV4dGVudEludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiBzZXRFeHRlbnQgKGV4dGVudCkge1xuICAgIC8vTnVsbCBleHRlbnQgbWVhbnMgbm8gYmJveFxuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudCA/IGV4dGVudCA6IG51bGw7XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZUV4dGVudEZlYXR1cmVfKGV4dGVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFeHRlbnRJbnRlcmFjdGlvbkV2ZW50KHRoaXMuZXh0ZW50XykpO1xuICB9O1xuXG4gIHJldHVybiBFeHRlbnRJbnRlcmFjdGlvbjtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBQcm9wYWdhdGUgZXZlbnQ/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0V4dGVudH5FeHRlbnR9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAoIShtYXBCcm93c2VyRXZlbnQgaW5zdGFuY2VvZiBNYXBCcm93c2VyUG9pbnRlckV2ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vZGlzcGxheSBwb2ludGVyIChpZiBub3QgZHJhZ2dpbmcpXG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFICYmICF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlXyhtYXBCcm93c2VyRXZlbnQpO1xuICB9XG4gIC8vY2FsbCBwb2ludGVyIHRvIGRldGVybWluZSB1cC9kb3duL2RyYWdcbiAgaGFuZGxlUG9pbnRlckV2ZW50LmNhbGwodGhpcywgbWFwQnJvd3NlckV2ZW50KTtcbiAgLy9yZXR1cm4gZmFsc2UgdG8gc3RvcCBwcm9wYWdhdGlvblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gRXZlbnQgaGFuZGxlZD9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vRXh0ZW50fkV4dGVudH1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgcGl4ZWwgPSBtYXBCcm93c2VyRXZlbnQucGl4ZWw7XG4gIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuXG4gIHZhciBleHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICB2YXIgdmVydGV4ID0gdGhpcy5zbmFwVG9WZXJ0ZXhfKHBpeGVsLCBtYXApO1xuXG4gIC8vZmluZCB0aGUgZXh0ZW50IGNvcm5lciBvcHBvc2l0ZSB0aGUgcGFzc2VkIGNvcm5lclxuICB2YXIgZ2V0T3Bwb3NpbmdQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIHhfID0gbnVsbDtcbiAgICB2YXIgeV8gPSBudWxsO1xuICAgIGlmIChwb2ludFswXSA9PSBleHRlbnRbMF0pIHtcbiAgICAgIHhfID0gZXh0ZW50WzJdO1xuICAgIH0gZWxzZSBpZiAocG9pbnRbMF0gPT0gZXh0ZW50WzJdKSB7XG4gICAgICB4XyA9IGV4dGVudFswXTtcbiAgICB9XG4gICAgaWYgKHBvaW50WzFdID09IGV4dGVudFsxXSkge1xuICAgICAgeV8gPSBleHRlbnRbM107XG4gICAgfSBlbHNlIGlmIChwb2ludFsxXSA9PSBleHRlbnRbM10pIHtcbiAgICAgIHlfID0gZXh0ZW50WzFdO1xuICAgIH1cbiAgICBpZiAoeF8gIT09IG51bGwgJiYgeV8gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbeF8sIHlfXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGlmICh2ZXJ0ZXggJiYgZXh0ZW50KSB7XG4gICAgdmFyIHggPSAodmVydGV4WzBdID09IGV4dGVudFswXSB8fCB2ZXJ0ZXhbMF0gPT0gZXh0ZW50WzJdKSA/IHZlcnRleFswXSA6IG51bGw7XG4gICAgdmFyIHkgPSAodmVydGV4WzFdID09IGV4dGVudFsxXSB8fCB2ZXJ0ZXhbMV0gPT0gZXh0ZW50WzNdKSA/IHZlcnRleFsxXSA6IG51bGw7XG5cbiAgICAvL3NuYXAgdG8gcG9pbnRcbiAgICBpZiAoeCAhPT0gbnVsbCAmJiB5ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldFBvaW50SGFuZGxlcihnZXRPcHBvc2luZ1BvaW50KHZlcnRleCkpO1xuICAgIC8vc25hcCB0byBlZGdlXG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldEVkZ2VIYW5kbGVyKFxuICAgICAgICBnZXRPcHBvc2luZ1BvaW50KFt4LCBleHRlbnRbMV1dKSxcbiAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbeCwgZXh0ZW50WzNdXSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IGdldEVkZ2VIYW5kbGVyKFxuICAgICAgICBnZXRPcHBvc2luZ1BvaW50KFtleHRlbnRbMF0sIHldKSxcbiAgICAgICAgZ2V0T3Bwb3NpbmdQb2ludChbZXh0ZW50WzJdLCB5XSlcbiAgICAgICk7XG4gICAgfVxuICAvL25vIHNuYXAgLSBuZXcgYmJveFxuICB9IGVsc2Uge1xuICAgIHZlcnRleCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICB0aGlzLnNldEV4dGVudChbdmVydGV4WzBdLCB2ZXJ0ZXhbMV0sIHZlcnRleFswXSwgdmVydGV4WzFdXSk7XG4gICAgdGhpcy5wb2ludGVySGFuZGxlcl8gPSBnZXRQb2ludEhhbmRsZXIodmVydGV4KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTsgLy9ldmVudCBoYW5kbGVkOyBzdGFydCBkb3dudXAgc2VxdWVuY2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFdmVudCBoYW5kbGVkP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50fVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICh0aGlzLnBvaW50ZXJIYW5kbGVyXykge1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGUgPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICB0aGlzLnNldEV4dGVudCh0aGlzLnBvaW50ZXJIYW5kbGVyXyhwaXhlbENvb3JkaW5hdGUpKTtcbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlUG9pbnRlckZlYXR1cmVfKHBpeGVsQ29vcmRpbmF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RvcCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9FeHRlbnR+RXh0ZW50fVxuICovXG5mdW5jdGlvbiBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB0aGlzLnBvaW50ZXJIYW5kbGVyXyA9IG51bGw7XG4gIC8vSWYgYmJveCBpcyB6ZXJvIGFyZWEsIHNldCB0byBudWxsO1xuICB2YXIgZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgaWYgKCFleHRlbnQgfHwgZ2V0QXJlYShleHRlbnQpID09PSAwKSB7XG4gICAgdGhpcy5zZXRFeHRlbnQobnVsbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlOyAvL1N0b3AgaGFuZGxpbmcgZG93bnVwIHNlcXVlbmNlXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBzdHlsZSBmb3IgdGhlIGRyYXduIGJib3hcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn0gRGVmYXVsdCBFeHRlbnQgc3R5bGVcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4dGVudFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZSA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBzdHlsZVtHZW9tZXRyeVR5cGUuUE9MWUdPTl07XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBzdHlsZSBmb3IgdGhlIHBvaW50ZXJcbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn0gRGVmYXVsdCBwb2ludGVyIHN0eWxlXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRQb2ludGVyU3R5bGVGdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gY3JlYXRlRWRpdGluZ1N0eWxlKCk7XG4gIHJldHVybiBmdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIHN0eWxlW0dlb21ldHJ5VHlwZS5QT0lOVF07XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBmaXhlZFBvaW50IGNvcm5lciB0aGF0IHdpbGwgYmUgdW5jaGFuZ2VkIGluIHRoZSBuZXcgZXh0ZW50XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24gKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXZlbnQgaGFuZGxlclxuICovXG5mdW5jdGlvbiBnZXRQb2ludEhhbmRsZXIoZml4ZWRQb2ludCkge1xuICByZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gYm91bmRpbmdFeHRlbnQoW2ZpeGVkUG9pbnQsIHBvaW50XSk7XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBmaXhlZFAxIGZpcnN0IGNvcm5lciB0aGF0IHdpbGwgYmUgdW5jaGFuZ2VkIGluIHRoZSBuZXcgZXh0ZW50XG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGZpeGVkUDIgc2Vjb25kIGNvcm5lciB0aGF0IHdpbGwgYmUgdW5jaGFuZ2VkIGluIHRoZSBuZXcgZXh0ZW50XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24gKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudHxudWxsfSBldmVudCBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGdldEVkZ2VIYW5kbGVyKGZpeGVkUDEsIGZpeGVkUDIpIHtcbiAgaWYgKGZpeGVkUDFbMF0gPT0gZml4ZWRQMlswXSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIGJvdW5kaW5nRXh0ZW50KFtmaXhlZFAxLCBbcG9pbnRbMF0sIGZpeGVkUDJbMV1dXSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmaXhlZFAxWzFdID09IGZpeGVkUDJbMV0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHJldHVybiBib3VuZGluZ0V4dGVudChbZml4ZWRQMSwgW2ZpeGVkUDJbMF0sIHBvaW50WzFdXV0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgZXh0ZW50XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT4+fSBleHRlbnQgbGluZSBzZWdtZW50c1xuICovXG5mdW5jdGlvbiBnZXRTZWdtZW50cyhleHRlbnQpIHtcbiAgcmV0dXJuIFtcbiAgICBbW2V4dGVudFswXSwgZXh0ZW50WzFdXSwgW2V4dGVudFswXSwgZXh0ZW50WzNdXV0sXG4gICAgW1tleHRlbnRbMF0sIGV4dGVudFszXV0sIFtleHRlbnRbMl0sIGV4dGVudFszXV1dLFxuICAgIFtbZXh0ZW50WzJdLCBleHRlbnRbM11dLCBbZXh0ZW50WzJdLCBleHRlbnRbMV1dXSxcbiAgICBbW2V4dGVudFsyXSwgZXh0ZW50WzFdXSwgW2V4dGVudFswXSwgZXh0ZW50WzFdXV1cbiAgXTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnRJbnRlcmFjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0ZW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IHtlYXNlT3V0LCBsaW5lYXJ9IGZyb20gJy4uL2Vhc2luZy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb25Qcm9wZXJ0eSBmcm9tICcuLi9pbnRlcmFjdGlvbi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIE9iamVjdCBsaXRlcmFsIHdpdGggY29uZmlnIG9wdGlvbnMgZm9yIGludGVyYWN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50KTpib29sZWFufSBoYW5kbGVFdmVudFxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHByb3BhZ2F0aW9uIG9mXG4gKiB0aGUgZXZlbnQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zIGluIHRoZSBtYXAncyBpbnRlcmFjdGlvbnMgY2hhaW4gd2lsbCBiZVxuICogcHJldmVudGVkICh0aGlzIGluY2x1ZGVzIGZ1bmN0aW9ucyB3aXRoIG5vIGV4cGxpY2l0IHJldHVybikuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIFVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGUgc3RhdGUgb2YgdGhlIG1hcC4gU29tZSBhcmUgc2ltaWxhciB0byBjb250cm9scyxcbiAqIGJ1dCBhcmUgbm90IGFzc29jaWF0ZWQgd2l0aCBhIERPTSBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX0gaXNcbiAqIGZ1bmN0aW9uYWxseSB0aGUgc2FtZSBhcyB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2wvWm9vbX5ab29tfSwgYnV0IHRyaWdnZXJlZFxuICogYnkgYSBrZXlib2FyZCBldmVudCBub3QgYSBidXR0b24gZWxlbWVudCBldmVudC5cbiAqIEFsdGhvdWdoIGludGVyYWN0aW9ucyBkbyBub3QgaGF2ZSBhIERPTSBlbGVtZW50LCBzb21lIG9mIHRoZW0gZG8gcmVuZGVyXG4gKiB2ZWN0b3JzIGFuZCBzbyBhcmUgdmlzaWJsZSBvbiB0aGUgc2NyZWVuLlxuICogQGFwaVxuICovXG52YXIgSW50ZXJhY3Rpb24gPSAoZnVuY3Rpb24gKEJhc2VPYmplY3QpIHtcbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb24ob3B0aW9ucykge1xuICAgIEJhc2VPYmplY3QuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQpOmJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVFdmVudCA9IG9wdGlvbnMuaGFuZGxlRXZlbnQ7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEludGVyYWN0aW9uLl9fcHJvdG9fXyA9IEJhc2VPYmplY3Q7XG4gIEludGVyYWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJhY3Rpb247XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBpbnRlcmFjdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIEludGVyYWN0aW9uLnByb3RvdHlwZS5nZXRBY3RpdmUgPSBmdW5jdGlvbiBnZXRBY3RpdmUgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcmFjdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSBpbnRlcmFjdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgQWN0aXZlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlID0gZnVuY3Rpb24gc2V0QWN0aXZlIChhY3RpdmUpIHtcbiAgICB0aGlzLnNldChJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSwgYWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBpbnRlcmFjdGlvbiBmcm9tIGl0cyBjdXJyZW50IG1hcCBhbmQgYXR0YWNoIGl0IHRvIHRoZSBuZXcgbWFwLlxuICAgKiBTdWJjbGFzc2VzIG1heSBzZXQgdXAgZXZlbnQgaGFuZGxlcnMgdG8gZ2V0IG5vdGlmaWVkIGFib3V0IGNoYW5nZXMgdG9cbiAgICogdGhlIG1hcCBoZXJlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG1hcCBNYXAuXG4gICAqL1xuICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH07XG5cbiAgcmV0dXJuIEludGVyYWN0aW9uO1xufShCYXNlT2JqZWN0KSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGRlbHRhIERlbHRhLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYW4odmlldywgZGVsdGEsIG9wdF9kdXJhdGlvbikge1xuICB2YXIgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gIGlmIChjdXJyZW50Q2VudGVyKSB7XG4gICAgdmFyIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKFxuICAgICAgW2N1cnJlbnRDZW50ZXJbMF0gKyBkZWx0YVswXSwgY3VycmVudENlbnRlclsxXSArIGRlbHRhWzFdXSk7XG4gICAgaWYgKG9wdF9kdXJhdGlvbikge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBsaW5lYXIsXG4gICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1ZpZXd9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICByb3RhdGlvbiA9IHZpZXcuY29uc3RyYWluUm90YXRpb24ocm90YXRpb24sIDApO1xuICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJvdGF0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3VycmVudFJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY3VycmVudFJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgY3VycmVudENlbnRlciAmJiBvcHRfZHVyYXRpb24gPiAwKSB7XG4gICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIGFuY2hvcjogb3B0X2FuY2hvcixcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBlYXNlT3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5yb3RhdGUocm90YXRpb24sIG9wdF9hbmNob3IpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVmlld30gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24gdG8gZ28gdG8uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gWm9vbWluZyBkaXJlY3Rpb247ID4gMCBpbmRpY2F0ZXNcbiAqICAgICB6b29taW5nIG91dCwgaW4gd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtIHdpbGwgc2VsZWN0XG4gKiAgICAgdGhlIGxhcmdlc3QgbmVhcmVzdCByZXNvbHV0aW9uOyA8IDAgaW5kaWNhdGVzIHpvb21pbmcgaW4sIGluXG4gKiAgICAgd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtIHdpbGwgc2VsZWN0IHRoZSBzbWFsbGVzdFxuICogICAgIG5lYXJlc3QgcmVzb2x1dGlvbjsgPT0gMCBpbmRpY2F0ZXMgdGhhdCB0aGUgem9vbWluZyBkaXJlY3Rpb25cbiAqICAgICBpcyB1bmtub3duL25vdCByZWxldmFudCwgaW4gd2hpY2ggY2FzZSB0aGUgY29uc3RyYWludHMgc3lzdGVtXG4gKiAgICAgd2lsbCBzZWxlY3QgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbi4gSWYgbm90IGRlZmluZWQgMCBpc1xuICogICAgIGFzc3VtZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICByZXNvbHV0aW9uID0gdmlldy5jb25zdHJhaW5SZXNvbHV0aW9uKHJlc29sdXRpb24sIDAsIG9wdF9kaXJlY3Rpb24pO1xuICB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9WaWV3fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEgZnJvbSBwcmV2aW91cyB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICB2YXIgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmNvbnN0cmFpblJlc29sdXRpb24oY3VycmVudFJlc29sdXRpb24sIGRlbHRhLCAwKTtcblxuICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlc29sdXRpb25zID0gdmlldy5nZXRSZXNvbHV0aW9ucygpO1xuICAgIHJlc29sdXRpb24gPSBjbGFtcChcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICB2aWV3LmdldE1pblJlc29sdXRpb24oKSB8fCByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXSxcbiAgICAgIHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpIHx8IHJlc29sdXRpb25zWzBdKTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBjb25zdHJhaW50IG9uIGNlbnRlciwgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGFuY2hvciBzbyB0aGF0IHRoZVxuICAvLyBuZXcgY2VudGVyIGlzIHdpdGhpbiB0aGUgZXh0ZW50LiBXZSBmaXJzdCBjYWxjdWxhdGUgdGhlIG5ldyBjZW50ZXIsIGFwcGx5XG4gIC8vIHRoZSBjb25zdHJhaW50IHRvIGl0LCBhbmQgdGhlbiBjYWxjdWxhdGUgYmFjayB0aGUgYW5jaG9yXG4gIGlmIChvcHRfYW5jaG9yICYmIHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCAmJiByZXNvbHV0aW9uICE9PSBjdXJyZW50UmVzb2x1dGlvbikge1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIG9wdF9hbmNob3IpO1xuICAgIGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKGNlbnRlcik7XG5cbiAgICBvcHRfYW5jaG9yID0gW1xuICAgICAgKHJlc29sdXRpb24gKiBjdXJyZW50Q2VudGVyWzBdIC0gY3VycmVudFJlc29sdXRpb24gKiBjZW50ZXJbMF0pIC9cbiAgICAgICAgICAocmVzb2x1dGlvbiAtIGN1cnJlbnRSZXNvbHV0aW9uKSxcbiAgICAgIChyZXNvbHV0aW9uICogY3VycmVudENlbnRlclsxXSAtIGN1cnJlbnRSZXNvbHV0aW9uICogY2VudGVyWzFdKSAvXG4gICAgICAgICAgKHJlc29sdXRpb24gLSBjdXJyZW50UmVzb2x1dGlvbilcbiAgICBdO1xuICB9XG5cbiAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvVmlld30gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24gdG8gZ28gdG8uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJlc29sdXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICBpZiAocmVzb2x1dGlvbikge1xuICAgIHZhciBjdXJyZW50UmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHZhciBjdXJyZW50Q2VudGVyID0gdmlldy5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY3VycmVudFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50Q2VudGVyICYmXG4gICAgICAgIHJlc29sdXRpb24gIT09IGN1cnJlbnRSZXNvbHV0aW9uICYmIG9wdF9kdXJhdGlvbikge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgYW5jaG9yOiBvcHRfYW5jaG9yLFxuICAgICAgICBkdXJhdGlvbjogb3B0X2R1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVhc2VPdXRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0X2FuY2hvcikge1xuICAgICAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIG9wdF9hbmNob3IpO1xuICAgICAgICB2aWV3LnNldENlbnRlcihjZW50ZXIpO1xuICAgICAgfVxuICAgICAgdmlldy5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcmFjdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW50ZXJhY3Rpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBLZXlDb2RlIGZyb20gJy4uL2V2ZW50cy9LZXlDb2RlLmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3Bhbn0gZnJvbSAnLi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufm5vTW9kaWZpZXJLZXlzfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn50YXJnZXROb3RFZGl0YWJsZX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxEZWx0YT0xMjhdIFRoZSBhbW91bnQgb2YgcGl4ZWxzIHRvIHBhbiBvbiBlYWNoIGtleVxuICogcHJlc3MuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBwYW4gdGhlIG1hcCB1c2luZyBrZXlib2FyZCBhcnJvd3MuXG4gKiBOb3RlIHRoYXQsIGFsdGhvdWdoIHRoaXMgaW50ZXJhY3Rpb24gaXMgYnkgZGVmYXVsdCBpbmNsdWRlZCBpbiBtYXBzLFxuICogdGhlIGtleXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGJyb3dzZXIgZm9jdXMgaXMgb24gdGhlIGVsZW1lbnQgdG8gd2hpY2hcbiAqIHRoZSBrZXlib2FyZCBldmVudHMgYXJlIGF0dGFjaGVkLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBtYXAgZGl2LFxuICogdGhvdWdoIHlvdSBjYW4gY2hhbmdlIHRoaXMgd2l0aCB0aGUgYGtleWJvYXJkRXZlbnRUYXJnZXRgIGluXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9LiBgZG9jdW1lbnRgIG5ldmVyIGxvc2VzIGZvY3VzIGJ1dCwgZm9yIGFueSBvdGhlclxuICogZWxlbWVudCwgZm9jdXMgd2lsbCBoYXZlIHRvIGJlIG9uLCBhbmQgcmV0dXJuZWQgdG8sIHRoaXMgZWxlbWVudCBpZiB0aGUga2V5c1xuICogYXJlIHRvIGZ1bmN0aW9uLlxuICogU2VlIGFsc28ge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfS5cbiAqIEBhcGlcbiAqL1xudmFyIEtleWJvYXJkUGFuID0gKGZ1bmN0aW9uIChJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBLZXlib2FyZFBhbihvcHRfb3B0aW9ucykge1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb25kaXRpb25fID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gbm9Nb2RpZmllcktleXMobWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICB0YXJnZXROb3RFZGl0YWJsZShtYXBCcm93c2VyRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmNvbmRpdGlvbiA6IHRoaXMuZGVmYXVsdENvbmRpdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMTAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxEZWx0YV8gPSBvcHRpb25zLnBpeGVsRGVsdGEgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnBpeGVsRGVsdGEgOiAxMjg7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBLZXlib2FyZFBhbi5fX3Byb3RvX18gPSBJbnRlcmFjdGlvbjtcbiAgS2V5Ym9hcmRQYW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIEtleWJvYXJkUGFuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWJvYXJkUGFuO1xuXG4gIHJldHVybiBLZXlib2FyZFBhbjtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBpZiBpdCB3YXMgYVxuICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgdGhlIGRpcmVjdGlvbiB0byBwYW4gdG8gKGlmIGFuIGFycm93IGtleSB3YXNcbiAqIHByZXNzZWQpLlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFufVxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHN0b3BFdmVudCA9IGZhbHNlO1xuICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWURPV04pIHtcbiAgICB2YXIga2V5RXZlbnQgPSBtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICB2YXIga2V5Q29kZSA9IGtleUV2ZW50LmtleUNvZGU7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIChrZXlDb2RlID09IEtleUNvZGUuRE9XTiB8fFxuICAgICAgICBrZXlDb2RlID09IEtleUNvZGUuTEVGVCB8fFxuICAgICAgICBrZXlDb2RlID09IEtleUNvZGUuUklHSFQgfHxcbiAgICAgICAga2V5Q29kZSA9PSBLZXlDb2RlLlVQKSkge1xuICAgICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICB2YXIgbWFwVW5pdHNEZWx0YSA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpICogdGhpcy5waXhlbERlbHRhXztcbiAgICAgIHZhciBkZWx0YVggPSAwLCBkZWx0YVkgPSAwO1xuICAgICAgaWYgKGtleUNvZGUgPT0gS2V5Q29kZS5ET1dOKSB7XG4gICAgICAgIGRlbHRhWSA9IC1tYXBVbml0c0RlbHRhO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09IEtleUNvZGUuTEVGVCkge1xuICAgICAgICBkZWx0YVggPSAtbWFwVW5pdHNEZWx0YTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PSBLZXlDb2RlLlJJR0hUKSB7XG4gICAgICAgIGRlbHRhWCA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YVkgPSBtYXBVbml0c0RlbHRhO1xuICAgICAgfVxuICAgICAgdmFyIGRlbHRhID0gW2RlbHRhWCwgZGVsdGFZXTtcbiAgICAgIHJvdGF0ZUNvb3JkaW5hdGUoZGVsdGEsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICBwYW4odmlldywgZGVsdGEsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFzdG9wRXZlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleWJvYXJkUGFuO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZFBhbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3RhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTEwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn50YXJnZXROb3RFZGl0YWJsZX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGxldmVsIGRlbHRhIG9uIGVhY2gga2V5IHByZXNzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIHVzaW5nIGtleWJvYXJkICsgYW5kIC0uXG4gKiBOb3RlIHRoYXQsIGFsdGhvdWdoIHRoaXMgaW50ZXJhY3Rpb24gaXMgYnkgZGVmYXVsdCBpbmNsdWRlZCBpbiBtYXBzLFxuICogdGhlIGtleXMgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIGJyb3dzZXIgZm9jdXMgaXMgb24gdGhlIGVsZW1lbnQgdG8gd2hpY2hcbiAqIHRoZSBrZXlib2FyZCBldmVudHMgYXJlIGF0dGFjaGVkLiBCeSBkZWZhdWx0LCB0aGlzIGlzIHRoZSBtYXAgZGl2LFxuICogdGhvdWdoIHlvdSBjYW4gY2hhbmdlIHRoaXMgd2l0aCB0aGUgYGtleWJvYXJkRXZlbnRUYXJnZXRgIGluXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXB9LiBgZG9jdW1lbnRgIG5ldmVyIGxvc2VzIGZvY3VzIGJ1dCwgZm9yIGFueSBvdGhlclxuICogZWxlbWVudCwgZm9jdXMgd2lsbCBoYXZlIHRvIGJlIG9uLCBhbmQgcmV0dXJuZWQgdG8sIHRoaXMgZWxlbWVudCBpZiB0aGUga2V5c1xuICogYXJlIHRvIGZ1bmN0aW9uLlxuICogU2VlIGFsc28ge0BsaW5rIG1vdWRsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFBhbn5LZXlib2FyZFBhbn0uXG4gKiBAYXBpXG4gKi9cbnZhciBLZXlib2FyZFpvb20gPSAoZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEtleWJvYXJkWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgSW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiB0YXJnZXROb3RFZGl0YWJsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IG9wdGlvbnMuZGVsdGEgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBLZXlib2FyZFpvb20uX19wcm90b19fID0gSW50ZXJhY3Rpb247XG4gIEtleWJvYXJkWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgS2V5Ym9hcmRab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWJvYXJkWm9vbTtcblxuICByZXR1cm4gS2V5Ym9hcmRab29tO1xufShJbnRlcmFjdGlvbikpO1xuXG5cbi8qKlxuICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGlmIGl0IHdhcyBhXG4gKiBgS2V5RXZlbnRgLCBhbmQgZGVjaWRlcyB3aGV0aGVyIHRvIHpvb20gaW4gb3Igb3V0IChkZXBlbmRpbmcgb24gd2hldGhlciB0aGVcbiAqIGtleSBwcmVzc2VkIHdhcyAnKycgb3IgJy0nKS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgc3RvcEV2ZW50ID0gZmFsc2U7XG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZRE9XTiB8fFxuICAgICAgbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWVBSRVNTKSB7XG4gICAgdmFyIGtleUV2ZW50ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG4gICAgdmFyIGNoYXJDb2RlID0ga2V5RXZlbnQuY2hhckNvZGU7XG4gICAgaWYgKHRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpICYmXG4gICAgICAgIChjaGFyQ29kZSA9PSAnKycuY2hhckNvZGVBdCgwKSB8fCBjaGFyQ29kZSA9PSAnLScuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdmFyIGRlbHRhID0gKGNoYXJDb2RlID09ICcrJy5jaGFyQ29kZUF0KDApKSA/IHRoaXMuZGVsdGFfIDogLXRoaXMuZGVsdGFfO1xuICAgICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgem9vbUJ5RGVsdGEodmlldywgZGVsdGEsIHVuZGVmaW5lZCwgdGhpcy5kdXJhdGlvbl8pO1xuICAgICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9wRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIXN0b3BFdmVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgS2V5Ym9hcmRab29tO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlib2FyZFpvb20uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL01vZGlmeVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnLi4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyUG9pbnRlckV2ZW50IGZyb20gJy4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7ZXF1YWxzIGFzIGNvb3JkaW5hdGVzRXF1YWwsIGRpc3RhbmNlIGFzIGNvb3JkaW5hdGVEaXN0YW5jZSwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCwgY2xvc2VzdE9uU2VnbWVudH0gZnJvbSAnLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2Fsd2F5cywgcHJpbWFyeUFjdGlvbiwgYWx0S2V5T25seSwgc2luZ2xlQ2xpY2t9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgYnVmZmVyLCBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi4vZ2VvbS9Qb2ludC5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7aGFuZGxlRXZlbnQgYXMgaGFuZGxlUG9pbnRlckV2ZW50fSBmcm9tICcuLi9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IFZlY3RvclNvdXJjZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yLmpzJztcbmltcG9ydCBWZWN0b3JFdmVudFR5cGUgZnJvbSAnLi4vc291cmNlL1ZlY3RvckV2ZW50VHlwZS5qcyc7XG5pbXBvcnQgUkJ1c2ggZnJvbSAnLi4vc3RydWN0cy9SQnVzaC5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogVGhlIHNlZ21lbnQgaW5kZXggYXNzaWduZWQgdG8gYSBjaXJjbGUncyBjZW50ZXIgd2hlblxuICogYnJlYWtpbmcgdXAgYSBjaXJjbGUgaW50byBNb2RpZnlTZWdtZW50RGF0YVR5cGUgc2VnbWVudHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgQ0lSQ0xFX0NFTlRFUl9JTkRFWCA9IDA7XG5cbi8qKlxuICogVGhlIHNlZ21lbnQgaW5kZXggYXNzaWduZWQgdG8gYSBjaXJjbGUncyBjaXJjdW1mZXJlbmNlIHdoZW5cbiAqIGJyZWFraW5nIHVwIGEgY2lyY2xlIGludG8gTW9kaWZ5U2VnbWVudERhdGFUeXBlIHNlZ21lbnRzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYID0gMTtcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBNb2RpZnlFdmVudFR5cGUgPSB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIG1vZGlmaWNhdGlvbiBzdGFydFxuICAgKiBAZXZlbnQgTW9kaWZ5RXZlbnQjbW9kaWZ5c3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9ESUZZU1RBUlQ6ICdtb2RpZnlzdGFydCcsXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgdXBvbiBmZWF0dXJlIG1vZGlmaWNhdGlvbiBlbmRcbiAgICogQGV2ZW50IE1vZGlmeUV2ZW50I21vZGlmeWVuZFxuICAgKiBAYXBpXG4gICAqL1xuICBNT0RJRllFTkQ6ICdtb2RpZnllbmQnXG59O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VnbWVudERhdGFcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IFtkZXB0aF1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmVcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50Pn0gc2VnbWVudFxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YT59IFtmZWF0dXJlU2VnbWVudHNdXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgd2lsbCBiZSBjb25zaWRlcmVkIHRvIGFkZCBvciBtb3ZlIGFcbiAqIHZlcnRleCB0byB0aGUgc2tldGNoLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+cHJpbWFyeUFjdGlvbn0uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn0gW2RlbGV0ZUNvbmRpdGlvbl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBCeSBkZWZhdWx0LFxuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNpbmdsZUNsaWNrfSB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+YWx0S2V5T25seX0gcmVzdWx0cyBpbiBhIHZlcnRleCBkZWxldGlvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbaW5zZXJ0VmVydGV4Q29uZGl0aW9uXSBBXG4gKiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kXG4gKiByZXR1cm5zIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgbmV3IHZlcnRleCBjYW4gYmUgYWRkZWQgdG8gdGhlIHNrZXRjaFxuICogZmVhdHVyZXMuIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsd2F5c30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsVG9sZXJhbmNlPTEwXSBQaXhlbCB0b2xlcmFuY2UgZm9yIGNvbnNpZGVyaW5nIHRoZVxuICogcG9pbnRlciBjbG9zZSBlbm91Z2ggdG8gYSBzZWdtZW50IG9yIHZlcnRleCBmb3IgZWRpdGluZy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+fG1vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufSBbc3R5bGVdXG4gKiBTdHlsZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMgYmVpbmcgbW9kaWZpZWQuIEJ5IGRlZmF1bHQgdGhlIGRlZmF1bHQgZWRpdFxuICogc3R5bGUgaXMgdXNlZCAoc2VlIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9KS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IFtzb3VyY2VdIFRoZSB2ZWN0b3Igc291cmNlIHdpdGhcbiAqIGZlYXR1cmVzIHRvIG1vZGlmeS4gIElmIGEgdmVjdG9yIHNvdXJjZSBpcyBub3QgcHJvdmlkZWQsIGEgZmVhdHVyZSBjb2xsZWN0aW9uXG4gKiBtdXN0IGJlIHByb3ZpZGVkIHdpdGggdGhlIGZlYXR1cmVzIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn0gW2ZlYXR1cmVzXVxuICogVGhlIGZlYXR1cmVzIHRoZSBpbnRlcmFjdGlvbiB3b3JrcyBvbi4gIElmIGEgZmVhdHVyZSBjb2xsZWN0aW9uIGlzIG5vdFxuICogcHJvdmlkZWQsIGEgdmVjdG9yIHNvdXJjZSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggdGhlIHNvdXJjZSBvcHRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD1mYWxzZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5IG9uIHRoZSBza2V0Y2hcbiAqIG92ZXJsYXkuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5fk1vZGlmeX0gaW5zdGFuY2VzIGFyZVxuICogaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IHZhciBNb2RpZnlFdmVudCA9IChmdW5jdGlvbiAoRXZlbnQpIHtcbiAgZnVuY3Rpb24gTW9kaWZ5RXZlbnQodHlwZSwgZmVhdHVyZXMsIG1hcEJyb3dzZXJQb2ludGVyRXZlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmVzIGJlaW5nIG1vZGlmaWVkLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fS5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyUG9pbnRlckV2ZW50O1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgTW9kaWZ5RXZlbnQuX19wcm90b19fID0gRXZlbnQ7XG4gIE1vZGlmeUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBNb2RpZnlFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb2RpZnlFdmVudDtcblxuICByZXR1cm4gTW9kaWZ5RXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbnRlcmFjdGlvbiBmb3IgbW9kaWZ5aW5nIGZlYXR1cmUgZ2VvbWV0cmllcy4gIFRvIG1vZGlmeSBmZWF0dXJlcyB0aGF0IGhhdmVcbiAqIGJlZW4gYWRkZWQgdG8gYW4gZXhpc3Rpbmcgc291cmNlLCBjb25zdHJ1Y3QgdGhlIG1vZGlmeSBpbnRlcmFjdGlvbiB3aXRoIHRoZVxuICogYHNvdXJjZWAgb3B0aW9uLiAgSWYgeW91IHdhbnQgdG8gbW9kaWZ5IGZlYXR1cmVzIGluIGEgY29sbGVjdGlvbiAoZm9yIGV4YW1wbGUsXG4gKiB0aGUgY29sbGVjdGlvbiB1c2VkIGJ5IGEgc2VsZWN0IGludGVyYWN0aW9uKSwgY29uc3RydWN0IHRoZSBpbnRlcmFjdGlvbiB3aXRoXG4gKiB0aGUgYGZlYXR1cmVzYCBvcHRpb24uICBUaGUgaW50ZXJhY3Rpb24gbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGVpdGhlciBhXG4gKiBgc291cmNlYCBvciBgZmVhdHVyZXNgIG9wdGlvbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgaW50ZXJhY3Rpb24gd2lsbCBhbGxvdyBkZWxldGlvbiBvZiB2ZXJ0aWNlcyB3aGVuIHRoZSBgYWx0YFxuICoga2V5IGlzIHByZXNzZWQuICBUbyBjb25maWd1cmUgdGhlIGludGVyYWN0aW9uIHdpdGggYSBkaWZmZXJlbnQgY29uZGl0aW9uXG4gKiBmb3IgZGVsZXRpb24sIHVzZSB0aGUgYGRlbGV0ZUNvbmRpdGlvbmAgb3B0aW9uLlxuICogQGZpcmVzIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+TW9kaWZ5RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIE1vZGlmeSA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIE1vZGlmeShvcHRpb25zKSB7XG5cbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVEb3duRXZlbnQ6IGhhbmRsZURvd25FdmVudCxcbiAgICAgIGhhbmRsZURyYWdFdmVudDogaGFuZGxlRHJhZ0V2ZW50LFxuICAgICAgaGFuZGxlRXZlbnQ6IGhhbmRsZUV2ZW50LFxuICAgICAgaGFuZGxlVXBFdmVudDogaGFuZGxlVXBFdmVudFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBwcmltYXJ5QWN0aW9uO1xuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHREZWxldGVDb25kaXRpb25fID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gYWx0S2V5T25seShtYXBCcm93c2VyRXZlbnQpICYmIHNpbmdsZUNsaWNrKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUNvbmRpdGlvbl8gPSBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvbiA/XG4gICAgICBvcHRpb25zLmRlbGV0ZUNvbmRpdGlvbiA6IHRoaXMuZGVmYXVsdERlbGV0ZUNvbmRpdGlvbl87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnNlcnRWZXJ0ZXhDb25kaXRpb25fID0gb3B0aW9ucy5pbnNlcnRWZXJ0ZXhDb25kaXRpb24gP1xuICAgICAgb3B0aW9ucy5pbnNlcnRWZXJ0ZXhDb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAgKiBFZGl0aW5nIHZlcnRleC5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnRzIGludGVyc2VjdGluZyB7QGxpbmsgdGhpcy52ZXJ0ZXhGZWF0dXJlX30gYnkgc2VnbWVudCB1aWQuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4U2VnbWVudHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQaXhlbF8gPSBbMCwgMF07XG5cbiAgICAvKipcbiAgICAgKiBUcmFja3MgaWYgdGhlIG5leHQgYHNpbmdsZWNsaWNrYCBldmVudCBzaG91bGQgYmUgaWdub3JlZCB0byBwcmV2ZW50XG4gICAgICogYWNjaWRlbnRhbCBkZWxldGlvbiByaWdodCBhZnRlciB2ZXJ0ZXggY3JlYXRpb24uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tb2RpZmllZF8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZ21lbnQgUlRyZWUgZm9yIGVhY2ggbGF5ZXJcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvUkJ1c2guPG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+U2VnbWVudERhdGE+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5yQnVzaF8gPSBuZXcgUkJ1c2goKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsVG9sZXJhbmNlXyA9IG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnBpeGVsVG9sZXJhbmNlIDogMTA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc25hcHBlZFRvVmVydGV4XyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgd2hldGhlciB0aGUgaW50ZXJhY3Rpb24gaXMgY3VycmVudGx5IGNoYW5naW5nIGEgZmVhdHVyZSdzXG4gICAgICogY29vcmRpbmF0ZXMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNoYW5naW5nRmVhdHVyZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRHJhdyBvdmVybGF5IHdoZXJlIHNrZXRjaCBmZWF0dXJlcyBhcmUgZHJhd24uXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9sYXllci9WZWN0b3J9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlfID0gbmV3IFZlY3RvckxheWVyKHtcbiAgICAgIHNvdXJjZTogbmV3IFZlY3RvclNvdXJjZSh7XG4gICAgICAgIHVzZVNwYXRpYWxJbmRleDogZmFsc2UsXG4gICAgICAgIHdyYXBYOiAhIW9wdGlvbnMud3JhcFhcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUgPyBvcHRpb25zLnN0eWxlIDpcbiAgICAgICAgZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbihtb2R1bGU6b2wvRmVhdHVyZSwgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnkpPn1cbiAgICAgKi9cbiAgICB0aGlzLlNFR01FTlRfV1JJVEVSU18gPSB7XG4gICAgICAnUG9pbnQnOiB0aGlzLndyaXRlUG9pbnRHZW9tZXRyeV8sXG4gICAgICAnTGluZVN0cmluZyc6IHRoaXMud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ0xpbmVhclJpbmcnOiB0aGlzLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdQb2x5Z29uJzogdGhpcy53cml0ZVBvbHlnb25HZW9tZXRyeV8sXG4gICAgICAnTXVsdGlQb2ludCc6IHRoaXMud3JpdGVNdWx0aVBvaW50R2VvbWV0cnlfLFxuICAgICAgJ011bHRpTGluZVN0cmluZyc6IHRoaXMud3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnTXVsdGlQb2x5Z29uJzogdGhpcy53cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5XyxcbiAgICAgICdDaXJjbGUnOiB0aGlzLndyaXRlQ2lyY2xlR2VvbWV0cnlfLFxuICAgICAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHRoaXMud3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV9cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZV8gPSBudWxsO1xuXG4gICAgdmFyIGZlYXR1cmVzO1xuICAgIGlmIChvcHRpb25zLnNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2U7XG4gICAgICBmZWF0dXJlcyA9IG5ldyBDb2xsZWN0aW9uKHRoaXMuc291cmNlXy5nZXRGZWF0dXJlcygpKTtcbiAgICAgIGxpc3Rlbih0aGlzLnNvdXJjZV8sIFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLFxuICAgICAgICB0aGlzLmhhbmRsZVNvdXJjZUFkZF8sIHRoaXMpO1xuICAgICAgbGlzdGVuKHRoaXMuc291cmNlXywgVmVjdG9yRXZlbnRUeXBlLlJFTU9WRUZFQVRVUkUsXG4gICAgICAgIHRoaXMuaGFuZGxlU291cmNlUmVtb3ZlXywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcbiAgICB9XG4gICAgaWYgKCFmZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbW9kaWZ5IGludGVyYWN0aW9uIHJlcXVpcmVzIGZlYXR1cmVzIG9yIGEgc291cmNlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzXyA9IGZlYXR1cmVzO1xuXG4gICAgdGhpcy5mZWF0dXJlc18uZm9yRWFjaCh0aGlzLmFkZEZlYXR1cmVfLmJpbmQodGhpcykpO1xuICAgIGxpc3Rlbih0aGlzLmZlYXR1cmVzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVBZGRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcy5mZWF0dXJlc18sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXywgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RQb2ludGVyRXZlbnRfID0gbnVsbDtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBNb2RpZnkuX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBNb2RpZnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgTW9kaWZ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZGlmeTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5hZGRGZWF0dXJlXyA9IGZ1bmN0aW9uIGFkZEZlYXR1cmVfIChmZWF0dXJlKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5nZXRUeXBlKCkgaW4gdGhpcy5TRUdNRU5UX1dSSVRFUlNfKSB7XG4gICAgICB0aGlzLlNFR01FTlRfV1JJVEVSU19bZ2VvbWV0cnkuZ2V0VHlwZSgpXS5jYWxsKHRoaXMsIGZlYXR1cmUsIGdlb21ldHJ5KTtcbiAgICB9XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCAmJiBtYXAuaXNSZW5kZXJlZCgpICYmIHRoaXMuZ2V0QWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKHRoaXMubGFzdFBpeGVsXywgbWFwKTtcbiAgICB9XG4gICAgbGlzdGVuKGZlYXR1cmUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gZXZ0IE1hcCBicm93c2VyIGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndpbGxNb2RpZnlGZWF0dXJlc18gPSBmdW5jdGlvbiB3aWxsTW9kaWZ5RmVhdHVyZXNfIChldnQpIHtcbiAgICBpZiAoIXRoaXMubW9kaWZpZWRfKSB7XG4gICAgICB0aGlzLm1vZGlmaWVkXyA9IHRydWU7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1vZGlmeUV2ZW50KFxuICAgICAgICBNb2RpZnlFdmVudFR5cGUuTU9ESUZZU1RBUlQsIHRoaXMuZmVhdHVyZXNfLCBldnQpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZV8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlXyAoZmVhdHVyZSkge1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZVNlZ21lbnREYXRhXyhmZWF0dXJlKTtcbiAgICAvLyBSZW1vdmUgdGhlIHZlcnRleCBmZWF0dXJlIGlmIHRoZSBjb2xsZWN0aW9uIG9mIGNhbmRpdGF0ZSBmZWF0dXJlc1xuICAgIC8vIGlzIGVtcHR5LlxuICAgIGlmICh0aGlzLnZlcnRleEZlYXR1cmVfICYmIHRoaXMuZmVhdHVyZXNfLmdldExlbmd0aCgpID09PSAwKSB7XG4gICAgICB0aGlzLm92ZXJsYXlfLmdldFNvdXJjZSgpLnJlbW92ZUZlYXR1cmUodGhpcy52ZXJ0ZXhGZWF0dXJlXyk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gbnVsbDtcbiAgICB9XG4gICAgdW5saXN0ZW4oZmVhdHVyZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLnJlbW92ZUZlYXR1cmVTZWdtZW50RGF0YV8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlU2VnbWVudERhdGFfIChmZWF0dXJlKSB7XG4gICAgdmFyIHJCdXNoID0gdGhpcy5yQnVzaF87XG4gICAgdmFyIC8qKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+U2VnbWVudERhdGE+fSAqLyBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgckJ1c2guZm9yRWFjaChcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSBub2RlIFJUcmVlIG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09IG5vZGUuZmVhdHVyZSkge1xuICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHJCdXNoLnJlbW92ZShub2Rlc1RvUmVtb3ZlW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIHNldEFjdGl2ZSAoYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMudmVydGV4RmVhdHVyZV8gJiYgIWFjdGl2ZSkge1xuICAgICAgdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKS5yZW1vdmVGZWF0dXJlKHRoaXMudmVydGV4RmVhdHVyZV8pO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgfVxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0QWN0aXZlLmNhbGwodGhpcywgYWN0aXZlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB0aGlzLm92ZXJsYXlfLnNldE1hcChtYXApO1xuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuc2V0TWFwLmNhbGwodGhpcywgbWFwKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVNvdXJjZUFkZF8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VBZGRfIChldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5wdXNoKGV2ZW50LmZlYXR1cmUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2VFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLmhhbmRsZVNvdXJjZVJlbW92ZV8gPSBmdW5jdGlvbiBoYW5kbGVTb3VyY2VSZW1vdmVfIChldmVudCkge1xuICAgIGlmIChldmVudC5mZWF0dXJlKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzXy5yZW1vdmUoZXZlbnQuZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlQWRkXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVBZGRfIChldnQpIHtcbiAgICB0aGlzLmFkZEZlYXR1cmVfKC8qKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9ICovIChldnQuZWxlbWVudCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVGZWF0dXJlQ2hhbmdlXyAoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmNoYW5naW5nRmVhdHVyZV8pIHtcbiAgICAgIHZhciBmZWF0dXJlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGV2dC50YXJnZXQpO1xuICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlXyhmZWF0dXJlKTtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZV8oZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb25FdmVudH0gZXZ0IEV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlUmVtb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVSZW1vdmVfIChldnQpIHtcbiAgICB2YXIgZmVhdHVyZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9ICovIChldnQuZWxlbWVudCk7XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlXyhmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vUG9pbnR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZVBvaW50R2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXVxuICAgIH0pO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVNdWx0aVBvaW50R2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVNdWx0aVBvaW50R2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvaW50cyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBkZXB0aDogW2ldLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICAgIH0pO1xuICAgICAgdGhpcyQxLnJCdXNoXy5pbnNlcnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIHNlZ21lbnREYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgfSk7XG4gICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsaW5lcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gbGluZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZXNbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgIGZlYXR1cmU6IGZlYXR1cmUsXG4gICAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICAgIGRlcHRoOiBbal0sXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcyQxLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQoc2VnbWVudCksIHNlZ21lbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1BvbHlnb259IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZVBvbHlnb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZVBvbHlnb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICBkZXB0aDogW2pdLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMkMS5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb259IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS53cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb25zID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBrID0gMCwga2sgPSBwb2x5Z29ucy5sZW5ndGg7IGsgPCBrazsgKytrKSB7XG4gICAgICB2YXIgcmluZ3MgPSBwb2x5Z29uc1trXTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcmluZ3Nbal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgIGRlcHRoOiBbaiwga10sXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXZSBjb252ZXJ0IGEgY2lyY2xlIGludG8gdHdvIHNlZ21lbnRzLiAgVGhlIHNlZ21lbnQgYXQgaW5kZXhcbiAgICoge0BsaW5rIENJUkNMRV9DRU5URVJfSU5ERVh9IGlzIHRoZVxuICAgKiBjaXJjbGUncyBjZW50ZXIgKGEgcG9pbnQpLiAgVGhlIHNlZ21lbnQgYXQgaW5kZXhcbiAgICoge0BsaW5rIENJUkNMRV9DSVJDVU1GRVJFTkNFX0lOREVYfSBpc1xuICAgKiB0aGUgY2lyY3VtZmVyZW5jZSwgYW5kIGlzIG5vdCBhIGxpbmUgc2VnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0NpcmNsZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb2RpZnkucHJvdG90eXBlLndyaXRlQ2lyY2xlR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVDaXJjbGVHZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q2VudGVyKCk7XG4gICAgdmFyIGNlbnRlclNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGluZGV4OiBDSVJDTEVfQ0VOVEVSX0lOREVYLFxuICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICB9KTtcbiAgICB2YXIgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGluZGV4OiBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCxcbiAgICAgIHNlZ21lbnQ6IFtjb29yZGluYXRlcywgY29vcmRpbmF0ZXNdXG4gICAgfSk7XG4gICAgdmFyIGZlYXR1cmVTZWdtZW50cyA9IFtjZW50ZXJTZWdtZW50RGF0YSwgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhXTtcbiAgICBjZW50ZXJTZWdtZW50RGF0YS5mZWF0dXJlU2VnbWVudHMgPSBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEuZmVhdHVyZVNlZ21lbnRzID0gZmVhdHVyZVNlZ21lbnRzO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKGNvb3JkaW5hdGVzKSwgY2VudGVyU2VnbWVudERhdGEpO1xuICAgIHRoaXMuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUud3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzJDEuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyaWVzW2ldLmdldFR5cGUoKV0uY2FsbCh0aGlzJDEsIGZlYXR1cmUsIGdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL0ZlYXR1cmV9IFZlcnRleCBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5jcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfID0gZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVWZXJ0ZXhGZWF0dXJlXyAoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgdmVydGV4RmVhdHVyZSA9IHRoaXMudmVydGV4RmVhdHVyZV87XG4gICAgaWYgKCF2ZXJ0ZXhGZWF0dXJlKSB7XG4gICAgICB2ZXJ0ZXhGZWF0dXJlID0gbmV3IEZlYXR1cmUobmV3IFBvaW50KGNvb3JkaW5hdGVzKSk7XG4gICAgICB0aGlzLnZlcnRleEZlYXR1cmVfID0gdmVydGV4RmVhdHVyZTtcbiAgICAgIHRoaXMub3ZlcmxheV8uZ2V0U291cmNlKCkuYWRkRmVhdHVyZSh2ZXJ0ZXhGZWF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9Qb2ludH0gKi8gKHZlcnRleEZlYXR1cmUuZ2V0R2VvbWV0cnkoKSk7XG4gICAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXhGZWF0dXJlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlUG9pbnRlck1vdmVfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmVfIChldnQpIHtcbiAgICB0aGlzLmxhc3RQaXhlbF8gPSBldnQucGl4ZWw7XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyQXRQaXhlbF8oZXZ0LnBpeGVsLCBldnQubWFwKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9IHBpeGVsIFBpeGVsXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gbWFwIE1hcC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuaGFuZGxlUG9pbnRlckF0UGl4ZWxfID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlckF0UGl4ZWxfIChwaXhlbCwgbWFwKSB7XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZSA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICB2YXIgc29ydEJ5RGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gcG9pbnREaXN0YW5jZVRvU2VnbWVudERhdGFTcXVhcmVkKHBpeGVsQ29vcmRpbmF0ZSwgYSkgLVxuICAgICAgICAgIHBvaW50RGlzdGFuY2VUb1NlZ21lbnREYXRhU3F1YXJlZChwaXhlbENvb3JkaW5hdGUsIGIpO1xuICAgIH07XG5cbiAgICB2YXIgYm94ID0gYnVmZmVyKGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUocGl4ZWxDb29yZGluYXRlKSxcbiAgICAgIG1hcC5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpICogdGhpcy5waXhlbFRvbGVyYW5jZV8pO1xuXG4gICAgdmFyIHJCdXNoID0gdGhpcy5yQnVzaF87XG4gICAgdmFyIG5vZGVzID0gckJ1c2guZ2V0SW5FeHRlbnQoYm94KTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZXMuc29ydChzb3J0QnlEaXN0YW5jZSk7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50ID0gbm9kZS5zZWdtZW50O1xuICAgICAgdmFyIHZlcnRleCA9IGNsb3Nlc3RPblNlZ21lbnREYXRhKHBpeGVsQ29vcmRpbmF0ZSwgbm9kZSk7XG4gICAgICB2YXIgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuICAgICAgdmFyIGRpc3QgPSBjb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHZlcnRleFBpeGVsKTtcbiAgICAgIGlmIChkaXN0IDw9IHRoaXMucGl4ZWxUb2xlcmFuY2VfKSB7XG4gICAgICAgIHZhciB2ZXJ0ZXhTZWdtZW50cyA9IHt9O1xuXG4gICAgICAgIGlmIChub2RlLmdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSAmJlxuICAgICAgICBub2RlLmluZGV4ID09PSBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCkge1xuXG4gICAgICAgICAgdGhpcy5zbmFwcGVkVG9WZXJ0ZXhfID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlVmVydGV4RmVhdHVyZV8odmVydGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcGl4ZWwxID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICAgIHZhciBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgICAgdmFyIHNxdWFyZWREaXN0MSA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMSk7XG4gICAgICAgICAgdmFyIHNxdWFyZWREaXN0MiA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UodmVydGV4UGl4ZWwsIHBpeGVsMik7XG4gICAgICAgICAgZGlzdCA9IE1hdGguc3FydChNYXRoLm1pbihzcXVhcmVkRGlzdDEsIHNxdWFyZWREaXN0MikpO1xuICAgICAgICAgIHRoaXMuc25hcHBlZFRvVmVydGV4XyA9IGRpc3QgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV87XG4gICAgICAgICAgaWYgKHRoaXMuc25hcHBlZFRvVmVydGV4Xykge1xuICAgICAgICAgICAgdmVydGV4ID0gc3F1YXJlZERpc3QxID4gc3F1YXJlZERpc3QyID8gY2xvc2VzdFNlZ21lbnRbMV0gOiBjbG9zZXN0U2VnbWVudFswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfKHZlcnRleCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGlpID0gbm9kZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBub2Rlc1tpXS5zZWdtZW50O1xuICAgICAgICAgICAgaWYgKChjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RTZWdtZW50WzBdLCBzZWdtZW50WzBdKSAmJlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMV0sIHNlZ21lbnRbMV0pIHx8XG4gICAgICAgICAgICAgICAgKGNvb3JkaW5hdGVzRXF1YWwoY2xvc2VzdFNlZ21lbnRbMF0sIHNlZ21lbnRbMV0pICYmXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXNFcXVhbChjbG9zZXN0U2VnbWVudFsxXSwgc2VnbWVudFswXSkpKSkge1xuICAgICAgICAgICAgICB2ZXJ0ZXhTZWdtZW50c1tnZXRVaWQoc2VnbWVudCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZlcnRleFNlZ21lbnRzW2dldFVpZChjbG9zZXN0U2VnbWVudCldID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhTZWdtZW50c18gPSB2ZXJ0ZXhTZWdtZW50cztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXykge1xuICAgICAgdGhpcy5vdmVybGF5Xy5nZXRTb3VyY2UoKS5yZW1vdmVGZWF0dXJlKHRoaXMudmVydGV4RmVhdHVyZV8pO1xuICAgICAgdGhpcy52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+U2VnbWVudERhdGF9IHNlZ21lbnREYXRhIFNlZ21lbnQgZGF0YS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB2ZXJ0ZXggVmVydGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5pbnNlcnRWZXJ0ZXhfID0gZnVuY3Rpb24gaW5zZXJ0VmVydGV4XyAoc2VnbWVudERhdGEsIHZlcnRleCkge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudERhdGEuc2VnbWVudDtcbiAgICB2YXIgZmVhdHVyZSA9IHNlZ21lbnREYXRhLmZlYXR1cmU7XG4gICAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgdmFyIGRlcHRoID0gc2VnbWVudERhdGEuZGVwdGg7XG4gICAgdmFyIGluZGV4ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChzZWdtZW50RGF0YS5pbmRleCk7XG4gICAgdmFyIGNvb3JkaW5hdGVzO1xuXG4gICAgd2hpbGUgKHZlcnRleC5sZW5ndGggPCBnZW9tZXRyeS5nZXRTdHJpZGUoKSkge1xuICAgICAgdmVydGV4LnB1c2goMCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzBdXS5zcGxpY2UoaW5kZXggKyAxLCAwLCB2ZXJ0ZXgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tkZXB0aFsxXV1bZGVwdGhbMF1dLnNwbGljZShpbmRleCArIDEsIDAsIHZlcnRleCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgdmVydGV4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyhnZW9tZXRyeSwgY29vcmRpbmF0ZXMpO1xuICAgIHZhciByVHJlZSA9IHRoaXMuckJ1c2hfO1xuICAgIHJUcmVlLnJlbW92ZShzZWdtZW50RGF0YSk7XG4gICAgdGhpcy51cGRhdGVTZWdtZW50SW5kaWNlc18oZ2VvbWV0cnksIGluZGV4LCBkZXB0aCwgMSk7XG4gICAgdmFyIG5ld1NlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgc2VnbWVudDogW3NlZ21lbnRbMF0sIHZlcnRleF0sXG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gICAgclRyZWUuaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KG5ld1NlZ21lbnREYXRhLnNlZ21lbnQpLFxuICAgICAgbmV3U2VnbWVudERhdGEpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YSwgMV0pO1xuXG4gICAgdmFyIG5ld1NlZ21lbnREYXRhMiA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgIHNlZ21lbnQ6IFt2ZXJ0ZXgsIHNlZ21lbnRbMV1dLFxuICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgIGluZGV4OiBpbmRleCArIDFcbiAgICB9KTtcbiAgICByVHJlZS5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEyLnNlZ21lbnQpLCBuZXdTZWdtZW50RGF0YTIpO1xuICAgIHRoaXMuZHJhZ1NlZ21lbnRzXy5wdXNoKFtuZXdTZWdtZW50RGF0YTIsIDBdKTtcbiAgICB0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18gPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB2ZXJ0ZXggY3VycmVudGx5IGJlaW5nIHBvaW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgd2hlbiBhIHZlcnRleCB3YXMgcmVtb3ZlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVQb2ludCA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5sYXN0UG9pbnRlckV2ZW50XyAmJiB0aGlzLmxhc3RQb2ludGVyRXZlbnRfLnR5cGUgIT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgdmFyIGV2dCA9IHRoaXMubGFzdFBvaW50ZXJFdmVudF87XG4gICAgICB0aGlzLndpbGxNb2RpZnlGZWF0dXJlc18oZXZ0KTtcbiAgICAgIHRoaXMucmVtb3ZlVmVydGV4XygpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNb2RpZnlFdmVudChNb2RpZnlFdmVudFR5cGUuTU9ESUZZRU5ELCB0aGlzLmZlYXR1cmVzXywgZXZ0KSk7XG4gICAgICB0aGlzLm1vZGlmaWVkXyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHZlcnRleCBmcm9tIGFsbCBtYXRjaGluZyBmZWF0dXJlcy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIGEgdmVydGV4IHdhcyByZW1vdmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTW9kaWZ5LnByb3RvdHlwZS5yZW1vdmVWZXJ0ZXhfID0gZnVuY3Rpb24gcmVtb3ZlVmVydGV4XyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZHJhZ1NlZ21lbnRzID0gdGhpcy5kcmFnU2VnbWVudHNfO1xuICAgIHZhciBzZWdtZW50c0J5RmVhdHVyZSA9IHt9O1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgdmFyIGNvbXBvbmVudCwgY29vcmRpbmF0ZXMsIGRyYWdTZWdtZW50LCBnZW9tZXRyeSwgaSwgaW5kZXgsIGxlZnQ7XG4gICAgdmFyIG5ld0luZGV4LCByaWdodCwgc2VnbWVudERhdGEsIHVpZDtcbiAgICBmb3IgKGkgPSBkcmFnU2VnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGRyYWdTZWdtZW50ID0gZHJhZ1NlZ21lbnRzW2ldO1xuICAgICAgc2VnbWVudERhdGEgPSBkcmFnU2VnbWVudFswXTtcbiAgICAgIHVpZCA9IGdldFVpZChzZWdtZW50RGF0YS5mZWF0dXJlKTtcbiAgICAgIGlmIChzZWdtZW50RGF0YS5kZXB0aCkge1xuICAgICAgICAvLyBzZXBhcmF0ZSBmZWF0dXJlIGNvbXBvbmVudHNcbiAgICAgICAgdWlkICs9ICctJyArIHNlZ21lbnREYXRhLmRlcHRoLmpvaW4oJy0nKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHVpZCBpbiBzZWdtZW50c0J5RmVhdHVyZSkpIHtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdTZWdtZW50WzFdID09PSAwKSB7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ucmlnaHQgPSBzZWdtZW50RGF0YTtcbiAgICAgICAgc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5pbmRleCA9IHNlZ21lbnREYXRhLmluZGV4O1xuICAgICAgfSBlbHNlIGlmIChkcmFnU2VnbWVudFsxXSA9PSAxKSB7XG4gICAgICAgIHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ubGVmdCA9IHNlZ21lbnREYXRhO1xuICAgICAgICBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmluZGV4ID0gc2VnbWVudERhdGEuaW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgfVxuICAgIGZvciAodWlkIGluIHNlZ21lbnRzQnlGZWF0dXJlKSB7XG4gICAgICByaWdodCA9IHNlZ21lbnRzQnlGZWF0dXJlW3VpZF0ucmlnaHQ7XG4gICAgICBsZWZ0ID0gc2VnbWVudHNCeUZlYXR1cmVbdWlkXS5sZWZ0O1xuICAgICAgaW5kZXggPSBzZWdtZW50c0J5RmVhdHVyZVt1aWRdLmluZGV4O1xuICAgICAgbmV3SW5kZXggPSBpbmRleCAtIDE7XG4gICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlZ21lbnREYXRhID0gbGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnREYXRhID0gcmlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgIG5ld0luZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG4gICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBjb21wb25lbnQgPSBjb29yZGluYXRlcztcbiAgICAgIGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAoZ2VvbWV0cnkuZ2V0VHlwZSgpKSB7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICAgIGlmIChjb29yZGluYXRlc1tzZWdtZW50RGF0YS5kZXB0aFswXV0ubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuZGVwdGhbMF1dLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOlxuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudFtzZWdtZW50RGF0YS5kZXB0aFsxXV07XG4gICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOlxuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudFtzZWdtZW50RGF0YS5kZXB0aFswXV07XG4gICAgICAgICAgaWYgKGNvbXBvbmVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gY29tcG9uZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgcmluZyBhZ2FpblxuICAgICAgICAgICAgICBjb21wb25lbnQucG9wKCk7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5wdXNoKGNvbXBvbmVudFswXSk7XG4gICAgICAgICAgICAgIG5ld0luZGV4ID0gY29tcG9uZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHBhc3NcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgdGhpcyQxLnNldEdlb21ldHJ5Q29vcmRpbmF0ZXNfKGdlb21ldHJ5LCBjb29yZGluYXRlcyk7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcyQxLnJCdXNoXy5yZW1vdmUobGVmdCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChsZWZ0LnNlZ21lbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcyQxLnJCdXNoXy5yZW1vdmUocmlnaHQpO1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2gocmlnaHQuc2VnbWVudFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgIT09IHVuZGVmaW5lZCAmJiByaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5ld1NlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZGVwdGg6IHNlZ21lbnREYXRhLmRlcHRoLFxuICAgICAgICAgICAgZmVhdHVyZTogc2VnbWVudERhdGEuZmVhdHVyZSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzZWdtZW50RGF0YS5nZW9tZXRyeSxcbiAgICAgICAgICAgIGluZGV4OiBuZXdJbmRleCxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcyQxLnJCdXNoXy5pbnNlcnQoYm91bmRpbmdFeHRlbnQobmV3U2VnbWVudERhdGEuc2VnbWVudCksXG4gICAgICAgICAgICBuZXdTZWdtZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcyQxLnVwZGF0ZVNlZ21lbnRJbmRpY2VzXyhnZW9tZXRyeSwgaW5kZXgsIHNlZ21lbnREYXRhLmRlcHRoLCAtMSk7XG4gICAgICAgIGlmICh0aGlzJDEudmVydGV4RmVhdHVyZV8pIHtcbiAgICAgICAgICB0aGlzJDEub3ZlcmxheV8uZ2V0U291cmNlKCkucmVtb3ZlRmVhdHVyZSh0aGlzJDEudmVydGV4RmVhdHVyZV8pO1xuICAgICAgICAgIHRoaXMkMS52ZXJ0ZXhGZWF0dXJlXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZHJhZ1NlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUuc2V0R2VvbWV0cnlDb29yZGluYXRlc18gPSBmdW5jdGlvbiBzZXRHZW9tZXRyeUNvb3JkaW5hdGVzXyAoZ2VvbWV0cnksIGNvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gdHJ1ZTtcbiAgICBnZW9tZXRyeS5zZXRDb29yZGluYXRlcyhjb29yZGluYXRlcyk7XG4gICAgdGhpcy5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfSBkZXB0aCBEZXB0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhICgxIG9yIC0xKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1vZGlmeS5wcm90b3R5cGUudXBkYXRlU2VnbWVudEluZGljZXNfID0gZnVuY3Rpb24gdXBkYXRlU2VnbWVudEluZGljZXNfIChnZW9tZXRyeSwgaW5kZXgsIGRlcHRoLCBkZWx0YSkge1xuICAgIHRoaXMuckJ1c2hfLmZvckVhY2hJbkV4dGVudChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgZnVuY3Rpb24oc2VnbWVudERhdGFNYXRjaCkge1xuICAgICAgaWYgKHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkgPT09IGdlb21ldHJ5ICYmXG4gICAgICAgICAgKGRlcHRoID09PSB1bmRlZmluZWQgfHwgc2VnbWVudERhdGFNYXRjaC5kZXB0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgZXF1YWxzKHNlZ21lbnREYXRhTWF0Y2guZGVwdGgsIGRlcHRoKSkgJiZcbiAgICAgICAgICBzZWdtZW50RGF0YU1hdGNoLmluZGV4ID4gaW5kZXgpIHtcbiAgICAgICAgc2VnbWVudERhdGFNYXRjaC5pbmRleCArPSBkZWx0YTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTW9kaWZ5O1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gYSBUaGUgZmlyc3Qgc2VnbWVudCBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vTW9kaWZ5flNlZ21lbnREYXRhfSBiIFRoZSBzZWNvbmQgc2VnbWVudCBkYXRhLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlmZmVyZW5jZSBpbiBpbmRleGVzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhLCBiKSB7XG4gIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IGV2dCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0YXJ0IGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50KGV2dCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoIXRoaXMuY29uZGl0aW9uXyhldnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRoaXMuaGFuZGxlUG9pbnRlckF0UGl4ZWxfKGV2dC5waXhlbCwgZXZ0Lm1hcCk7XG4gIHZhciBwaXhlbENvb3JkaW5hdGUgPSBldnQubWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoZXZ0LnBpeGVsKTtcbiAgdGhpcy5kcmFnU2VnbWVudHNfLmxlbmd0aCA9IDA7XG4gIHRoaXMubW9kaWZpZWRfID0gZmFsc2U7XG4gIHZhciB2ZXJ0ZXhGZWF0dXJlID0gdGhpcy52ZXJ0ZXhGZWF0dXJlXztcbiAgaWYgKHZlcnRleEZlYXR1cmUpIHtcbiAgICB2YXIgaW5zZXJ0VmVydGljZXMgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cnkgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvaW50fSAqLyAodmVydGV4RmVhdHVyZS5nZXRHZW9tZXRyeSgpKTtcbiAgICB2YXIgdmVydGV4ID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgdmVydGV4RXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW3ZlcnRleF0pO1xuICAgIHZhciBzZWdtZW50RGF0YU1hdGNoZXMgPSB0aGlzLnJCdXNoXy5nZXRJbkV4dGVudCh2ZXJ0ZXhFeHRlbnQpO1xuICAgIHZhciBjb21wb25lbnRTZWdtZW50cyA9IHt9O1xuICAgIHNlZ21lbnREYXRhTWF0Y2hlcy5zb3J0KGNvbXBhcmVJbmRleGVzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzZWdtZW50RGF0YU1hdGNoZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnREYXRhTWF0Y2ggPSBzZWdtZW50RGF0YU1hdGNoZXNbaV07XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnREYXRhTWF0Y2guc2VnbWVudDtcbiAgICAgIHZhciB1aWQgPSBnZXRVaWQoc2VnbWVudERhdGFNYXRjaC5mZWF0dXJlKTtcbiAgICAgIHZhciBkZXB0aCA9IHNlZ21lbnREYXRhTWF0Y2guZGVwdGg7XG4gICAgICBpZiAoZGVwdGgpIHtcbiAgICAgICAgdWlkICs9ICctJyArIGRlcHRoLmpvaW4oJy0nKTsgLy8gc2VwYXJhdGUgZmVhdHVyZSBjb21wb25lbnRzXG4gICAgICB9XG4gICAgICBpZiAoIWNvbXBvbmVudFNlZ21lbnRzW3VpZF0pIHtcbiAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXSA9IG5ldyBBcnJheSgyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWdtZW50RGF0YU1hdGNoLmdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSAmJlxuICAgICAgc2VnbWVudERhdGFNYXRjaC5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcblxuICAgICAgICB2YXIgY2xvc2VzdFZlcnRleCA9IGNsb3Nlc3RPblNlZ21lbnREYXRhKHBpeGVsQ29vcmRpbmF0ZSwgc2VnbWVudERhdGFNYXRjaCk7XG4gICAgICAgIGlmIChjb29yZGluYXRlc0VxdWFsKGNsb3Nlc3RWZXJ0ZXgsIHZlcnRleCkgJiYgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0pIHtcbiAgICAgICAgICB0aGlzJDEuZHJhZ1NlZ21lbnRzXy5wdXNoKFtzZWdtZW50RGF0YU1hdGNoLCAwXSk7XG4gICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSA9IHNlZ21lbnREYXRhTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29vcmRpbmF0ZXNFcXVhbChzZWdtZW50WzBdLCB2ZXJ0ZXgpICYmXG4gICAgICAgICAgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMF0pIHtcbiAgICAgICAgdGhpcyQxLmRyYWdTZWdtZW50c18ucHVzaChbc2VnbWVudERhdGFNYXRjaCwgMF0pO1xuICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzBdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgIH0gZWxzZSBpZiAoY29vcmRpbmF0ZXNFcXVhbChzZWdtZW50WzFdLCB2ZXJ0ZXgpICYmXG4gICAgICAgICAgIWNvbXBvbmVudFNlZ21lbnRzW3VpZF1bMV0pIHtcblxuICAgICAgICAvLyBwcmV2ZW50IGRyYWdnaW5nIGNsb3NlZCBsaW5lc3RyaW5ncyBieSB0aGUgY29ubmVjdGluZyBub2RlXG4gICAgICAgIGlmICgoc2VnbWVudERhdGFNYXRjaC5nZW9tZXRyeS5nZXRUeXBlKCkgPT09XG4gICAgICAgICAgICBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkcgfHxcbiAgICAgICAgICAgIHNlZ21lbnREYXRhTWF0Y2guZ2VvbWV0cnkuZ2V0VHlwZSgpID09PVxuICAgICAgICAgICAgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HKSAmJlxuICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSAmJlxuICAgICAgICAgICAgY29tcG9uZW50U2VnbWVudHNbdWlkXVswXS5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcyQxLmRyYWdTZWdtZW50c18ucHVzaChbc2VnbWVudERhdGFNYXRjaCwgMV0pO1xuICAgICAgICBjb21wb25lbnRTZWdtZW50c1t1aWRdWzFdID0gc2VnbWVudERhdGFNYXRjaDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyQxLmluc2VydFZlcnRleENvbmRpdGlvbl8oZXZ0KSAmJiBnZXRVaWQoc2VnbWVudCkgaW4gdGhpcyQxLnZlcnRleFNlZ21lbnRzXyAmJlxuICAgICAgICAgICghY29tcG9uZW50U2VnbWVudHNbdWlkXVswXSAmJiAhY29tcG9uZW50U2VnbWVudHNbdWlkXVsxXSkpIHtcbiAgICAgICAgaW5zZXJ0VmVydGljZXMucHVzaChbc2VnbWVudERhdGFNYXRjaCwgdmVydGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnNlcnRWZXJ0aWNlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQpO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gaW5zZXJ0VmVydGljZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgIHRoaXMkMS5pbnNlcnRWZXJ0ZXhfLmFwcGx5KHRoaXMkMSwgaW5zZXJ0VmVydGljZXNbal0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gISF0aGlzLnZlcnRleEZlYXR1cmVfO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gZXZ0IEV2ZW50LlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudChldnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfID0gZmFsc2U7XG4gIHRoaXMud2lsbE1vZGlmeUZlYXR1cmVzXyhldnQpO1xuXG4gIHZhciB2ZXJ0ZXggPSBldnQuY29vcmRpbmF0ZTtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5kcmFnU2VnbWVudHNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgZHJhZ1NlZ21lbnQgPSB0aGlzJDEuZHJhZ1NlZ21lbnRzX1tpXTtcbiAgICB2YXIgc2VnbWVudERhdGEgPSBkcmFnU2VnbWVudFswXTtcbiAgICB2YXIgZGVwdGggPSBzZWdtZW50RGF0YS5kZXB0aDtcbiAgICB2YXIgZ2VvbWV0cnkgPSBzZWdtZW50RGF0YS5nZW9tZXRyeTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSAodm9pZCAwKTtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnREYXRhLnNlZ21lbnQ7XG4gICAgdmFyIGluZGV4ID0gZHJhZ1NlZ21lbnRbMV07XG5cbiAgICB3aGlsZSAodmVydGV4Lmxlbmd0aCA8IGdlb21ldHJ5LmdldFN0cmlkZSgpKSB7XG4gICAgICB2ZXJ0ZXgucHVzaChzZWdtZW50W2luZGV4XVt2ZXJ0ZXgubGVuZ3RoXSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChnZW9tZXRyeS5nZXRUeXBlKCkpIHtcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgICAgICBjb29yZGluYXRlcyA9IHZlcnRleDtcbiAgICAgICAgc2VnbWVudFswXSA9IHNlZ21lbnRbMV0gPSB2ZXJ0ZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbc2VnbWVudERhdGEuaW5kZXhdID0gdmVydGV4O1xuICAgICAgICBzZWdtZW50WzBdID0gc2VnbWVudFsxXSA9IHZlcnRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgc2VnbWVudFtpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgICAgY29vcmRpbmF0ZXNbZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOlxuICAgICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgICAgIGNvb3JkaW5hdGVzW2RlcHRoWzBdXVtzZWdtZW50RGF0YS5pbmRleCArIGluZGV4XSA9IHZlcnRleDtcbiAgICAgICAgc2VnbWVudFtpbmRleF0gPSB2ZXJ0ZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgICBjb29yZGluYXRlc1tkZXB0aFsxXV1bZGVwdGhbMF1dW3NlZ21lbnREYXRhLmluZGV4ICsgaW5kZXhdID0gdmVydGV4O1xuICAgICAgICBzZWdtZW50W2luZGV4XSA9IHZlcnRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5DSVJDTEU6XG4gICAgICAgIHNlZ21lbnRbMF0gPSBzZWdtZW50WzFdID0gdmVydGV4O1xuICAgICAgICBpZiAoc2VnbWVudERhdGEuaW5kZXggPT09IENJUkNMRV9DRU5URVJfSU5ERVgpIHtcbiAgICAgICAgICB0aGlzJDEuY2hhbmdpbmdGZWF0dXJlXyA9IHRydWU7XG4gICAgICAgICAgZ2VvbWV0cnkuc2V0Q2VudGVyKHZlcnRleCk7XG4gICAgICAgICAgdGhpcyQxLmNoYW5naW5nRmVhdHVyZV8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gV2UncmUgZHJhZ2dpbmcgdGhlIGNpcmNsZSdzIGNpcmN1bWZlcmVuY2U6XG4gICAgICAgICAgdGhpcyQxLmNoYW5naW5nRmVhdHVyZV8gPSB0cnVlO1xuICAgICAgICAgIGdlb21ldHJ5LnNldFJhZGl1cyhjb29yZGluYXRlRGlzdGFuY2UoZ2VvbWV0cnkuZ2V0Q2VudGVyKCksIHZlcnRleCkpO1xuICAgICAgICAgIHRoaXMkMS5jaGFuZ2luZ0ZlYXR1cmVfID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBwYXNzXG4gICAgfVxuXG4gICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzJDEuc2V0R2VvbWV0cnlDb29yZGluYXRlc18oZ2VvbWV0cnksIGNvb3JkaW5hdGVzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jcmVhdGVPclVwZGF0ZVZlcnRleEZlYXR1cmVfKHZlcnRleCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBldnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdG9wIGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVXBFdmVudChldnQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMuZHJhZ1NlZ21lbnRzXy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBzZWdtZW50RGF0YSA9IHRoaXMkMS5kcmFnU2VnbWVudHNfW2ldWzBdO1xuICAgIHZhciBnZW9tZXRyeSA9IHNlZ21lbnREYXRhLmdlb21ldHJ5O1xuICAgIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT09IEdlb21ldHJ5VHlwZS5DSVJDTEUpIHtcbiAgICAgIC8vIFVwZGF0ZSBhIGNpcmNsZSBvYmplY3QgaW4gdGhlIFIqIGJ1c2g6XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDZW50ZXIoKTtcbiAgICAgIHZhciBjZW50ZXJTZWdtZW50RGF0YSA9IHNlZ21lbnREYXRhLmZlYXR1cmVTZWdtZW50c1swXTtcbiAgICAgIHZhciBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEgPSBzZWdtZW50RGF0YS5mZWF0dXJlU2VnbWVudHNbMV07XG4gICAgICBjZW50ZXJTZWdtZW50RGF0YS5zZWdtZW50WzBdID0gY2VudGVyU2VnbWVudERhdGEuc2VnbWVudFsxXSA9IGNvb3JkaW5hdGVzO1xuICAgICAgY2lyY3VtZmVyZW5jZVNlZ21lbnREYXRhLnNlZ21lbnRbMF0gPSBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEuc2VnbWVudFsxXSA9IGNvb3JkaW5hdGVzO1xuICAgICAgdGhpcyQxLnJCdXNoXy51cGRhdGUoY3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlcyksIGNlbnRlclNlZ21lbnREYXRhKTtcbiAgICAgIHRoaXMkMS5yQnVzaF8udXBkYXRlKGdlb21ldHJ5LmdldEV4dGVudCgpLCBjaXJjdW1mZXJlbmNlU2VnbWVudERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzJDEuckJ1c2hfLnVwZGF0ZShib3VuZGluZ0V4dGVudChzZWdtZW50RGF0YS5zZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5tb2RpZmllZF8pIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IE1vZGlmeUV2ZW50KE1vZGlmeUV2ZW50VHlwZS5NT0RJRllFTkQsIHRoaXMuZmVhdHVyZXNfLCBldnQpKTtcbiAgICB0aGlzLm1vZGlmaWVkXyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IG1vZGlmeSB0aGVcbiAqIGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghKG1hcEJyb3dzZXJFdmVudCBpbnN0YW5jZW9mIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdGhpcy5sYXN0UG9pbnRlckV2ZW50XyA9IG1hcEJyb3dzZXJFdmVudDtcblxuICB2YXIgaGFuZGxlZDtcbiAgaWYgKCFtYXBCcm93c2VyRXZlbnQubWFwLmdldFZpZXcoKS5nZXRJbnRlcmFjdGluZygpICYmXG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFICYmXG4gICAgICAhdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8obWFwQnJvd3NlckV2ZW50KTtcbiAgfVxuICBpZiAodGhpcy52ZXJ0ZXhGZWF0dXJlXyAmJiB0aGlzLmRlbGV0ZUNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSAhPSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLIHx8ICF0aGlzLmlnbm9yZU5leHRTaW5nbGVDbGlja18pIHtcbiAgICAgIGhhbmRsZWQgPSB0aGlzLnJlbW92ZVBvaW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLKSB7XG4gICAgdGhpcy5pZ25vcmVOZXh0U2luZ2xlQ2xpY2tfID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlUG9pbnRlckV2ZW50LmNhbGwodGhpcywgbWFwQnJvd3NlckV2ZW50KSAmJiAhaGFuZGxlZDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHBvaW50Q29vcmRpbmF0ZXMgVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCBmcm9tXG4gKiAgICAgICAgd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL01vZGlmeX5TZWdtZW50RGF0YX0gc2VnbWVudERhdGEgVGhlIG9iamVjdCBkZXNjcmliaW5nIHRoZSBsaW5lXG4gKiAgICAgICAgc2VnbWVudCB3ZSBhcmUgY2FsY3VsYXRpbmcgdGhlIGRpc3RhbmNlIHRvLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3F1YXJlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgYW5kIGEgbGluZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBwb2ludERpc3RhbmNlVG9TZWdtZW50RGF0YVNxdWFyZWQocG9pbnRDb29yZGluYXRlcywgc2VnbWVudERhdGEpIHtcbiAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG5cbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSkge1xuICAgIHZhciBjaXJjbGVHZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSAqLyAoZ2VvbWV0cnkpO1xuXG4gICAgaWYgKHNlZ21lbnREYXRhLmluZGV4ID09PSBDSVJDTEVfQ0lSQ1VNRkVSRU5DRV9JTkRFWCkge1xuICAgICAgdmFyIGRpc3RhbmNlVG9DZW50ZXJTcXVhcmVkID1cbiAgICAgICAgICAgIHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UoY2lyY2xlR2VvbWV0cnkuZ2V0Q2VudGVyKCksIHBvaW50Q29vcmRpbmF0ZXMpO1xuICAgICAgdmFyIGRpc3RhbmNlVG9DaXJjdW1mZXJlbmNlID1cbiAgICAgICAgICAgIE1hdGguc3FydChkaXN0YW5jZVRvQ2VudGVyU3F1YXJlZCkgLSBjaXJjbGVHZW9tZXRyeS5nZXRSYWRpdXMoKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZVRvQ2lyY3VtZmVyZW5jZSAqIGRpc3RhbmNlVG9DaXJjdW1mZXJlbmNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KHBvaW50Q29vcmRpbmF0ZXMsIHNlZ21lbnREYXRhLnNlZ21lbnQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBvaW50IGNsb3Nlc3QgdG8gYSBnaXZlbiBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwb2ludENvb3JkaW5hdGVzIFRoZSBwb2ludCB0byB3aGljaCBhIGNsb3Nlc3QgcG9pbnRcbiAqICAgICAgICBzaG91bGQgYmUgZm91bmQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb2RpZnl+U2VnbWVudERhdGF9IHNlZ21lbnREYXRhIFRoZSBvYmplY3QgZGVzY3JpYmluZyB0aGUgbGluZVxuICogICAgICAgIHNlZ21lbnQgd2hpY2ggc2hvdWxkIGNvbnRhaW4gdGhlIGNsb3Nlc3QgcG9pbnQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUaGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgc3BlY2lmaWVkIGxpbmUgc2VnbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xvc2VzdE9uU2VnbWVudERhdGEocG9pbnRDb29yZGluYXRlcywgc2VnbWVudERhdGEpIHtcbiAgdmFyIGdlb21ldHJ5ID0gc2VnbWVudERhdGEuZ2VvbWV0cnk7XG5cbiAgaWYgKGdlb21ldHJ5LmdldFR5cGUoKSA9PT0gR2VvbWV0cnlUeXBlLkNJUkNMRSAmJlxuICBzZWdtZW50RGF0YS5pbmRleCA9PT0gQ0lSQ0xFX0NJUkNVTUZFUkVOQ0VfSU5ERVgpIHtcbiAgICByZXR1cm4gZ2VvbWV0cnkuZ2V0Q2xvc2VzdFBvaW50KHBvaW50Q29vcmRpbmF0ZXMpO1xuICB9XG4gIHJldHVybiBjbG9zZXN0T25TZWdtZW50KHBvaW50Q29vcmRpbmF0ZXMsIHNlZ21lbnREYXRhLnNlZ21lbnQpO1xufVxuXG5cbi8qKlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZSA9IGNyZWF0ZUVkaXRpbmdTdHlsZSgpO1xuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIHJldHVybiBzdHlsZVtHZW9tZXRyeVR5cGUuUE9JTlRdO1xuICB9O1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE1vZGlmeTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW9kaWZ5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbVxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHthbHdheXN9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBGSVJFRk9YLCBTQUZBUkl9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBNYXhpbXVtIG1vdXNlIHdoZWVsIGRlbHRhLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIE1BWF9ERUxUQSA9IDE7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIE1vZGUgPSB7XG4gIFRSQUNLUEFEOiAndHJhY2twYWQnLFxuICBXSEVFTDogJ3doZWVsJ1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5hbHdheXN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXQ9ODBdIE1vdXNlIHdoZWVsIHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluUmVzb2x1dGlvbj1mYWxzZV0gV2hlbiB1c2luZyBhIHRyYWNrcGFkIG9yXG4gKiBtYWdpYyBtb3VzZSwgem9vbSB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyIHpvb20gbGV2ZWwgYWZ0ZXIgdGhlIHNjcm9sbCBnZXN0dXJlXG4gKiBlbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlQW5jaG9yPXRydWVdIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSdzXG4gKiBsb2NhdGlvbiBhcyB0aGUgYW5jaG9yLiBXaGVuIHNldCB0byBgZmFsc2VgLCB6b29taW5nIGluIGFuZCBvdXQgd2lsbCB6b29tIHRvXG4gKiB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4gaW5zdGVhZCBvZiB6b29taW5nIG9uIHRoZSBtb3VzZSdzIGxvY2F0aW9uLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGJ5IHNjcm9sbGluZyB0aGUgbW91c2Ugd2hlZWwuXG4gKiBAYXBpXG4gKi9cbnZhciBNb3VzZVdoZWVsWm9vbSA9IChmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gTW91c2VXaGVlbFpvb20ob3B0X29wdGlvbnMpIHtcblxuICAgIEludGVyYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgaGFuZGxlRXZlbnQ6IGhhbmRsZUV2ZW50XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0XyA9IG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lb3V0IDogODA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQW5jaG9yXyA9IG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPSBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IGFsd2F5cztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGltZW91dElkXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbX5Nb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRFdmVudEdhcF8gPSA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVsdGEgdmFsdWVzIHBlciB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWREZWx0YVBlclpvb21fID0gMzAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHpvb20gZmFjdG9yIGJ5IHdoaWNoIHNjcm9sbCB6b29taW5nIGlzIGFsbG93ZWQgdG8gZXhjZWVkIHRoZSBsaW1pdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyA9IDEuNTtcblxuICB9XG5cbiAgaWYgKCBJbnRlcmFjdGlvbiApIE1vdXNlV2hlZWxab29tLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VXaGVlbFpvb207XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNb3VzZVdoZWVsWm9vbS5wcm90b3R5cGUuZGVjcmVtZW50SW50ZXJhY3RpbmdIaW50XyA9IGZ1bmN0aW9uIGRlY3JlbWVudEludGVyYWN0aW5nSGludF8gKCkge1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgIHZhciB2aWV3ID0gdGhpcy5nZXRNYXAoKS5nZXRWaWV3KCk7XG4gICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gbWFwIE1hcC5cbiAgICovXG4gIE1vdXNlV2hlZWxab29tLnByb3RvdHlwZS5oYW5kbGVXaGVlbFpvb21fID0gZnVuY3Rpb24gaGFuZGxlV2hlZWxab29tXyAobWFwKSB7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIG1heERlbHRhID0gTUFYX0RFTFRBO1xuICAgIHZhciBkZWx0YSA9IGNsYW1wKHRoaXMuZGVsdGFfLCAtbWF4RGVsdGEsIG1heERlbHRhKTtcbiAgICB6b29tQnlEZWx0YSh2aWV3LCAtZGVsdGEsIHRoaXMubGFzdEFuY2hvcl8sIHRoaXMuZHVyYXRpb25fKTtcbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGVsdGFfID0gMDtcbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGltZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSB1c2luZyB0aGUgbW91c2UncyBsb2NhdGlvbiBhcyBhbiBhbmNob3Igd2hlbiB6b29taW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQW5jaG9yIHRydWUgdG8gem9vbSB0byB0aGUgbW91c2UncyBsb2NhdGlvbiwgZmFsc2VcbiAgICogdG8gem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSBtYXBcbiAgICogQGFwaVxuICAgKi9cbiAgTW91c2VXaGVlbFpvb20ucHJvdG90eXBlLnNldE1vdXNlQW5jaG9yID0gZnVuY3Rpb24gc2V0TW91c2VBbmNob3IgKHVzZUFuY2hvcikge1xuICAgIHRoaXMudXNlQW5jaG9yXyA9IHVzZUFuY2hvcjtcbiAgICBpZiAoIXVzZUFuY2hvcikge1xuICAgICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBNb3VzZVdoZWVsWm9vbTtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSAoaWYgaXQgd2FzIGFcbiAqIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5IHpvb21zIHRoZSBtYXAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEFsbG93IGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICghdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgdHlwZSA9IG1hcEJyb3dzZXJFdmVudC50eXBlO1xuICBpZiAodHlwZSAhPT0gRXZlbnRUeXBlLldIRUVMICYmIHR5cGUgIT09IEV2ZW50VHlwZS5NT1VTRVdIRUVMKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgdmFyIHdoZWVsRXZlbnQgPSAvKiogQHR5cGUge1doZWVsRXZlbnR9ICovIChtYXBCcm93c2VyRXZlbnQub3JpZ2luYWxFdmVudCk7XG5cbiAgaWYgKHRoaXMudXNlQW5jaG9yXykge1xuICAgIHRoaXMubGFzdEFuY2hvcl8gPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgfVxuXG4gIC8vIERlbHRhIG5vcm1hbGlzYXRpb24gaW5zcGlyZWQgYnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi8wMDFjN2I5L2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanNcbiAgdmFyIGRlbHRhO1xuICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLldIRUVMKSB7XG4gICAgZGVsdGEgPSB3aGVlbEV2ZW50LmRlbHRhWTtcbiAgICBpZiAoRklSRUZPWCAmJlxuICAgICAgICB3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgIGRlbHRhIC89IERFVklDRV9QSVhFTF9SQVRJTztcbiAgICB9XG4gICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSBXaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB7XG4gICAgICBkZWx0YSAqPSA0MDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLk1PVVNFV0hFRUwpIHtcbiAgICBkZWx0YSA9IC13aGVlbEV2ZW50LndoZWVsRGVsdGFZO1xuICAgIGlmIChTQUZBUkkpIHtcbiAgICAgIGRlbHRhIC89IDM7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgaWYgKHRoaXMuc3RhcnRUaW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdGFydFRpbWVfID0gbm93O1xuICB9XG5cbiAgaWYgKCF0aGlzLm1vZGVfIHx8IG5vdyAtIHRoaXMuc3RhcnRUaW1lXyA+IHRoaXMudHJhY2twYWRFdmVudEdhcF8pIHtcbiAgICB0aGlzLm1vZGVfID0gTWF0aC5hYnMoZGVsdGEpIDwgNCA/XG4gICAgICBNb2RlLlRSQUNLUEFEIDpcbiAgICAgIE1vZGUuV0hFRUw7XG4gIH1cblxuICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5UUkFDS1BBRCkge1xuICAgIHZhciB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYWNrcGFkVGltZW91dElkXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgfVxuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gc2V0VGltZW91dCh0aGlzLmRlY3JlbWVudEludGVyYWN0aW5nSGludF8uYmluZCh0aGlzKSwgdGhpcy50cmFja3BhZEV2ZW50R2FwXyk7XG4gICAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKSAqIE1hdGgucG93KDIsIGRlbHRhIC8gdGhpcy50cmFja3BhZERlbHRhUGVyWm9vbV8pO1xuICAgIHZhciBtaW5SZXNvbHV0aW9uID0gdmlldy5nZXRNaW5SZXNvbHV0aW9uKCk7XG4gICAgdmFyIG1heFJlc29sdXRpb24gPSB2aWV3LmdldE1heFJlc29sdXRpb24oKTtcbiAgICB2YXIgcmVib3VuZCA9IDA7XG4gICAgaWYgKHJlc29sdXRpb24gPCBtaW5SZXNvbHV0aW9uKSB7XG4gICAgICByZXNvbHV0aW9uID0gTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbiAvIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyk7XG4gICAgICByZWJvdW5kID0gMTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdXRpb24gPiBtYXhSZXNvbHV0aW9uKSB7XG4gICAgICByZXNvbHV0aW9uID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgbWF4UmVzb2x1dGlvbiAqIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyk7XG4gICAgICByZWJvdW5kID0gLTE7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RBbmNob3JfKSB7XG4gICAgICB2YXIgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIHRoaXMubGFzdEFuY2hvcl8pO1xuICAgICAgdmlldy5zZXRDZW50ZXIodmlldy5jb25zdHJhaW5DZW50ZXIoY2VudGVyKSk7XG4gICAgfVxuICAgIHZpZXcuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcblxuICAgIGlmIChyZWJvdW5kID09PSAwICYmIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8pIHtcbiAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgIHJlc29sdXRpb246IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZWx0YSA+IDAgPyAtMSA6IDEpLFxuICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIGFuY2hvcjogdGhpcy5sYXN0QW5jaG9yXyxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVib3VuZCA+IDApIHtcbiAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgIHJlc29sdXRpb246IG1pblJlc29sdXRpb24sXG4gICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgYW5jaG9yOiB0aGlzLmxhc3RBbmNob3JfLFxuICAgICAgICBkdXJhdGlvbjogNTAwXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlYm91bmQgPCAwKSB7XG4gICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICByZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgICAgICBlYXNpbmc6IGVhc2VPdXQsXG4gICAgICAgIGFuY2hvcjogdGhpcy5sYXN0QW5jaG9yXyxcbiAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLmRlbHRhXyArPSBkZWx0YTtcblxuICB2YXIgdGltZUxlZnQgPSBNYXRoLm1heCh0aGlzLnRpbWVvdXRfIC0gKG5vdyAtIHRoaXMuc3RhcnRUaW1lXyksIDApO1xuXG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICB0aGlzLnRpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlV2hlZWxab29tXy5iaW5kKHRoaXMsIG1hcCksIHRpbWVMZWZ0KTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTW91c2VXaGVlbFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vdXNlV2hlZWxab29tLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZVxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHtGQUxTRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7cm90YXRlLCByb3RhdGVXaXRob3V0Q29uc3RyYWludHN9IGZyb20gJy4uL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtjZW50cm9pZCBhcyBjZW50cm9pZEZyb21Qb2ludGVyc30gZnJvbSAnLi4vaW50ZXJhY3Rpb24vUG9pbnRlci5qcyc7XG5pbXBvcnQge2Rpc2FibGV9IGZyb20gJy4uL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGhyZXNob2xkPTAuM10gTWluaW1hbCBhbmdsZSBpbiByYWRpYW5zIHRvIHN0YXJ0IGEgcm90YXRpb24uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byByb3RhdGUgdGhlIG1hcCBieSB0d2lzdGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xudmFyIFBpbmNoUm90YXRlID0gKGZ1bmN0aW9uIChQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gUGluY2hSb3RhdGUob3B0X29wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZURvd25FdmVudDogaGFuZGxlRG93bkV2ZW50LFxuICAgICAgaGFuZGxlRHJhZ0V2ZW50OiBoYW5kbGVEcmFnRXZlbnQsXG4gICAgICBoYW5kbGVVcEV2ZW50OiBoYW5kbGVVcEV2ZW50LFxuICAgICAgc3RvcERvd246IEZBTFNFXG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmdsZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpbmdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRocmVzaG9sZF8gPSBvcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aHJlc2hvbGQgOiAwLjM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogMjUwO1xuXG4gIH1cblxuICBpZiAoIFBvaW50ZXJJbnRlcmFjdGlvbiApIFBpbmNoUm90YXRlLl9fcHJvdG9fXyA9IFBvaW50ZXJJbnRlcmFjdGlvbjtcbiAgUGluY2hSb3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgUGluY2hSb3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGluY2hSb3RhdGU7XG5cbiAgcmV0dXJuIFBpbmNoUm90YXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hSb3RhdGV9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgdmFyIHJvdGF0aW9uRGVsdGEgPSAwLjA7XG5cbiAgdmFyIHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gIHZhciB0b3VjaDEgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzFdO1xuXG4gIC8vIGFuZ2xlIGJldHdlZW4gdG91Y2hlc1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKFxuICAgIHRvdWNoMS5jbGllbnRZIC0gdG91Y2gwLmNsaWVudFksXG4gICAgdG91Y2gxLmNsaWVudFggLSB0b3VjaDAuY2xpZW50WCk7XG5cbiAgaWYgKHRoaXMubGFzdEFuZ2xlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGRlbHRhID0gYW5nbGUgLSB0aGlzLmxhc3RBbmdsZV87XG4gICAgdGhpcy5yb3RhdGlvbkRlbHRhXyArPSBkZWx0YTtcbiAgICBpZiAoIXRoaXMucm90YXRpbmdfICYmXG4gICAgICAgIE1hdGguYWJzKHRoaXMucm90YXRpb25EZWx0YV8pID4gdGhpcy50aHJlc2hvbGRfKSB7XG4gICAgICB0aGlzLnJvdGF0aW5nXyA9IHRydWU7XG4gICAgfVxuICAgIHJvdGF0aW9uRGVsdGEgPSBkZWx0YTtcbiAgfVxuICB0aGlzLmxhc3RBbmdsZV8gPSBhbmdsZTtcblxuICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICBpZiAodmlldy5nZXRDb25zdHJhaW50cygpLnJvdGF0aW9uID09PSBkaXNhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcm90YXRlIGFuY2hvciBwb2ludC5cbiAgLy8gRklYTUU6IHNob3VsZCBiZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGJldHdlZW4gdGhlIGxpbmVzOlxuICAvLyAgICAgdG91Y2gwLHRvdWNoMSBhbmQgcHJldmlvdXNUb3VjaDAscHJldmlvdXNUb3VjaDFcbiAgdmFyIHZpZXdwb3J0UG9zaXRpb24gPSBtYXAuZ2V0Vmlld3BvcnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGNlbnRyb2lkID0gY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycyk7XG4gIGNlbnRyb2lkWzBdIC09IHZpZXdwb3J0UG9zaXRpb24ubGVmdDtcbiAgY2VudHJvaWRbMV0gLT0gdmlld3BvcnRQb3NpdGlvbi50b3A7XG4gIHRoaXMuYW5jaG9yXyA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGNlbnRyb2lkKTtcblxuICAvLyByb3RhdGVcbiAgaWYgKHRoaXMucm90YXRpbmdfKSB7XG4gICAgdmFyIHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgIG1hcC5yZW5kZXIoKTtcbiAgICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24gKyByb3RhdGlvbkRlbHRhLCB0aGlzLmFuY2hvcl8pO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdG9wIGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1BpbmNoUm90YXRlfVxuICovXG5mdW5jdGlvbiBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgLTEpO1xuICAgIGlmICh0aGlzLnJvdGF0aW5nXykge1xuICAgICAgdmFyIHJvdGF0aW9uID0gdmlldy5nZXRSb3RhdGlvbigpO1xuICAgICAgcm90YXRlKHZpZXcsIHJvdGF0aW9uLCB0aGlzLmFuY2hvcl8sIHRoaXMuZHVyYXRpb25fKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdGFydCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAodGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPj0gMikge1xuICAgIHZhciBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG4gICAgdGhpcy5sYXN0QW5nbGVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucm90YXRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5yb3RhdGlvbkRlbHRhXyA9IDAuMDtcbiAgICBpZiAoIXRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSkge1xuICAgICAgbWFwLmdldFZpZXcoKS5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBpbmNoUm90YXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QaW5jaFJvdGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hab29tXG4gKi9cbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHt6b29tLCB6b29tV2l0aG91dENvbnN0cmFpbnRzfSBmcm9tICcuLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7Y2VudHJvaWQgYXMgY2VudHJvaWRGcm9tUG9pbnRlcnN9IGZyb20gJy4uL2ludGVyYWN0aW9uL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj00MDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBab29tIHRvIHRoZSBjbG9zZXN0IGludGVnZXJcbiAqIHpvb20gbGV2ZWwgYWZ0ZXIgdGhlIHBpbmNoIGdlc3R1cmUgZW5kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBwaW5jaGluZyB3aXRoIHR3byBmaW5nZXJzXG4gKiBvbiBhIHRvdWNoIHNjcmVlbi5cbiAqIEBhcGlcbiAqL1xudmFyIFBpbmNoWm9vbSA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFBpbmNoWm9vbShvcHRfb3B0aW9ucykge1xuXG4gICAgUG9pbnRlckludGVyYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgaGFuZGxlRG93bkV2ZW50OiBoYW5kbGVEb3duRXZlbnQsXG4gICAgICBoYW5kbGVEcmFnRXZlbnQ6IGhhbmRsZURyYWdFdmVudCxcbiAgICAgIGhhbmRsZVVwRXZlbnQ6IGhhbmRsZVVwRXZlbnQsXG4gICAgICBzdG9wRG93bjogRkFMU0VcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fID0gb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZHVyYXRpb25fID0gb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDQwMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5sYXN0RGlzdGFuY2VfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMTtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBQaW5jaFpvb20uX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBQaW5jaFpvb20ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgUGluY2hab29tLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBpbmNoWm9vbTtcblxuICByZXR1cm4gUGluY2hab29tO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vUGluY2hab29tfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIHZhciBzY2FsZURlbHRhID0gMS4wO1xuXG4gIHZhciB0b3VjaDAgPSB0aGlzLnRhcmdldFBvaW50ZXJzWzBdO1xuICB2YXIgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcbiAgdmFyIGR4ID0gdG91Y2gwLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WDtcbiAgdmFyIGR5ID0gdG91Y2gwLmNsaWVudFkgLSB0b3VjaDEuY2xpZW50WTtcblxuICAvLyBkaXN0YW5jZSBiZXR3ZWVuIHRvdWNoZXNcbiAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICBpZiAodGhpcy5sYXN0RGlzdGFuY2VfICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2FsZURlbHRhID0gdGhpcy5sYXN0RGlzdGFuY2VfIC8gZGlzdGFuY2U7XG4gIH1cbiAgdGhpcy5sYXN0RGlzdGFuY2VfID0gZGlzdGFuY2U7XG5cblxuICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgdmFyIHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICB2YXIgcmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpO1xuICB2YXIgbWF4UmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpO1xuICB2YXIgbWluUmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpO1xuICB2YXIgbmV3UmVzb2x1dGlvbiA9IHJlc29sdXRpb24gKiBzY2FsZURlbHRhO1xuICBpZiAobmV3UmVzb2x1dGlvbiA+IG1heFJlc29sdXRpb24pIHtcbiAgICBzY2FsZURlbHRhID0gbWF4UmVzb2x1dGlvbiAvIHJlc29sdXRpb247XG4gICAgbmV3UmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAobmV3UmVzb2x1dGlvbiA8IG1pblJlc29sdXRpb24pIHtcbiAgICBzY2FsZURlbHRhID0gbWluUmVzb2x1dGlvbiAvIHJlc29sdXRpb247XG4gICAgbmV3UmVzb2x1dGlvbiA9IG1pblJlc29sdXRpb247XG4gIH1cblxuICBpZiAoc2NhbGVEZWx0YSAhPSAxLjApIHtcbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IHNjYWxlRGVsdGE7XG4gIH1cblxuICAvLyBzY2FsZSBhbmNob3IgcG9pbnQuXG4gIHZhciB2aWV3cG9ydFBvc2l0aW9uID0gbWFwLmdldFZpZXdwb3J0KCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkRnJvbVBvaW50ZXJzKHRoaXMudGFyZ2V0UG9pbnRlcnMpO1xuICBjZW50cm9pZFswXSAtPSB2aWV3cG9ydFBvc2l0aW9uLmxlZnQ7XG4gIGNlbnRyb2lkWzFdIC09IHZpZXdwb3J0UG9zaXRpb24udG9wO1xuICB0aGlzLmFuY2hvcl8gPSBtYXAuZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbChjZW50cm9pZCk7XG5cbiAgLy8gc2NhbGUsIGJ5cGFzcyB0aGUgcmVzb2x1dGlvbiBjb25zdHJhaW50XG4gIG1hcC5yZW5kZXIoKTtcbiAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCBuZXdSZXNvbHV0aW9uLCB0aGlzLmFuY2hvcl8pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RvcCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFpvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB2YXIgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgdmFyIHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAodGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXyB8fFxuICAgICAgICByZXNvbHV0aW9uIDwgdmlldy5nZXRNaW5SZXNvbHV0aW9uKCkgfHxcbiAgICAgICAgcmVzb2x1dGlvbiA+IHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpKSB7XG4gICAgICAvLyBab29tIHRvIGZpbmFsIHJlc29sdXRpb24sIHdpdGggYW4gYW5pbWF0aW9uLCBhbmQgcHJvdmlkZSBhXG4gICAgICAvLyBkaXJlY3Rpb24gbm90IHRvIHpvb20gb3V0L2luIGlmIHVzZXIgd2FzIHBpbmNoaW5nIGluL291dC5cbiAgICAgIC8vIERpcmVjdGlvbiBpcyA+IDAgaWYgcGluY2hpbmcgb3V0LCBhbmQgPCAwIGlmIHBpbmNoaW5nIGluLlxuICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMubGFzdFNjYWxlRGVsdGFfIC0gMTtcbiAgICAgIHpvb20odmlldywgcmVzb2x1dGlvbiwgdGhpcy5hbmNob3JfLCB0aGlzLmR1cmF0aW9uXywgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdGFydCBkcmFnIHNlcXVlbmNlP1xuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9QaW5jaFpvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURvd25FdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID49IDIpIHtcbiAgICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhc3RTY2FsZURlbHRhXyA9IDE7XG4gICAgaWYgKCF0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIG1hcC5nZXRWaWV3KCkuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFpvb207XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBpbmNoWm9vbS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUG9pbnRlclxuICovXG5pbXBvcnQge0ZBTFNFLCBVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyUG9pbnRlckV2ZW50IGZyb20gJy4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4uL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9Qb2ludGVyfVxuICovXG52YXIgaGFuZGxlRHJhZ0V2ZW50ID0gVU5ERUZJTkVEO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gQ2FwdHVyZSBkcmFnZ2luZy5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vUG9pbnRlcn1cbiAqL1xudmFyIGhhbmRsZVVwRXZlbnQgPSBGQUxTRTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENhcHR1cmUgZHJhZ2dpbmcuXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1BvaW50ZXJ9XG4gKi9cbnZhciBoYW5kbGVEb3duRXZlbnQgPSBGQUxTRTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vUG9pbnRlcn1cbiAqL1xudmFyIGhhbmRsZU1vdmVFdmVudCA9IFVOREVGSU5FRDtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKG1vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50KTpib29sZWFuKX0gW2hhbmRsZURvd25FdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZG93blwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIHRoZW4gYSBkcmFnXG4gKiBzZXF1ZW5jZSBpcyBzdGFydGVkLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24obW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnQpKX0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24obW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCk6Ym9vbGVhbil9IFtoYW5kbGVFdmVudF1cbiAqIE1ldGhvZCBjYWxsZWQgYnkgdGhlIG1hcCB0byBub3RpZnkgdGhlIGludGVyYWN0aW9uIHRoYXQgYSBicm93c2VyIGV2ZW50IHdhc1xuICogZGlzcGF0Y2hlZCB0byB0aGUgbWFwLiBUaGUgZnVuY3Rpb24gbWF5IHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgdGhlXG4gKiBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQgdG8gb3RoZXIgaW50ZXJhY3Rpb25zIGluIHRoZSBtYXAncyBpbnRlcmFjdGlvbnNcbiAqIGNoYWluLlxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24obW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnQpKX0gW2hhbmRsZU1vdmVFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwibW92ZVwiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzLFxuICogYWxzbyBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlIChzbyBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlIGJvdGggdGhlXG4gKiBgaGFuZGxlRHJhZ0V2ZW50YCBmdW5jdGlvbiBhbmQgdGhpcyBmdW5jdGlvbiBhcmUgY2FsbGVkKS5cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKG1vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50KTpib29sZWFuKX0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IHN0b3BEb3duXG4gKiBTaG91bGQgdGhlIGRvd24gZXZlbnQgYmUgcHJvcGFnYXRlZCB0byBvdGhlciBpbnRlcmFjdGlvbnMsIG9yIHNob3VsZCBiZVxuICogc3RvcHBlZD9cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyB0aGF0IGNhbGxzIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMgb24gYGRvd25gLCBgbW92ZWAgYW5kIGB1cGBcbiAqIGV2ZW50cy4gVGhpcyBjbGFzcyBhbHNvIG1hbmFnZXMgXCJkcmFnIHNlcXVlbmNlc1wiLlxuICpcbiAqIFdoZW4gdGhlIGBoYW5kbGVEb3duRXZlbnRgIHVzZXIgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgYSBkcmFnIHNlcXVlbmNlIGlzXG4gKiBzdGFydGVkLiBEdXJpbmcgYSBkcmFnIHNlcXVlbmNlIHRoZSBgaGFuZGxlRHJhZ0V2ZW50YCB1c2VyIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb24gYG1vdmVgIGV2ZW50cy4gVGhlIGRyYWcgc2VxdWVuY2UgZW5kcyB3aGVuIHRoZSBgaGFuZGxlVXBFdmVudGBcbiAqIHVzZXIgZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gKiBAYXBpXG4gKi9cbnZhciBQb2ludGVySW50ZXJhY3Rpb24gPSAoZnVuY3Rpb24gKEludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFBvaW50ZXJJbnRlcmFjdGlvbihvcHRfb3B0aW9ucykge1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBvcHRpb25zLmhhbmRsZUV2ZW50IHx8IGhhbmRsZUV2ZW50XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnQpOmJvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZURvd25FdmVudF8gPSBvcHRpb25zLmhhbmRsZURvd25FdmVudCA/XG4gICAgICBvcHRpb25zLmhhbmRsZURvd25FdmVudCA6IGhhbmRsZURvd25FdmVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudCl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZURyYWdFdmVudF8gPSBvcHRpb25zLmhhbmRsZURyYWdFdmVudCA/XG4gICAgICBvcHRpb25zLmhhbmRsZURyYWdFdmVudCA6IGhhbmRsZURyYWdFdmVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudCl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsZU1vdmVFdmVudF8gPSBvcHRpb25zLmhhbmRsZU1vdmVFdmVudCA/XG4gICAgICBvcHRpb25zLmhhbmRsZU1vdmVFdmVudCA6IGhhbmRsZU1vdmVFdmVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvTWFwQnJvd3NlclBvaW50ZXJFdmVudCk6Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxlVXBFdmVudF8gPSBvcHRpb25zLmhhbmRsZVVwRXZlbnQgP1xuICAgICAgb3B0aW9ucy5oYW5kbGVVcEV2ZW50IDogaGFuZGxlVXBFdmVudDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgXCJkb3duXCIgZXZlbnRzIHNob3VsZCBiZSBwcm9wYWdhdGVkXG4gICAgICogdG8gb3RoZXIgaW50ZXJhY3Rpb25zIG9yIHNob3VsZCBiZSBzdG9wcGVkLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihib29sZWFuKTpib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnN0b3BEb3duID0gb3B0aW9ucy5zdG9wRG93biA/IG9wdGlvbnMuc3RvcERvd24gOiBzdG9wRG93bjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrZWRQb2ludGVyc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQb2ludGVycyA9IFtdO1xuXG4gIH1cblxuICBpZiAoIEludGVyYWN0aW9uICkgUG9pbnRlckludGVyYWN0aW9uLl9fcHJvdG9fXyA9IEludGVyYWN0aW9uO1xuICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJhY3Rpb24gJiYgSW50ZXJhY3Rpb24ucHJvdG90eXBlICk7XG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludGVySW50ZXJhY3Rpb247XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUudXBkYXRlVHJhY2tlZFBvaW50ZXJzXyA9IGZ1bmN0aW9uIHVwZGF0ZVRyYWNrZWRQb2ludGVyc18gKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmIChpc1BvaW50ZXJEcmFnZ2luZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHZhciBldmVudCA9IG1hcEJyb3dzZXJFdmVudC5wb2ludGVyRXZlbnQ7XG5cbiAgICAgIHZhciBpZCA9IGV2ZW50LnBvaW50ZXJJZC50b1N0cmluZygpO1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyYWNrZWRQb2ludGVyc19baWRdO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PVxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgICAgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXSA9IGV2ZW50O1xuICAgICAgfSBlbHNlIGlmIChpZCBpbiB0aGlzLnRyYWNrZWRQb2ludGVyc18pIHtcbiAgICAgICAgLy8gdXBkYXRlIG9ubHkgd2hlbiB0aGVyZSB3YXMgYSBwb2ludGVyZG93biBldmVudCBmb3IgdGhpcyBwb2ludGVyXG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJzX1tpZF0gPSBldmVudDtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFyZ2V0UG9pbnRlcnMgPSBnZXRWYWx1ZXModGhpcy50cmFja2VkUG9pbnRlcnNfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50ZXJJbnRlcmFjdGlvbjtcbn0oSW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudD59IHBvaW50ZXJFdmVudHMgTGlzdCBvZiBldmVudHMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9IENlbnRyb2lkIHBpeGVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2VudHJvaWQocG9pbnRlckV2ZW50cykge1xuICB2YXIgbGVuZ3RoID0gcG9pbnRlckV2ZW50cy5sZW5ndGg7XG4gIHZhciBjbGllbnRYID0gMDtcbiAgdmFyIGNsaWVudFkgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xpZW50WCArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFg7XG4gICAgY2xpZW50WSArPSBwb2ludGVyRXZlbnRzW2ldLmNsaWVudFk7XG4gIH1cbiAgcmV0dXJuIFtjbGllbnRYIC8gbGVuZ3RoLCBjbGllbnRZIC8gbGVuZ3RoXTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV2ZW50IGlzIGEgcG9pbnRlcmRvd24sIHBvaW50ZXJkcmFnXG4gKiAgICAgb3IgcG9pbnRlcnVwIGV2ZW50LlxuICovXG5mdW5jdGlvbiBpc1BvaW50ZXJEcmFnZ2luZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICB2YXIgdHlwZSA9IG1hcEJyb3dzZXJFdmVudC50eXBlO1xuICByZXR1cm4gdHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiB8fFxuICAgIHR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcgfHxcbiAgICB0eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUDtcbn1cblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBhbmQgbWF5IGNhbGwgaW50b1xuICogb3RoZXIgZnVuY3Rpb25zLCBpZiBldmVudCBzZXF1ZW5jZXMgbGlrZSBlLmcuICdkcmFnJyBvciAnZG93bi11cCcgZXRjLiBhcmVcbiAqIGRldGVjdGVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBgZmFsc2VgIHRvIHN0b3AgZXZlbnQgcHJvcGFnYXRpb24uXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1BvaW50ZXJ9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgaWYgKCEobWFwQnJvd3NlckV2ZW50IGluc3RhbmNlb2YgTWFwQnJvd3NlclBvaW50ZXJFdmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgdGhpcy51cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCk7XG4gIGlmICh0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgdGhpcy5oYW5kbGVEcmFnRXZlbnRfKG1hcEJyb3dzZXJFdmVudCk7XG4gICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgdmFyIGhhbmRsZWRVcCA9IHRoaXMuaGFuZGxlVXBFdmVudF8obWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9IGhhbmRsZWRVcCAmJiB0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICB2YXIgaGFuZGxlZCA9IHRoaXMuaGFuZGxlRG93bkV2ZW50XyhtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gaGFuZGxlZDtcbiAgICAgIHN0b3BFdmVudCA9IHRoaXMuc3RvcERvd24oaGFuZGxlZCk7XG4gICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJNT1ZFKSB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudF8obWFwQnJvd3NlckV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFzdG9wRXZlbnQ7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckludGVyYWN0aW9uO1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICogQHJldHVybiB7Ym9vbGVhbn0gU2hvdWxkIHRoZSBgZG93bmAgZXZlbnQgYmUgc3RvcHBlZD9cbiAqL1xuZnVuY3Rpb24gc3RvcERvd24oaGFuZGxlZCkge1xuICByZXR1cm4gaGFuZGxlZDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQUNUSVZFOiAnYWN0aXZlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvcGVydHkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL1NlbGVjdFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXh0ZW5kLCBpbmNsdWRlc30gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7c2luZ2xlQ2xpY2ssIG5ldmVyLCBzaGlmdEtleU9ubHksIHBvaW50ZXJNb3ZlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4uL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBWZWN0b3JMYXllciBmcm9tICcuLi9sYXllci9WZWN0b3IuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCBWZWN0b3JTb3VyY2UgZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQge2NyZWF0ZUVkaXRpbmdTdHlsZX0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIFNlbGVjdEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGZlYXR1cmUocykgaGFzIGJlZW4gKGRlKXNlbGVjdGVkLlxuICAgKiBAZXZlbnQgU2VsZWN0RXZlbnQjc2VsZWN0XG4gICAqIEBhcGlcbiAgICovXG4gIFNFTEVDVDogJ3NlbGVjdCdcbn07XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gYW5kIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZlYXR1cmUgbWF5IGJlXG4gKiBzZWxlY3RlZCBvciBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSwgbW9kdWxlOm9sL2xheWVyL0xheWVyKTpcbiAqICAgICBib29sZWFufSBGaWx0ZXJGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn0gW2FkZENvbmRpdGlvbl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLlxuICogQnkgZGVmYXVsdCwgdGhpcyBpcyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+bmV2ZXJ9LiBVc2UgdGhpcyBpZiB5b3VcbiAqIHdhbnQgdG8gdXNlIGRpZmZlcmVudCBldmVudHMgZm9yIGFkZCBhbmQgcmVtb3ZlIGluc3RlYWQgb2YgYHRvZ2dsZWAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBUaGlzIGlzIHRoZSBldmVudFxuICogZm9yIHRoZSBzZWxlY3RlZCBmZWF0dXJlcyBhcyBhIHdob2xlLiBCeSBkZWZhdWx0LCB0aGlzIGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+c2luZ2xlQ2xpY2t9LiBDbGlja2luZyBvbiBhIGZlYXR1cmUgc2VsZWN0cyB0aGF0XG4gKiBmZWF0dXJlIGFuZCByZW1vdmVzIGFueSB0aGF0IHdlcmUgaW4gdGhlIHNlbGVjdGlvbi4gQ2xpY2tpbmcgb3V0c2lkZSBhbnlcbiAqIGZlYXR1cmUgcmVtb3ZlcyBhbGwgZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogU2VlIGB0b2dnbGVgLCBgYWRkYCwgYHJlbW92ZWAgb3B0aW9ucyBmb3IgYWRkaW5nL3JlbW92aW5nIGV4dHJhIGZlYXR1cmVzIHRvL1xuICogZnJvbSB0aGUgc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL2xheWVyL0xheWVyPnxmdW5jdGlvbihtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBib29sZWFufSBbbGF5ZXJzXVxuICogQSBsaXN0IG9mIGxheWVycyBmcm9tIHdoaWNoIGZlYXR1cmVzIHNob3VsZCBiZSBzZWxlY3RlZC4gQWx0ZXJuYXRpdmVseSwgYVxuICogZmlsdGVyIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGxheWVyXG4gKiBpbiB0aGUgbWFwIGFuZCBzaG91bGQgcmV0dXJuIGB0cnVlYCBmb3IgbGF5ZXJzIHRoYXQgeW91IHdhbnQgdG8gYmVcbiAqIHNlbGVjdGFibGUuIElmIHRoZSBvcHRpb24gaXMgYWJzZW50LCBhbGwgdmlzaWJsZSBsYXllcnMgd2lsbCBiZSBjb25zaWRlcmVkXG4gKiBzZWxlY3RhYmxlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3R5bGV8QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT58bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFtzdHlsZV1cbiAqIFN0eWxlIGZvciB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuIEJ5IGRlZmF1bHQgdGhlIGRlZmF1bHQgZWRpdCBzdHlsZSBpcyB1c2VkXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9KS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbcmVtb3ZlQ29uZGl0aW9uXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBCeSBkZWZhdWx0LCB0aGlzIGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5uZXZlcn0uIFVzZSB0aGlzIGlmIHlvdVxuICogd2FudCB0byB1c2UgZGlmZmVyZW50IGV2ZW50cyBmb3IgYWRkIGFuZCByZW1vdmUgaW5zdGVhZCBvZiBgdG9nZ2xlYC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufSBbdG9nZ2xlQ29uZGl0aW9uXSBBIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIFRoaXMgaXMgaW4gYWRkaXRpb25cbiAqIHRvIHRoZSBgY29uZGl0aW9uYCBldmVudC4gQnkgZGVmYXVsdCxcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5zaGlmdEtleU9ubHl9LCBpLmUuIHByZXNzaW5nIGBzaGlmdGAgYXNcbiAqIHdlbGwgYXMgdGhlIGBjb25kaXRpb25gIGV2ZW50LCBhZGRzIHRoYXQgZmVhdHVyZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaWZcbiAqIGl0IGlzIG5vdCBjdXJyZW50bHkgc2VsZWN0ZWQsIGFuZCByZW1vdmVzIGl0IGlmIGl0IGlzLiBTZWUgYGFkZGAgYW5kIGByZW1vdmVgXG4gKiBpZiB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IGV2ZW50cyBpbnN0ZWFkIG9mIGEgdG9nZ2xlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbXVsdGk9ZmFsc2VdIEEgYm9vbGVhbiB0aGF0IGRldGVybWluZXMgaWYgdGhlIGRlZmF1bHRcbiAqIGJlaGF2aW91ciBzaG91bGQgc2VsZWN0IG9ubHkgc2luZ2xlIGZlYXR1cmVzIG9yIGFsbCAob3ZlcmxhcHBpbmcpIGZlYXR1cmVzIGF0XG4gKiB0aGUgY2xpY2tlZCBtYXAgcG9zaXRpb24uIFRoZSBkZWZhdWx0IG9mIGBmYWxzZWAgbWVhbnMgc2luZ2xlIHNlbGVjdC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn0gW2ZlYXR1cmVzXVxuICogQ29sbGVjdGlvbiB3aGVyZSB0aGUgaW50ZXJhY3Rpb24gd2lsbCBwbGFjZSBzZWxlY3RlZCBmZWF0dXJlcy4gT3B0aW9uYWwuIElmXG4gKiBub3Qgc2V0IHRoZSBpbnRlcmFjdGlvbiB3aWxsIGNyZWF0ZSBhIGNvbGxlY3Rpb24uIEluIGFueSBjYXNlIHRoZSBjb2xsZWN0aW9uXG4gKiB1c2VkIGJ5IHRoZSBpbnRlcmFjdGlvbiBpcyByZXR1cm5lZCBieVxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0I2dldEZlYXR1cmVzfS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5GaWx0ZXJGdW5jdGlvbn0gW2ZpbHRlcl0gQSBmdW5jdGlvblxuICogdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn0gYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSBmZWF0dXJlIG1heSBiZVxuICogc2VsZWN0ZWQgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXcmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkgb24gdGhlIHNlbGVjdGlvblxuICogb3ZlcmxheS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlXG4gKiB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5XG4gKiB3b3JrcyBmb3IgdGhlIGNhbnZhcyByZW5kZXJlciBhbmQgbm90IGZvciBXZWJHTC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG52YXIgU2VsZWN0RXZlbnQgPSAoZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFNlbGVjdEV2ZW50KHR5cGUsIHNlbGVjdGVkLCBkZXNlbGVjdGVkLCBtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogU2VsZWN0ZWQgZmVhdHVyZXMgYXJyYXkuXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0ZWQgZmVhdHVyZXMgYXJyYXkuXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZGVzZWxlY3RlZCA9IGRlc2VsZWN0ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fS5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5tYXBCcm93c2VyRXZlbnQgPSBtYXBCcm93c2VyRXZlbnQ7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBTZWxlY3RFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgU2VsZWN0RXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIFNlbGVjdEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdEV2ZW50O1xuXG4gIHJldHVybiBTZWxlY3RFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEludGVyYWN0aW9uIGZvciBzZWxlY3RpbmcgdmVjdG9yIGZlYXR1cmVzLiBCeSBkZWZhdWx0LCBzZWxlY3RlZCBmZWF0dXJlcyBhcmVcbiAqIHN0eWxlZCBkaWZmZXJlbnRseSwgc28gdGhpcyBpbnRlcmFjdGlvbiBjYW4gYmUgdXNlZCBmb3IgdmlzdWFsIGhpZ2hsaWdodGluZyxcbiAqIGFzIHdlbGwgYXMgc2VsZWN0aW5nIGZlYXR1cmVzIGZvciBvdGhlciBhY3Rpb25zLCBzdWNoIGFzIG1vZGlmaWNhdGlvbiBvclxuICogb3V0cHV0LiBUaGVyZSBhcmUgdGhyZWUgd2F5cyBvZiBjb250cm9sbGluZyB3aGljaCBmZWF0dXJlcyBhcmUgc2VsZWN0ZWQ6XG4gKiB1c2luZyB0aGUgYnJvd3NlciBldmVudCBhcyBkZWZpbmVkIGJ5IHRoZSBgY29uZGl0aW9uYCBhbmQgb3B0aW9uYWxseSB0aGVcbiAqIGB0b2dnbGVgLCBgYWRkYC9gcmVtb3ZlYCwgYW5kIGBtdWx0aWAgb3B0aW9uczsgYSBgbGF5ZXJzYCBmaWx0ZXI7IGFuZCBhXG4gKiBmdXJ0aGVyIGZlYXR1cmUgZmlsdGVyIHVzaW5nIHRoZSBgZmlsdGVyYCBvcHRpb24uXG4gKlxuICogU2VsZWN0ZWQgZmVhdHVyZXMgYXJlIGFkZGVkIHRvIGFuIGludGVybmFsIHVubWFuYWdlZCBsYXllci5cbiAqXG4gKiBAZmlyZXMgU2VsZWN0RXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFNlbGVjdCA9IChmdW5jdGlvbiAoSW50ZXJhY3Rpb24pIHtcbiAgZnVuY3Rpb24gU2VsZWN0KG9wdF9vcHRpb25zKSB7XG5cbiAgICBJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IHNpbmdsZUNsaWNrO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+Q29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuYWRkQ29uZGl0aW9uXyA9IG9wdGlvbnMuYWRkQ29uZGl0aW9uID8gb3B0aW9ucy5hZGRDb25kaXRpb24gOiBuZXZlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUNvbmRpdGlvbl8gPSBvcHRpb25zLnJlbW92ZUNvbmRpdGlvbiA/IG9wdGlvbnMucmVtb3ZlQ29uZGl0aW9uIDogbmV2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy50b2dnbGVDb25kaXRpb25fID0gb3B0aW9ucy50b2dnbGVDb25kaXRpb24gPyBvcHRpb25zLnRvZ2dsZUNvbmRpdGlvbiA6IHNoaWZ0S2V5T25seTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tdWx0aV8gPSBvcHRpb25zLm11bHRpID8gb3B0aW9ucy5tdWx0aSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5GaWx0ZXJGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmZpbHRlcl8gPSBvcHRpb25zLmZpbHRlciA/IG9wdGlvbnMuZmlsdGVyIDogVFJVRTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdFRvbGVyYW5jZV8gPSBvcHRpb25zLmhpdFRvbGVyYW5jZSA/IG9wdGlvbnMuaGl0VG9sZXJhbmNlIDogMDtcblxuICAgIHZhciBmZWF0dXJlT3ZlcmxheSA9IG5ldyBWZWN0b3JMYXllcih7XG4gICAgICBzb3VyY2U6IG5ldyBWZWN0b3JTb3VyY2Uoe1xuICAgICAgICB1c2VTcGF0aWFsSW5kZXg6IGZhbHNlLFxuICAgICAgICBmZWF0dXJlczogb3B0aW9ucy5mZWF0dXJlcyxcbiAgICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFhcbiAgICAgIH0pLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUgPyBvcHRpb25zLnN0eWxlIDpcbiAgICAgICAgZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSxcbiAgICAgIHVwZGF0ZVdoaWxlQW5pbWF0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlV2hpbGVJbnRlcmFjdGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVPdmVybGF5XyA9IGZlYXR1cmVPdmVybGF5O1xuXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBib29sZWFufSAqL1xuICAgIHZhciBsYXllckZpbHRlcjtcbiAgICBpZiAob3B0aW9ucy5sYXllcnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sYXllcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBvcHRpb25zLmxheWVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsYXllcnMgPSBvcHRpb25zLmxheWVycztcbiAgICAgICAgbGF5ZXJGaWx0ZXIgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyhsYXllcnMsIGxheWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJGaWx0ZXIgPSBUUlVFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG1vZHVsZTpvbC9sYXllci9MYXllcik6IGJvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sYXllckZpbHRlcl8gPSBsYXllckZpbHRlcjtcblxuICAgIC8qKlxuICAgICAqIEFuIGFzc29jaWF0aW9uIGJldHdlZW4gc2VsZWN0ZWQgZmVhdHVyZSAoa2V5KVxuICAgICAqIGFuZCBsYXllciAodmFsdWUpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIG1vZHVsZTpvbC9sYXllci9MYXllcj59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSB7fTtcblxuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZU92ZXJsYXlfLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzQ29sbGVjdGlvbigpO1xuICAgIGxpc3RlbihmZWF0dXJlcywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICB0aGlzLmFkZEZlYXR1cmVfLCB0aGlzKTtcbiAgICBsaXN0ZW4oZmVhdHVyZXMsIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJhY3Rpb24gKSBTZWxlY3QuX19wcm90b19fID0gSW50ZXJhY3Rpb247XG4gIFNlbGVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmFjdGlvbiAmJiBJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgU2VsZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlbGVjdDtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9IGxheWVyIExheWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5hZGRGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSBmdW5jdGlvbiBhZGRGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gKGZlYXR1cmUsIGxheWVyKSB7XG4gICAgdmFyIGtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICB0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uX1trZXldID0gbGF5ZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59IEZlYXR1cmVzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiBnZXRGZWF0dXJlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmVhdHVyZU92ZXJsYXlfLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzQ29sbGVjdGlvbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS5cbiAgICogQHJldHVybnMge251bWJlcn0gSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuZ2V0SGl0VG9sZXJhbmNlID0gZnVuY3Rpb24gZ2V0SGl0VG9sZXJhbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUb2xlcmFuY2VfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvVmVjdG9yflZlY3RvciB2ZWN0b3JsYXllcn0gb2ZcbiAgICogdGhlIChsYXN0KSBzZWxlY3RlZCBmZWF0dXJlLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCB3b3JrIHdpdGggYW55XG4gICAqIHByb2dyYW1tYXRpYyBtZXRob2QgbGlrZSBwdXNoaW5nIGZlYXR1cmVzIHRvXG4gICAqIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU2VsZWN0flNlbGVjdCNnZXRGZWF0dXJlcyBjb2xsZWN0aW9ufS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfSBMYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uIGdldExheWVyIChmZWF0dXJlKSB7XG4gICAgdmFyIGtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfSAqLyAodGhpcy5mZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl9ba2V5XSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaXQtZGV0ZWN0aW9uIHRvbGVyYW5jZS4gUGl4ZWxzIGluc2lkZSB0aGUgcmFkaXVzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb25cbiAgICogd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aGUgY2FudmFzIHJlbmRlcmVyIGFuZFxuICAgKiBub3QgZm9yIFdlYkdMLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBTZWxlY3QucHJvdG90eXBlLnNldEhpdFRvbGVyYW5jZSA9IGZ1bmN0aW9uIHNldEhpdFRvbGVyYW5jZSAoaGl0VG9sZXJhbmNlKSB7XG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gaGl0VG9sZXJhbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGludGVyYWN0aW9uIGZyb20gaXRzIGN1cnJlbnQgbWFwLCBpZiBhbnksICBhbmQgYXR0YWNoIGl0IHRvIGEgbmV3XG4gICAqIG1hcCwgaWYgYW55LiBQYXNzIGBudWxsYCB0byBqdXN0IHJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSB0aGUgY3VycmVudCBtYXAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gbWFwIE1hcC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICB2YXIgY3VycmVudE1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdmFyIHNlbGVjdGVkRmVhdHVyZXMgPVxuICAgICAgICB0aGlzLmZlYXR1cmVPdmVybGF5Xy5nZXRTb3VyY2UoKS5nZXRGZWF0dXJlc0NvbGxlY3Rpb24oKTtcbiAgICBpZiAoY3VycmVudE1hcCkge1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlcy5mb3JFYWNoKGN1cnJlbnRNYXAudW5za2lwRmVhdHVyZS5iaW5kKGN1cnJlbnRNYXApKTtcbiAgICB9XG4gICAgSW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgdGhpcy5mZWF0dXJlT3ZlcmxheV8uc2V0TWFwKG1hcCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgc2VsZWN0ZWRGZWF0dXJlcy5mb3JFYWNoKG1hcC5za2lwRmVhdHVyZS5iaW5kKG1hcCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUuYWRkRmVhdHVyZV8gPSBmdW5jdGlvbiBhZGRGZWF0dXJlXyAoZXZ0KSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgbWFwLnNraXBGZWF0dXJlKC8qKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9ICovIChldnQuZWxlbWVudCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNlbGVjdC5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZV8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlXyAoZXZ0KSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgaWYgKG1hcCkge1xuICAgICAgbWFwLnVuc2tpcEZlYXR1cmUoLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU2VsZWN0LnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlTGF5ZXJBc3NvY2lhdGlvbl8gKGZlYXR1cmUpIHtcbiAgICB2YXIga2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uX1trZXldO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3Q7XG59KEludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gYW5kIG1heSBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBzdGF0ZSBvZiBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBpZiAoIXRoaXMuY29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGFkZCA9IHRoaXMuYWRkQ29uZGl0aW9uXyhtYXBCcm93c2VyRXZlbnQpO1xuICB2YXIgcmVtb3ZlID0gdGhpcy5yZW1vdmVDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCk7XG4gIHZhciB0b2dnbGUgPSB0aGlzLnRvZ2dsZUNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KTtcbiAgdmFyIHNldCA9ICFhZGQgJiYgIXJlbW92ZSAmJiAhdG9nZ2xlO1xuICB2YXIgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlT3ZlcmxheV8uZ2V0U291cmNlKCkuZ2V0RmVhdHVyZXNDb2xsZWN0aW9uKCk7XG4gIHZhciBkZXNlbGVjdGVkID0gW107XG4gIHZhciBzZWxlY3RlZCA9IFtdO1xuICBpZiAoc2V0KSB7XG4gICAgLy8gUmVwbGFjZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZlYXR1cmUocykgd2l0aCB0aGUgZmVhdHVyZShzKSBhdCB0aGVcbiAgICAvLyBwaXhlbCwgb3IgY2xlYXIgdGhlIHNlbGVjdGVkIGZlYXR1cmUocykgaWYgdGhlcmUgaXMgbm8gZmVhdHVyZSBhdFxuICAgIC8vIHRoZSBwaXhlbC5cbiAgICBjbGVhcih0aGlzLmZlYXR1cmVMYXllckFzc29jaWF0aW9uXyk7XG4gICAgbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChtYXBCcm93c2VyRXZlbnQucGl4ZWwsXG4gICAgICAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn0gbGF5ZXIgTGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBDb250aW51ZSB0byBpdGVyYXRlIG92ZXIgdGhlIGZlYXR1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJfKGZlYXR1cmUsIGxheWVyKSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUsIGxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5tdWx0aV87XG4gICAgICAgICAgfVxuICAgICAgICB9KS5iaW5kKHRoaXMpLCB7XG4gICAgICAgIGxheWVyRmlsdGVyOiB0aGlzLmxheWVyRmlsdGVyXyxcbiAgICAgICAgaGl0VG9sZXJhbmNlOiB0aGlzLmhpdFRvbGVyYW5jZV9cbiAgICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSBmZWF0dXJlcy5nZXRMZW5ndGgoKSAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzLml0ZW0oaSk7XG4gICAgICB2YXIgaW5kZXggPSBzZWxlY3RlZC5pbmRleE9mKGZlYXR1cmUpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgIHNlbGVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZWF0dXJlcy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICAgIGRlc2VsZWN0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZmVhdHVyZXMuZXh0ZW5kKHNlbGVjdGVkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTW9kaWZ5IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmVhdHVyZShzKS5cbiAgICBtYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKG1hcEJyb3dzZXJFdmVudC5waXhlbCxcbiAgICAgIChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllciBMYXllci5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IENvbnRpbnVlIHRvIGl0ZXJhdGUgb3ZlciB0aGUgZmVhdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlLCBsYXllcikge1xuICAgICAgICAgIGlmICh0aGlzLmZpbHRlcl8oZmVhdHVyZSwgbGF5ZXIpKSB7XG4gICAgICAgICAgICBpZiAoKGFkZCB8fCB0b2dnbGUpICYmICFpbmNsdWRlcyhmZWF0dXJlcy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICB0aGlzLmFkZEZlYXR1cmVMYXllckFzc29jaWF0aW9uXyhmZWF0dXJlLCBsYXllcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChyZW1vdmUgfHwgdG9nZ2xlKSAmJiBpbmNsdWRlcyhmZWF0dXJlcy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgICAgICBkZXNlbGVjdGVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZUxheWVyQXNzb2NpYXRpb25fKGZlYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm11bHRpXztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcyksIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMubGF5ZXJGaWx0ZXJfLFxuICAgICAgICBoaXRUb2xlcmFuY2U6IHRoaXMuaGl0VG9sZXJhbmNlX1xuICAgICAgfSk7XG4gICAgZm9yICh2YXIgaiA9IGRlc2VsZWN0ZWQubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgIGZlYXR1cmVzLnJlbW92ZShkZXNlbGVjdGVkW2pdKTtcbiAgICB9XG4gICAgZmVhdHVyZXMuZXh0ZW5kKHNlbGVjdGVkKTtcbiAgfVxuICBpZiAoc2VsZWN0ZWQubGVuZ3RoID4gMCB8fCBkZXNlbGVjdGVkLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgU2VsZWN0RXZlbnQoU2VsZWN0RXZlbnRUeXBlLlNFTEVDVCxcbiAgICAgICAgc2VsZWN0ZWQsIGRlc2VsZWN0ZWQsIG1hcEJyb3dzZXJFdmVudCkpO1xuICB9XG4gIHJldHVybiBwb2ludGVyTW92ZShtYXBCcm93c2VyRXZlbnQpO1xufVxuXG5cbi8qKlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFN0eWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlRnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVFZGl0aW5nU3R5bGUoKTtcbiAgZXh0ZW5kKHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0sIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddKTtcbiAgZXh0ZW5kKHN0eWxlc1tHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTl0sIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAgIGlmICghZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlc1tmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0VHlwZSgpXTtcbiAgfTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbGVjdC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vU25hcFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge0NvbGxlY3Rpb25FdmVudH0gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZGlzdGFuY2UgYXMgY29vcmRpbmF0ZURpc3RhbmNlLCBzcXVhcmVkRGlzdGFuY2UgYXMgc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSwgY2xvc2VzdE9uQ2lyY2xlLCBjbG9zZXN0T25TZWdtZW50LCBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnR9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgY3JlYXRlRW1wdHl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUUsIEZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge2Zyb21DaXJjbGV9IGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uLCB7aGFuZGxlRXZlbnQgYXMgaGFuZGxlUG9pbnRlckV2ZW50fSBmcm9tICcuLi9pbnRlcmFjdGlvbi9Qb2ludGVyLmpzJztcbmltcG9ydCB7Z2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtWZWN0b3JTb3VyY2VFdmVudH0gZnJvbSAnLi4vc291cmNlL1ZlY3Rvci5qcyc7XG5pbXBvcnQgVmVjdG9yRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJCdXNoIGZyb20gJy4uL3N0cnVjdHMvUkJ1c2guanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNuYXBwZWRcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXxudWxsfSB2ZXJ0ZXhcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfG51bGx9IHZlcnRleFBpeGVsXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnREYXRhXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn0gc2VnbWVudFxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59IFtmZWF0dXJlc10gU25hcCB0byB0aGVzZSBmZWF0dXJlcy4gRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHNvdXJjZSBzaG91bGQgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlZGdlPXRydWVdIFNuYXAgdG8gZWRnZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2ZXJ0ZXg9dHJ1ZV0gU25hcCB0byB2ZXJ0aWNlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGl4ZWxUb2xlcmFuY2U9MTBdIFBpeGVsIHRvbGVyYW5jZSBmb3IgY29uc2lkZXJpbmcgdGhlIHBvaW50ZXIgY2xvc2UgZW5vdWdoIHRvIGEgc2VnbWVudCBvclxuICogdmVydGV4IGZvciBzbmFwcGluZy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IFtzb3VyY2VdIFNuYXAgdG8gZmVhdHVyZXMgZnJvbSB0aGlzIHNvdXJjZS4gRWl0aGVyIHRoaXMgb3B0aW9uIG9yIGZlYXR1cmVzIHNob3VsZCBiZSBwcm92aWRlZFxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBIYW5kbGVzIHNuYXBwaW5nIG9mIHZlY3RvciBmZWF0dXJlcyB3aGlsZSBtb2RpZnlpbmcgb3IgZHJhd2luZyB0aGVtLiAgVGhlXG4gKiBmZWF0dXJlcyBjYW4gY29tZSBmcm9tIGEge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBvciB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn1cbiAqIEFueSBpbnRlcmFjdGlvbiBvYmplY3QgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gaW50ZXJhY3RcbiAqIHdpdGggdGhlIGZlYXR1cmVzIHVzaW5nIHRoZSBtb3VzZSBjYW4gYmVuZWZpdCBmcm9tIHRoZSBzbmFwcGluZywgYXMgbG9uZ1xuICogYXMgaXQgaXMgYWRkZWQgYmVmb3JlLlxuICpcbiAqIFRoZSBzbmFwIGludGVyYWN0aW9uIG1vZGlmaWVzIG1hcCBicm93c2VyIGV2ZW50IGBjb29yZGluYXRlYCBhbmQgYHBpeGVsYFxuICogcHJvcGVydGllcyB0byBmb3JjZSB0aGUgc25hcCB0byBvY2N1ciB0byBhbnkgaW50ZXJhY3Rpb24gdGhhdCB0aGVtLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCBTbmFwIGZyb20gJ29sL2ludGVyYWN0aW9uL1NuYXAnO1xuICpcbiAqICAgICB2YXIgc25hcCA9IG5ldyBTbmFwKHtcbiAqICAgICAgIHNvdXJjZTogc291cmNlXG4gKiAgICAgfSk7XG4gKlxuICogQGFwaVxuICovXG52YXIgU25hcCA9IChmdW5jdGlvbiAoUG9pbnRlckludGVyYWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNuYXAob3B0X29wdGlvbnMpIHtcblxuICAgIFBvaW50ZXJJbnRlcmFjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudCxcbiAgICAgIGhhbmRsZURvd25FdmVudDogVFJVRSxcbiAgICAgIGhhbmRsZVVwRXZlbnQ6IGhhbmRsZVVwRXZlbnQsXG4gICAgICBzdG9wRG93bjogRkFMU0VcbiAgICB9KTtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VfID0gb3B0aW9ucy5zb3VyY2UgPyBvcHRpb25zLnNvdXJjZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudmVydGV4XyA9IG9wdGlvbnMudmVydGV4ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnZlcnRleCA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZWRnZV8gPSBvcHRpb25zLmVkZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZWRnZSA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZXNfID0gb3B0aW9ucy5mZWF0dXJlcyA/IG9wdGlvbnMuZmVhdHVyZXMgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLCBtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VMaXN0ZW5lcktleXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnRzIGFyZSBwcmVzZXJ2ZWQgc28gaW5kZXhlZCBzZWdtZW50IGNhbiBiZSBxdWlja2x5IHJlbW92ZWRcbiAgICAgKiB3aGVuIGl0cyBmZWF0dXJlIGdlb21ldHJ5IGNoYW5nZXNcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIElmIGEgZmVhdHVyZSBnZW9tZXRyeSBjaGFuZ2VzIHdoaWxlIGEgcG9pbnRlciBkcmFnfG1vdmUgZXZlbnQgb2NjdXJzLCB0aGVcbiAgICAgKiBmZWF0dXJlIGRvZXNuJ3QgZ2V0IHVwZGF0ZWQgcmlnaHQgYXdheS4gIEl0IHdpbGwgYmUgYXQgdGhlIG5leHQgJ3BvaW50ZXJ1cCdcbiAgICAgKiBldmVudCBmaXJlZC5cbiAgICAgKiBAdHlwZSB7IU9iamVjdC48bnVtYmVyLCBtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGRpc3RhbmNlIHNvcnRpbmcgaW4gc29ydEJ5RGlzdGFuY2VfXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxUb2xlcmFuY2VfID0gb3B0aW9ucy5waXhlbFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxUb2xlcmFuY2UgOiAxMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YSwgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1NuYXB+U2VnbWVudERhdGEpOiBudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvcnRCeURpc3RhbmNlXyA9IHNvcnRCeURpc3RhbmNlLmJpbmQodGhpcyk7XG5cblxuICAgIC8qKlxuICAgICogU2VnbWVudCBSVHJlZSBmb3IgZWFjaCBsYXllclxuICAgICogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL1JCdXNoLjxtb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YT59XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5yQnVzaF8gPSBuZXcgUkJ1c2goKTtcblxuXG4gICAgLyoqXG4gICAgKiBAY29uc3RcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKG1vZHVsZTpvbC9GZWF0dXJlLCBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeSk+fVxuICAgICovXG4gICAgdGhpcy5TRUdNRU5UX1dSSVRFUlNfID0ge1xuICAgICAgJ1BvaW50JzogdGhpcy53cml0ZVBvaW50R2VvbWV0cnlfLFxuICAgICAgJ0xpbmVTdHJpbmcnOiB0aGlzLndyaXRlTGluZVN0cmluZ0dlb21ldHJ5XyxcbiAgICAgICdMaW5lYXJSaW5nJzogdGhpcy53cml0ZUxpbmVTdHJpbmdHZW9tZXRyeV8sXG4gICAgICAnUG9seWdvbic6IHRoaXMud3JpdGVQb2x5Z29uR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9pbnQnOiB0aGlzLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyxcbiAgICAgICdNdWx0aUxpbmVTdHJpbmcnOiB0aGlzLndyaXRlTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnlfLFxuICAgICAgJ011bHRpUG9seWdvbic6IHRoaXMud3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8sXG4gICAgICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogdGhpcy53cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5XyxcbiAgICAgICdDaXJjbGUnOiB0aGlzLndyaXRlQ2lyY2xlR2VvbWV0cnlfXG4gICAgfTtcbiAgfVxuXG4gIGlmICggUG9pbnRlckludGVyYWN0aW9uICkgU25hcC5fX3Byb3RvX18gPSBQb2ludGVySW50ZXJhY3Rpb247XG4gIFNuYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgU25hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbmFwO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBmZWF0dXJlIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZlYXR1cmVzIHRoYXQgd2UgbWF5IHNuYXAgdG8uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2xpc3RlbiBXaGV0aGVyIHRvIGxpc3RlbiB0byB0aGUgZmVhdHVyZSBjaGFuZ2Ugb3Igbm90XG4gICAqICAgICBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBhcGlcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiBhZGRGZWF0dXJlIChmZWF0dXJlLCBvcHRfbGlzdGVuKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gb3B0X2xpc3RlbiAhPT0gdW5kZWZpbmVkID8gb3B0X2xpc3RlbiA6IHRydWU7XG4gICAgdmFyIGZlYXR1cmVfdWlkID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBzZWdtZW50V3JpdGVyID0gdGhpcy5TRUdNRU5UX1dSSVRFUlNfW2dlb21ldHJ5LmdldFR5cGUoKV07XG4gICAgICBpZiAoc2VnbWVudFdyaXRlcikge1xuICAgICAgICB0aGlzLmluZGV4ZWRGZWF0dXJlc0V4dGVudHNfW2ZlYXR1cmVfdWlkXSA9IGdlb21ldHJ5LmdldEV4dGVudChjcmVhdGVFbXB0eSgpKTtcbiAgICAgICAgc2VnbWVudFdyaXRlci5jYWxsKHRoaXMsIGZlYXR1cmUsIGdlb21ldHJ5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c19bZmVhdHVyZV91aWRdID0gbGlzdGVuKFxuICAgICAgICBmZWF0dXJlLFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQWRkXyA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQWRkXyAoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVSZW1vdmVfID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVSZW1vdmVfIChmZWF0dXJlKSB7XG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlKGZlYXR1cmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fEFycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT59IEZlYXR1cmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUuZ2V0RmVhdHVyZXNfID0gZnVuY3Rpb24gZ2V0RmVhdHVyZXNfICgpIHtcbiAgICB2YXIgZmVhdHVyZXM7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNfKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNfO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2VfKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuc291cmNlXy5nZXRGZWF0dXJlcygpO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHshQXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPnwhbW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn0gKi8gKGZlYXR1cmVzKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J8bW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbkV2ZW50fSBldnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS5oYW5kbGVGZWF0dXJlQWRkXyA9IGZ1bmN0aW9uIGhhbmRsZUZlYXR1cmVBZGRfIChldnQpIHtcbiAgICB2YXIgZmVhdHVyZTtcbiAgICBpZiAoZXZ0IGluc3RhbmNlb2YgVmVjdG9yU291cmNlRXZlbnQpIHtcbiAgICAgIGZlYXR1cmUgPSBldnQuZmVhdHVyZTtcbiAgICB9IGVsc2UgaWYgKGV2dCBpbnN0YW5jZW9mIENvbGxlY3Rpb25FdmVudCkge1xuICAgICAgZmVhdHVyZSA9IGV2dC5lbGVtZW50O1xuICAgIH1cbiAgICB0aGlzLmFkZEZlYXR1cmUoLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGZlYXR1cmUpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcnxtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVSZW1vdmVfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZVJlbW92ZV8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlO1xuICAgIGlmIChldnQgaW5zdGFuY2VvZiBWZWN0b3JTb3VyY2VFdmVudCkge1xuICAgICAgZmVhdHVyZSA9IGV2dC5mZWF0dXJlO1xuICAgIH0gZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgQ29sbGVjdGlvbkV2ZW50KSB7XG4gICAgICBmZWF0dXJlID0gZXZ0LmVsZW1lbnQ7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlRmVhdHVyZSgvKiogQHR5cGUge21vZHVsZTpvbC9GZWF0dXJlfSAqLyAoZmVhdHVyZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2dCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLmhhbmRsZUZlYXR1cmVDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRmVhdHVyZUNoYW5nZV8gKGV2dCkge1xuICAgIHZhciBmZWF0dXJlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGV2dC50YXJnZXQpO1xuICAgIGlmICh0aGlzLmhhbmRsaW5nRG93blVwU2VxdWVuY2UpIHtcbiAgICAgIHZhciB1aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgICBpZiAoISh1aWQgaW4gdGhpcy5wZW5kaW5nRmVhdHVyZXNfKSkge1xuICAgICAgICB0aGlzLnBlbmRpbmdGZWF0dXJlc19bdWlkXSA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRmVhdHVyZV8oZmVhdHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmZWF0dXJlIGZyb20gdGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMgdGhhdCB3ZSBtYXkgc25hcCB0by5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF91bmxpc3RlbiBXaGV0aGVyIHRvIHVubGlzdGVuIHRvIHRoZSBmZWF0dXJlIGNoYW5nZVxuICAgKiAgICAgb3Igbm90LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBhcGlcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnJlbW92ZUZlYXR1cmUgPSBmdW5jdGlvbiByZW1vdmVGZWF0dXJlIChmZWF0dXJlLCBvcHRfdW5saXN0ZW4pIHtcbiAgICB2YXIgdW5yZWdpc3RlciA9IG9wdF91bmxpc3RlbiAhPT0gdW5kZWZpbmVkID8gb3B0X3VubGlzdGVuIDogdHJ1ZTtcbiAgICB2YXIgZmVhdHVyZV91aWQgPSBnZXRVaWQoZmVhdHVyZSk7XG4gICAgdmFyIGV4dGVudCA9IHRoaXMuaW5kZXhlZEZlYXR1cmVzRXh0ZW50c19bZmVhdHVyZV91aWRdO1xuICAgIGlmIChleHRlbnQpIHtcbiAgICAgIHZhciByQnVzaCA9IHRoaXMuckJ1c2hfO1xuICAgICAgdmFyIG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgIHJCdXNoLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgPT09IG5vZGUuZmVhdHVyZSkge1xuICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gbm9kZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICByQnVzaC5yZW1vdmUobm9kZXNUb1JlbW92ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVucmVnaXN0ZXIpIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5mZWF0dXJlQ2hhbmdlTGlzdGVuZXJLZXlzX1tmZWF0dXJlX3VpZF0pO1xuICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZUNoYW5nZUxpc3RlbmVyS2V5c19bZmVhdHVyZV91aWRdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIGN1cnJlbnRNYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBrZXlzID0gdGhpcy5mZWF0dXJlc0xpc3RlbmVyS2V5c187XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5nZXRGZWF0dXJlc18oKTtcblxuICAgIGlmIChjdXJyZW50TWFwKSB7XG4gICAgICBrZXlzLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICBrZXlzLmxlbmd0aCA9IDA7XG4gICAgICBmZWF0dXJlcy5mb3JFYWNoKHRoaXMuZm9yRWFjaEZlYXR1cmVSZW1vdmVfLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBQb2ludGVySW50ZXJhY3Rpb24ucHJvdG90eXBlLnNldE1hcC5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICBpZiAobWFwKSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc18pIHtcbiAgICAgICAga2V5cy5wdXNoKFxuICAgICAgICAgIGxpc3Rlbih0aGlzLmZlYXR1cmVzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVBZGRfLCB0aGlzKSxcbiAgICAgICAgICBsaXN0ZW4odGhpcy5mZWF0dXJlc18sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXywgdGhpcylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zb3VyY2VfKSB7XG4gICAgICAgIGtleXMucHVzaChcbiAgICAgICAgICBsaXN0ZW4odGhpcy5zb3VyY2VfLCBWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSxcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUFkZF8sIHRoaXMpLFxuICAgICAgICAgIGxpc3Rlbih0aGlzLnNvdXJjZV8sIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlUmVtb3ZlXywgdGhpcylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLmZvckVhY2godGhpcy5mb3JFYWNoRmVhdHVyZUFkZF8uYmluZCh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgUGl4ZWxcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwaXhlbENvb3JkaW5hdGUgQ29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG1hcCBNYXAuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TbmFwflJlc3VsdH0gU25hcCByZXN1bHRcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnNuYXBUbyA9IGZ1bmN0aW9uIHNuYXBUbyAocGl4ZWwsIHBpeGVsQ29vcmRpbmF0ZSwgbWFwKSB7XG5cbiAgICB2YXIgbG93ZXJMZWZ0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoXG4gICAgICBbcGl4ZWxbMF0gLSB0aGlzLnBpeGVsVG9sZXJhbmNlXywgcGl4ZWxbMV0gKyB0aGlzLnBpeGVsVG9sZXJhbmNlX10pO1xuICAgIHZhciB1cHBlclJpZ2h0ID0gbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwoXG4gICAgICBbcGl4ZWxbMF0gKyB0aGlzLnBpeGVsVG9sZXJhbmNlXywgcGl4ZWxbMV0gLSB0aGlzLnBpeGVsVG9sZXJhbmNlX10pO1xuICAgIHZhciBib3ggPSBib3VuZGluZ0V4dGVudChbbG93ZXJMZWZ0LCB1cHBlclJpZ2h0XSk7XG5cbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnJCdXNoXy5nZXRJbkV4dGVudChib3gpO1xuXG4gICAgLy8gSWYgc25hcHBpbmcgb24gdmVydGljZXMgb25seSwgZG9uJ3QgY29uc2lkZXIgY2lyY2xlc1xuICAgIGlmICh0aGlzLnZlcnRleF8gJiYgIXRoaXMuZWRnZV8pIHtcbiAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQuZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldFR5cGUoKSAhPT1cbiAgICAgICAgICAgIEdlb21ldHJ5VHlwZS5DSVJDTEU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZFRvVmVydGV4ID0gZmFsc2U7XG4gICAgdmFyIHNuYXBwZWQgPSBmYWxzZTtcbiAgICB2YXIgdmVydGV4ID0gbnVsbDtcbiAgICB2YXIgdmVydGV4UGl4ZWwgPSBudWxsO1xuICAgIHZhciBkaXN0LCBwaXhlbDEsIHBpeGVsMiwgc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDI7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlXyA9IHBpeGVsQ29vcmRpbmF0ZTtcbiAgICAgIHNlZ21lbnRzLnNvcnQodGhpcy5zb3J0QnlEaXN0YW5jZV8pO1xuICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50ID0gc2VnbWVudHNbMF0uc2VnbWVudDtcbiAgICAgIHZhciBpc0NpcmNsZSA9IHNlZ21lbnRzWzBdLmZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRUeXBlKCkgPT09XG4gICAgICAgICAgR2VvbWV0cnlUeXBlLkNJUkNMRTtcbiAgICAgIGlmICh0aGlzLnZlcnRleF8gJiYgIXRoaXMuZWRnZV8pIHtcbiAgICAgICAgcGl4ZWwxID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2xvc2VzdFNlZ21lbnRbMF0pO1xuICAgICAgICBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgIHNxdWFyZWREaXN0MSA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHBpeGVsMSk7XG4gICAgICAgIHNxdWFyZWREaXN0MiA9IHNxdWFyZWRDb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHBpeGVsMik7XG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgc25hcHBlZFRvVmVydGV4ID0gZGlzdCA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXztcbiAgICAgICAgaWYgKHNuYXBwZWRUb1ZlcnRleCkge1xuICAgICAgICAgIHNuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/IGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgICAgdmVydGV4UGl4ZWwgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZSh2ZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWRnZV8pIHtcbiAgICAgICAgaWYgKGlzQ2lyY2xlKSB7XG4gICAgICAgICAgdmVydGV4ID0gY2xvc2VzdE9uQ2lyY2xlKHBpeGVsQ29vcmRpbmF0ZSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSAqLyAoc2VnbWVudHNbMF0uZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmVydGV4ID0gY2xvc2VzdE9uU2VnbWVudChwaXhlbENvb3JkaW5hdGUsIGNsb3Nlc3RTZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2ZXJ0ZXhQaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKHZlcnRleCk7XG4gICAgICAgIGlmIChjb29yZGluYXRlRGlzdGFuY2UocGl4ZWwsIHZlcnRleFBpeGVsKSA8PSB0aGlzLnBpeGVsVG9sZXJhbmNlXykge1xuICAgICAgICAgIHNuYXBwZWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLnZlcnRleF8gJiYgIWlzQ2lyY2xlKSB7XG4gICAgICAgICAgICBwaXhlbDEgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFswXSk7XG4gICAgICAgICAgICBwaXhlbDIgPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjbG9zZXN0U2VnbWVudFsxXSk7XG4gICAgICAgICAgICBzcXVhcmVkRGlzdDEgPSBzcXVhcmVkQ29vcmRpbmF0ZURpc3RhbmNlKHZlcnRleFBpeGVsLCBwaXhlbDEpO1xuICAgICAgICAgICAgc3F1YXJlZERpc3QyID0gc3F1YXJlZENvb3JkaW5hdGVEaXN0YW5jZSh2ZXJ0ZXhQaXhlbCwgcGl4ZWwyKTtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoTWF0aC5taW4oc3F1YXJlZERpc3QxLCBzcXVhcmVkRGlzdDIpKTtcbiAgICAgICAgICAgIHNuYXBwZWRUb1ZlcnRleCA9IGRpc3QgPD0gdGhpcy5waXhlbFRvbGVyYW5jZV87XG4gICAgICAgICAgICBpZiAoc25hcHBlZFRvVmVydGV4KSB7XG4gICAgICAgICAgICAgIHZlcnRleCA9IHNxdWFyZWREaXN0MSA+IHNxdWFyZWREaXN0MiA/IGNsb3Nlc3RTZWdtZW50WzFdIDogY2xvc2VzdFNlZ21lbnRbMF07XG4gICAgICAgICAgICAgIHZlcnRleFBpeGVsID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUodmVydGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzbmFwcGVkKSB7XG4gICAgICAgIHZlcnRleFBpeGVsID0gW01hdGgucm91bmQodmVydGV4UGl4ZWxbMF0pLCBNYXRoLnJvdW5kKHZlcnRleFBpeGVsWzFdKV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TbmFwflJlc3VsdH0gKi8gKHtcbiAgICAgICAgc25hcHBlZDogc25hcHBlZCxcbiAgICAgICAgdmVydGV4OiB2ZXJ0ZXgsXG4gICAgICAgIHZlcnRleFBpeGVsOiB2ZXJ0ZXhQaXhlbFxuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLnVwZGF0ZUZlYXR1cmVfID0gZnVuY3Rpb24gdXBkYXRlRmVhdHVyZV8gKGZlYXR1cmUpIHtcbiAgICB0aGlzLnJlbW92ZUZlYXR1cmUoZmVhdHVyZSwgZmFsc2UpO1xuICAgIHRoaXMuYWRkRmVhdHVyZShmZWF0dXJlLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0NpcmNsZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZUNpcmNsZUdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlQ2lyY2xlR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb24gPSBmcm9tQ2lyY2xlKGdlb21ldHJ5KTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwb2x5Z29uLmdldENvb3JkaW5hdGVzKClbMF07XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBzZWdtZW50ID0gY29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgc2VnbWVudDogc2VnbWVudFxuICAgICAgfSk7XG4gICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVHZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnRXcml0ZXIgPSB0aGlzJDEuU0VHTUVOVF9XUklURVJTX1tnZW9tZXRyaWVzW2ldLmdldFR5cGUoKV07XG4gICAgICBpZiAoc2VnbWVudFdyaXRlcikge1xuICAgICAgICBzZWdtZW50V3JpdGVyLmNhbGwodGhpcyQxLCBmZWF0dXJlLCBnZW9tZXRyaWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVMaW5lU3RyaW5nR2VvbWV0cnlfIChmZWF0dXJlLCBnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TbmFwflNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICB9KTtcbiAgICAgIHRoaXMkMS5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgU25hcC5wcm90b3R5cGUud3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZU11bHRpTGluZVN0cmluZ0dlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsaW5lcyA9IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaiA9IDAsIGpqID0gbGluZXMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZXNbal07XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgdmFyIHNlZ21lbnREYXRhID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YX0gKi8gKHtcbiAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMkMS5yQnVzaF8uaW5zZXJ0KGJvdW5kaW5nRXh0ZW50KHNlZ21lbnQpLCBzZWdtZW50RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyA9IGZ1bmN0aW9uIHdyaXRlTXVsdGlQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2ludHMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBwb2ludHNbaV07XG4gICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TbmFwflNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICBzZWdtZW50OiBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXVxuICAgICAgfSk7XG4gICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChnZW9tZXRyeS5nZXRFeHRlbnQoKSwgc2VnbWVudERhdGEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFNuYXAucHJvdG90eXBlLndyaXRlTXVsdGlQb2x5Z29uR2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9seWdvbnMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGsgPSAwLCBrayA9IHBvbHlnb25zLmxlbmd0aDsgayA8IGtrOyArK2spIHtcbiAgICAgIHZhciByaW5ncyA9IHBvbHlnb25zW2tdO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gcmluZ3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSByaW5nc1tqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IGNvb3JkaW5hdGVzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICB2YXIgc2VnbWVudERhdGEgPSAvKiogQHR5cGUge21vZHVsZTpvbC9pbnRlcmFjdGlvbi9TbmFwflNlZ21lbnREYXRhfSAqLyAoe1xuICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHNlZ21lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmVcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9Qb2ludH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZVBvaW50R2VvbWV0cnlfID0gZnVuY3Rpb24gd3JpdGVQb2ludEdlb21ldHJ5XyAoZmVhdHVyZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NuYXB+U2VnbWVudERhdGF9ICovICh7XG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgc2VnbWVudDogW2Nvb3JkaW5hdGVzLCBjb29yZGluYXRlc11cbiAgICB9KTtcbiAgICB0aGlzLnJCdXNoXy5pbnNlcnQoZ2VvbWV0cnkuZ2V0RXh0ZW50KCksIHNlZ21lbnREYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vUG9seWdvbn0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBTbmFwLnByb3RvdHlwZS53cml0ZVBvbHlnb25HZW9tZXRyeV8gPSBmdW5jdGlvbiB3cml0ZVBvbHlnb25HZW9tZXRyeV8gKGZlYXR1cmUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGogPSAwLCBqaiA9IHJpbmdzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHJpbmdzW2pdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBjb29yZGluYXRlcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgIHZhciBzZWdtZW50RGF0YSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NuYXB+U2VnbWVudERhdGF9ICovICh7XG4gICAgICAgICAgZmVhdHVyZTogZmVhdHVyZSxcbiAgICAgICAgICBzZWdtZW50OiBzZWdtZW50XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzJDEuckJ1c2hfLmluc2VydChib3VuZGluZ0V4dGVudChzZWdtZW50KSwgc2VnbWVudERhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU25hcDtcbn0oUG9pbnRlckludGVyYWN0aW9uKSk7XG5cblxuLyoqXG4gKiBIYW5kbGUgYWxsIHBvaW50ZXIgZXZlbnRzIGV2ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gZXZ0IEEgbW92ZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFBhc3MgdGhlIGV2ZW50IHRvIG90aGVyIGludGVyYWN0aW9ucy5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2dCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5zbmFwVG8oZXZ0LnBpeGVsLCBldnQuY29vcmRpbmF0ZSwgZXZ0Lm1hcCk7XG4gIGlmIChyZXN1bHQuc25hcHBlZCkge1xuICAgIGV2dC5jb29yZGluYXRlID0gcmVzdWx0LnZlcnRleC5zbGljZSgwLCAyKTtcbiAgICBldnQucGl4ZWwgPSByZXN1bHQudmVydGV4UGl4ZWw7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZVBvaW50ZXJFdmVudC5jYWxsKHRoaXMsIGV2dCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBldnQgRXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBTdG9wIGRyYWcgc2VxdWVuY2U/XG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NuYXB9XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVVwRXZlbnQoZXZ0KSB7XG4gIHZhciBmZWF0dXJlc1RvVXBkYXRlID0gZ2V0VmFsdWVzKHRoaXMucGVuZGluZ0ZlYXR1cmVzXyk7XG4gIGlmIChmZWF0dXJlc1RvVXBkYXRlLmxlbmd0aCkge1xuICAgIGZlYXR1cmVzVG9VcGRhdGUuZm9yRWFjaCh0aGlzLnVwZGF0ZUZlYXR1cmVfLmJpbmQodGhpcykpO1xuICAgIHRoaXMucGVuZGluZ0ZlYXR1cmVzXyA9IHt9O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFNvcnQgc2VnbWVudHMgYnkgZGlzdGFuY2UsIGhlbHBlciBmdW5jdGlvblxuICogQHBhcmFtIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YX0gYSBUaGUgZmlyc3Qgc2VnbWVudCBkYXRhLlxuICogQHBhcmFtIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vU25hcH5TZWdtZW50RGF0YX0gYiBUaGUgc2Vjb25kIHNlZ21lbnQgZGF0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpZmZlcmVuY2UgaW4gZGlzdGFuY2UuXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1NuYXB9XG4gKi9cbmZ1bmN0aW9uIHNvcnRCeURpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIGRlbHRhQSA9IHNxdWFyZWREaXN0YW5jZVRvU2VnbWVudCh0aGlzLnBpeGVsQ29vcmRpbmF0ZV8sIGEuc2VnbWVudCk7XG4gIHZhciBkZWx0YUIgPSBzcXVhcmVkRGlzdGFuY2VUb1NlZ21lbnQodGhpcy5waXhlbENvb3JkaW5hdGVfLCBiLnNlZ21lbnQpO1xuICByZXR1cm4gZGVsdGFBIC0gZGVsdGFCO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTbmFwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbmFwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGVcbiAqL1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2luY2x1ZGVzfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4uL2ludGVyYWN0aW9uL1BvaW50ZXIuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uUHJvcGVydHkgZnJvbSAnLi4vaW50ZXJhY3Rpb24vUHJvcGVydHkuanMnO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xudmFyIFRyYW5zbGF0ZUV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgdHJhbnNsYXRpb24gc3RhcnQuXG4gICAqIEBldmVudCBUcmFuc2xhdGVFdmVudCN0cmFuc2xhdGVzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBUUkFOU0xBVEVTVEFSVDogJ3RyYW5zbGF0ZXN0YXJ0JyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgdHJhbnNsYXRpb24uXG4gICAqIEBldmVudCBUcmFuc2xhdGVFdmVudCN0cmFuc2xhdGluZ1xuICAgKiBAYXBpXG4gICAqL1xuICBUUkFOU0xBVElORzogJ3RyYW5zbGF0aW5nJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGZlYXR1cmUgdHJhbnNsYXRpb24gZW5kLlxuICAgKiBAZXZlbnQgVHJhbnNsYXRlRXZlbnQjdHJhbnNsYXRlZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIFRSQU5TTEFURUVORDogJ3RyYW5zbGF0ZWVuZCdcbn07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59IFtmZWF0dXJlc10gT25seSBmZWF0dXJlcyBjb250YWluZWQgaW4gdGhpcyBjb2xsZWN0aW9uIHdpbGwgYmUgYWJsZSB0byBiZSB0cmFuc2xhdGVkLiBJZlxuICogbm90IHNwZWNpZmllZCwgYWxsIGZlYXR1cmVzIG9uIHRoZSBtYXAgd2lsbCBiZSBhYmxlIHRvIGJlIHRyYW5zbGF0ZWQuXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXI+fGZ1bmN0aW9uKG1vZHVsZTpvbC9sYXllci9MYXllcik6IGJvb2xlYW59IFtsYXllcnNdIEEgbGlzdCBvZiBsYXllcnMgZnJvbSB3aGljaCBmZWF0dXJlcyBzaG91bGQgYmVcbiAqIHRyYW5zbGF0ZWQuIEFsdGVybmF0aXZlbHksIGEgZmlsdGVyIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZC4gVGhlXG4gKiBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBsYXllciBpbiB0aGUgbWFwIGFuZCBzaG91bGQgcmV0dXJuXG4gKiBgdHJ1ZWAgZm9yIGxheWVycyB0aGF0IHlvdSB3YW50IHRvIGJlIHRyYW5zbGF0YWJsZS4gSWYgdGhlIG9wdGlvbiBpc1xuICogYWJzZW50LCBhbGwgdmlzaWJsZSBsYXllcnMgd2lsbCBiZSBjb25zaWRlcmVkIHRyYW5zbGF0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvblxuICogd2lsbCBiZSBjaGVja2VkIGZvciBmZWF0dXJlcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aGUgY2FudmFzIHJlbmRlcmVyIGFuZFxuICogbm90IGZvciBXZWJHTC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9UcmFuc2xhdGV+VHJhbnNsYXRlfSBpbnN0YW5jZXNcbiAqIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICovXG5leHBvcnQgdmFyIFRyYW5zbGF0ZUV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBUcmFuc2xhdGVFdmVudCh0eXBlLCBmZWF0dXJlcywgY29vcmRpbmF0ZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlcyBiZWluZyB0cmFuc2xhdGVkLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZyBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlID0gY29vcmRpbmF0ZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFRyYW5zbGF0ZUV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBUcmFuc2xhdGVFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgVHJhbnNsYXRlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNsYXRlRXZlbnQ7XG5cbiAgcmV0dXJuIFRyYW5zbGF0ZUV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSW50ZXJhY3Rpb24gZm9yIHRyYW5zbGF0aW5nIChtb3ZpbmcpIGZlYXR1cmVzLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlflRyYW5zbGF0ZUV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBUcmFuc2xhdGUgPSAoZnVuY3Rpb24gKFBvaW50ZXJJbnRlcmFjdGlvbikge1xuICBmdW5jdGlvbiBUcmFuc2xhdGUob3B0X29wdGlvbnMpIHtcbiAgICBQb2ludGVySW50ZXJhY3Rpb24uY2FsbCh0aGlzLCB7XG4gICAgICBoYW5kbGVEb3duRXZlbnQ6IGhhbmRsZURvd25FdmVudCxcbiAgICAgIGhhbmRsZURyYWdFdmVudDogaGFuZGxlRHJhZ0V2ZW50LFxuICAgICAgaGFuZGxlTW92ZUV2ZW50OiBoYW5kbGVNb3ZlRXZlbnQsXG4gICAgICBoYW5kbGVVcEV2ZW50OiBoYW5kbGVVcEV2ZW50XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIHdlIHRyYW5zbGF0ZWQgdG8uXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG51bGw7XG5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc18gPSBvcHRpb25zLmZlYXR1cmVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZlYXR1cmVzIDogbnVsbDtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24obW9kdWxlOm9sL2xheWVyL0xheWVyKTogYm9vbGVhbn0gKi9cbiAgICB2YXIgbGF5ZXJGaWx0ZXI7XG4gICAgaWYgKG9wdGlvbnMubGF5ZXJzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGF5ZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxheWVyRmlsdGVyID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGF5ZXJzID0gb3B0aW9ucy5sYXllcnM7XG4gICAgICAgIGxheWVyRmlsdGVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZXMobGF5ZXJzLCBsYXllcik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyRmlsdGVyID0gVFJVRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJGaWx0ZXJfID0gbGF5ZXJGaWx0ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaXRUb2xlcmFuY2VfID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgPyBvcHRpb25zLmhpdFRvbGVyYW5jZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmxhc3RGZWF0dXJlXyA9IG51bGw7XG5cbiAgICBsaXN0ZW4odGhpcyxcbiAgICAgIGdldENoYW5nZUV2ZW50VHlwZShJbnRlcmFjdGlvblByb3BlcnR5LkFDVElWRSksXG4gICAgICB0aGlzLmhhbmRsZUFjdGl2ZUNoYW5nZWRfLCB0aGlzKTtcblxuICB9XG5cbiAgaWYgKCBQb2ludGVySW50ZXJhY3Rpb24gKSBUcmFuc2xhdGUuX19wcm90b19fID0gUG9pbnRlckludGVyYWN0aW9uO1xuICBUcmFuc2xhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9pbnRlckludGVyYWN0aW9uICYmIFBvaW50ZXJJbnRlcmFjdGlvbi5wcm90b3R5cGUgKTtcbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zbGF0ZTtcblxuICAvKipcbiAgICogVGVzdHMgdG8gc2VlIGlmIHRoZSBnaXZlbiBjb29yZGluYXRlcyBpbnRlcnNlY3RzIGFueSBvZiBvdXIgc2VsZWN0ZWRcbiAgICogZmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfSBwaXhlbCBQaXhlbCBjb29yZGluYXRlIHRvIHRlc3QgZm9yIGludGVyc2VjdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfSBtYXAgTWFwIHRvIHRlc3QgdGhlIGludGVyc2VjdGlvbiBvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL0ZlYXR1cmV9IFJldHVybnMgdGhlIGZlYXR1cmUgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBwaXhlbFxuICAgKiBjb29yZGluYXRlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuZmVhdHVyZXNBdFBpeGVsXyA9IGZ1bmN0aW9uIGZlYXR1cmVzQXRQaXhlbF8gKHBpeGVsLCBtYXApIHtcbiAgICByZXR1cm4gbWFwLmZvckVhY2hGZWF0dXJlQXRQaXhlbChwaXhlbCxcbiAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzXyB8fCBpbmNsdWRlcyh0aGlzLmZlYXR1cmVzXy5nZXRBcnJheSgpLCBmZWF0dXJlKSkge1xuICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyksIHtcbiAgICAgICAgbGF5ZXJGaWx0ZXI6IHRoaXMubGF5ZXJGaWx0ZXJfLFxuICAgICAgICBoaXRUb2xlcmFuY2U6IHRoaXMuaGl0VG9sZXJhbmNlX1xuICAgICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQGFwaVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS5nZXRIaXRUb2xlcmFuY2UgPSBmdW5jdGlvbiBnZXRIaXRUb2xlcmFuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLmhpdFRvbGVyYW5jZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlLiBQaXhlbHMgaW5zaWRlIHRoZSByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgKiB3aWxsIGJlIGNoZWNrZWQgZm9yIGZlYXR1cmVzLiBUaGlzIG9ubHkgd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kXG4gICAqIG5vdCBmb3IgV2ViR0wuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIFRyYW5zbGF0ZS5wcm90b3R5cGUuc2V0SGl0VG9sZXJhbmNlID0gZnVuY3Rpb24gc2V0SGl0VG9sZXJhbmNlIChoaXRUb2xlcmFuY2UpIHtcbiAgICB0aGlzLmhpdFRvbGVyYW5jZV8gPSBoaXRUb2xlcmFuY2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLnNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcCAobWFwKSB7XG4gICAgdmFyIG9sZE1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgUG9pbnRlckludGVyYWN0aW9uLnByb3RvdHlwZS5zZXRNYXAuY2FsbCh0aGlzLCBtYXApO1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG9sZE1hcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUcmFuc2xhdGUucHJvdG90eXBlLmhhbmRsZUFjdGl2ZUNoYW5nZWRfID0gZnVuY3Rpb24gaGFuZGxlQWN0aXZlQ2hhbmdlZF8gKCkge1xuICAgIHRoaXMudXBkYXRlU3RhdGVfKG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG9sZE1hcCBPbGQgbWFwLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVHJhbnNsYXRlLnByb3RvdHlwZS51cGRhdGVTdGF0ZV8gPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZV8gKG9sZE1hcCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBhY3RpdmUgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgIGlmICghbWFwIHx8ICFhY3RpdmUpIHtcbiAgICAgIG1hcCA9IG1hcCB8fCBvbGRNYXA7XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIHZhciBlbGVtID0gbWFwLmdldFZpZXdwb3J0KCk7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgnb2wtZ3JhYicsICdvbC1ncmFiYmluZycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVHJhbnNsYXRlO1xufShQb2ludGVySW50ZXJhY3Rpb24pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnR9IGV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gU3RhcnQgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEb3duRXZlbnQoZXZlbnQpIHtcbiAgdGhpcy5sYXN0RmVhdHVyZV8gPSB0aGlzLmZlYXR1cmVzQXRQaXhlbF8oZXZlbnQucGl4ZWwsIGV2ZW50Lm1hcCk7XG4gIGlmICghdGhpcy5sYXN0Q29vcmRpbmF0ZV8gJiYgdGhpcy5sYXN0RmVhdHVyZV8pIHtcbiAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IGV2ZW50LmNvb3JkaW5hdGU7XG4gICAgaGFuZGxlTW92ZUV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc18gfHwgbmV3IENvbGxlY3Rpb24oW3RoaXMubGFzdEZlYXR1cmVfXSk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgVHJhbnNsYXRlRXZlbnQoXG4gICAgICAgIFRyYW5zbGF0ZUV2ZW50VHlwZS5UUkFOU0xBVEVTVEFSVCwgZmVhdHVyZXMsXG4gICAgICAgIGV2ZW50LmNvb3JkaW5hdGUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBldmVudCBFdmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFN0b3AgZHJhZyBzZXF1ZW5jZT9cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlfVxuICovXG5mdW5jdGlvbiBoYW5kbGVVcEV2ZW50KGV2ZW50KSB7XG4gIGlmICh0aGlzLmxhc3RDb29yZGluYXRlXykge1xuICAgIHRoaXMubGFzdENvb3JkaW5hdGVfID0gbnVsbDtcbiAgICBoYW5kbGVNb3ZlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzXyB8fCBuZXcgQ29sbGVjdGlvbihbdGhpcy5sYXN0RmVhdHVyZV9dKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBUcmFuc2xhdGVFdmVudChcbiAgICAgICAgVHJhbnNsYXRlRXZlbnRUeXBlLlRSQU5TTEFURUVORCwgZmVhdHVyZXMsXG4gICAgICAgIGV2ZW50LmNvb3JkaW5hdGUpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50fSBldmVudCBFdmVudC5cbiAqIEB0aGlzIHttb2R1bGU6b2wvaW50ZXJhY3Rpb24vVHJhbnNsYXRlfVxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnRXZlbnQoZXZlbnQpIHtcbiAgaWYgKHRoaXMubGFzdENvb3JkaW5hdGVfKSB7XG4gICAgdmFyIG5ld0Nvb3JkaW5hdGUgPSBldmVudC5jb29yZGluYXRlO1xuICAgIHZhciBkZWx0YVggPSBuZXdDb29yZGluYXRlWzBdIC0gdGhpcy5sYXN0Q29vcmRpbmF0ZV9bMF07XG4gICAgdmFyIGRlbHRhWSA9IG5ld0Nvb3JkaW5hdGVbMV0gLSB0aGlzLmxhc3RDb29yZGluYXRlX1sxXTtcblxuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNfIHx8IG5ldyBDb2xsZWN0aW9uKFt0aGlzLmxhc3RGZWF0dXJlX10pO1xuXG4gICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGdlb20udHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhc3RDb29yZGluYXRlXyA9IG5ld0Nvb3JkaW5hdGU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IFRyYW5zbGF0ZUV2ZW50KFxuICAgICAgICBUcmFuc2xhdGVFdmVudFR5cGUuVFJBTlNMQVRJTkcsIGZlYXR1cmVzLFxuICAgICAgICBuZXdDb29yZGluYXRlKSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH0gZXZlbnQgRXZlbnQuXG4gKiBAdGhpcyB7bW9kdWxlOm9sL2ludGVyYWN0aW9uL1RyYW5zbGF0ZX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50KGV2ZW50KSB7XG4gIHZhciBlbGVtID0gZXZlbnQubWFwLmdldFZpZXdwb3J0KCk7XG5cbiAgLy8gQ2hhbmdlIHRoZSBjdXJzb3IgdG8gZ3JhYi9ncmFiYmluZyBpZiBob3ZlcmluZyBhbnkgb2YgdGhlIGZlYXR1cmVzIG1hbmFnZWRcbiAgLy8gYnkgdGhlIGludGVyYWN0aW9uXG4gIGlmICh0aGlzLmZlYXR1cmVzQXRQaXhlbF8oZXZlbnQucGl4ZWwsIGV2ZW50Lm1hcCkpIHtcbiAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5sYXN0Q29vcmRpbmF0ZV8gPyAnb2wtZ3JhYicgOiAnb2wtZ3JhYmJpbmcnKTtcbiAgICBlbGVtLmNsYXNzTGlzdC5hZGQodGhpcy5sYXN0Q29vcmRpbmF0ZV8gPyAnb2wtZ3JhYmJpbmcnIDogJ29sLWdyYWInKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ29sLWdyYWInLCAnb2wtZ3JhYmJpbmcnKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zbGF0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNsYXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9CYXNlXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuLi9sYXllci9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTm90ZSB0aGF0IHdpdGgge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfSBhbmQgYWxsIGl0cyBzdWJjbGFzc2VzLCBhbnkgcHJvcGVydHkgc2V0IGluXG4gKiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH0gcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdCwgc29cbiAqIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG52YXIgQmFzZUxheWVyID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIEJhc2VMYXllcihvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgKj59XG4gICAgKi9cbiAgICB2YXIgcHJvcGVydGllcyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk9QQUNJVFldID1cbiAgICAgICBvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhY2l0eSA6IDE7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5LlZJU0lCTEVdID1cbiAgICAgICBvcHRpb25zLnZpc2libGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudmlzaWJsZSA6IHRydWU7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5LlpfSU5ERVhdID1cbiAgICAgICBvcHRpb25zLnpJbmRleCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy56SW5kZXggOiAwO1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTl0gPVxuICAgICAgIG9wdGlvbnMubWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhSZXNvbHV0aW9uIDogSW5maW5pdHk7XG4gICAgcHJvcGVydGllc1tMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OXSA9XG4gICAgICAgb3B0aW9ucy5taW5SZXNvbHV0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblJlc29sdXRpb24gOiAwO1xuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL0xheWVyflN0YXRlfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuc3RhdGVfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGV9ICovICh7XG4gICAgICBsYXllcjogLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9ICovICh0aGlzKSxcbiAgICAgIG1hbmFnZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL0xheWVyVHlwZX1cbiAgICAqIEBwcm90ZWN0ZWQ7XG4gICAgKi9cbiAgICB0aGlzLnR5cGU7XG5cbiAgfVxuXG4gIGlmICggQmFzZU9iamVjdCApIEJhc2VMYXllci5fX3Byb3RvX18gPSBCYXNlT2JqZWN0O1xuICBCYXNlTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZU9iamVjdCAmJiBCYXNlT2JqZWN0LnByb3RvdHlwZSApO1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFzZUxheWVyO1xuXG4gIC8qKlxuICAqIEdldCB0aGUgbGF5ZXIgdHlwZSAodXNlZCB3aGVuIGNyZWF0aW5nIGEgbGF5ZXIgcmVuZGVyZXIpLlxuICAqIEByZXR1cm4ge21vZHVsZTpvbC9MYXllclR5cGV9IFRoZSBsYXllciB0eXBlLlxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge21vZHVsZTpvbC9sYXllci9MYXllcn5TdGF0ZX0gTGF5ZXIgc3RhdGUuXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJTdGF0ZSA9IGZ1bmN0aW9uIGdldExheWVyU3RhdGUgKCkge1xuICAgIHRoaXMuc3RhdGVfLm9wYWNpdHkgPSBjbGFtcCh0aGlzLmdldE9wYWNpdHkoKSwgMCwgMSk7XG4gICAgdGhpcy5zdGF0ZV8uc291cmNlU3RhdGUgPSB0aGlzLmdldFNvdXJjZVN0YXRlKCk7XG4gICAgdGhpcy5zdGF0ZV8udmlzaWJsZSA9IHRoaXMuZ2V0VmlzaWJsZSgpO1xuICAgIHRoaXMuc3RhdGVfLmV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgdGhpcy5zdGF0ZV8uekluZGV4ID0gdGhpcy5nZXRaSW5kZXgoKTtcbiAgICB0aGlzLnN0YXRlXy5tYXhSZXNvbHV0aW9uID0gdGhpcy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgdGhpcy5zdGF0ZV8ubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KHRoaXMuZ2V0TWluUmVzb2x1dGlvbigpLCAwKTtcblxuICAgIHJldHVybiB0aGlzLnN0YXRlXztcbiAgfTtcblxuICAvKipcbiAgKiBAYWJzdHJhY3RcbiAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXI+PX0gb3B0X2FycmF5IEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgKiAgICAgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXI+fSBBcnJheSBvZiBsYXllcnMuXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7fTtcblxuICAvKipcbiAgKiBAYWJzdHJhY3RcbiAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGU+PX0gb3B0X3N0YXRlcyBPcHRpb25hbCBsaXN0IG9mIGxheWVyXG4gICogICAgIHN0YXRlcyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGU+fSBMaXN0IG9mIGxheWVyIHN0YXRlcy5cbiAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5nZXRMYXllclN0YXRlc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJTdGF0ZXNBcnJheSAob3B0X3N0YXRlcykge307XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQgZXh0ZW50fSBvZiB0aGUgbGF5ZXIgb3IgYHVuZGVmaW5lZGAgaWYgaXRcbiAgKiB3aWxsIGJlIHZpc2libGUgcmVnYXJkbGVzcyBvZiBleHRlbnQuXG4gICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR8dW5kZWZpbmVkfSBUaGUgbGF5ZXIgZXh0ZW50LlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAvKiogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuRVhURU5UKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAqIFJldHVybiB0aGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldE1heFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRNYXhSZXNvbHV0aW9uICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1BWF9SRVNPTFVUSU9OKSk7XG4gIH07XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0TWluUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldE1pblJlc29sdXRpb24gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuTUlOX1JFU09MVVRJT04pKTtcbiAgfTtcblxuICAvKipcbiAgKiBSZXR1cm4gdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyIChiZXR3ZWVuIDAgYW5kIDEpLlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5ICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk9QQUNJVFkpKTtcbiAgfTtcblxuICAvKipcbiAgKiBAYWJzdHJhY3RcbiAgKiBAcmV0dXJuIHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBTb3VyY2Ugc3RhdGUuXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0U291cmNlU3RhdGUgPSBmdW5jdGlvbiBnZXRTb3VyY2VTdGF0ZSAoKSB7fTtcblxuICAvKipcbiAgKiBSZXR1cm4gdGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyIChgdHJ1ZWAgb3IgYGZhbHNlYCkuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLmdldFZpc2libGUgPSBmdW5jdGlvbiBnZXRWaXNpYmxlICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFKSk7XG4gIH07XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICogcmVuZGVyaW5nLiBUaGUgZGVmYXVsdCBaLWluZGV4IGlzIDAuXG4gICogQHJldHVybiB7bnVtYmVyfSBUaGUgWi1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24gZ2V0WkluZGV4ICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LlpfSU5ERVgpKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgdGhlIGV4dGVudCBhdCB3aGljaCB0aGUgbGF5ZXIgaXMgdmlzaWJsZS4gIElmIGB1bmRlZmluZWRgLCB0aGUgbGF5ZXJcbiAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgQmFzZUxheWVyLnByb3RvdHlwZS5zZXRFeHRlbnQgPSBmdW5jdGlvbiBzZXRFeHRlbnQgKGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldE1heFJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRNYXhSZXNvbHV0aW9uIChtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICogQHBhcmFtIHtudW1iZXJ9IG1pblJlc29sdXRpb24gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0TWluUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIHNldE1pblJlc29sdXRpb24gKG1pblJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OLCBtaW5SZXNvbHV0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLCBhbGxvd2VkIHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gMS5cbiAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIEJhc2VMYXllci5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKG9wYWNpdHkpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk9QQUNJVFksIG9wYWNpdHkpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGF5ZXIgKGB0cnVlYCBvciBgZmFsc2VgKS5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiBzZXRWaXNpYmxlICh2aXNpYmxlKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFLCB2aXNpYmxlKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgWi1pbmRleCBvZiB0aGUgbGF5ZXIsIHdoaWNoIGlzIHVzZWQgdG8gb3JkZXIgbGF5ZXJzIGJlZm9yZSByZW5kZXJpbmcuXG4gICogVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAqIEBwYXJhbSB7bnVtYmVyfSB6aW5kZXggVGhlIHotaW5kZXggb2YgdGhlIGxheWVyLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBCYXNlTGF5ZXIucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIHNldFpJbmRleCAoemluZGV4KSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5aX0lOREVYLCB6aW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBCYXNlTGF5ZXI7XG59KEJhc2VPYmplY3QpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBCYXNlTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0dyb3VwXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuLi9sYXllci9CYXNlLmpzJztcbmltcG9ydCB7YXNzaWduLCBjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7KEFycmF5Ljxtb2R1bGU6b2wvbGF5ZXIvQmFzZT58bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9sYXllci9CYXNlPil9IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQcm9wZXJ0eSA9IHtcbiAgTEFZRVJTOiAnbGF5ZXJzJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259IG9mIGxheWVycyB0aGF0IGFyZSBoYW5kbGVkIHRvZ2V0aGVyLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgZ3JvdXAvQ29sbGVjdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBhcGlcbiAqL1xudmFyIExheWVyR3JvdXAgPSAoZnVuY3Rpb24gKEJhc2VMYXllcikge1xuICBmdW5jdGlvbiBMYXllckdyb3VwKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIHZhciBiYXNlT3B0aW9ucyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL0dyb3Vwfk9wdGlvbnN9ICovIChhc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMubGF5ZXJzO1xuXG4gICAgdmFyIGxheWVycyA9IG9wdGlvbnMubGF5ZXJzO1xuXG4gICAgQmFzZUxheWVyLmNhbGwodGhpcywgYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBBcnJheS48bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxpc3RlbmVyS2V5c18gPSB7fTtcblxuICAgIGxpc3Rlbih0aGlzLFxuICAgICAgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5LkxBWUVSUyksXG4gICAgICB0aGlzLmhhbmRsZUxheWVyc0NoYW5nZWRfLCB0aGlzKTtcblxuICAgIGlmIChsYXllcnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGxheWVycykpIHtcbiAgICAgICAgbGF5ZXJzID0gbmV3IENvbGxlY3Rpb24obGF5ZXJzLnNsaWNlKCksIHt1bmlxdWU6IHRydWV9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChsYXllcnMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uLFxuICAgICAgICAgIDQzKTsgLy8gRXhwZWN0ZWQgYGxheWVyc2AgdG8gYmUgYW4gYXJyYXkgb3IgYSBgQ29sbGVjdGlvbmBcbiAgICAgICAgbGF5ZXJzID0gbGF5ZXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbih1bmRlZmluZWQsIHt1bmlxdWU6IHRydWV9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldExheWVycyhsYXllcnMpO1xuXG4gIH1cblxuICBpZiAoIEJhc2VMYXllciApIExheWVyR3JvdXAuX19wcm90b19fID0gQmFzZUxheWVyO1xuICBMYXllckdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VMYXllciAmJiBCYXNlTGF5ZXIucHJvdG90eXBlICk7XG4gIExheWVyR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXJHcm91cDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLmhhbmRsZUxheWVyQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyQ2hhbmdlXyAoKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2V2ZW50cy9FdmVudH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5oYW5kbGVMYXllcnNDaGFuZ2VkXyA9IGZ1bmN0aW9uIGhhbmRsZUxheWVyc0NoYW5nZWRfICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgdGhpcy5sYXllcnNMaXN0ZW5lcktleXNfLnB1c2goXG4gICAgICBsaXN0ZW4obGF5ZXJzLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgdGhpcy5oYW5kbGVMYXllcnNBZGRfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihsYXllcnMsIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCB0aGlzLmhhbmRsZUxheWVyc1JlbW92ZV8sIHRoaXMpXG4gICAgKTtcblxuICAgIGZvciAodmFyIGlkIGluIHRoaXMkMS5saXN0ZW5lcktleXNfKSB7XG4gICAgICB0aGlzJDEubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIHZhciBsYXllcnNBcnJheSA9IGxheWVycy5nZXRBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc0FycmF5W2ldO1xuICAgICAgdGhpcyQxLmxpc3RlbmVyS2V5c19bZ2V0VWlkKGxheWVyKS50b1N0cmluZygpXSA9IFtcbiAgICAgICAgbGlzdGVuKGxheWVyLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsIHRoaXMkMS5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMkMSksXG4gICAgICAgIGxpc3RlbihsYXllciwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcyQxLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyQxKVxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGNvbGxlY3Rpb25FdmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5oYW5kbGVMYXllcnNBZGRfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJzQWRkXyAoY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvQmFzZX0gKi8gKGNvbGxlY3Rpb25FdmVudC5lbGVtZW50KTtcbiAgICB2YXIga2V5ID0gZ2V0VWlkKGxheWVyKS50b1N0cmluZygpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldID0gW1xuICAgICAgbGlzdGVuKGxheWVyLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihsYXllciwgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVMYXllckNoYW5nZV8sIHRoaXMpXG4gICAgXTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9uRXZlbnR9IGNvbGxlY3Rpb25FdmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5oYW5kbGVMYXllcnNSZW1vdmVfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJzUmVtb3ZlXyAoY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgdmFyIGxheWVyID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvQmFzZX0gKi8gKGNvbGxlY3Rpb25FdmVudC5lbGVtZW50KTtcbiAgICB2YXIga2V5ID0gZ2V0VWlkKGxheWVyKS50b1N0cmluZygpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1trZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXJLZXlzX1trZXldO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb24gY29sbGVjdGlvbn0gb2Yge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciBsYXllcnN9XG4gICAqIGluIHRoaXMgZ3JvdXAuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2xheWVyL0Jhc2U+fSBDb2xsZWN0aW9uIG9mXG4gICAqICAge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlIGxheWVyc30gdGhhdCBhcmUgcGFydCBvZiB0aGlzIGdyb3VwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiBnZXRMYXllcnMgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUgeyFtb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL2xheWVyL0Jhc2U+fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuTEFZRVJTKSlcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbiBjb2xsZWN0aW9ufSBvZiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyIGxheWVyc31cbiAgICogaW4gdGhpcyBncm91cC5cbiAgICogQHBhcmFtIHshbW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9sYXllci9CYXNlPn0gbGF5ZXJzIENvbGxlY3Rpb24gb2ZcbiAgICogICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0Jhc2UgbGF5ZXJzfSB0aGF0IGFyZSBwYXJ0IG9mIHRoaXMgZ3JvdXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIExheWVyR3JvdXAucHJvdG90eXBlLnNldExheWVycyA9IGZ1bmN0aW9uIHNldExheWVycyAobGF5ZXJzKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuTEFZRVJTLCBsYXllcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgTGF5ZXJHcm91cC5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gb3B0X2FycmF5ICE9PSB1bmRlZmluZWQgPyBvcHRfYXJyYXkgOiBbXTtcbiAgICB0aGlzLmdldExheWVycygpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGxheWVyLmdldExheWVyc0FycmF5KGFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRMYXllclN0YXRlc0FycmF5ID0gZnVuY3Rpb24gZ2V0TGF5ZXJTdGF0ZXNBcnJheSAob3B0X3N0YXRlcykge1xuICAgIHZhciBzdGF0ZXMgPSBvcHRfc3RhdGVzICE9PSB1bmRlZmluZWQgPyBvcHRfc3RhdGVzIDogW107XG5cbiAgICB2YXIgcG9zID0gc3RhdGVzLmxlbmd0aDtcblxuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpO1xuICAgIH0pO1xuXG4gICAgdmFyIG93bkxheWVyU3RhdGUgPSB0aGlzLmdldExheWVyU3RhdGUoKTtcbiAgICBmb3IgKHZhciBpID0gcG9zLCBpaSA9IHN0YXRlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgbGF5ZXJTdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgIGxheWVyU3RhdGUub3BhY2l0eSAqPSBvd25MYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICBsYXllclN0YXRlLnZpc2libGUgPSBsYXllclN0YXRlLnZpc2libGUgJiYgb3duTGF5ZXJTdGF0ZS52aXNpYmxlO1xuICAgICAgbGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uID0gTWF0aC5taW4oXG4gICAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbiwgb3duTGF5ZXJTdGF0ZS5tYXhSZXNvbHV0aW9uKTtcbiAgICAgIGxheWVyU3RhdGUubWluUmVzb2x1dGlvbiA9IE1hdGgubWF4KFxuICAgICAgICBsYXllclN0YXRlLm1pblJlc29sdXRpb24sIG93bkxheWVyU3RhdGUubWluUmVzb2x1dGlvbik7XG4gICAgICBpZiAob3duTGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKGxheWVyU3RhdGUuZXh0ZW50LCBvd25MYXllclN0YXRlLmV4dGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5leHRlbnQgPSBvd25MYXllclN0YXRlLmV4dGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllckdyb3VwLnByb3RvdHlwZS5nZXRTb3VyY2VTdGF0ZSA9IGZ1bmN0aW9uIGdldFNvdXJjZVN0YXRlICgpIHtcbiAgICByZXR1cm4gU291cmNlU3RhdGUuUkVBRFk7XG4gIH07XG5cbiAgcmV0dXJuIExheWVyR3JvdXA7XG59KEJhc2VMYXllcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IExheWVyR3JvdXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VwLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9JbWFnZVxuICovXG5pbXBvcnQgTGF5ZXJUeXBlIGZyb20gJy4uL0xheWVyVHlwZS5qcyc7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL0ltYWdlfSBbc291cmNlXSBTb3VyY2UgZm9yIHRoaXMgbGF5ZXIuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNlcnZlci1yZW5kZXJlZCBpbWFnZXMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciBhcmJpdHJhcnkgZXh0ZW50cyBhbmRcbiAqIHJlc29sdXRpb25zLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBJbWFnZUxheWVyID0gKGZ1bmN0aW9uIChMYXllcikge1xuICBmdW5jdGlvbiBJbWFnZUxheWVyKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG4gICAgTGF5ZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsYXllciB0eXBlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL0xheWVyVHlwZX1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBMYXllclR5cGUuSU1BR0U7XG5cbiAgfVxuXG4gIGlmICggTGF5ZXIgKSBJbWFnZUxheWVyLl9fcHJvdG9fXyA9IExheWVyO1xuICBJbWFnZUxheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExheWVyICYmIExheWVyLnByb3RvdHlwZSApO1xuICBJbWFnZUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlTGF5ZXI7XG5cbiAgcmV0dXJuIEltYWdlTGF5ZXI7XG59KExheWVyKSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvSW1hZ2Ugc291cmNlfSBvZiB0aGUgaW1hZ2UgbGF5ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zb3VyY2UvSW1hZ2V9IFNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuSW1hZ2VMYXllci5wcm90b3R5cGUuZ2V0U291cmNlO1xuZXhwb3J0IGRlZmF1bHQgSW1hZ2VMYXllcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0xheWVyXG4gKi9cbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuLi9sYXllci9CYXNlLmpzJztcbmltcG9ydCBMYXllclByb3BlcnR5IGZyb20gJy4uL2xheWVyL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci4gIElmIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsXG4gKiB0aGUgc291cmNlIGNhbiBiZSBzZXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyI3NldFNvdXJjZSBsYXllci5zZXRTb3VyY2Uoc291cmNlKX0gYWZ0ZXJcbiAqIGNvbnN0cnVjdGlvbi5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+U3RhdGV9IHNvdXJjZVN0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZpc2libGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFuYWdlZFxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6SW5kZXhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhSZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluUmVzb2x1dGlvblxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgcmFzdGVyIG9yIHZlY3RvciBtYXAgZGF0YS5cbiAqIExheWVycyBncm91cCB0b2dldGhlciB0aG9zZSBwcm9wZXJ0aWVzIHRoYXQgcGVydGFpbiB0byBob3cgdGhlIGRhdGEgaXMgdG8gYmVcbiAqIGRpc3BsYXllZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBzb3VyY2Ugb2YgdGhhdCBkYXRhLlxuICpcbiAqIExheWVycyBhcmUgdXN1YWxseSBhZGRlZCB0byBhIG1hcCB3aXRoIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfS4gQ29tcG9uZW50c1xuICogbGlrZSB7QGxpbmsgbW9kdWxlOm9sL2ludGVyYWN0aW9uL1NlbGVjdH5TZWxlY3R9IHVzZSB1bm1hbmFnZWQgbGF5ZXJzXG4gKiBpbnRlcm5hbGx5LiBUaGVzZSB1bm1hbmFnZWQgbGF5ZXJzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcCB1c2luZ1xuICoge0BsaW5rIG1vZHVsZTpvbC9sYXllci9MYXllcn5MYXllciNzZXRNYXB9IGluc3RlYWQuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBzb3VyY2UgY2hhbmdlcy5cbiAqXG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudFxuICovXG52YXIgTGF5ZXIgPSAoZnVuY3Rpb24gKEJhc2VMYXllcikge1xuICBmdW5jdGlvbiBMYXllcihvcHRpb25zKSB7XG5cbiAgICB2YXIgYmFzZU9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5zb3VyY2U7XG5cbiAgICBCYXNlTGF5ZXIuY2FsbCh0aGlzLCBiYXNlT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL2V2ZW50c35FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMubWFwKSB7XG4gICAgICB0aGlzLnNldE1hcChvcHRpb25zLm1hcCk7XG4gICAgfVxuXG4gICAgbGlzdGVuKHRoaXMsXG4gICAgICBnZXRDaGFuZ2VFdmVudFR5cGUoTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UpLFxuICAgICAgdGhpcy5oYW5kbGVTb3VyY2VQcm9wZXJ0eUNoYW5nZV8sIHRoaXMpO1xuXG4gICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlID8gb3B0aW9ucy5zb3VyY2UgOiBudWxsO1xuICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gIH1cblxuICBpZiAoIEJhc2VMYXllciApIExheWVyLl9fcHJvdG9fXyA9IEJhc2VMYXllcjtcbiAgTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQmFzZUxheWVyICYmIEJhc2VMYXllci5wcm90b3R5cGUgKTtcbiAgTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF5ZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJzQXJyYXkgPSBmdW5jdGlvbiBnZXRMYXllcnNBcnJheSAob3B0X2FycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gb3B0X2FycmF5ID8gb3B0X2FycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0TGF5ZXJTdGF0ZXNBcnJheSA9IGZ1bmN0aW9uIGdldExheWVyU3RhdGVzQXJyYXkgKG9wdF9zdGF0ZXMpIHtcbiAgICB2YXIgc3RhdGVzID0gb3B0X3N0YXRlcyA/IG9wdF9zdGF0ZXMgOiBbXTtcbiAgICBzdGF0ZXMucHVzaCh0aGlzLmdldExheWVyU3RhdGUoKSk7XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfSBUaGUgbGF5ZXIgc291cmNlIChvciBgbnVsbGAgaWYgbm90IHlldCBzZXQpLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gZ2V0U291cmNlICgpIHtcbiAgICB2YXIgc291cmNlID0gdGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5TT1VSQ0UpO1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfSAqLyAoc291cmNlKSB8fCBudWxsXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICAqIEBpbmhlcml0RG9jXG4gICAgKi9cbiAgTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZVN0YXRlID0gZnVuY3Rpb24gZ2V0U291cmNlU3RhdGUgKCkge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgIHJldHVybiAhc291cmNlID8gU291cmNlU3RhdGUuVU5ERUZJTkVEIDogc291cmNlLmdldFN0YXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuaGFuZGxlU291cmNlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVNvdXJjZUNoYW5nZV8gKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTGF5ZXIucHJvdG90eXBlLmhhbmRsZVNvdXJjZVByb3BlcnR5Q2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVNvdXJjZVByb3BlcnR5Q2hhbmdlXyAoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlQ2hhbmdlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnNvdXJjZUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbGlzdGVuKHNvdXJjZSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVTb3VyY2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxheWVyIHRvIGJlIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBsYXllcnMgb24gYSBtYXAuIFRoZSBtYXAgd2lsbFxuICAgKiBub3QgbWFuYWdlIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGNhbGxiYWNrIGluXG4gICAqIHtAbGluayBtb2R1bGU6b2wvTWFwI2ZvckVhY2hMYXllckF0UGl4ZWx9IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgbGF5ZXIuIFRoaXNcbiAgICogaXMgdXNlZnVsIGZvciB0ZW1wb3JhcnkgbGF5ZXJzLiBUbyByZW1vdmUgYW4gdW5tYW5hZ2VkIGxheWVyIGZyb20gdGhlIG1hcCxcbiAgICogdXNlIGAjc2V0TWFwKG51bGwpYC5cbiAgICpcbiAgICogVG8gYWRkIHRoZSBsYXllciB0byBhIG1hcCBhbmQgaGF2ZSBpdCBtYW5hZ2VkIGJ5IHRoZSBtYXAsIHVzZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL01hcCNhZGRMYXllcn0gaW5zdGVhZC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfSBtYXAgTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwIChtYXApIHtcbiAgICBpZiAodGhpcy5tYXBQcmVjb21wb3NlS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLm1hcFByZWNvbXBvc2VLZXlfKTtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIW1hcCkge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcFJlbmRlcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5tYXBSZW5kZXJLZXlfKTtcbiAgICAgIHRoaXMubWFwUmVuZGVyS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtYXApIHtcbiAgICAgIHRoaXMubWFwUHJlY29tcG9zZUtleV8gPSBsaXN0ZW4obWFwLCBSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBsYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgICAgIGxheWVyU3RhdGUubWFuYWdlZCA9IGZhbHNlO1xuICAgICAgICBsYXllclN0YXRlLnpJbmRleCA9IEluZmluaXR5O1xuICAgICAgICBldnQuZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5LnB1c2gobGF5ZXJTdGF0ZSk7XG4gICAgICAgIGV2dC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzW2dldFVpZCh0aGlzKV0gPSBsYXllclN0YXRlO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLm1hcFJlbmRlcktleV8gPSBsaXN0ZW4odGhpcywgRXZlbnRUeXBlLkNIQU5HRSwgbWFwLnJlbmRlciwgbWFwKTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V9IHNvdXJjZSBUaGUgbGF5ZXIgc291cmNlLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBMYXllci5wcm90b3R5cGUuc2V0U291cmNlID0gZnVuY3Rpb24gc2V0U291cmNlIChzb3VyY2UpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlNPVVJDRSwgc291cmNlKTtcbiAgfTtcblxuICByZXR1cm4gTGF5ZXI7XG59KEJhc2VMYXllcikpO1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgbGF5ZXIgaXMgdmlzaWJsZSwgYW5kIGlmIHRoZSBwYXNzZWQgcmVzb2x1dGlvbiBpc1xuICogYmV0d2VlbiB0aGUgbGF5ZXIncyBtaW5SZXNvbHV0aW9uIGFuZCBtYXhSZXNvbHV0aW9uLiBUaGUgY29tcGFyaXNvbiBpc1xuICogaW5jbHVzaXZlIGZvciBgbWluUmVzb2x1dGlvbmAgYW5kIGV4Y2x1c2l2ZSBmb3IgYG1heFJlc29sdXRpb25gLlxuICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGxheWVyIGlzIHZpc2libGUgYXQgdGhlIGdpdmVuIHJlc29sdXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2aXNpYmxlQXRSZXNvbHV0aW9uKGxheWVyU3RhdGUsIHJlc29sdXRpb24pIHtcbiAgcmV0dXJuIGxheWVyU3RhdGUudmlzaWJsZSAmJiByZXNvbHV0aW9uID49IGxheWVyU3RhdGUubWluUmVzb2x1dGlvbiAmJlxuICAgICAgcmVzb2x1dGlvbiA8IGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbjtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBMYXllcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE9QQUNJVFk6ICdvcGFjaXR5JyxcbiAgVklTSUJMRTogJ3Zpc2libGUnLFxuICBFWFRFTlQ6ICdleHRlbnQnLFxuICBaX0lOREVYOiAnekluZGV4JyxcbiAgTUFYX1JFU09MVVRJT046ICdtYXhSZXNvbHV0aW9uJyxcbiAgTUlOX1JFU09MVVRJT046ICdtaW5SZXNvbHV0aW9uJyxcbiAgU09VUkNFOiAnc291cmNlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvcGVydHkuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVcbiAqL1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IExheWVyIGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCBUaWxlUHJvcGVydHkgZnJvbSAnLi4vbGF5ZXIvVGlsZVByb3BlcnR5LmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJlbG9hZD0wXSBQcmVsb2FkLiBMb2FkIGxvdy1yZXNvbHV0aW9uIHRpbGVzIHVwIHRvIGBwcmVsb2FkYCBsZXZlbHMuIGAwYFxuICogbWVhbnMgbm8gcHJlbG9hZGluZy5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlfSBbc291cmNlXSBTb3VyY2UgZm9yIHRoaXMgbGF5ZXIuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IFttYXBdIFNldHMgdGhlIGxheWVyIGFzIG92ZXJsYXkgb24gYSBtYXAuIFRoZSBtYXAgd2lsbCBub3QgbWFuYWdlXG4gKiB0aGlzIGxheWVyIGluIGl0cyBsYXllcnMgY29sbGVjdGlvbiwgYW5kIHRoZSBsYXllciB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcC4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiB0ZW1wb3JhcnkgbGF5ZXJzLiBUaGUgc3RhbmRhcmQgd2F5IHRvIGFkZCBhIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCBpcyB0b1xuICogdXNlIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VzZUludGVyaW1UaWxlc09uRXJyb3I9dHJ1ZV0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBGb3IgbGF5ZXIgc291cmNlcyB0aGF0IHByb3ZpZGUgcHJlLXJlbmRlcmVkLCB0aWxlZCBpbWFnZXMgaW4gZ3JpZHMgdGhhdCBhcmVcbiAqIG9yZ2FuaXplZCBieSB6b29tIGxldmVscyBmb3Igc3BlY2lmaWMgcmVzb2x1dGlvbnMuXG4gKiBOb3RlIHRoYXQgYW55IHByb3BlcnR5IHNldCBpbiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH5CYXNlT2JqZWN0fVxuICogcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdDsgZm9yIGV4YW1wbGUsIHNldHRpbmcgYHRpdGxlOiAnTXkgVGl0bGUnYCBpbiB0aGVcbiAqIG9wdGlvbnMgbWVhbnMgdGhhdCBgdGl0bGVgIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG52YXIgVGlsZUxheWVyID0gKGZ1bmN0aW9uIChMYXllcikge1xuICBmdW5jdGlvbiBUaWxlTGF5ZXIob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHZhciBiYXNlT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMucHJlbG9hZDtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXNlSW50ZXJpbVRpbGVzT25FcnJvcjtcbiAgICBMYXllci5jYWxsKHRoaXMsIGJhc2VPcHRpb25zKTtcblxuICAgIHRoaXMuc2V0UHJlbG9hZChvcHRpb25zLnByZWxvYWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucHJlbG9hZCA6IDApO1xuICAgIHRoaXMuc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcihvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgOiB0cnVlKTtcblxuICAgIC8qKlxuICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL0xheWVyVHlwZX1cbiAgICAqL1xuICAgIHRoaXMudHlwZSA9IExheWVyVHlwZS5USUxFO1xuXG4gIH1cblxuICBpZiAoIExheWVyICkgVGlsZUxheWVyLl9fcHJvdG9fXyA9IExheWVyO1xuICBUaWxlTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGF5ZXIgJiYgTGF5ZXIucHJvdG90eXBlICk7XG4gIFRpbGVMYXllci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlTGF5ZXI7XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSBsZXZlbCBhcyBudW1iZXIgdG8gd2hpY2ggd2Ugd2lsbCBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIFRpbGVMYXllci5wcm90b3R5cGUuZ2V0UHJlbG9hZCA9IGZ1bmN0aW9uIGdldFByZWxvYWQgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KFRpbGVQcm9wZXJ0eS5QUkVMT0FEKSk7XG4gIH07XG5cbiAgLyoqXG4gICogU2V0IHRoZSBsZXZlbCBhcyBudW1iZXIgdG8gd2hpY2ggd2Ugd2lsbCBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIFRoZSBsZXZlbCB0byBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAqIEBvYnNlcnZhYmxlXG4gICogQGFwaVxuICAqL1xuICBUaWxlTGF5ZXIucHJvdG90eXBlLnNldFByZWxvYWQgPSBmdW5jdGlvbiBzZXRQcmVsb2FkIChwcmVsb2FkKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQsIHByZWxvYWQpO1xuICB9O1xuXG4gIC8qKlxuICAqIFdoZXRoZXIgd2UgdXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIFRpbGVMYXllci5wcm90b3R5cGUuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvciA9IGZ1bmN0aW9uIGdldFVzZUludGVyaW1UaWxlc09uRXJyb3IgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2Jvb2xlYW59ICovICh0aGlzLmdldChUaWxlUHJvcGVydHkuVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1IpKTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgd2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUludGVyaW1UaWxlc09uRXJyb3IgVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIFRpbGVMYXllci5wcm90b3R5cGUuc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvciA9IGZ1bmN0aW9uIHNldFVzZUludGVyaW1UaWxlc09uRXJyb3IgKHVzZUludGVyaW1UaWxlc09uRXJyb3IpIHtcbiAgICB0aGlzLnNldChUaWxlUHJvcGVydHkuVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1IsIHVzZUludGVyaW1UaWxlc09uRXJyb3IpO1xuICB9O1xuXG4gIHJldHVybiBUaWxlTGF5ZXI7XG59KExheWVyKSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZSB0aWxlc291cmNlfSBvZiB0aGUgbGF5ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zb3VyY2UvVGlsZX0gU291cmNlLlxuICogQGFwaVxuICovXG5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlTGF5ZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1RpbGVQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQUkVMT0FEOiAncHJlbG9hZCcsXG4gIFVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SOiAndXNlSW50ZXJpbVRpbGVzT25FcnJvcidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVQcm9wZXJ0eS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuLi9sYXllci9MYXllci5qcyc7XG5pbXBvcnQgVmVjdG9yUmVuZGVyVHlwZSBmcm9tICcuLi9sYXllci9WZWN0b3JSZW5kZXJUeXBlLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHtjcmVhdGVEZWZhdWx0U3R5bGUsIHRvRnVuY3Rpb24gYXMgdG9TdHlsZUZ1bmN0aW9ufSBmcm9tICcuLi9zdHlsZS9TdHlsZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleD0wXSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcmVuZGVyfk9yZGVyRnVuY3Rpb259IFtyZW5kZXJPcmRlcl0gUmVuZGVyIG9yZGVyLiBGdW5jdGlvbiB0byBiZSB1c2VkIHdoZW4gc29ydGluZ1xuICogZmVhdHVyZXMgYmVmb3JlIHJlbmRlcmluZy4gQnkgZGVmYXVsdCBmZWF0dXJlcyBhcmUgZHJhd24gaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgY3JlYXRlZC4gVXNlXG4gKiBgbnVsbGAgdG8gYXZvaWQgdGhlIHNvcnQsIGJ1dCBnZXQgYW4gdW5kZWZpbmVkIGRyYXcgb3JkZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlbmRlckJ1ZmZlcj0xMDBdIFRoZSBidWZmZXIgaW4gcGl4ZWxzIGFyb3VuZCB0aGUgdmlld3BvcnQgZXh0ZW50IHVzZWQgYnkgdGhlXG4gKiByZW5kZXJlciB3aGVuIGdldHRpbmcgZmVhdHVyZXMgZnJvbSB0aGUgdmVjdG9yIHNvdXJjZSBmb3IgdGhlIHJlbmRlcmluZyBvciBoaXQtZGV0ZWN0aW9uLlxuICogUmVjb21tZW5kZWQgdmFsdWU6IHRoZSBzaXplIG9mIHRoZSBsYXJnZXN0IHN5bWJvbCwgbGluZSB3aWR0aCBvciBsYWJlbC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2xheWVyL1ZlY3RvclJlbmRlclR5cGV8c3RyaW5nfSBbcmVuZGVyTW9kZT0ndmVjdG9yJ10gUmVuZGVyIG1vZGUgZm9yIHZlY3RvciBsYXllcnM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcy4gR3JlYXQgcGVyZm9ybWFuY2UsIGJ1dCBwb2ludCBzeW1ib2xzIGFuZFxuICogICAgdGV4dHMgYXJlIGFsd2F5cyByb3RhdGVkIHdpdGggdGhlIHZpZXcgYW5kIHBpeGVscyBhcmUgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuXG4gKiAgKiBgJ3ZlY3RvcidgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyB2ZWN0b3JzLiBNb3N0IGFjY3VyYXRlIHJlbmRlcmluZyBldmVuIGR1cmluZ1xuICogICAgYW5pbWF0aW9ucywgYnV0IHNsb3dlciBwZXJmb3JtYW5jZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IFtzb3VyY2VdIFNvdXJjZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVjbHV0dGVyPWZhbHNlXSBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LiBEZWNsdXR0ZXJpbmcgaXMgYXBwbGllZCB0byBhbGxcbiAqIGltYWdlIGFuZCB0ZXh0IHN0eWxlcywgYW5kIHRoZSBwcmlvcml0eSBpcyBkZWZpbmVkIGJ5IHRoZSB6LWluZGV4IG9mIHRoZSBzdHlsZS4gTG93ZXIgei1pbmRleFxuICogbWVhbnMgaGlnaGVyIHByaW9yaXR5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3R5bGV8QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT58bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb259IFtzdHlsZV0gTGF5ZXIgc3R5bGUuIFNlZVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZX0gZm9yIGRlZmF1bHQgc3R5bGUgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgaXMgbm90IGRlZmluZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGFuZCBgcmVuZGVyTW9kZWBcbiAqIGlzIGB2ZWN0b3JgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgZHVyaW5nIGFuaW1hdGlvbnMuIFRoaXMgbWVhbnMgdGhhdCBub1xuICogdmVjdG9ycyB3aWxsIGJlIHNob3duIGNsaXBwZWQsIGJ1dCB0aGUgc2V0dGluZyB3aWxsIGhhdmUgYSBwZXJmb3JtYW5jZSBpbXBhY3QgZm9yIGxhcmdlXG4gKiBhbW91bnRzIG9mIHZlY3RvciBkYXRhLiBXaGVuIHNldCB0byBgZmFsc2VgLCBiYXRjaGVzIHdpbGwgYmUgcmVjcmVhdGVkIHdoZW4gbm8gYW5pbWF0aW9uXG4gKiBpcyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAgYW5kIGByZW5kZXJNb2RlYFxuICogaXMgYHZlY3RvcmAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCBkdXJpbmcgaW50ZXJhY3Rpb25zLiBTZWUgYWxzb1xuICogYHVwZGF0ZVdoaWxlQW5pbWF0aW5nYC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgbGF5ZXJzOlxuICogICogYCdpbWFnZSdgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMuIEdyZWF0IHBlcmZvcm1hbmNlLCBidXRcbiAqICAgIHBvaW50IHN5bWJvbHMgYW5kIHRleHRzIGFyZSBhbHdheXMgcm90YXRlZCB3aXRoIHRoZSB2aWV3IGFuZCBwaXhlbHMgYXJlXG4gKiAgICBzY2FsZWQgZHVyaW5nIHpvb20gYW5pbWF0aW9ucy5cbiAqICAqIGAndmVjdG9yJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIHZlY3RvcnMuIE1vc3QgYWNjdXJhdGUgcmVuZGVyaW5nXG4gKiAgICBldmVuIGR1cmluZyBhbmltYXRpb25zLCBidXQgc2xvd2VyIHBlcmZvcm1hbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIFJlbmRlclR5cGUgPSB7XG4gIElNQUdFOiAnaW1hZ2UnLFxuICBWRUNUT1I6ICd2ZWN0b3InXG59O1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBQcm9wZXJ0eSA9IHtcbiAgUkVOREVSX09SREVSOiAncmVuZGVyT3JkZXInXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVmVjdG9yIGRhdGEgdGhhdCBpcyByZW5kZXJlZCBjbGllbnQtc2lkZS5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBWZWN0b3JMYXllciA9IChmdW5jdGlvbiAoTGF5ZXIpIHtcbiAgZnVuY3Rpb24gVmVjdG9yTGF5ZXIob3B0X29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zID9cbiAgICAgIG9wdF9vcHRpb25zIDogLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfk9wdGlvbnN9ICovICh7fSk7XG5cbiAgICB2YXIgYmFzZU9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnN0eWxlO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5yZW5kZXJCdWZmZXI7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nO1xuICAgIExheWVyLmNhbGwodGhpcywgYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlcl8gPSBvcHRpb25zLmRlY2x1dHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWNsdXR0ZXIgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPSBvcHRpb25zLnJlbmRlckJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmVuZGVyQnVmZmVyIDogMTAwO1xuXG4gICAgLyoqXG4gICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9TdHlsZXxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0eWxlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIFN0eWxlIGZ1bmN0aW9uIGZvciB1c2Ugd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9TdHlsZX5TdHlsZUZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5zZXRTdHlsZShvcHRpb25zLnN0eWxlKTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy51cGRhdGVXaGlsZUFuaW1hdGluZ18gPSBvcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUFuaW1hdGluZyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfID0gb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy51cGRhdGVXaGlsZUludGVyYWN0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlfHN0cmluZ31cbiAgICAqL1xuICAgIHRoaXMucmVuZGVyTW9kZV8gPSBvcHRpb25zLnJlbmRlck1vZGUgfHwgVmVjdG9yUmVuZGVyVHlwZS5WRUNUT1I7XG5cbiAgICAvKipcbiAgICAqIFRoZSBsYXllciB0eXBlLlxuICAgICogQHByb3RlY3RlZFxuICAgICogQHR5cGUge21vZHVsZTpvbC9MYXllclR5cGV9XG4gICAgKi9cbiAgICB0aGlzLnR5cGUgPSBMYXllclR5cGUuVkVDVE9SO1xuXG4gIH1cblxuICBpZiAoIExheWVyICkgVmVjdG9yTGF5ZXIuX19wcm90b19fID0gTGF5ZXI7XG4gIFZlY3RvckxheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExheWVyICYmIExheWVyLnByb3RvdHlwZSApO1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZWN0b3JMYXllcjtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtib29sZWFufSBEZWNsdXR0ZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXREZWNsdXR0ZXIgPSBmdW5jdGlvbiBnZXREZWNsdXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLmRlY2x1dHRlcl87XG4gIH07XG5cbiAgLyoqXG4gICogQHBhcmFtIHtib29sZWFufSBkZWNsdXR0ZXIgRGVjbHV0dGVyLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuc2V0RGVjbHV0dGVyID0gZnVuY3Rpb24gc2V0RGVjbHV0dGVyIChkZWNsdXR0ZXIpIHtcbiAgICB0aGlzLmRlY2x1dHRlcl8gPSBkZWNsdXR0ZXI7XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVuZGVyIGJ1ZmZlci5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFJlbmRlckJ1ZmZlciA9IGZ1bmN0aW9uIGdldFJlbmRlckJ1ZmZlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyQnVmZmVyXztcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHtmdW5jdGlvbihtb2R1bGU6b2wvRmVhdHVyZSwgbW9kdWxlOm9sL0ZlYXR1cmUpOiBudW1iZXJ8bnVsbHx1bmRlZmluZWR9IFJlbmRlclxuICAqICAgICBvcmRlci5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFJlbmRlck9yZGVyID0gZnVuY3Rpb24gZ2V0UmVuZGVyT3JkZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyfk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5SRU5ERVJfT1JERVIpKVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICogR2V0IHRoZSBzdHlsZSBmb3IgZmVhdHVyZXMuICBUaGlzIHJldHVybnMgd2hhdGV2ZXIgd2FzIHBhc3NlZCB0byB0aGUgYHN0eWxlYFxuICAqIG9wdGlvbiBhdCBjb25zdHJ1Y3Rpb24gb3IgdG8gdGhlIGBzZXRTdHlsZWAgbWV0aG9kLlxuICAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9TdHlsZXxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn1cbiAgKiAgICAgTGF5ZXIgc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVfO1xuICB9O1xuXG4gIC8qKlxuICAqIEdldCB0aGUgc3R5bGUgZnVuY3Rpb24uXG4gICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfSBMYXllciBzdHlsZSBmdW5jdGlvbi5cbiAgKiBAYXBpXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5nZXRTdHlsZUZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0U3R5bGVGdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVGdW5jdGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgKiAgICAgYW5pbWF0aW5nLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0VXBkYXRlV2hpbGVBbmltYXRpbmcgPSBmdW5jdGlvbiBnZXRVcGRhdGVXaGlsZUFuaW1hdGluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVBbmltYXRpbmdfO1xuICB9O1xuXG4gIC8qKlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmVkIGxheWVyIHNob3VsZCBiZSB1cGRhdGVkIHdoaWxlXG4gICogICAgIGludGVyYWN0aW5nLlxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0VXBkYXRlV2hpbGVJbnRlcmFjdGluZyA9IGZ1bmN0aW9uIGdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmdfO1xuICB9O1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlcn5PcmRlckZ1bmN0aW9ufG51bGx8dW5kZWZpbmVkfSByZW5kZXJPcmRlclxuICAqICAgICBSZW5kZXIgb3JkZXIuXG4gICovXG4gIFZlY3RvckxheWVyLnByb3RvdHlwZS5zZXRSZW5kZXJPcmRlciA9IGZ1bmN0aW9uIHNldFJlbmRlck9yZGVyIChyZW5kZXJPcmRlcikge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LlJFTkRFUl9PUkRFUiwgcmVuZGVyT3JkZXIpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgc3R5bGUgZm9yIGZlYXR1cmVzLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAqIG9mIHN0eWxlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZmVhdHVyZSBhbmQgcmVzb2x1dGlvbiBhbmQgcmV0dXJuc1xuICAqIGFuIGFycmF5IG9mIHN0eWxlcy4gSWYgaXQgaXMgYHVuZGVmaW5lZGAgdGhlIGRlZmF1bHQgc3R5bGUgaXMgdXNlZC4gSWZcbiAgKiBpdCBpcyBgbnVsbGAgdGhlIGxheWVyIGhhcyBubyBzdHlsZSAoYSBgbnVsbGAgc3R5bGUpLCBzbyBvbmx5IGZlYXR1cmVzXG4gICogdGhhdCBoYXZlIHRoZWlyIG93biBzdHlsZXMgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgbGF5ZXIuIFNlZVxuICAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGV9IGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgZGVmYXVsdCBzdHlsZS5cbiAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZXxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbnxudWxsfHVuZGVmaW5lZH1cbiAgKiAgICAgc3R5bGUgTGF5ZXIgc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBWZWN0b3JMYXllci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlICE9PSB1bmRlZmluZWQgPyBzdHlsZSA6IGNyZWF0ZURlZmF1bHRTdHlsZTtcbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gc3R5bGUgPT09IG51bGwgP1xuICAgICAgdW5kZWZpbmVkIDogdG9TdHlsZUZ1bmN0aW9uKHRoaXMuc3R5bGVfKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgKiBAcmV0dXJuIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yUmVuZGVyVHlwZXxzdHJpbmd9IFRoZSByZW5kZXIgbW9kZS5cbiAgKi9cbiAgVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFJlbmRlck1vZGUgPSBmdW5jdGlvbiBnZXRSZW5kZXJNb2RlICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJNb2RlXztcbiAgfTtcblxuICByZXR1cm4gVmVjdG9yTGF5ZXI7XG59KExheWVyKSk7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yIHZlY3RvcnNvdXJjZX0gb2YgdGhlIGxheWVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gU291cmNlLlxuICogQGFwaVxuICovXG5WZWN0b3JMYXllci5wcm90b3R5cGUuZ2V0U291cmNlO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvckxheWVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1ZlY3RvclJlbmRlclR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBSZW5kZXIgbW9kZSBmb3IgdmVjdG9yIGxheWVyczpcbiAqICAqIGAnaW1hZ2UnYDogVmVjdG9yIGxheWVycyBhcmUgcmVuZGVyZWQgYXMgaW1hZ2VzLiBHcmVhdCBwZXJmb3JtYW5jZSwgYnV0XG4gKiAgICBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0cyBhcmUgYWx3YXlzIHJvdGF0ZWQgd2l0aCB0aGUgdmlldyBhbmQgcGl4ZWxzIGFyZVxuICogICAgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuXG4gKiAgKiBgJ3ZlY3RvcidgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyB2ZWN0b3JzLiBNb3N0IGFjY3VyYXRlIHJlbmRlcmluZ1xuICogICAgZXZlbiBkdXJpbmcgYW5pbWF0aW9ucywgYnV0IHNsb3dlciBwZXJmb3JtYW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJTUFHRTogJ2ltYWdlJyxcbiAgVkVDVE9SOiAndmVjdG9yJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yUmVuZGVyVHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVmVjdG9yVGlsZVJlbmRlclR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBSZW5kZXIgbW9kZSBmb3IgdmVjdG9yIHRpbGVzOlxuICogICogYCdpbWFnZSdgOiBWZWN0b3IgdGlsZXMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcy4gR3JlYXQgcGVyZm9ybWFuY2UsIGJ1dFxuICogICAgcG9pbnQgc3ltYm9scyBhbmQgdGV4dHMgYXJlIGFsd2F5cyByb3RhdGVkIHdpdGggdGhlIHZpZXcgYW5kIHBpeGVscyBhcmVcbiAqICAgIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLlxuICogICogYCdoeWJyaWQnYDogUG9seWdvbiBhbmQgbGluZSBlbGVtZW50cyBhcmUgcmVuZGVyZWQgYXMgaW1hZ2VzLCBzbyBwaXhlbHNcbiAqICAgIGFyZSBzY2FsZWQgZHVyaW5nIHpvb20gYW5pbWF0aW9ucy4gUG9pbnQgc3ltYm9scyBhbmQgdGV4dHMgYXJlIGFjY3VyYXRlbHlcbiAqICAgIHJlbmRlcmVkIGFzIHZlY3RvcnMgYW5kIGNhbiBzdGF5IHVwcmlnaHQgb24gcm90YXRlZCB2aWV3cy5cbiAqICAqIGAndmVjdG9yJ2A6IFZlY3RvciB0aWxlcyBhcmUgcmVuZGVyZWQgYXMgdmVjdG9ycy4gTW9zdCBhY2N1cmF0ZSByZW5kZXJpbmdcbiAqICAgIGV2ZW4gZHVyaW5nIGFuaW1hdGlvbnMsIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UgdGhhbiB0aGUgb3RoZXIgb3B0aW9ucy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJTUFHRTogJ2ltYWdlJyxcbiAgSFlCUklEOiAnaHlicmlkJyxcbiAgVkVDVE9SOiAndmVjdG9yJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yVGlsZVJlbmRlclR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xvYWRpbmdzdHJhdGVneVxuICovXG5cblxuLyoqXG4gKiBTdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBhbGwgZmVhdHVyZXMgd2l0aCBhIHNpbmdsZSByZXF1ZXN0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW1stSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XV07XG59XG5cblxuLyoqXG4gKiBTdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgdmlldydzIGV4dGVudCBhbmRcbiAqIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZXh0ZW50fkV4dGVudD59IEV4dGVudHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYm94KGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW2V4dGVudF07XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyYXRlZ3kgZnVuY3Rpb24gZm9yIGxvYWRpbmcgZmVhdHVyZXMgYmFzZWQgb24gYSB0aWxlIGdyaWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7ZnVuY3Rpb24obW9kdWxlOm9sL2V4dGVudH5FeHRlbnQsIG51bWJlcik6IEFycmF5Ljxtb2R1bGU6b2wvZXh0ZW50fkV4dGVudD59IExvYWRpbmcgc3RyYXRlZ3kuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aWxlKHRpbGVHcmlkKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvZXh0ZW50fkV4dGVudD59IEV4dGVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gICAgICB2YXIgeiA9IHRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgICAgdmFyIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6KTtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50Pn0gKi9cbiAgICAgIHZhciBleHRlbnRzID0gW107XG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSAqL1xuICAgICAgdmFyIHRpbGVDb29yZCA9IFt6LCAwLCAwXTtcbiAgICAgIGZvciAodGlsZUNvb3JkWzFdID0gdGlsZVJhbmdlLm1pblg7IHRpbGVDb29yZFsxXSA8PSB0aWxlUmFuZ2UubWF4WDsgKyt0aWxlQ29vcmRbMV0pIHtcbiAgICAgICAgZm9yICh0aWxlQ29vcmRbMl0gPSB0aWxlUmFuZ2UubWluWTsgdGlsZUNvb3JkWzJdIDw9IHRpbGVSYW5nZS5tYXhZOyArK3RpbGVDb29yZFsyXSkge1xuICAgICAgICAgIGV4dGVudHMucHVzaCh0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cbiAgKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGluZ3N0cmF0ZWd5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9tYXRoXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIGdpdmVuIG51bWJlci4gVGhlIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAqIG5hdGl2ZSBgTWF0aC5jb3NoYCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSB0aGUgaHlwZXJib2xpY1xuICogY29zaW5lIHdpbGwgYmUgY2FsY3VsYXRlZCB2aWEgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW96aWxsYVxuICogZGV2ZWxvcGVyIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cbiAqL1xuZXhwb3J0IHZhciBjb3NoID0gKGZ1bmN0aW9uKCkge1xuICAvLyBXcmFwcGVkIGluIGEgaWlmZSwgdG8gc2F2ZSB0aGUgb3ZlcmhlYWQgb2YgY2hlY2tpbmcgZm9yIHRoZSBuYXRpdmVcbiAgLy8gaW1wbGVtZW50YXRpb24gb24gZXZlcnkgaW52b2NhdGlvbi5cbiAgdmFyIGNvc2g7XG4gIGlmICgnY29zaCcgaW4gTWF0aCkge1xuICAgIC8vIFRoZSBlbnZpcm9ubWVudCBzdXBwb3J0cyB0aGUgbmF0aXZlIE1hdGguY29zaCBmdW5jdGlvbiwgdXNlIGl04oCmXG4gICAgY29zaCA9IE1hdGguY29zaDtcbiAgfSBlbHNlIHtcbiAgICAvLyDigKYgZWxzZSwgdXNlIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgTUROOlxuICAgIGNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgeSA9IE1hdGguZXhwKHgpO1xuICAgICAgcmV0dXJuICh5ICsgMSAvIHkpIC8gMjtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjb3NoO1xufSgpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFVwVG9Qb3dlck9mVHdvKHgpIHtcbiAgYXNzZXJ0KDAgPCB4LCAyOSk7IC8vIGB4YCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBgMGBcbiAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZyh4KSAvIE1hdGguTE4yKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnQgKHgsIHkpIGFuZCB0aGVcbiAqIGxpbmUgc2VnbWVudCAoeDEsIHkxKSB0byAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHgxIFgxLlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIFkxLlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIFgyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIFkyLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIGRpc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZFNlZ21lbnREaXN0YW5jZSh4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZHggPSB4MiAtIHgxO1xuICB2YXIgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICB2YXIgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGlmICh0ID4gMSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeDEgKz0gZHggKiB0O1xuICAgICAgeTEgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3F1YXJlZERpc3RhbmNlKHgsIHksIHgxLCB5MSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcXVhcmUgb2YgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoeDEsIHkxKSBhbmQgKHgyLCB5MikuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MTtcbiAgdmFyIGR5ID0geTIgLSB5MTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogU29sdmVzIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHVzaW5nIEdhdXNzaWFuIGVsaW1pbmF0aW9uIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IG1hdCBBdWdtZW50ZWQgbWF0cml4IChuIHggbiArIDEgY29sdW1uKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gcm93LW1ham9yIG9yZGVyLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFRoZSByZXN1bHRpbmcgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0obWF0KSB7XG4gIHZhciBuID0gbWF0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIC8vIEZpbmQgbWF4IGluIHRoZSBpLXRoIGNvbHVtbiAoaWdub3JpbmcgaSAtIDEgZmlyc3Qgcm93cylcbiAgICB2YXIgbWF4Um93ID0gaTtcbiAgICB2YXIgbWF4RWwgPSBNYXRoLmFicyhtYXRbaV1baV0pO1xuICAgIGZvciAodmFyIHIgPSBpICsgMTsgciA8IG47IHIrKykge1xuICAgICAgdmFyIGFic1ZhbHVlID0gTWF0aC5hYnMobWF0W3JdW2ldKTtcbiAgICAgIGlmIChhYnNWYWx1ZSA+IG1heEVsKSB7XG4gICAgICAgIG1heEVsID0gYWJzVmFsdWU7XG4gICAgICAgIG1heFJvdyA9IHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heEVsID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbWF0cml4IGlzIHNpbmd1bGFyXG4gICAgfVxuXG4gICAgLy8gU3dhcCBtYXggcm93IHdpdGggaS10aCAoY3VycmVudCkgcm93XG4gICAgdmFyIHRtcCA9IG1hdFttYXhSb3ddO1xuICAgIG1hdFttYXhSb3ddID0gbWF0W2ldO1xuICAgIG1hdFtpXSA9IHRtcDtcblxuICAgIC8vIFN1YnRyYWN0IHRoZSBpLXRoIHJvdyB0byBtYWtlIGFsbCB0aGUgcmVtYWluaW5nIHJvd3MgMCBpbiB0aGUgaS10aCBjb2x1bW5cbiAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIHZhciBjb2VmID0gLW1hdFtqXVtpXSAvIG1hdFtpXVtpXTtcbiAgICAgIGZvciAodmFyIGsgPSBpOyBrIDwgbiArIDE7IGsrKykge1xuICAgICAgICBpZiAoaSA9PSBrKSB7XG4gICAgICAgICAgbWF0W2pdW2tdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRbal1ba10gKz0gY29lZiAqIG1hdFtpXVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvbHZlIEF4PWIgZm9yIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IEEgKG1hdClcbiAgdmFyIHggPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGwgPSBuIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICB4W2xdID0gbWF0W2xdW25dIC8gbWF0W2xdW2xdO1xuICAgIGZvciAodmFyIG0gPSBsIC0gMTsgbSA+PSAwOyBtLS0pIHtcbiAgICAgIG1hdFttXVtuXSAtPSBtYXRbbV1bbF0gKiB4W2xdO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gdG8gZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJblJhZGlhbnMgQW5nbGUgaW4gcmFkaWFucy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhhbmdsZUluUmFkaWFucykge1xuICByZXR1cm4gYW5nbGVJblJhZGlhbnMgKiAxODAgLyBNYXRoLlBJO1xufVxuXG5cbi8qKlxuICogQ29udmVydHMgZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluRGVncmVlcyBBbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SYWRpYW5zKGFuZ2xlSW5EZWdyZWVzKSB7XG4gIHJldHVybiBhbmdsZUluRGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbW9kdWxvIG9mIGEgLyBiLCBkZXBlbmRpbmcgb24gdGhlIHNpZ24gb2YgYi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYSBEaXZpZGVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIERpdmlzb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1vZHVsby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vZHVsbyhhLCBiKSB7XG4gIHZhciByID0gYSAlIGI7XG4gIHJldHVybiByICogYiA8IDAgPyByICsgYiA6IHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIHggYmV0d2VlbiBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geCBWYWx1ZSB0byBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVycG9sYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoYSwgYiwgeCkge1xuICByZXR1cm4gYSArIHggKiAoYiAtIGEpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9vYmpcbiAqL1xuXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIE9iamVjdC5hc3NpZ24oKS4gIEFzc2lnbnMgZW51bWVyYWJsZSBhbmQgb3duIHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX3NvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgbW9kaWZpZWQgdGFyZ2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IHZhciBhc3NpZ24gPSAodHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbicpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uKHRhcmdldCwgdmFyX3NvdXJjZXMpIHtcbiAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDEsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzJDFbaV07XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBvdXRwdXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbGVhci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKG9iamVjdCkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgfVxufVxuXG5cbi8qKlxuICogR2V0IGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PEssVj59IG9iamVjdCBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gZ2V0IHRoZSB2YWx1ZXMuXG4gKiBAcmV0dXJuIHshQXJyYXk8Vj59IFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAdGVtcGxhdGUgSyxWXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZXMob2JqZWN0KSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgdmFsdWVzLnB1c2gob2JqZWN0W3Byb3BlcnR5XSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaGFzIGFueSBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqZWN0KSB7XG4gIHZhciBwcm9wZXJ0eTtcbiAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICFwcm9wZXJ0eTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50U291cmNlXG4gKi9cblxudmFyIEV2ZW50U291cmNlID0gZnVuY3Rpb24gRXZlbnRTb3VyY2UoZGlzcGF0Y2hlciwgbWFwcGluZykge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlcn1cbiAgICovXG4gIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdFxuICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBmdW5jdGlvbihFdmVudCk+fVxuICAgKi9cbiAgdGhpcy5tYXBwaW5nXyA9IG1hcHBpbmc7XG59O1xuXG4vKipcbiAqIExpc3Qgb2YgZXZlbnRzIHN1cHBvcnRlZCBieSB0aGlzIHNvdXJjZS5cbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBFdmVudCBuYW1lc1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gZ2V0RXZlbnRzICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwcGluZ18pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYW5kbGVyIHRoYXQgc2hvdWxkIGhhbmRsZSBhIGdpdmVuIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIFRoZSBldmVudCB0eXBlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oRXZlbnQpfSBIYW5kbGVyXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5nZXRIYW5kbGVyRm9yRXZlbnQgPSBmdW5jdGlvbiBnZXRIYW5kbGVyRm9yRXZlbnQgKGV2ZW50VHlwZSkge1xuICByZXR1cm4gdGhpcy5tYXBwaW5nX1tldmVudFR5cGVdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U291cmNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgUE9JTlRFUk1PVkU6ICdwb2ludGVybW92ZScsXG4gIFBPSU5URVJET1dOOiAncG9pbnRlcmRvd24nLFxuICBQT0lOVEVSVVA6ICdwb2ludGVydXAnLFxuICBQT0lOVEVST1ZFUjogJ3BvaW50ZXJvdmVyJyxcbiAgUE9JTlRFUk9VVDogJ3BvaW50ZXJvdXQnLFxuICBQT0lOVEVSRU5URVI6ICdwb2ludGVyZW50ZXInLFxuICBQT0lOVEVSTEVBVkU6ICdwb2ludGVybGVhdmUnLFxuICBQT0lOVEVSQ0FOQ0VMOiAncG9pbnRlcmNhbmNlbCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50VHlwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Nb3VzZVNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJy4uL3BvaW50ZXIvRXZlbnRTb3VyY2UuanMnO1xuXG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBQT0lOVEVSX0lEID0gMTtcblxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgUE9JTlRFUl9UWVBFID0gJ21vdXNlJztcblxuXG4vKipcbiAqIFJhZGl1cyBhcm91bmQgdG91Y2hlbmQgdGhhdCBzd2FsbG93cyBtb3VzZSBldmVudHMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIERFRFVQX0RJU1QgPSAyNTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2Vkb3duYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZWRvd24oaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICAvLyBUT0RPKGRmcmVlZG1hbikgd29ya2Fyb3VuZCBmb3Igc29tZSBlbGVtZW50cyBub3Qgc2VuZGluZyBtb3VzZXVwXG4gICAgLy8gaHR0cDovL2NyYnVnLzE0OTA5MVxuICAgIGlmIChQT0lOVEVSX0lELnRvU3RyaW5nKCkgaW4gdGhpcy5wb2ludGVyTWFwKSB7XG4gICAgICB0aGlzLmNhbmNlbChpbkV2ZW50KTtcbiAgICB9XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLnBvaW50ZXJNYXBbUE9JTlRFUl9JRC50b1N0cmluZygpXSA9IGluRXZlbnQ7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmRvd24oZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2Vtb3ZlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW1vdmUoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5tb3ZlKGUsIGluRXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1vdXNldXBgLlxuICpcbiAqIEB0aGlzIHttb2R1bGU6b2wvcG9pbnRlci9Nb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNldXAoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgcCA9IHRoaXMucG9pbnRlck1hcFtQT0lOVEVSX0lELnRvU3RyaW5nKCldO1xuXG4gICAgaWYgKHAgJiYgcC5idXR0b24gPT09IGluRXZlbnQuYnV0dG9uKSB7XG4gICAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaGVyLnVwKGUsIGluRXZlbnQpO1xuICAgICAgdGhpcy5jbGVhbnVwTW91c2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2VvdmVyYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW92ZXIoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICB2YXIgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5lbnRlck92ZXIoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2VvdXRgLlxuICpcbiAqIEB0aGlzIHttb2R1bGU6b2wvcG9pbnRlci9Nb3VzZVNvdXJjZX1cbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1vdXNlb3V0KGluRXZlbnQpIHtcbiAgaWYgKCF0aGlzLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfKGluRXZlbnQpKSB7XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmVPdXQoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuXG52YXIgTW91c2VTb3VyY2UgPSAoZnVuY3Rpb24gKEV2ZW50U291cmNlKSB7XG4gIGZ1bmN0aW9uIE1vdXNlU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdtb3VzZWRvd24nOiBtb3VzZWRvd24sXG4gICAgICAnbW91c2Vtb3ZlJzogbW91c2Vtb3ZlLFxuICAgICAgJ21vdXNldXAnOiBtb3VzZXVwLFxuICAgICAgJ21vdXNlb3Zlcic6IG1vdXNlb3ZlcixcbiAgICAgICdtb3VzZW91dCc6IG1vdXNlb3V0XG4gICAgfTtcbiAgICBFdmVudFNvdXJjZS5jYWxsKHRoaXMsIGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJNYXA7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9waXhlbH5QaXhlbD59XG4gICAgICovXG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICB9XG5cbiAgaWYgKCBFdmVudFNvdXJjZSApIE1vdXNlU291cmNlLl9fcHJvdG9fXyA9IEV2ZW50U291cmNlO1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFNvdXJjZSAmJiBFdmVudFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW91c2VTb3VyY2U7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBhIG1vdXNlIGV2ZW50IHdhcyBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGJ5XG4gICAqIGNoZWNraW5nIGlmIHByZXZpb3VzbHkgdGhlcmUgd2FzIGEgdG91Y2ggZXZlbnQgYXQgdGhlXG4gICAqIHNhbWUgcG9zaXRpb24uXG4gICAqXG4gICAqIEZJWE1FIC0gS25vd24gcHJvYmxlbSB3aXRoIHRoZSBuYXRpdmUgQW5kcm9pZCBicm93c2VyIG9uXG4gICAqIFNhbXN1bmcgR1QtSTkxMDAgKEFuZHJvaWQgNC4xLjIpOlxuICAgKiBJbiBjYXNlIHRoZSBwYWdlIGlzIHNjcm9sbGVkLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHdvcmtcbiAgICogY29ycmVjdGx5IHdoZW4gYSBjYW52YXMgaXMgdXNlZCAoV2ViR0wgb3IgY2FudmFzIHJlbmRlcmVyKS5cbiAgICogTW91c2UgbGlzdGVuZXJzIG9uIGNhbnZhcyBlbGVtZW50cyAoZm9yIHRoaXMgYnJvd3NlciksIGNyZWF0ZVxuICAgKiB0d28gbW91c2UgZXZlbnRzOiBPbmUgJ2dvb2QnIGFuZCBvbmUgJ2JhZCcgb25lIChvbiBvdGhlciBicm93c2VycyBvclxuICAgKiB3aGVuIGEgZGl2IGlzIHVzZWQsIHRoZXJlIGlzIG9ubHkgb25lIGV2ZW50KS4gRm9yIHRoZSAnYmFkJyBvbmUsXG4gICAqIGNsaWVudFgvY2xpZW50WSBhbmQgYWxzbyBwYWdlWC9wYWdlWSBhcmUgd3Jvbmcgd2hlbiB0aGUgcGFnZVxuICAgKiBpcyBzY3JvbGxlZC4gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIGZ1bmN0aW9uIGNhbiBub3QgZGV0ZWN0IGlmXG4gICAqIHRoZSBldmVudHMgd2VyZSBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGV2ZW50LiBBcyByZXN1bHQsIGFcbiAgICogcG9pbnRlciBldmVudCBhdCBhIHdyb25nIHBvc2l0aW9uIGlzIGRpc3BhdGNoZWQsIHdoaWNoIGNvbmZ1c2VzXG4gICAqIHRoZSBtYXAgaW50ZXJhY3Rpb25zLlxuICAgKiBJdCBpcyB1bmNsZWFyLCBob3cgb25lIGNhbiBnZXQgdGhlIGNvcnJlY3QgcG9zaXRpb24gZm9yIHRoZSBldmVudFxuICAgKiBvciBkZXRlY3QgdGhhdCB0aGUgcG9zaXRpb25zIGFyZSBpbnZhbGlkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLCBpZiB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoLlxuICAgKi9cbiAgTW91c2VTb3VyY2UucHJvdG90eXBlLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfID0gZnVuY3Rpb24gaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8gKGluRXZlbnQpIHtcbiAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQgPSAodm9pZCAwKTsgaSA8IGwgJiYgKHQgPSBsdHNbaV0pOyBpKyspIHtcbiAgICAgIC8vIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgd2lsbCBiZSBzd2FsbG93ZWQgbmVhciBhIHByaW1hcnkgdG91Y2hlbmRcbiAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0WzBdKTtcbiAgICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0WzFdKTtcbiAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGBwb2ludGVyY2FuY2VsYCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsIChpbkV2ZW50KSB7XG4gICAgdmFyIGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuY2FuY2VsKGUsIGluRXZlbnQpO1xuICAgIHRoaXMuY2xlYW51cE1vdXNlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbW91c2UgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcG9pbnRlcnMuXG4gICAqL1xuICBNb3VzZVNvdXJjZS5wcm90b3R5cGUuY2xlYW51cE1vdXNlID0gZnVuY3Rpb24gY2xlYW51cE1vdXNlICgpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW1BPSU5URVJfSUQudG9TdHJpbmcoKV07XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlU291cmNlO1xufShFdmVudFNvdXJjZSkpO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgd2lsbCBiZSB1c2VkXG4gKiBmb3IgdGhlIGZha2UgcG9pbnRlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlcn0gZGlzcGF0Y2hlciBFdmVudCBoYW5kbGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29waWVkIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwcmVwYXJlRXZlbnQoaW5FdmVudCwgZGlzcGF0Y2hlcikge1xuICB2YXIgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50LCBpbkV2ZW50KTtcblxuICAvLyBmb3J3YXJkIG1vdXNlIHByZXZlbnREZWZhdWx0XG4gIHZhciBwZCA9IGUucHJldmVudERlZmF1bHQ7XG4gIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcGQoKTtcbiAgfTtcblxuICBlLnBvaW50ZXJJZCA9IFBPSU5URVJfSUQ7XG4gIGUuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgZS5wb2ludGVyVHlwZSA9IFBPSU5URVJfVFlQRTtcblxuICByZXR1cm4gZTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNb3VzZVNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW91c2VTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvTXNTb3VyY2VcbiAqL1xuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi4vcG9pbnRlci9FdmVudFNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAqL1xudmFyIFBPSU5URVJfVFlQRVMgPSBbXG4gICcnLFxuICAndW5hdmFpbGFibGUnLFxuICAndG91Y2gnLFxuICAncGVuJyxcbiAgJ21vdXNlJ1xuXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyRG93bmAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlckRvd24oaW5FdmVudCkge1xuICB0aGlzLnBvaW50ZXJNYXBbaW5FdmVudC5wb2ludGVySWQudG9TdHJpbmcoKV0gPSBpbkV2ZW50O1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmRvd24oZSwgaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlck1vdmVgLlxuICpcbiAqIEB0aGlzIHttb2R1bGU6b2wvcG9pbnRlci9Nc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJNb3ZlKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5tb3ZlKGUsIGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJVcGAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlclVwKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci51cChlLCBpbkV2ZW50KTtcbiAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyT3V0YC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyT3V0KGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZU91dChlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyT3ZlcmAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlck92ZXIoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmVudGVyT3ZlcihlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyQ2FuY2VsYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyQ2FuY2VsKGluRXZlbnQpIHtcbiAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5jYW5jZWwoZSwgaW5FdmVudCk7XG4gIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zTG9zdFBvaW50ZXJDYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNMb3N0UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMuZGlzcGF0Y2hlci5tYWtlRXZlbnQoJ2xvc3Rwb2ludGVyY2FwdHVyZScsIGluRXZlbnQsIGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNHb3RQb2ludGVyQ2FwdHVyZWAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zR290UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICB2YXIgZSA9IHRoaXMuZGlzcGF0Y2hlci5tYWtlRXZlbnQoJ2dvdHBvaW50ZXJjYXB0dXJlJywgaW5FdmVudCwgaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG52YXIgTXNTb3VyY2UgPSAoZnVuY3Rpb24gKEV2ZW50U291cmNlKSB7XG4gIGZ1bmN0aW9uIE1zU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdNU1BvaW50ZXJEb3duJzogbXNQb2ludGVyRG93bixcbiAgICAgICdNU1BvaW50ZXJNb3ZlJzogbXNQb2ludGVyTW92ZSxcbiAgICAgICdNU1BvaW50ZXJVcCc6IG1zUG9pbnRlclVwLFxuICAgICAgJ01TUG9pbnRlck91dCc6IG1zUG9pbnRlck91dCxcbiAgICAgICdNU1BvaW50ZXJPdmVyJzogbXNQb2ludGVyT3ZlcixcbiAgICAgICdNU1BvaW50ZXJDYW5jZWwnOiBtc1BvaW50ZXJDYW5jZWwsXG4gICAgICAnTVNHb3RQb2ludGVyQ2FwdHVyZSc6IG1zR290UG9pbnRlckNhcHR1cmUsXG4gICAgICAnTVNMb3N0UG9pbnRlckNhcHR1cmUnOiBtc0xvc3RQb2ludGVyQ2FwdHVyZVxuICAgIH07XG4gICAgRXZlbnRTb3VyY2UuY2FsbCh0aGlzLCBkaXNwYXRjaGVyLCBtYXBwaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIE1TUG9pbnRlckV2ZW50fE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyTWFwID0gZGlzcGF0Y2hlci5wb2ludGVyTWFwO1xuICB9XG5cbiAgaWYgKCBFdmVudFNvdXJjZSApIE1zU291cmNlLl9fcHJvdG9fXyA9IEV2ZW50U291cmNlO1xuICBNc1NvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudFNvdXJjZSAmJiBFdmVudFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgTXNTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXNTb3VyY2U7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IHdpbGwgYmUgdXNlZFxuICAgKiBmb3IgdGhlIGZha2UgcG9pbnRlciBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvcGllZCBldmVudC5cbiAgICovXG4gIE1zU291cmNlLnByb3RvdHlwZS5wcmVwYXJlRXZlbnRfID0gZnVuY3Rpb24gcHJlcGFyZUV2ZW50XyAoaW5FdmVudCkge1xuICAgIHZhciBlID0gaW5FdmVudDtcbiAgICBpZiAodHlwZW9mIGluRXZlbnQucG9pbnRlclR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBlID0gdGhpcy5kaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCwgaW5FdmVudCk7XG4gICAgICBlLnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFU1tpbkV2ZW50LnBvaW50ZXJUeXBlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoaXMgcG9pbnRlciBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwb2ludGVycy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50ZXJJZCBQb2ludGVyIGlkZW50aWZpZXIuXG4gICAqL1xuICBNc1NvdXJjZS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uIGNsZWFudXAgKHBvaW50ZXJJZCkge1xuICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJNYXBbcG9pbnRlcklkLnRvU3RyaW5nKCldO1xuICB9O1xuXG4gIHJldHVybiBNc1NvdXJjZTtcbn0oRXZlbnRTb3VyY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgTXNTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1zU291cmNlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wb2ludGVyL05hdGl2ZVNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IEV2ZW50U291cmNlIGZyb20gJy4uL3BvaW50ZXIvRXZlbnRTb3VyY2UuanMnO1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVyZG93bmAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyRG93bihpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJtb3ZlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJNb3ZlKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcnVwYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJVcChpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJvdXRgLlxuICpcbiAqIEB0aGlzIHttb2R1bGU6b2wvcG9pbnRlci9OYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlck91dChpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJvdmVyYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJPdmVyKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcmNhbmNlbGAuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyQ2FuY2VsKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbG9zdHBvaW50ZXJjYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvc3RQb2ludGVyQ2FwdHVyZShpbkV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hlci5maXJlTmF0aXZlRXZlbnQoaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYGdvdHBvaW50ZXJjYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvTmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdvdFBvaW50ZXJDYXB0dXJlKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxudmFyIE5hdGl2ZVNvdXJjZSA9IChmdW5jdGlvbiAoRXZlbnRTb3VyY2UpIHtcbiAgZnVuY3Rpb24gTmF0aXZlU291cmNlKGRpc3BhdGNoZXIpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICdwb2ludGVyZG93bic6IHBvaW50ZXJEb3duLFxuICAgICAgJ3BvaW50ZXJtb3ZlJzogcG9pbnRlck1vdmUsXG4gICAgICAncG9pbnRlcnVwJzogcG9pbnRlclVwLFxuICAgICAgJ3BvaW50ZXJvdXQnOiBwb2ludGVyT3V0LFxuICAgICAgJ3BvaW50ZXJvdmVyJzogcG9pbnRlck92ZXIsXG4gICAgICAncG9pbnRlcmNhbmNlbCc6IHBvaW50ZXJDYW5jZWwsXG4gICAgICAnZ290cG9pbnRlcmNhcHR1cmUnOiBnb3RQb2ludGVyQ2FwdHVyZSxcbiAgICAgICdsb3N0cG9pbnRlcmNhcHR1cmUnOiBsb3N0UG9pbnRlckNhcHR1cmVcbiAgICB9O1xuICAgIEV2ZW50U291cmNlLmNhbGwodGhpcywgZGlzcGF0Y2hlciwgbWFwcGluZyk7XG4gIH1cblxuICBpZiAoIEV2ZW50U291cmNlICkgTmF0aXZlU291cmNlLl9fcHJvdG9fXyA9IEV2ZW50U291cmNlO1xuICBOYXRpdmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRTb3VyY2UgJiYgRXZlbnRTb3VyY2UucHJvdG90eXBlICk7XG4gIE5hdGl2ZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYXRpdmVTb3VyY2U7XG5cbiAgcmV0dXJuIE5hdGl2ZVNvdXJjZTtcbn0oRXZlbnRTb3VyY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgTmF0aXZlU291cmNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OYXRpdmVTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvUG9pbnRlckV2ZW50XG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIElzIHRoZSBgYnV0dG9uc2AgcHJvcGVydHkgc3VwcG9ydGVkP1xuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZhciBIQVNfQlVUVE9OUyA9IGZhbHNlO1xuXG5cbnZhciBQb2ludGVyRXZlbnQgPSAoZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudCh0eXBlLCBvcmlnaW5hbEV2ZW50LCBvcHRfZXZlbnREaWN0KSB7XG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuXG4gICAgdmFyIGV2ZW50RGljdCA9IG9wdF9ldmVudERpY3QgPyBvcHRfZXZlbnREaWN0IDoge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9uc18oZXZlbnREaWN0KTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wcmVzc3VyZSA9IHRoaXMuZ2V0UHJlc3N1cmVfKGV2ZW50RGljdCwgdGhpcy5idXR0b25zKTtcblxuICAgIC8vIE1vdXNlRXZlbnQgcmVsYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1YmJsZXMgPSAnYnViYmxlcycgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydidWJibGVzJ10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY2FuY2VsYWJsZSA9ICdjYW5jZWxhYmxlJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2NhbmNlbGFibGUnXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXcgPSAndmlldycgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd2aWV3J10gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRldGFpbCA9ICdkZXRhaWwnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnZGV0YWlsJ10gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblggPSAnc2NyZWVuWCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydzY3JlZW5YJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSAnc2NyZWVuWScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydzY3JlZW5ZJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFggPSAnY2xpZW50WCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjbGllbnRYJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFkgPSAnY2xpZW50WScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjbGllbnRZJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gJ2N0cmxLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY3RybEtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsdEtleSA9ICdhbHRLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYWx0S2V5J10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hpZnRLZXkgPSAnc2hpZnRLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2hpZnRLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tZXRhS2V5ID0gJ21ldGFLZXknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnbWV0YUtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYnV0dG9uID0gJ2J1dHRvbicgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydidXR0b24nXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSAncmVsYXRlZFRhcmdldCcgaW4gZXZlbnREaWN0ID9cbiAgICAgIGV2ZW50RGljdFsncmVsYXRlZFRhcmdldCddIDogbnVsbDtcblxuICAgIC8vIFBvaW50ZXJFdmVudCByZWxhdGVkIHByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVySWQgPSAncG9pbnRlcklkJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ3BvaW50ZXJJZCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9ICd3aWR0aCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd3aWR0aCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSAnaGVpZ2h0JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2hlaWdodCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WCA9ICd0aWx0WCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd0aWx0WCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWx0WSA9ICd0aWx0WScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wyd0aWx0WSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyVHlwZSA9ICdwb2ludGVyVHlwZScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wydwb2ludGVyVHlwZSddIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaHdUaW1lc3RhbXAgPSAnaHdUaW1lc3RhbXAnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnaHdUaW1lc3RhbXAnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzUHJpbWFyeSA9ICdpc1ByaW1hcnknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnaXNQcmltYXJ5J10gOiBmYWxzZTtcblxuICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgIGlmIChvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgaWYgKCBFdmVudCApIFBvaW50ZXJFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgUG9pbnRlckV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBQb2ludGVyRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRlckV2ZW50O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCA/Pn0gZXZlbnREaWN0IFRoZSBldmVudCBkaWN0aW9uYXJ5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEJ1dHRvbiBpbmRpY2F0b3IuXG4gICAqL1xuICBQb2ludGVyRXZlbnQucHJvdG90eXBlLmdldEJ1dHRvbnNfID0gZnVuY3Rpb24gZ2V0QnV0dG9uc18gKGV2ZW50RGljdCkge1xuICAgIC8vIEFjY29yZGluZyB0byB0aGUgdzNjIHNwZWMsXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtTW91c2VFdmVudC1idXR0b25cbiAgICAvLyBNb3VzZUV2ZW50LmJ1dHRvbiA9PSAwIGNhbiBtZWFuIGVpdGhlciBubyBtb3VzZSBidXR0b24gZGVwcmVzc2VkLCBvciB0aGVcbiAgICAvLyBsZWZ0IG1vdXNlIGJ1dHRvbiBkZXByZXNzZWQuXG4gICAgLy9cbiAgICAvLyBBcyBvZiBub3csIHRoZSBvbmx5IHdheSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d28gc3RhdGVzIG9mXG4gICAgLy8gTW91c2VFdmVudC5idXR0b24gaXMgYnkgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgTW91c2VFdmVudC53aGljaCBwcm9wZXJ0eSwgYXNcbiAgICAvLyB0aGlzIG1hcHMgbW91c2UgYnV0dG9ucyB0byBwb3NpdGl2ZSBpbnRlZ2VycyA+IDAsIGFuZCB1c2VzIDAgdG8gbWVhbiB0aGF0XG4gICAgLy8gbm8gbW91c2UgYnV0dG9uIGlzIGhlbGQuXG4gICAgLy9cbiAgICAvLyBNb3VzZUV2ZW50LndoaWNoIGlzIGRlcml2ZWQgZnJvbSBNb3VzZUV2ZW50LmJ1dHRvbiBhdCBNb3VzZUV2ZW50IGNyZWF0aW9uLFxuICAgIC8vIGJ1dCBpbml0TW91c2VFdmVudCBkb2VzIG5vdCBleHBvc2UgYW4gYXJndW1lbnQgd2l0aCB3aGljaCB0byBzZXRcbiAgICAvLyBNb3VzZUV2ZW50LndoaWNoLiBDYWxsaW5nIGluaXRNb3VzZUV2ZW50IHdpdGggYSBidXR0b25Bcmcgb2YgMCB3aWxsIHNldFxuICAgIC8vIE1vdXNlRXZlbnQuYnV0dG9uID09IDAgYW5kIE1vdXNlRXZlbnQud2hpY2ggPT0gMSwgYnJlYWtpbmcgdGhlIGV4cGVjdGF0aW9uc1xuICAgIC8vIG9mIGFwcCBkZXZlbG9wZXJzLlxuICAgIC8vXG4gICAgLy8gVGhlIG9ubHkgd2F5IHRvIHByb3BhZ2F0ZSB0aGUgY29ycmVjdCBzdGF0ZSBvZiBNb3VzZUV2ZW50LndoaWNoIGFuZFxuICAgIC8vIE1vdXNlRXZlbnQuYnV0dG9uIHRvIGEgbmV3IE1vdXNlRXZlbnQuYnV0dG9uID09IDAgYW5kIE1vdXNlRXZlbnQud2hpY2ggPT0gMFxuICAgIC8vIGlzIHRvIGNhbGwgaW5pdE1vdXNlRXZlbnQgd2l0aCBhIGJ1dHRvbkFyZyB2YWx1ZSBvZiAtMS5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgZml4ZWQgd2l0aCBET00gTGV2ZWwgNCdzIHVzZSBvZiBidXR0b25zXG4gICAgdmFyIGJ1dHRvbnM7XG4gICAgaWYgKGV2ZW50RGljdC5idXR0b25zIHx8IEhBU19CVVRUT05TKSB7XG4gICAgICBidXR0b25zID0gZXZlbnREaWN0LmJ1dHRvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoZXZlbnREaWN0LndoaWNoKSB7XG4gICAgICAgIGNhc2UgMTogYnV0dG9ucyA9IDE7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGJ1dHRvbnMgPSA0OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBidXR0b25zID0gMjsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IGJ1dHRvbnMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnV0dG9ucztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgPz59IGV2ZW50RGljdCBUaGUgZXZlbnQgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1dHRvbnMgQnV0dG9uIGluZGljYXRvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcHJlc3N1cmUuXG4gICAqL1xuICBQb2ludGVyRXZlbnQucHJvdG90eXBlLmdldFByZXNzdXJlXyA9IGZ1bmN0aW9uIGdldFByZXNzdXJlXyAoZXZlbnREaWN0LCBidXR0b25zKSB7XG4gICAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgICAvLyBzdGF0ZSBhbmQgMCBmb3IgdXAgc3RhdGUuXG4gICAgdmFyIHByZXNzdXJlID0gMDtcbiAgICBpZiAoZXZlbnREaWN0LnByZXNzdXJlKSB7XG4gICAgICBwcmVzc3VyZSA9IGV2ZW50RGljdC5wcmVzc3VyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlc3N1cmUgPSBidXR0b25zID8gMC41IDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXNzdXJlO1xuICB9O1xuXG4gIHJldHVybiBQb2ludGVyRXZlbnQ7XG59KEV2ZW50KSk7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBidXR0b25zYCBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZXYgPSBuZXcgTW91c2VFdmVudCgnY2xpY2snLCB7YnV0dG9uczogMX0pO1xuICAgIEhBU19CVVRUT05TID0gZXYuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHBhc3NcbiAgfVxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckV2ZW50O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVyRXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvUG9pbnRlckV2ZW50SGFuZGxlclxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9FdmVudFRhcmdldC5qcyc7XG5pbXBvcnQge1BPSU5URVIsIE1TUE9JTlRFUiwgVE9VQ0h9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuLi9wb2ludGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTW91c2VTb3VyY2UgZnJvbSAnLi4vcG9pbnRlci9Nb3VzZVNvdXJjZS5qcyc7XG5pbXBvcnQgTXNTb3VyY2UgZnJvbSAnLi4vcG9pbnRlci9Nc1NvdXJjZS5qcyc7XG5pbXBvcnQgTmF0aXZlU291cmNlIGZyb20gJy4uL3BvaW50ZXIvTmF0aXZlU291cmNlLmpzJztcbmltcG9ydCBQb2ludGVyRXZlbnQgZnJvbSAnLi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanMnO1xuaW1wb3J0IFRvdWNoU291cmNlIGZyb20gJy4uL3BvaW50ZXIvVG91Y2hTb3VyY2UuanMnO1xuXG5cbi8qKlxuICogUHJvcGVydGllcyB0byBjb3B5IHdoZW4gY2xvbmluZyBhbiBldmVudCwgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEB0eXBlIHtBcnJheS48QXJyYXk+fVxuICovXG52YXIgQ0xPTkVfUFJPUFMgPSBbXG4gIC8vIE1vdXNlRXZlbnRcbiAgWydidWJibGVzJywgZmFsc2VdLFxuICBbJ2NhbmNlbGFibGUnLCBmYWxzZV0sXG4gIFsndmlldycsIG51bGxdLFxuICBbJ2RldGFpbCcsIG51bGxdLFxuICBbJ3NjcmVlblgnLCAwXSxcbiAgWydzY3JlZW5ZJywgMF0sXG4gIFsnY2xpZW50WCcsIDBdLFxuICBbJ2NsaWVudFknLCAwXSxcbiAgWydjdHJsS2V5JywgZmFsc2VdLFxuICBbJ2FsdEtleScsIGZhbHNlXSxcbiAgWydzaGlmdEtleScsIGZhbHNlXSxcbiAgWydtZXRhS2V5JywgZmFsc2VdLFxuICBbJ2J1dHRvbicsIDBdLFxuICBbJ3JlbGF0ZWRUYXJnZXQnLCBudWxsXSxcbiAgLy8gRE9NIExldmVsIDNcbiAgWydidXR0b25zJywgMF0sXG4gIC8vIFBvaW50ZXJFdmVudFxuICBbJ3BvaW50ZXJJZCcsIDBdLFxuICBbJ3dpZHRoJywgMF0sXG4gIFsnaGVpZ2h0JywgMF0sXG4gIFsncHJlc3N1cmUnLCAwXSxcbiAgWyd0aWx0WCcsIDBdLFxuICBbJ3RpbHRZJywgMF0sXG4gIFsncG9pbnRlclR5cGUnLCAnJ10sXG4gIFsnaHdUaW1lc3RhbXAnLCAwXSxcbiAgWydpc1ByaW1hcnknLCBmYWxzZV0sXG4gIC8vIGV2ZW50IGluc3RhbmNlXG4gIFsndHlwZScsICcnXSxcbiAgWyd0YXJnZXQnLCBudWxsXSxcbiAgWydjdXJyZW50VGFyZ2V0JywgbnVsbF0sXG4gIFsnd2hpY2gnLCAwXVxuXTtcblxuXG52YXIgUG9pbnRlckV2ZW50SGFuZGxlciA9IChmdW5jdGlvbiAoRXZlbnRUYXJnZXQpIHtcbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SGFuZGxlcihlbGVtZW50KSB7XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0VsZW1lbnR8SFRNTERvY3VtZW50fVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudF8gPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRNYXBfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9wb2ludGVyL0V2ZW50U291cmNlPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRTb3VyY2VMaXN0XyA9IFtdO1xuXG4gICAgdGhpcy5yZWdpc3RlclNvdXJjZXMoKTtcbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBQb2ludGVyRXZlbnRIYW5kbGVyLl9fcHJvdG9fXyA9IEV2ZW50VGFyZ2V0O1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50VGFyZ2V0ICYmIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSApO1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50ZXJFdmVudEhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgZXZlbnQgc291cmNlcyAobW91c2UsIHRvdWNoIGFuZCBuYXRpdmUgcG9pbnRlcnMpXG4gICAqIHRoYXQgZ2VuZXJhdGUgcG9pbnRlciBldmVudHMuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5yZWdpc3RlclNvdXJjZXMgPSBmdW5jdGlvbiByZWdpc3RlclNvdXJjZXMgKCkge1xuICAgIGlmIChQT0lOVEVSKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCduYXRpdmUnLCBuZXcgTmF0aXZlU291cmNlKHRoaXMpKTtcbiAgICB9IGVsc2UgaWYgKE1TUE9JTlRFUikge1xuICAgICAgdGhpcy5yZWdpc3RlclNvdXJjZSgnbXMnLCBuZXcgTXNTb3VyY2UodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbW91c2VTb3VyY2UgPSBuZXcgTW91c2VTb3VyY2UodGhpcyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCdtb3VzZScsIG1vdXNlU291cmNlKTtcblxuICAgICAgaWYgKFRPVUNIKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTb3VyY2UoJ3RvdWNoJywgbmV3IFRvdWNoU291cmNlKHRoaXMsIG1vdXNlU291cmNlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVnaXN0ZXIgZXZlbnRzIG9uIHRoZSB2aWV3cG9ydCBlbGVtZW50XG4gICAgdGhpcy5yZWdpc3Rlcl8oKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgbmV3IGV2ZW50IHNvdXJjZSB0aGF0IHdpbGwgZ2VuZXJhdGUgcG9pbnRlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgbmFtZSBmb3IgdGhlIGV2ZW50IHNvdXJjZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wb2ludGVyL0V2ZW50U291cmNlfSBzb3VyY2UgVGhlIHNvdXJjZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyU291cmNlID0gZnVuY3Rpb24gcmVnaXN0ZXJTb3VyY2UgKG5hbWUsIHNvdXJjZSkge1xuICAgIHZhciBzID0gc291cmNlO1xuICAgIHZhciBuZXdFdmVudHMgPSBzLmdldEV2ZW50cygpO1xuXG4gICAgaWYgKG5ld0V2ZW50cykge1xuICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHMuZ2V0SGFuZGxlckZvckV2ZW50KGUpO1xuXG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5ldmVudE1hcF9bZV0gPSBoYW5kbGVyLmJpbmQocyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U291cmNlTGlzdF8ucHVzaChzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgZXZlbnRzIGZvciBhbGwgcmVnaXN0ZXJlZCBldmVudCBzb3VyY2VzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUucmVnaXN0ZXJfID0gZnVuY3Rpb24gcmVnaXN0ZXJfICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3RfLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGV2ZW50U291cmNlID0gdGhpcyQxLmV2ZW50U291cmNlTGlzdF9baV07XG4gICAgICB0aGlzJDEuYWRkRXZlbnRzXyhldmVudFNvdXJjZS5nZXRFdmVudHMoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUudW5yZWdpc3Rlcl8gPSBmdW5jdGlvbiB1bnJlZ2lzdGVyXyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbCA9IHRoaXMuZXZlbnRTb3VyY2VMaXN0Xy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBldmVudFNvdXJjZSA9IHRoaXMkMS5ldmVudFNvdXJjZUxpc3RfW2ldO1xuICAgICAgdGhpcyQxLnJlbW92ZUV2ZW50c18oZXZlbnRTb3VyY2UuZ2V0RXZlbnRzKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbHMgdGhlIHJpZ2h0IGhhbmRsZXIgZm9yIGEgbmV3IGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5ldmVudEhhbmRsZXJfID0gZnVuY3Rpb24gZXZlbnRIYW5kbGVyXyAoaW5FdmVudCkge1xuICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudE1hcF9bdHlwZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIoaW5FdmVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmFkZEV2ZW50c18gPSBmdW5jdGlvbiBhZGRFdmVudHNfIChldmVudHMpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGxpc3Rlbih0aGlzLmVsZW1lbnRfLCBldmVudE5hbWUsIHRoaXMuZXZlbnRIYW5kbGVyXywgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogVW5yZWdpc3RlciBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50c18gPSBmdW5jdGlvbiByZW1vdmVFdmVudHNfIChldmVudHMpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICB1bmxpc3Rlbih0aGlzLmVsZW1lbnRfLCBlLCB0aGlzLmV2ZW50SGFuZGxlcl8sIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzbmFwc2hvdCBvZiBpbkV2ZW50LCB3aXRoIHdyaXRhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqIEBwYXJhbSB7RXZlbnR8VG91Y2h9IGluRXZlbnQgQW4gZXZlbnQgdGhhdCBjb250YWluc1xuICAgKiAgICBwcm9wZXJ0aWVzIHRvIGNvcHkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgc2hhbGxvdyBjb3BpZXMgb2ZcbiAgICogICAgYGluRXZlbnRgJ3MgcHJvcGVydGllcy5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNsb25lRXZlbnQgPSBmdW5jdGlvbiBjbG9uZUV2ZW50IChldmVudCwgaW5FdmVudCkge1xuICAgIHZhciBldmVudENvcHkgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBDTE9ORV9QUk9QUy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgcCA9IENMT05FX1BST1BTW2ldWzBdO1xuICAgICAgZXZlbnRDb3B5W3BdID0gZXZlbnRbcF0gfHwgaW5FdmVudFtwXSB8fCBDTE9ORV9QUk9QU1tpXVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRDb3B5O1xuICB9O1xuXG4gIC8vIEVWRU5UU1xuXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJkb3duJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5kb3duID0gZnVuY3Rpb24gZG93biAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJET1dOLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJtb3ZlJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gbW92ZSAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJNT1ZFLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJ1cCcgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUudXAgPSBmdW5jdGlvbiB1cCAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJVUCwgZGF0YSwgZXZlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyZW50ZXInIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gZW50ZXIgKGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gZmFsc2U7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRU5URVIsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcmxlYXZlJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIGxlYXZlIChkYXRhLCBldmVudCkge1xuICAgIGRhdGEuYnViYmxlcyA9IGZhbHNlO1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUkxFQVZFLCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJvdmVyJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vdmVyID0gZnVuY3Rpb24gb3ZlciAoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSB0cnVlO1xuICAgIHRoaXMuZmlyZUV2ZW50KFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk9WRVIsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcm91dCcgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUub3V0ID0gZnVuY3Rpb24gb3V0IChkYXRhLCBldmVudCkge1xuICAgIGRhdGEuYnViYmxlcyA9IHRydWU7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVST1VULCBkYXRhLCBldmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJjYW5jZWwnIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUwsIGRhdGEsIGV2ZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBjb21iaW5hdGlvbiBvZiAncG9pbnRlcm91dCcgYW5kICdwb2ludGVybGVhdmUnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5sZWF2ZU91dCA9IGZ1bmN0aW9uIGxlYXZlT3V0IChkYXRhLCBldmVudCkge1xuICAgIHRoaXMub3V0KGRhdGEsIGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuY29udGFpbnNfKGRhdGEudGFyZ2V0LCBkYXRhLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICB0aGlzLmxlYXZlKGRhdGEsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgY29tYmluYXRpb24gb2YgJ3BvaW50ZXJvdmVyJyBhbmQgJ3BvaW50ZXJldmVudHMnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5lbnRlck92ZXIgPSBmdW5jdGlvbiBlbnRlck92ZXIgKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5vdmVyKGRhdGEsIGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuY29udGFpbnNfKGRhdGEudGFyZ2V0LCBkYXRhLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICB0aGlzLmVudGVyKGRhdGEsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIFRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZWQgVGhlIGNvbnRhaW5lZCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRhaW5lciBlbGVtZW50XG4gICAqICAgY29udGFpbnMgdGhlIG90aGVyIGVsZW1lbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jb250YWluc18gPSBmdW5jdGlvbiBjb250YWluc18gKGNvbnRhaW5lciwgY29udGFpbmVkKSB7XG4gICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyLmNvbnRhaW5zKGNvbnRhaW5lZCk7XG4gIH07XG5cbiAgLy8gRVZFTlQgQ1JFQVRJT04gQU5EIFRSQUNLSU5HXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50IG9mIHR5cGUgYGluVHlwZWAsIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBpblxuICAgKiBgZGF0YWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpblR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudH0gQSBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYC5cbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLm1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCAoaW5UeXBlLCBkYXRhLCBldmVudCkge1xuICAgIHJldHVybiBuZXcgUG9pbnRlckV2ZW50KGluVHlwZSwgZXZlbnQsIGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGFuZCBkaXNwYXRjaCBhbiBldmVudCBpbiBvbmUgY2FsbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGluVHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgUG9pbnRlckV2ZW50SGFuZGxlci5wcm90b3R5cGUuZmlyZUV2ZW50ID0gZnVuY3Rpb24gZmlyZUV2ZW50IChpblR5cGUsIGRhdGEsIGV2ZW50KSB7XG4gICAgdmFyIGUgPSB0aGlzLm1ha2VFdmVudChpblR5cGUsIGRhdGEsIGV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwb2ludGVyIGV2ZW50IGZyb20gYSBuYXRpdmUgcG9pbnRlciBldmVudFxuICAgKiBhbmQgZGlzcGF0Y2hlcyB0aGlzIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBBIHBsYXRmb3JtIGV2ZW50IHdpdGggYSB0YXJnZXQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5maXJlTmF0aXZlRXZlbnQgPSBmdW5jdGlvbiBmaXJlTmF0aXZlRXZlbnQgKGV2ZW50KSB7XG4gICAgdmFyIGUgPSB0aGlzLm1ha2VFdmVudChldmVudC50eXBlLCBldmVudCwgZXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfTtcblxuICAvKipcbiAgICogV3JhcCBhIG5hdGl2ZSBtb3VzZSBldmVudCBpbnRvIGEgcG9pbnRlciBldmVudC5cbiAgICogVGhpcyBwcm94eSBtZXRob2QgaXMgcmVxdWlyZWQgZm9yIHRoZSBsZWdhY3kgSUUgc3VwcG9ydC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBUaGUgcG9pbnRlciBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9wb2ludGVyL1BvaW50ZXJFdmVudH0gVGhlIHdyYXBwZWQgZXZlbnQuXG4gICAqL1xuICBQb2ludGVyRXZlbnRIYW5kbGVyLnByb3RvdHlwZS53cmFwTW91c2VFdmVudCA9IGZ1bmN0aW9uIHdyYXBNb3VzZUV2ZW50IChldmVudFR5cGUsIGV2ZW50KSB7XG4gICAgdmFyIHBvaW50ZXJFdmVudCA9IHRoaXMubWFrZUV2ZW50KFxuICAgICAgZXZlbnRUeXBlLCBNb3VzZVNvdXJjZS5wcmVwYXJlRXZlbnQoZXZlbnQsIHRoaXMpLCBldmVudCk7XG4gICAgcmV0dXJuIHBvaW50ZXJFdmVudDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFBvaW50ZXJFdmVudEhhbmRsZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyXygpO1xuICAgIEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gUG9pbnRlckV2ZW50SGFuZGxlcjtcbn0oRXZlbnRUYXJnZXQpKTtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckV2ZW50SGFuZGxlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlckV2ZW50SGFuZGxlci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Ub3VjaFNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtyZW1vdmV9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuLi9wb2ludGVyL0V2ZW50U291cmNlLmpzJztcbmltcG9ydCB7UE9JTlRFUl9JRH0gZnJvbSAnLi4vcG9pbnRlci9Nb3VzZVNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgUE9JTlRFUl9UWVBFID0gJ3RvdWNoJztcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2hzdGFydGAsIHRyaWdnZXJzIGBwb2ludGVyb3ZlcmAsXG4gKiBgcG9pbnRlcmVudGVyYCBhbmQgYHBvaW50ZXJkb3duYCBldmVudHMuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2hzdGFydChpbkV2ZW50KSB7XG4gIHRoaXMudmFjdXVtVG91Y2hlc18oaW5FdmVudCk7XG4gIHRoaXMuc2V0UHJpbWFyeVRvdWNoXyhpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgdGhpcy5kZWR1cFN5bnRoTW91c2VfKGluRXZlbnQpO1xuICB0aGlzLmNsaWNrQ291bnRfKys7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMub3ZlckRvd25fKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2htb3ZlYC5cbiAqXG4gKiBAdGhpcyB7bW9kdWxlOm9sL3BvaW50ZXIvVG91Y2hTb3VyY2V9XG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiB0b3VjaG1vdmUoaW5FdmVudCkge1xuICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMubW92ZU92ZXJPdXRfKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2hlbmRgLCB0cmlnZ2VycyBgcG9pbnRlcnVwYCxcbiAqIGBwb2ludGVyb3V0YCBhbmQgYHBvaW50ZXJsZWF2ZWAgZXZlbnRzLlxuICpcbiAqIEB0aGlzIHttb2R1bGU6b2wvcG9pbnRlci9Ub3VjaFNvdXJjZX1cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHRvdWNoZW5kKGluRXZlbnQpIHtcbiAgdGhpcy5kZWR1cFN5bnRoTW91c2VfKGluRXZlbnQpO1xuICB0aGlzLnByb2Nlc3NUb3VjaGVzXyhpbkV2ZW50LCB0aGlzLnVwT3V0Xyk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNoY2FuY2VsYCwgdHJpZ2dlcnMgYHBvaW50ZXJjYW5jZWxgLFxuICogYHBvaW50ZXJvdXRgIGFuZCBgcG9pbnRlcmxlYXZlYCBldmVudHMuXG4gKlxuICogQHRoaXMge21vZHVsZTpvbC9wb2ludGVyL1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2hjYW5jZWwoaW5FdmVudCkge1xuICB0aGlzLnByb2Nlc3NUb3VjaGVzXyhpbkV2ZW50LCB0aGlzLmNhbmNlbE91dF8pO1xufVxuXG5cbnZhciBUb3VjaFNvdXJjZSA9IChmdW5jdGlvbiAoRXZlbnRTb3VyY2UpIHtcbiAgZnVuY3Rpb24gVG91Y2hTb3VyY2UoZGlzcGF0Y2hlciwgbW91c2VTb3VyY2UpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICd0b3VjaHN0YXJ0JzogdG91Y2hzdGFydCxcbiAgICAgICd0b3VjaG1vdmUnOiB0b3VjaG1vdmUsXG4gICAgICAndG91Y2hlbmQnOiB0b3VjaGVuZCxcbiAgICAgICd0b3VjaGNhbmNlbCc6IHRvdWNoY2FuY2VsXG4gICAgfTtcbiAgICBFdmVudFNvdXJjZS5jYWxsKHRoaXMsIGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJNYXA7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3BvaW50ZXIvTW91c2VTb3VyY2V9XG4gICAgICovXG4gICAgdGhpcy5tb3VzZVNvdXJjZSA9IG1vdXNlU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmZpcnN0VG91Y2hJZF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGlja0NvdW50XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVzZXRJZF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBNb3VzZSBldmVudCB0aW1lb3V0OiBUaGlzIHNob3VsZCBiZSBsb25nIGVub3VnaCB0b1xuICAgICAqIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVkdXBUaW1lb3V0XyA9IDI1MDA7XG4gIH1cblxuICBpZiAoIEV2ZW50U291cmNlICkgVG91Y2hTb3VyY2UuX19wcm90b19fID0gRXZlbnRTb3VyY2U7XG4gIFRvdWNoU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50U291cmNlICYmIEV2ZW50U291cmNlLnByb3RvdHlwZSApO1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3VjaFNvdXJjZTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaH0gaW5Ub3VjaCBUaGUgaW4gdG91Y2guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUsIGlmIHRoaXMgaXMgdGhlIHByaW1hcnkgdG91Y2guXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuaXNQcmltYXJ5VG91Y2hfID0gZnVuY3Rpb24gaXNQcmltYXJ5VG91Y2hfIChpblRvdWNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RUb3VjaElkXyA9PT0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgcHJpbWFyeSB0b3VjaCBpZiB0aGVyZSBhcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlLlxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRoZSBpbiB0b3VjaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5zZXRQcmltYXJ5VG91Y2hfID0gZnVuY3Rpb24gc2V0UHJpbWFyeVRvdWNoXyAoaW5Ub3VjaCkge1xuICAgIHZhciBjb3VudCA9IE9iamVjdC5rZXlzKHRoaXMucG9pbnRlck1hcCkubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMCB8fCAoY291bnQgPT09IDEgJiYgUE9JTlRFUl9JRC50b1N0cmluZygpIGluIHRoaXMucG9pbnRlck1hcCkpIHtcbiAgICAgIHRoaXMuZmlyc3RUb3VjaElkXyA9IGluVG91Y2guaWRlbnRpZmllcjtcbiAgICAgIHRoaXMuY2FuY2VsUmVzZXRDbGlja0NvdW50XygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlUHJpbWFyeVBvaW50ZXJfID0gZnVuY3Rpb24gcmVtb3ZlUHJpbWFyeVBvaW50ZXJfIChpblBvaW50ZXIpIHtcbiAgICBpZiAoaW5Qb2ludGVyLmlzUHJpbWFyeSkge1xuICAgICAgdGhpcy5maXJzdFRvdWNoSWRfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5yZXNldENsaWNrQ291bnRfKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnJlc2V0Q2xpY2tDb3VudF8gPSBmdW5jdGlvbiByZXNldENsaWNrQ291bnRfICgpIHtcbiAgICB0aGlzLnJlc2V0SWRfID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMucmVzZXRDbGlja0NvdW50SGFuZGxlcl8uYmluZCh0aGlzKSxcbiAgICAgIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLnJlc2V0Q2xpY2tDb3VudEhhbmRsZXJfID0gZnVuY3Rpb24gcmVzZXRDbGlja0NvdW50SGFuZGxlcl8gKCkge1xuICAgIHRoaXMuY2xpY2tDb3VudF8gPSAwO1xuICAgIHRoaXMucmVzZXRJZF8gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY2FuY2VsUmVzZXRDbGlja0NvdW50XyA9IGZ1bmN0aW9uIGNhbmNlbFJlc2V0Q2xpY2tDb3VudF8gKCkge1xuICAgIGlmICh0aGlzLnJlc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnRcbiAgICogQHBhcmFtIHtUb3VjaH0gaW5Ub3VjaCBUb3VjaCBldmVudFxuICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnR9IEEgcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUudG91Y2hUb1BvaW50ZXJfID0gZnVuY3Rpb24gdG91Y2hUb1BvaW50ZXJfIChicm93c2VyRXZlbnQsIGluVG91Y2gpIHtcbiAgICB2YXIgZSA9IHRoaXMuZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGJyb3dzZXJFdmVudCwgaW5Ub3VjaCk7XG4gICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgY2FuIHN0YXJ0IGF0IDAuXG4gICAgLy8gQWRkIDIgdG8gdGhlIHRvdWNoIGlkZW50aWZpZXIgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAgZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgaXMgbmVjZXNzYXJ5P1xuICAgIC8vZS50YXJnZXQgPSBmaW5kVGFyZ2V0KGUpO1xuICAgIGUuYnViYmxlcyA9IHRydWU7XG4gICAgZS5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudF87XG4gICAgZS5idXR0b24gPSAwO1xuICAgIGUuYnV0dG9ucyA9IDE7XG4gICAgZS53aWR0aCA9IGluVG91Y2gud2Via2l0UmFkaXVzWCB8fCBpblRvdWNoLnJhZGl1c1ggfHwgMDtcbiAgICBlLmhlaWdodCA9IGluVG91Y2gud2Via2l0UmFkaXVzWSB8fCBpblRvdWNoLnJhZGl1c1kgfHwgMDtcbiAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC53ZWJraXRGb3JjZSB8fCBpblRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICBlLmlzUHJpbWFyeSA9IHRoaXMuaXNQcmltYXJ5VG91Y2hfKGluVG91Y2gpO1xuICAgIGUucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEU7XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBkaWZmZXJlbnQgZm9yXG4gICAgLy8gZWFjaCBgVG91Y2hgIG9iamVjdCBhcmUgbm90IGNvcGllZCBmcm9tIHRoZSBCcm93c2VyRXZlbnQgb2JqZWN0XG4gICAgZS5jbGllbnRYID0gaW5Ub3VjaC5jbGllbnRYO1xuICAgIGUuY2xpZW50WSA9IGluVG91Y2guY2xpZW50WTtcbiAgICBlLnNjcmVlblggPSBpblRvdWNoLnNjcmVlblg7XG4gICAgZS5zY3JlZW5ZID0gaW5Ub3VjaC5zY3JlZW5ZO1xuXG4gICAgcmV0dXJuIGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUb3VjaCBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRvdWNoRXZlbnQsIFBvaW50ZXJFdmVudCl9IGluRnVuY3Rpb24gSW4gZnVuY3Rpb24uXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUucHJvY2Vzc1RvdWNoZXNfID0gZnVuY3Rpb24gcHJvY2Vzc1RvdWNoZXNfIChpbkV2ZW50LCBpbkZ1bmN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdG91Y2hlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluRXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgIHZhciBjb3VudCA9IHRvdWNoZXMubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcyQxLnRvdWNoVG9Qb2ludGVyXyhpbkV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIC8vIGZvcndhcmQgdG91Y2ggcHJldmVudERlZmF1bHRzXG4gICAgICBwb2ludGVyLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICBpbkZ1bmN0aW9uLmNhbGwodGhpcyQxLCBpbkV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hMaXN0fSB0b3VjaExpc3QgVGhlIHRvdWNoIGxpc3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWFyY2hJZCBTZWFyY2ggaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGBUb3VjaGAgd2l0aCB0aGUgZ2l2ZW4gaWQgaXMgaW4gdGhlIGxpc3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuZmluZFRvdWNoXyA9IGZ1bmN0aW9uIGZpbmRUb3VjaF8gKHRvdWNoTGlzdCwgc2VhcmNoSWQpIHtcbiAgICB2YXIgbCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoTGlzdFtpXTtcbiAgICAgIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSBzZWFyY2hJZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbiBzb21lIGluc3RhbmNlcywgYSB0b3VjaHN0YXJ0IGNhbiBoYXBwZW4gd2l0aG91dCBhIHRvdWNoZW5kLiBUaGlzXG4gICAqIGxlYXZlcyB0aGUgcG9pbnRlcm1hcCBpbiBhIGJyb2tlbiBzdGF0ZS5cbiAgICogVGhlcmVmb3JlLCBvbiBldmVyeSB0b3VjaHN0YXJ0LCB3ZSByZW1vdmUgdGhlIHRvdWNoZXMgdGhhdCBkaWQgbm90IGZpcmUgYVxuICAgKiB0b3VjaGVuZCBldmVudC5cbiAgICogVG8ga2VlcCBzdGF0ZSBnbG9iYWxseSBjb25zaXN0ZW50LCB3ZSBmaXJlIGEgcG9pbnRlcmNhbmNlbCBmb3JcbiAgICogdGhpcyBcImFiYW5kb25lZFwiIHRvdWNoXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUudmFjdXVtVG91Y2hlc18gPSBmdW5jdGlvbiB2YWN1dW1Ub3VjaGVzXyAoaW5FdmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRvdWNoTGlzdCA9IGluRXZlbnQudG91Y2hlcztcbiAgICAvLyBwb2ludGVyTWFwLmdldENvdW50KCkgc2hvdWxkIGJlIDwgdG91Y2hMaXN0Lmxlbmd0aCBoZXJlLFxuICAgIC8vIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5wb2ludGVyTWFwKTtcbiAgICB2YXIgY291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPj0gdG91Y2hMaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcyQxLnBvaW50ZXJNYXBba2V5XTtcbiAgICAgICAgLy8gTmV2ZXIgcmVtb3ZlIHBvaW50ZXJJZCA9PSAxLCB3aGljaCBpcyBtb3VzZS5cbiAgICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgYXJlIDIgc21hbGxlciB0aGFuIHRoZWlyIHBvaW50ZXJJZCwgd2hpY2ggaXMgdGhlXG4gICAgICAgIC8vIGluZGV4IGluIHBvaW50ZXJtYXAuXG4gICAgICAgIGlmIChrZXkgIT0gUE9JTlRFUl9JRCAmJiAhdGhpcyQxLmZpbmRUb3VjaF8odG91Y2hMaXN0LCBrZXkgLSAyKSkge1xuICAgICAgICAgIGQucHVzaCh2YWx1ZS5vdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBkLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdGhpcyQxLmNhbmNlbE91dF8oaW5FdmVudCwgZFtpJDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IFRoZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUub3ZlckRvd25fID0gZnVuY3Rpb24gb3ZlckRvd25fIChicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRlck1hcFtpblBvaW50ZXIucG9pbnRlcklkXSA9IHtcbiAgICAgIHRhcmdldDogaW5Qb2ludGVyLnRhcmdldCxcbiAgICAgIG91dDogaW5Qb2ludGVyLFxuICAgICAgb3V0VGFyZ2V0OiBpblBvaW50ZXIudGFyZ2V0XG4gICAgfTtcbiAgICB0aGlzLmRpc3BhdGNoZXIub3ZlcihpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuZG93bihpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IFRoZSBldmVudC5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlci5cbiAgICovXG4gIFRvdWNoU291cmNlLnByb3RvdHlwZS5tb3ZlT3Zlck91dF8gPSBmdW5jdGlvbiBtb3ZlT3Zlck91dF8gKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgdmFyIGV2ZW50ID0gaW5Qb2ludGVyO1xuICAgIHZhciBwb2ludGVyID0gdGhpcy5wb2ludGVyTWFwW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgLy8gYSBmaW5nZXIgZHJpZnRlZCBvZmYgdGhlIHNjcmVlbiwgaWdub3JlIGl0XG4gICAgaWYgKCFwb2ludGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBvdXRFdmVudCA9IHBvaW50ZXIub3V0O1xuICAgIHZhciBvdXRUYXJnZXQgPSBwb2ludGVyLm91dFRhcmdldDtcbiAgICB0aGlzLmRpc3BhdGNoZXIubW92ZShldmVudCwgYnJvd3NlckV2ZW50KTtcbiAgICBpZiAob3V0RXZlbnQgJiYgb3V0VGFyZ2V0ICE9PSBldmVudC50YXJnZXQpIHtcbiAgICAgIG91dEV2ZW50LnJlbGF0ZWRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gb3V0VGFyZ2V0O1xuICAgICAgLy8gcmVjb3ZlciBmcm9tIHJldGFyZ2V0aW5nIGJ5IHNoYWRvd1xuICAgICAgb3V0RXZlbnQudGFyZ2V0ID0gb3V0VGFyZ2V0O1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmVPdXQob3V0RXZlbnQsIGJyb3dzZXJFdmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5lbnRlck92ZXIoZXZlbnQsIGJyb3dzZXJFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjbGVhbiB1cCBjYXNlIHdoZW4gZmluZ2VyIGxlYXZlcyB0aGUgc2NyZWVuXG4gICAgICAgIGV2ZW50LnRhcmdldCA9IG91dFRhcmdldDtcbiAgICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FuY2VsT3V0Xyhicm93c2VyRXZlbnQsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlci5vdXQgPSBldmVudDtcbiAgICBwb2ludGVyLm91dFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgQW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBpblBvaW50ZXIgVGhlIGluUG9pbnRlciBvYmplY3QuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUudXBPdXRfID0gZnVuY3Rpb24gdXBPdXRfIChicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHRoaXMuZGlzcGF0Y2hlci51cChpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLm91dChpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmNsZWFuVXBQb2ludGVyXyhpblBvaW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGJyb3dzZXJFdmVudCBUaGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBpblBvaW50ZXIgVGhlIGluIHBvaW50ZXIuXG4gICAqL1xuICBUb3VjaFNvdXJjZS5wcm90b3R5cGUuY2FuY2VsT3V0XyA9IGZ1bmN0aW9uIGNhbmNlbE91dF8gKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmNhbmNlbChpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLm91dChpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmNsZWFuVXBQb2ludGVyXyhpblBvaW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpblBvaW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLmNsZWFuVXBQb2ludGVyXyA9IGZ1bmN0aW9uIGNsZWFuVXBQb2ludGVyXyAoaW5Qb2ludGVyKSB7XG4gICAgZGVsZXRlIHRoaXMucG9pbnRlck1hcFtpblBvaW50ZXIucG9pbnRlcklkXTtcbiAgICB0aGlzLnJlbW92ZVByaW1hcnlQb2ludGVyXyhpblBvaW50ZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKi9cbiAgVG91Y2hTb3VyY2UucHJvdG90eXBlLmRlZHVwU3ludGhNb3VzZV8gPSBmdW5jdGlvbiBkZWR1cFN5bnRoTW91c2VfIChpbkV2ZW50KSB7XG4gICAgdmFyIGx0cyA9IHRoaXMubW91c2VTb3VyY2UubGFzdFRvdWNoZXM7XG4gICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIC8vIG9ubHkgdGhlIHByaW1hcnkgZmluZ2VyIHdpbGwgc3ludGggbW91c2UgZXZlbnRzXG4gICAgaWYgKHRoaXMuaXNQcmltYXJ5VG91Y2hfKHQpKSB7XG4gICAgICAvLyByZW1lbWJlciB4L3kgb2YgbGFzdCB0b3VjaFxuICAgICAgdmFyIGx0ID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgIGx0cy5wdXNoKGx0KTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRvdWNoIGFmdGVyIHRpbWVvdXRcbiAgICAgICAgcmVtb3ZlKGx0cywgbHQpO1xuICAgICAgfSwgdGhpcy5kZWR1cFRpbWVvdXRfKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRvdWNoU291cmNlO1xufShFdmVudFNvdXJjZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBUb3VjaFNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG91Y2hTb3VyY2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUgaHR0cDovL3Byb2o0anMub3JnL1xuICogbGlicmFyeSAodmVyc2lvbiAyLjIgb3IgbGF0ZXIpLiBZb3UgY2FuIHVzZSB0aGUgZnVsbCBidWlsZCBzdXBwbGllZCBieVxuICogUHJvajRqcywgb3IgY3JlYXRlIGEgY3VzdG9tIGJ1aWxkIHRvIHN1cHBvcnQgdGhvc2UgcHJvamVjdGlvbnMgeW91IG5lZWQ7IHNlZVxuICogdGhlIFByb2o0anMgd2Vic2l0ZSBmb3IgaG93IHRvIGRvIHRoaXMuIFlvdSBhbHNvIG5lZWQgdGhlIFByb2o0anMgZGVmaW5pdGlvbnNcbiAqIGZvciB0aGUgcmVxdWlyZWQgcHJvamVjdGlvbnMuIFRoZXNlIGRlZmluaXRpb25zIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2Vwc2cuaW8vLCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IG9iamVjdCBmb3IgdGhlIG5ldyBwcm9qZWN0aW9uIGFuZCBhZGQgaXQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBZb3UgY2FuIHRoZW4gYWRkIHRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlXG4gKiBmdW5jdGlvbnMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXN9LiBTZWVcbiAqIGV4YW1wbGVzL3dtcy1jdXN0b20tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZiB0aGlzLlxuICpcbiAqIE5vdGUgdGhhdCBpZiBubyB0cmFuc2Zvcm1zIGFyZSBuZWVkZWQgYW5kIHlvdSBvbmx5IG5lZWQgdG8gZGVmaW5lIHRoZVxuICogcHJvamVjdGlvbiwganVzdCBhZGQgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm19IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHt0b0VQU0c0MzI2LCBmcm9tRVBTRzQzMjYsIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cywge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qL1VuaXRzLmpzJztcbmltcG9ydCAqIGFzIHByb2plY3Rpb25zIGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge2FkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLCBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLCBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuY30gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuXG5cbi8qKlxuICogQSBwcm9qZWN0aW9uIGFzIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBBIHRyYW5zZm9ybSBmdW5jdGlvbiBhY2NlcHRzIGFuIGFycmF5IG9mIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBhbiBvcHRpb25hbFxuICogb3V0cHV0IGFycmF5LCBhbmQgYW4gb3B0aW9uYWwgZGltZW5zaW9uIChkZWZhdWx0IHNob3VsZCBiZSAyKS4gIFRoZSBmdW5jdGlvblxuICogdHJhbnNmb3JtcyB0aGUgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIHBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5LCBhbmRcbiAqIHJldHVybnMgdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXkuPG51bWJlcj4sIEFycmF5LjxudW1iZXI+PSwgbnVtYmVyPSk6IEFycmF5LjxudW1iZXI+fSBUcmFuc2Zvcm1GdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuZXhwb3J0IHtNRVRFUlNfUEVSX1VOSVR9O1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3V0cHV0IGNvb3JkaW5hdGUgYXJyYXkgKG5ldyBhcnJheSwgc2FtZSBjb29yZGluYXRlXG4gKiAgICAgdmFsdWVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVHJhbnNmb3JtKGlucHV0LCBvcHRfb3V0cHV0LCBvcHRfZGltZW5zaW9uKSB7XG4gIHZhciBvdXRwdXQ7XG4gIGlmIChvcHRfb3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvcHRfb3V0cHV0W2ldID0gaW5wdXRbaV07XG4gICAgfVxuICAgIG91dHB1dCA9IG9wdF9vdXRwdXQ7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gSW5wdXQgY29vcmRpbmF0ZSBhcnJheSAoc2FtZSBhcnJheSBhcyBpbnB1dCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eVRyYW5zZm9ybShpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBpZiAob3B0X291dHB1dCAhPT0gdW5kZWZpbmVkICYmIGlucHV0ICE9PSBvcHRfb3V0cHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3B0X291dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBpbnB1dCA9IG9wdF9vdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5cbi8qKlxuICogQWRkIGEgUHJvamVjdGlvbiBvYmplY3QgdG8gdGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIHByb2plY3Rpb25zIHRoYXQgY2FuIGJlXG4gKiBsb29rZWQgdXAgYnkgdGhlaXIgY29kZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBpbnN0YW5jZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9ucy5hZGQocHJvamVjdGlvbi5nZXRDb2RlKCksIHByb2plY3Rpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24sIHByb2plY3Rpb24sIGNsb25lVHJhbnNmb3JtKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cblxuLyoqXG4gKiBGZXRjaGVzIGEgUHJvamVjdGlvbiBvYmplY3QgZm9yIHRoZSBjb2RlIHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uTGlrZSBFaXRoZXIgYSBjb2RlIHN0cmluZyB3aGljaCBpc1xuICogICAgIGEgY29tYmluYXRpb24gb2YgYXV0aG9yaXR5IGFuZCBpZGVudGlmaWVyIHN1Y2ggYXMgXCJFUFNHOjQzMjZcIiwgb3IgYW5cbiAqICAgICBleGlzdGluZyBwcm9qZWN0aW9uIG9iamVjdCwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgdmFyIHByb2plY3Rpb24gPSBudWxsO1xuICBpZiAocHJvamVjdGlvbkxpa2UgaW5zdGFuY2VvZiBQcm9qZWN0aW9uKSB7XG4gICAgcHJvamVjdGlvbiA9IHByb2plY3Rpb25MaWtlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgY29kZSA9IHByb2plY3Rpb25MaWtlO1xuICAgIHByb2plY3Rpb24gPSBwcm9qZWN0aW9ucy5nZXQoY29kZSk7XG4gIH1cbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlICdwb2ludCcgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gcG9pbnQgUG9pbnQgdG8gZmluZCBhZGp1c3RlZCByZXNvbHV0aW9uIGF0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Vbml0cz19IG9wdF91bml0cyBVbml0cyB0byBnZXQgdGhlIHBvaW50IHJlc29sdXRpb24gaW4uXG4gKiBEZWZhdWx0IGlzIHRoZSBwcm9qZWN0aW9uJ3MgdW5pdHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBvaW50IHJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb2ludFJlc29sdXRpb24ocHJvamVjdGlvbiwgcmVzb2x1dGlvbiwgcG9pbnQsIG9wdF91bml0cykge1xuICBwcm9qZWN0aW9uID0gZ2V0KHByb2plY3Rpb24pO1xuICB2YXIgcG9pbnRSZXNvbHV0aW9uO1xuICB2YXIgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhciB1bml0cyA9IHByb2plY3Rpb24uZ2V0VW5pdHMoKTtcbiAgICBpZiAodW5pdHMgPT0gVW5pdHMuREVHUkVFUyAmJiAhb3B0X3VuaXRzIHx8IG9wdF91bml0cyA9PSBVbml0cy5ERUdSRUVTKSB7XG4gICAgICBwb2ludFJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFc3RpbWF0ZSBwb2ludCByZXNvbHV0aW9uIGJ5IHRyYW5zZm9ybWluZyB0aGUgY2VudGVyIHBpeGVsIHRvIEVQU0c6NDMyNixcbiAgICAgIC8vIG1lYXN1cmluZyBpdHMgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgbm9ybWFsIHNwaGVyZSwgYW5kIHRha2luZyB0aGVcbiAgICAgIC8vIGF2ZXJhZ2Ugb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICB2YXIgdG9FUFNHNDMyNiA9IGdldFRyYW5zZm9ybUZyb21Qcm9qZWN0aW9ucyhwcm9qZWN0aW9uLCBnZXQoJ0VQU0c6NDMyNicpKTtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgICAgcG9pbnRbMF0gLSByZXNvbHV0aW9uIC8gMiwgcG9pbnRbMV0sXG4gICAgICAgIHBvaW50WzBdICsgcmVzb2x1dGlvbiAvIDIsIHBvaW50WzFdLFxuICAgICAgICBwb2ludFswXSwgcG9pbnRbMV0gLSByZXNvbHV0aW9uIC8gMixcbiAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdICsgcmVzb2x1dGlvbiAvIDJcbiAgICAgIF07XG4gICAgICB2ZXJ0aWNlcyA9IHRvRVBTRzQzMjYodmVydGljZXMsIHZlcnRpY2VzLCAyKTtcbiAgICAgIHZhciB3aWR0aCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDAsIDIpLCB2ZXJ0aWNlcy5zbGljZSgyLCA0KSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gZ2V0RGlzdGFuY2UodmVydGljZXMuc2xpY2UoNCwgNiksIHZlcnRpY2VzLnNsaWNlKDYsIDgpKTtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuICAgICAgdmFyIG1ldGVyc1BlclVuaXQgPSBvcHRfdW5pdHMgP1xuICAgICAgICBNRVRFUlNfUEVSX1VOSVRbb3B0X3VuaXRzXSA6XG4gICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICAgICAgaWYgKG1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludFJlc29sdXRpb24gLz0gbWV0ZXJzUGVyVW5pdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBvaW50UmVzb2x1dGlvbjtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdGhhdCBkb24ndCBhbHRlciBjb29yZGluYXRlcy4gVGhvc2UgYWxsb3dcbiAqIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpO1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlLCBkZXN0aW5hdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBhbnkgcHJvamVjdGlvblxuICogaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59IHByb2plY3Rpb25zMSBQcm9qZWN0aW9ucyB3aXRoIGVxdWFsXG4gKiAgICAgbWVhbmluZy5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fSBwcm9qZWN0aW9uczIgUHJvamVjdGlvbnMgd2l0aCBlcXVhbFxuICogICAgIG1lYW5pbmcuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmb3J3YXJkVHJhbnNmb3JtIFRyYW5zZm9ybWF0aW9uIGZyb20gYW55XG4gKiAgIHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBpbnZlcnNlVHJhbnNmb3JtIFRyYW5zZm9ybSBmcm9tIGFueSBwcm9qZWN0aW9uXG4gKiAgIGluIHByb2plY3Rpb24yIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEVxdWl2YWxlbnRUcmFuc2Zvcm1zKHByb2plY3Rpb25zMSwgcHJvamVjdGlvbnMyLCBmb3J3YXJkVHJhbnNmb3JtLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gIHByb2plY3Rpb25zMS5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3Rpb24xKSB7XG4gICAgcHJvamVjdGlvbnMyLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlvbjIpIHtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yLCBmb3J3YXJkVHJhbnNmb3JtKTtcbiAgICAgIGFkZFRyYW5zZm9ybUZ1bmMocHJvamVjdGlvbjIsIHByb2plY3Rpb24xLCBpbnZlcnNlVHJhbnNmb3JtKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIHByb2plY3Rpb25zIGFuZCB0cmFuc2Zvcm1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxQcm9qZWN0aW9ucygpIHtcbiAgcHJvamVjdGlvbnMuY2xlYXIoKTtcbiAgY2xlYXJUcmFuc2Zvcm1GdW5jcygpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufHN0cmluZ3x1bmRlZmluZWR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q29kZSBEZWZhdWx0IGNvZGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbihwcm9qZWN0aW9uLCBkZWZhdWx0Q29kZSkge1xuICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gZ2V0KGRlZmF1bHRDb2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0KHByb2plY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uKVxuICAgICk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+VHJhbnNmb3JtRnVuY3Rpb259IGZyb20gYSBzaW1wbGUgMkQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1cbiAqIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTogbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB2YXIgZGltZW5zaW9uID0gb3B0X2RpbWVuc2lvbiAhPT0gdW5kZWZpbmVkID8gb3B0X2RpbWVuc2lvbiA6IDI7XG4gICAgICB2YXIgb3V0cHV0ID0gb3B0X291dHB1dCAhPT0gdW5kZWZpbmVkID8gb3B0X291dHB1dCA6IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGNvb3JkVHJhbnNmb3JtKFtpbnB1dFtpXSwgaW5wdXRbaSArIDFdXSk7XG4gICAgICAgIG91dHB1dFtpXSA9IHBvaW50WzBdO1xuICAgICAgICBvdXRwdXRbaSArIDFdID0gcG9pbnRbMV07XG4gICAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSAxOyBqID49IDI7IC0taikge1xuICAgICAgICAgIG91dHB1dFtpICsgal0gPSBpbnB1dFtpICsgal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgY29vcmRpbmF0ZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGVcbiAqIHNvdXJjZSBwcm9qZWN0aW9uIGFuZCB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlIGZ1bmN0aW9ucyBjb252ZXJ0IGNvb3JkaW5hdGUgcGFpcnM7IHRoaXMgZnVuY3Rpb25cbiAqIGNvbnZlcnRzIHRoZXNlIGludG8gdGhlIGZ1bmN0aW9ucyB1c2VkIGludGVybmFsbHkgd2hpY2ggYWxzbyBoYW5kbGVcbiAqIGV4dGVudHMgYW5kIGNvb3JkaW5hdGUgYXJyYXlzLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOiBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBmb3J3YXJkIFRoZSBmb3J3YXJkIHRyYW5zZm9ybVxuICogICAgIGZ1bmN0aW9uICh0aGF0IGlzLCBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb25cbiAqICAgICBwcm9qZWN0aW9uKSB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGFzIGFyZ3VtZW50IGFuZCByZXR1cm5zXG4gKiAgICAgdGhlIHRyYW5zZm9ybWVkIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6IG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGludmVyc2UgVGhlIGludmVyc2UgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gdG8gdGhlIHNvdXJjZVxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMoc291cmNlLCBkZXN0aW5hdGlvbiwgZm9yd2FyZCwgaW52ZXJzZSkge1xuICB2YXIgc291cmNlUHJvaiA9IGdldChzb3VyY2UpO1xuICB2YXIgZGVzdFByb2ogPSBnZXQoZGVzdGluYXRpb24pO1xuICBhZGRUcmFuc2Zvcm1GdW5jKHNvdXJjZVByb2osIGRlc3RQcm9qLCBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShmb3J3YXJkKSk7XG4gIGFkZFRyYW5zZm9ybUZ1bmMoZGVzdFByb2osIHNvdXJjZVByb2osIGNyZWF0ZVRyYW5zZm9ybUZyb21Db29yZGluYXRlVHJhbnNmb3JtKGludmVyc2UpKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIGEgZGlmZmVyZW50IHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuXG4gKiAgICAgYW4gYXJyYXkgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2U9fSBvcHRfcHJvamVjdGlvbiBUYXJnZXQgcHJvamVjdGlvbi4gVGhlXG4gKiAgICAgZGVmYXVsdCBpcyBXZWIgTWVyY2F0b3IsIGkuZS4gJ0VQU0c6Mzg1NycuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgJ0VQU0c6NDMyNicsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgdG8gbG9uZ2l0dWRlL2xhdGl0dWRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIFByb2plY3RlZCBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZT19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24gb2YgdGhlIGNvb3JkaW5hdGUuXG4gKiAgICAgVGhlIGRlZmF1bHQgaXMgV2ViIE1lcmNhdG9yLCBpLmUuICdFUFNHOjM4NTcnLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZSBhcyBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBpLmUuIGFuIGFycmF5XG4gKiAgICAgd2l0aCBsb25naXR1ZGUgYXMgMXN0IGFuZCBsYXRpdHVkZSBhcyAybmQgZWxlbWVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIHZhciBsb25MYXQgPSB0cmFuc2Zvcm0oY29vcmRpbmF0ZSxcbiAgICBvcHRfcHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0X3Byb2plY3Rpb24gOiAnRVBTRzozODU3JywgJ0VQU0c6NDMyNicpO1xuICB2YXIgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBlcXVhbFVuaXRzID0gcHJvamVjdGlvbjEuZ2V0VW5pdHMoKSA9PT0gcHJvamVjdGlvbjIuZ2V0VW5pdHMoKTtcbiAgaWYgKHByb2plY3Rpb24xLmdldENvZGUoKSA9PT0gcHJvamVjdGlvbjIuZ2V0Q29kZSgpKSB7XG4gICAgcmV0dXJuIGVxdWFsVW5pdHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMocHJvamVjdGlvbjEsIHByb2plY3Rpb24yKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtRnVuYyA9PT0gY2xvbmVUcmFuc2Zvcm0gJiYgZXF1YWxVbml0cztcbiAgfVxufVxuXG5cbi8qKlxuICogU2VhcmNoZXMgaW4gdGhlIGxpc3Qgb2YgdHJhbnNmb3JtIGZ1bmN0aW9ucyBmb3IgdGhlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZVByb2plY3Rpb24gU291cmNlIFByb2plY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gUHJvamVjdGlvblxuICogICAgIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKSB7XG4gIHZhciBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIHZhciBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvblByb2plY3Rpb24uZ2V0Q29kZSgpO1xuICB2YXIgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybUZ1bmMoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKTtcbiAgaWYgKCF0cmFuc2Zvcm1GdW5jKSB7XG4gICAgdHJhbnNmb3JtRnVuYyA9IGlkZW50aXR5VHJhbnNmb3JtO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jO1xufVxuXG5cbi8qKlxuICogR2l2ZW4gdGhlIHByb2plY3Rpb24tbGlrZSBvYmplY3RzLCBzZWFyY2hlcyBmb3IgYSB0cmFuc2Zvcm1hdGlvblxuICogZnVuY3Rpb24gdG8gY29udmVydCBhIGNvb3JkaW5hdGVzIGFycmF5IGZyb20gdGhlIHNvdXJjZSBwcm9qZWN0aW9uIHRvIHRoZVxuICogZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHNvdXJjZVByb2plY3Rpb24gPSBnZXQoc291cmNlKTtcbiAgdmFyIGRlc3RpbmF0aW9uUHJvamVjdGlvbiA9IGdldChkZXN0aW5hdGlvbik7XG4gIHJldHVybiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBwcm9qZWN0aW9uLWxpa2UuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGNvb3JkaW5hdGUsIHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbik7XG4gIHJldHVybiB0cmFuc2Zvcm1GdW5jKGNvb3JkaW5hdGUsIHVuZGVmaW5lZCwgY29vcmRpbmF0ZS5sZW5ndGgpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleHRlbnQgZnJvbSBzb3VyY2UgcHJvamVjdGlvbiB0byBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLiAgVGhpc1xuICogcmV0dXJucyBhIG5ldyBleHRlbnQgKGFuZCBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsKS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudCB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBzb3VyY2UgU291cmNlIHByb2plY3Rpb24tbGlrZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24tbGlrZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBUaGUgdHJhbnNmb3JtZWQgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICB2YXIgdHJhbnNmb3JtRnVuYyA9IGdldFRyYW5zZm9ybShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGV4dGVudCwgdHJhbnNmb3JtRnVuYyk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBnaXZlbiBwb2ludCB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFBvaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtV2l0aFByb2plY3Rpb25zKHBvaW50LCBzb3VyY2VQcm9qZWN0aW9uLCBkZXN0aW5hdGlvblByb2plY3Rpb24pIHtcbiAgdmFyIHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEFkZCB0cmFuc2Zvcm1zIHRvIGFuZCBmcm9tIEVQU0c6NDMyNiBhbmQgRVBTRzozODU3LiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIGJ5IHdoZW4gdGhpcyBtb2R1bGUgaXMgZXhlY3V0ZWQgYW5kIHNob3VsZCBvbmx5IG5lZWQgdG8gYmUgY2FsbGVkIGFnYWluIGFmdGVyXG4gKiBgY2xlYXJBbGxQcm9qZWN0aW9ucygpYCBpcyBjYWxsZWQgKGUuZy4gaW4gdGVzdHMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29tbW9uKCkge1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMgdG8gY29udmVydCB3aXRoaW4gc2V0IG9mXG4gIC8vIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0czODU3X1BST0pFQ1RJT05TKTtcbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0c0MzI2X1BST0pFQ1RJT05TKTtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0byBjb252ZXJ0IEVQU0c6NDMyNiBsaWtlIGNvb3JkaW5hdGVzIHRvIEVQU0c6Mzg1NyBsaWtlXG4gIC8vIGNvb3JkaW5hdGVzIGFuZCBiYWNrLlxuICBhZGRFcXVpdmFsZW50VHJhbnNmb3JtcyhFUFNHNDMyNl9QUk9KRUNUSU9OUywgRVBTRzM4NTdfUFJPSkVDVElPTlMsIGZyb21FUFNHNDMyNiwgdG9FUFNHNDMyNik7XG59XG5cbmFkZENvbW1vbigpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9qLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1Byb2plY3Rpb25cbiAqL1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4uL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qL1VuaXRzfHN0cmluZ30gW3VuaXRzXSBVbml0cy4gUmVxdWlyZWQgdW5sZXNzIGFcbiAqIHByb2o0IHByb2plY3Rpb24gaXMgZGVmaW5lZCBmb3IgYGNvZGVgLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1VuaXRzfk1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IFt3b3JsZEV4dGVudF0gVGhlIHdvcmxkIGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyLCBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlKTpudW1iZXJ9IFtnZXRQb2ludFJlc29sdXRpb25dXG4gKiBGdW5jdGlvbiB0byBkZXRlcm1pbmUgcmVzb2x1dGlvbiBhdCBhIHBvaW50LiBUaGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICogYHtudW1iZXJ9YCB2aWV3IHJlc29sdXRpb24gYW5kIGFuIGB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX1gIGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnNcbiAqIHRoZSBge251bWJlcn1gIHJlc29sdXRpb24gYXQgdGhlIHBhc3NlZCBjb29yZGluYXRlLiBJZiB0aGlzIGlzIGB1bmRlZmluZWRgLFxuICogdGhlIGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9wcm9qI2dldFBvaW50UmVzb2x1dGlvbn0gZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIGRlZmluaXRpb24gY2xhc3MuIE9uZSBvZiB0aGVzZSBpcyBjcmVhdGVkIGZvciBlYWNoIHByb2plY3Rpb25cbiAqIHN1cHBvcnRlZCBpbiB0aGUgYXBwbGljYXRpb24gYW5kIHN0b3JlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfSBuYW1lc3BhY2UuXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBpbiBhcHBsaWNhdGlvbnMsIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgQVBJIHBhcmFtc1xuICogYW5kIG9wdGlvbnMgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gd2hpY2ggbWVhbnMgdGhlIHNpbXBsZSBzdHJpbmdcbiAqIGNvZGUgd2lsbCBzdWZmaWNlLlxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXR9IHRvIHJldHJpZXZlIHRoZSBvYmplY3QgZm9yIGEgcGFydGljdWxhclxuICogcHJvamVjdGlvbi5cbiAqXG4gKiBUaGUgbGlicmFyeSBpbmNsdWRlcyBkZWZpbml0aW9ucyBmb3IgYEVQU0c6NDMyNmAgYW5kIGBFUFNHOjM4NTdgLCB0b2dldGhlclxuICogd2l0aCB0aGUgZm9sbG93aW5nIGFsaWFzZXM6XG4gKiAqIGBFUFNHOjQzMjZgOiBDUlM6ODQsIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2LFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0LCB1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYsXG4gKiAgICAgdXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2XG4gKiAqIGBFUFNHOjM4NTdgOiBFUFNHOjEwMjEwMCwgRVBTRzoxMDIxMTMsIEVQU0c6OTAwOTEzLFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3XG4gKlxuICogSWYgeW91IHVzZSBbcHJvajRqc10oaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcyksIGFsaWFzZXMgY2FuXG4gKiBiZSBhZGRlZCB1c2luZyBgcHJvajQuZGVmcygpYC4gQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlXG4gKiBhZGRlZCwgY2FsbCB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL3Byb2o0fnJlZ2lzdGVyfSBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpXG4gKi9cbnZhciBQcm9qZWN0aW9uID0gZnVuY3Rpb24gUHJvamVjdGlvbihvcHRpb25zKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGhpcy5jb2RlXyA9IG9wdGlvbnMuY29kZTtcblxuICAvKipcbiAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAqIGB0aGlzLmV4dGVudF9gIGFuZCBgdGhpcy53b3JsZEV4dGVudF9gIG11c3QgYmUgY29uZmlndXJlZCBwcm9wZXJseSBmb3IgZWFjaFxuICAgKiB0aWxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovVW5pdHN9XG4gICAqL1xuICB0aGlzLnVuaXRzXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovVW5pdHN9ICovIChvcHRpb25zLnVuaXRzKTtcblxuICAvKipcbiAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAqIHdpdGggYFRJTEVfUElYRUxTYCB1bml0cywgdGhpcyBpcyB0aGUgZXh0ZW50IG9mIHRoZSB0aWxlIGluXG4gICAqIHRpbGUgcGl4ZWwgc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICovXG4gIHRoaXMuZXh0ZW50XyA9IG9wdGlvbnMuZXh0ZW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dGVudCA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEV4dGVudCBvZiB0aGUgd29ybGQgaW4gRVBTRzo0MzI2LiBGb3IgcHJvamVjdGlvbnMgd2l0aFxuICAgKiBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICogcHJvamVjdGVkIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICovXG4gIHRoaXMud29ybGRFeHRlbnRfID0gb3B0aW9ucy53b3JsZEV4dGVudCAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLndvcmxkRXh0ZW50IDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRoaXMuYXhpc09yaWVudGF0aW9uXyA9IG9wdGlvbnMuYXhpc09yaWVudGF0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuYXhpc09yaWVudGF0aW9uIDogJ2VudSc7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5nbG9iYWxfID0gb3B0aW9ucy5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2xvYmFsIDogZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICovXG4gIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHByb2plY3Rpb24gaXMgc3VpdGFibGUgZm9yIHdyYXBwaW5nIHRoZSB4LWF4aXNcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuY2FuV3JhcFggPSBmdW5jdGlvbiBjYW5XcmFwWCAoKSB7XG4gIHJldHVybiB0aGlzLmNhbldyYXBYXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIGZvciB0aGlzIHByb2plY3Rpb24sIGUuZy4gJ0VQU0c6NDMyNicuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmdldENvZGUgPSBmdW5jdGlvbiBnZXRDb2RlICgpIHtcbiAgcmV0dXJuIHRoaXMuY29kZV87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdmFsaWRpdHkgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiBnZXRFeHRlbnQgKCkge1xuICByZXR1cm4gdGhpcy5leHRlbnRfO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVuaXRzIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qL1VuaXRzfSBVbml0cy5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0VW5pdHMgPSBmdW5jdGlvbiBnZXRVbml0cyAoKSB7XG4gIHJldHVybiB0aGlzLnVuaXRzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbW91bnQgb2YgbWV0ZXJzIHBlciB1bml0IG9mIHRoaXMgcHJvamVjdGlvbi5JZiB0aGUgcHJvamVjdGlvbiBpc1xuICogbm90IGNvbmZpZ3VyZWQgd2l0aCBgbWV0ZXJzUGVyVW5pdGAgb3IgYSB1bml0cyBpZGVudGlmaWVyLCB0aGUgcmV0dXJuIGlzXG4gKiBgdW5kZWZpbmVkYC5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0TWV0ZXJzUGVyVW5pdCA9IGZ1bmN0aW9uIGdldE1ldGVyc1BlclVuaXQgKCkge1xuICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0V29ybGRFeHRlbnQgPSBmdW5jdGlvbiBnZXRXb3JsZEV4dGVudCAoKSB7XG4gIHJldHVybiB0aGlzLndvcmxkRXh0ZW50Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBheGlzIG9yaWVudGF0aW9uIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAqIGVudSAtIHRoZSBkZWZhdWx0IGVhc3RpbmcsIG5vcnRoaW5nLCBlbGV2YXRpb24uXG4gKiBuZXUgLSBub3J0aGluZywgZWFzdGluZywgdXAgLSB1c2VmdWwgZm9yIFwibGF0L2xvbmdcIiBnZW9ncmFwaGljIGNvb3JkaW5hdGVzLFxuICogICBvciBzb3V0aCBvcmllbnRhdGVkIHRyYW5zdmVyc2UgbWVyY2F0b3IuXG4gKiB3bnUgLSB3ZXN0aW5nLCBub3J0aGluZywgdXAgLSBzb21lIHBsYW5ldGFyeSBjb29yZGluYXRlIHN5c3RlbXMgaGF2ZVxuICogICBcIndlc3QgcG9zaXRpdmVcIiBjb29yZGluYXRlIHN5c3RlbXNcbiAqIEByZXR1cm4ge3N0cmluZ30gQXhpcyBvcmllbnRhdGlvbi5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0QXhpc09yaWVudGF0aW9uID0gZnVuY3Rpb24gZ2V0QXhpc09yaWVudGF0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXhpc09yaWVudGF0aW9uXztcbn07XG5cbi8qKlxuICogSXMgdGhpcyBwcm9qZWN0aW9uIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkP1xuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gKiBAYXBpXG4gKi9cblByb2plY3Rpb24ucHJvdG90eXBlLmlzR2xvYmFsID0gZnVuY3Rpb24gaXNHbG9iYWwgKCkge1xuICByZXR1cm4gdGhpcy5nbG9iYWxfO1xufTtcblxuLyoqXG4gKiBTZXQgaWYgdGhlIHByb2plY3Rpb24gaXMgYSBnbG9iYWwgcHJvamVjdGlvbiB3aGljaCBzcGFucyB0aGUgd2hvbGUgd29ybGRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRHbG9iYWwgPSBmdW5jdGlvbiBzZXRHbG9iYWwgKGdsb2JhbCkge1xuICB0aGlzLmdsb2JhbF8gPSBnbG9iYWw7XG4gIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5nZXREZWZhdWx0VGlsZUdyaWQgPSBmdW5jdGlvbiBnZXREZWZhdWx0VGlsZUdyaWQgKCkge1xuICByZXR1cm4gdGhpcy5kZWZhdWx0VGlsZUdyaWRfO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXREZWZhdWx0VGlsZUdyaWQgPSBmdW5jdGlvbiBzZXREZWZhdWx0VGlsZUdyaWQgKHRpbGVHcmlkKSB7XG4gIHRoaXMuZGVmYXVsdFRpbGVHcmlkXyA9IHRpbGVHcmlkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuc2V0RXh0ZW50ID0gZnVuY3Rpb24gc2V0RXh0ZW50IChleHRlbnQpIHtcbiAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuICB0aGlzLmNhbldyYXBYXyA9ICEhKHRoaXMuZ2xvYmFsXyAmJiBleHRlbnQpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gd29ybGRFeHRlbnQgV29ybGQgZXh0ZW50XG4gKiAgIFttaW5sb24sIG1pbmxhdCwgbWF4bG9uLCBtYXhsYXRdLlxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRXb3JsZEV4dGVudCA9IGZ1bmN0aW9uIHNldFdvcmxkRXh0ZW50ICh3b3JsZEV4dGVudCkge1xuICB0aGlzLndvcmxkRXh0ZW50XyA9IHdvcmxkRXh0ZW50O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXRQb2ludFJlc29sdXRpb259XG4gKiBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICogQGFwaVxuICovXG5Qcm9qZWN0aW9uLnByb3RvdHlwZS5zZXRHZXRQb2ludFJlc29sdXRpb24gPSBmdW5jdGlvbiBzZXRHZXRQb2ludFJlc29sdXRpb24gKGZ1bmMpIHtcbiAgdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXyA9IGZ1bmM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZSk6bnVtYmVyfHVuZGVmaW5lZH0gVGhlIGN1c3RvbSBwb2ludFxuICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAqL1xuUHJvamVjdGlvbi5wcm90b3R5cGUuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuYyA9IGZ1bmN0aW9uIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMgKCkge1xuICByZXR1cm4gdGhpcy5nZXRQb2ludFJlc29sdXRpb25GdW5jXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByb2plY3Rpb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovVW5pdHNcbiAqL1xuXG4vKipcbiAqIFByb2plY3Rpb24gdW5pdHM6IGAnZGVncmVlcydgLCBgJ2Z0J2AsIGAnbSdgLCBgJ3BpeGVscydgLCBgJ3RpbGUtcGl4ZWxzJ2Agb3JcbiAqIGAndXMtZnQnYC5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBVbml0cyA9IHtcbiAgREVHUkVFUzogJ2RlZ3JlZXMnLFxuICBGRUVUOiAnZnQnLFxuICBNRVRFUlM6ICdtJyxcbiAgUElYRUxTOiAncGl4ZWxzJyxcbiAgVElMRV9QSVhFTFM6ICd0aWxlLXBpeGVscycsXG4gIFVTRkVFVDogJ3VzLWZ0J1xufTtcblxuXG4vKipcbiAqIE1ldGVycyBwZXIgdW5pdCBsb29rdXAgdGFibGUuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3QuPG1vZHVsZTpvbC9wcm9qL1VuaXRzLCBudW1iZXI+fVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIE1FVEVSU19QRVJfVU5JVCA9IHt9O1xuLy8gdXNlIHRoZSByYWRpdXMgb2YgdGhlIE5vcm1hbCBzcGhlcmVcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5ERUdSRUVTXSA9IDIgKiBNYXRoLlBJICogNjM3MDk5NyAvIDM2MDtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5GRUVUXSA9IDAuMzA0ODtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5NRVRFUlNdID0gMTtcbk1FVEVSU19QRVJfVU5JVFtVbml0cy5VU0ZFRVRdID0gMTIwMCAvIDM5Mzc7XG5cbmV4cG9ydCBkZWZhdWx0IFVuaXRzO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Vbml0cy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQge2Nvc2h9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuLi9wcm9qL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBIQUxGX1NJWkUgPSBNYXRoLlBJICogUkFESVVTO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gKi9cbmV4cG9ydCB2YXIgRVhURU5UID0gW1xuICAtSEFMRl9TSVpFLCAtSEFMRl9TSVpFLFxuICBIQUxGX1NJWkUsIEhBTEZfU0laRVxuXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICovXG5leHBvcnQgdmFyIFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbnZhciBFUFNHMzg1N1Byb2plY3Rpb24gPSAoZnVuY3Rpb24gKFByb2plY3Rpb24pIHtcbiAgZnVuY3Rpb24gRVBTRzM4NTdQcm9qZWN0aW9uKGNvZGUpIHtcbiAgICBQcm9qZWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIHVuaXRzOiBVbml0cy5NRVRFUlMsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIHdvcmxkRXh0ZW50OiBXT1JMRF9FWFRFTlQsXG4gICAgICBnZXRQb2ludFJlc29sdXRpb246IGZ1bmN0aW9uKHJlc29sdXRpb24sIHBvaW50KSB7XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uIC8gY29zaChwb2ludFsxXSAvIFJBRElVUyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggUHJvamVjdGlvbiApIEVQU0czODU3UHJvamVjdGlvbi5fX3Byb3RvX18gPSBQcm9qZWN0aW9uO1xuICBFUFNHMzg1N1Byb2plY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUHJvamVjdGlvbiAmJiBQcm9qZWN0aW9uLnByb3RvdHlwZSApO1xuICBFUFNHMzg1N1Byb2plY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRVBTRzM4NTdQcm9qZWN0aW9uO1xuXG4gIHJldHVybiBFUFNHMzg1N1Byb2plY3Rpb247XG59KFByb2plY3Rpb24pKTtcblxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj59XG4gKi9cbmV4cG9ydCB2YXIgUFJPSkVDVElPTlMgPSBbXG4gIG5ldyBFUFNHMzg1N1Byb2plY3Rpb24oJ0VQU0c6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjEwMCcpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjEwMjExMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjkwMDkxMycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo2LjE4OjM6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo6Mzg1NycpLFxuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjMzg1NycpXG5dO1xuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjQzMjYgdG8gRVBTRzozODU3LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbiAoZGVmYXVsdCBpcyBgMmApLlxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FUFNHNDMyNihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICB2YXIgZGltZW5zaW9uID0gb3B0X2RpbWVuc2lvbiA+IDEgPyBvcHRfZGltZW5zaW9uIDogMjtcbiAgdmFyIG91dHB1dCA9IG9wdF9vdXRwdXQ7XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICB2YXIgaGFsZlNpemUgPSBIQUxGX1NJWkU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IGhhbGZTaXplICogaW5wdXRbaV0gLyAxODA7XG4gICAgdmFyIHkgPSBSQURJVVMgKlxuICAgICAgICBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJICogKGlucHV0W2kgKyAxXSArIDkwKSAvIDM2MCkpO1xuICAgIGlmICh5ID4gaGFsZlNpemUpIHtcbiAgICAgIHkgPSBoYWxmU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHkgPCAtaGFsZlNpemUpIHtcbiAgICAgIHkgPSAtaGFsZlNpemU7XG4gICAgfVxuICAgIG91dHB1dFtpICsgMV0gPSB5O1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBmcm9tIEVQU0c6Mzg1NyB0byBFUFNHOjQzMjYuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9FUFNHNDMyNihpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICB2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICB2YXIgZGltZW5zaW9uID0gb3B0X2RpbWVuc2lvbiA+IDEgPyBvcHRfZGltZW5zaW9uIDogMjtcbiAgdmFyIG91dHB1dCA9IG9wdF9vdXRwdXQ7XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkaW1lbnNpb24gPiAyKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSB2YWx1ZXMgYmV5b25kIHNlY29uZCBkaW1lbnNpb25cbiAgICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSAxODAgKiBpbnB1dFtpXSAvIEhBTEZfU0laRTtcbiAgICBvdXRwdXRbaSArIDFdID0gMzYwICogTWF0aC5hdGFuKFxuICAgICAgTWF0aC5leHAoaW5wdXRbaSArIDFdIC8gUkFESVVTKSkgLyBNYXRoLlBJIC0gOTA7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXBzZzM4NTcuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzQzMjZcbiAqL1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuLi9wcm9qL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFNlbWktbWFqb3IgcmFkaXVzIG9mIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFJBRElVUyA9IDYzNzgxMzc7XG5cblxuLyoqXG4gKiBFeHRlbnQgb2YgdGhlIEVQU0c6NDMyNiBwcm9qZWN0aW9uIHdoaWNoIGlzIHRoZSB3aG9sZSB3b3JsZC5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAqL1xuZXhwb3J0IHZhciBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBNRVRFUlNfUEVSX1VOSVQgPSBNYXRoLlBJICogUkFESVVTIC8gMTgwO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIFdHUzg0IGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMgKEVQU0c6NDMyNikuXG4gKlxuICogTm90ZSB0aGF0IE9wZW5MYXllcnMgZG9lcyBub3Qgc3RyaWN0bHkgY29tcGx5IHdpdGggdGhlIEVQU0cgZGVmaW5pdGlvbi5cbiAqIFRoZSBFUFNHIHJlZ2lzdHJ5IGRlZmluZXMgNDMyNiBhcyBhIENSUyBmb3IgTGF0aXR1ZGUsTG9uZ2l0dWRlICh5LHgpLlxuICogT3BlbkxheWVycyB0cmVhdHMgRVBTRzo0MzI2IGFzIGEgcHNldWRvLXByb2plY3Rpb24sIHdpdGggeCx5IGNvb3JkaW5hdGVzLlxuICovXG52YXIgRVBTRzQzMjZQcm9qZWN0aW9uID0gKGZ1bmN0aW9uIChQcm9qZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEVQU0c0MzI2UHJvamVjdGlvbihjb2RlLCBvcHRfYXhpc09yaWVudGF0aW9uKSB7XG4gICAgUHJvamVjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogVW5pdHMuREVHUkVFUyxcbiAgICAgIGV4dGVudDogRVhURU5ULFxuICAgICAgYXhpc09yaWVudGF0aW9uOiBvcHRfYXhpc09yaWVudGF0aW9uLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgbWV0ZXJzUGVyVW5pdDogTUVURVJTX1BFUl9VTklULFxuICAgICAgd29ybGRFeHRlbnQ6IEVYVEVOVFxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFByb2plY3Rpb24gKSBFUFNHNDMyNlByb2plY3Rpb24uX19wcm90b19fID0gUHJvamVjdGlvbjtcbiAgRVBTRzQzMjZQcm9qZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFByb2plY3Rpb24gJiYgUHJvamVjdGlvbi5wcm90b3R5cGUgKTtcbiAgRVBTRzQzMjZQcm9qZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVQU0c0MzI2UHJvamVjdGlvbjtcblxuICByZXR1cm4gRVBTRzQzMjZQcm9qZWN0aW9uO1xufShQcm9qZWN0aW9uKSk7XG5cblxuLyoqXG4gKiBQcm9qZWN0aW9ucyBlcXVhbCB0byBFUFNHOjQzMjYuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fVxuICovXG5leHBvcnQgdmFyIFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdDUlM6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignRVBTRzo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6RVBTRzo6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni42OjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpPR0M6Mjo4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCdodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbC9zcnMvZXBzZy54bWwjNDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2JywgJ25ldScpXG5dO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcHNnNDMyNi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9wcm9qZWN0aW9uc1xuICovXG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb24+fVxuICovXG52YXIgY2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIENsZWFyIHRoZSBwcm9qZWN0aW9ucyBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICBjYWNoZSA9IHt9O1xufVxuXG5cbi8qKlxuICogR2V0IGEgY2FjaGVkIHByb2plY3Rpb24gYnkgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBjb2RlIGZvciB0aGUgcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IFRoZSBwcm9qZWN0aW9uIChpZiBjYWNoZWQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvZGUpIHtcbiAgcmV0dXJuIGNhY2hlW2NvZGVdIHx8IG51bGw7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBwcm9qZWN0aW9uIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24gdG8gY2FjaGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29kZSwgcHJvamVjdGlvbikge1xuICBjYWNoZVtjb2RlXSA9IHByb2plY3Rpb247XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2plY3Rpb25zLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvcHJvan5UcmFuc2Zvcm1GdW5jdGlvbj4+fVxuICovXG52YXIgdHJhbnNmb3JtcyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHRyYW5zZm9ybSBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0cmFuc2Zvcm1zID0ge307XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gc291cmNlIFNvdXJjZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb24gRGVzdGluYXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoc291cmNlLCBkZXN0aW5hdGlvbiwgdHJhbnNmb3JtRm4pIHtcbiAgdmFyIHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICB2YXIgZGVzdGluYXRpb25Db2RlID0gZGVzdGluYXRpb24uZ2V0Q29kZSgpO1xuICBpZiAoIShzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMpKSB7XG4gICAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSA9IHt9O1xuICB9XG4gIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXSA9IHRyYW5zZm9ybUZuO1xufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgdGhlIGNvbnZlcnNpb24gZnVuY3Rpb24gdG8gY29udmVydCBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uICBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFuIHVwXG4gKiBjYWNoZWQgdHJhbnNmb3JtcyBkdXJpbmcgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUaGUgdW5yZWdpc3RlcmVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBzb3VyY2VDb2RlID0gc291cmNlLmdldENvZGUoKTtcbiAgdmFyIGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uLmdldENvZGUoKTtcbiAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgaWYgKGlzRW1wdHkodHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkpIHtcbiAgICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdHJhbnNmb3JtIGdpdmVuIGEgc291cmNlIGNvZGUgYW5kIGEgZGVzdGluYXRpb24gY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VDb2RlIFRoZSBjb2RlIGZvciB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25Db2RlIFRoZSBjb2RlIGZvciB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufHVuZGVmaW5lZH0gVGhlIHRyYW5zZm9ybSBmdW5jdGlvbiAoaWYgZm91bmQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHNvdXJjZUNvZGUsIGRlc3RpbmF0aW9uQ29kZSkge1xuICB2YXIgdHJhbnNmb3JtO1xuICBpZiAoc291cmNlQ29kZSBpbiB0cmFuc2Zvcm1zICYmIGRlc3RpbmF0aW9uQ29kZSBpbiB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdKSB7XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybXMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9Cb3hcbiAqL1xuXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5cbnZhciBSZW5kZXJCb3ggPSAoZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgZnVuY3Rpb24gUmVuZGVyQm94KGNsYXNzTmFtZSkge1xuICAgIERpc3Bvc2FibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5jbGFzc05hbWUgPSAnb2wtYm94ICcgKyBjbGFzc05hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5lbmRQaXhlbF8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIERpc3Bvc2FibGUgKSBSZW5kZXJCb3guX19wcm90b19fID0gRGlzcG9zYWJsZTtcbiAgUmVuZGVyQm94LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERpc3Bvc2FibGUgJiYgRGlzcG9zYWJsZS5wcm90b3R5cGUgKTtcbiAgUmVuZGVyQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlbmRlckJveDtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsICgpIHtcbiAgICB0aGlzLnNldE1hcChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlbmRlckJveC5wcm90b3R5cGUucmVuZGVyXyA9IGZ1bmN0aW9uIHJlbmRlcl8gKCkge1xuICAgIHZhciBzdGFydFBpeGVsID0gdGhpcy5zdGFydFBpeGVsXztcbiAgICB2YXIgZW5kUGl4ZWwgPSB0aGlzLmVuZFBpeGVsXztcbiAgICB2YXIgcHggPSAncHgnO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudF8uc3R5bGU7XG4gICAgc3R5bGUubGVmdCA9IE1hdGgubWluKHN0YXJ0UGl4ZWxbMF0sIGVuZFBpeGVsWzBdKSArIHB4O1xuICAgIHN0eWxlLnRvcCA9IE1hdGgubWluKHN0YXJ0UGl4ZWxbMV0sIGVuZFBpeGVsWzFdKSArIHB4O1xuICAgIHN0eWxlLndpZHRoID0gTWF0aC5hYnMoZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdKSArIHB4O1xuICAgIHN0eWxlLmhlaWdodCA9IE1hdGguYWJzKGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXSkgKyBweDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfSBtYXAgTWFwLlxuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAgKG1hcCkge1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsZW1lbnRfLnN0eWxlO1xuICAgICAgc3R5bGUubGVmdCA9IHN0eWxlLnRvcCA9IHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICAgIH1cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdGhpcy5tYXBfLmdldE92ZXJsYXlDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRfKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3BpeGVsflBpeGVsfSBzdGFydFBpeGVsIFN0YXJ0IHBpeGVsLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gZW5kUGl4ZWwgRW5kIHBpeGVsLlxuICAgKi9cbiAgUmVuZGVyQm94LnByb3RvdHlwZS5zZXRQaXhlbHMgPSBmdW5jdGlvbiBzZXRQaXhlbHMgKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKSB7XG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5lbmRQaXhlbF8gPSBlbmRQaXhlbDtcbiAgICB0aGlzLmNyZWF0ZU9yVXBkYXRlR2VvbWV0cnkoKTtcbiAgICB0aGlzLnJlbmRlcl8oKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHRoZSBjYWNoZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBSZW5kZXJCb3gucHJvdG90eXBlLmNyZWF0ZU9yVXBkYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUdlb21ldHJ5ICgpIHtcbiAgICB2YXIgc3RhcnRQaXhlbCA9IHRoaXMuc3RhcnRQaXhlbF87XG4gICAgdmFyIGVuZFBpeGVsID0gdGhpcy5lbmRQaXhlbF87XG4gICAgdmFyIHBpeGVscyA9IFtcbiAgICAgIHN0YXJ0UGl4ZWwsXG4gICAgICBbc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMV1dLFxuICAgICAgZW5kUGl4ZWwsXG4gICAgICBbZW5kUGl4ZWxbMF0sIHN0YXJ0UGl4ZWxbMV1dXG4gICAgXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwaXhlbHMubWFwKHRoaXMubWFwXy5nZXRDb29yZGluYXRlRnJvbVBpeGVsLCB0aGlzLm1hcF8pO1xuICAgIC8vIGNsb3NlIHRoZSBwb2x5Z29uXG4gICAgY29vcmRpbmF0ZXNbNF0gPSBjb29yZGluYXRlc1swXS5zbGljZSgpO1xuICAgIGlmICghdGhpcy5nZW9tZXRyeV8pIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlfID0gbmV3IFBvbHlnb24oW2Nvb3JkaW5hdGVzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlfLnNldENvb3JkaW5hdGVzKFtjb29yZGluYXRlc10pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bW9kdWxlOm9sL2dlb20vUG9seWdvbn0gR2VvbWV0cnkuXG4gICAqL1xuICBSZW5kZXJCb3gucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfTtcblxuICByZXR1cm4gUmVuZGVyQm94O1xufShEaXNwb3NhYmxlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQm94O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Cb3guanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9FdmVudFxuICovXG5cbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuXG52YXIgUmVuZGVyRXZlbnQgPSAoZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIFJlbmRlckV2ZW50KHR5cGUsIG9wdF92ZWN0b3JDb250ZXh0LCBvcHRfZnJhbWVTdGF0ZSwgb3B0X2NvbnRleHQsIG9wdF9nbENvbnRleHQpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgY2FudmFzLCB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGV9LlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL1ZlY3RvckNvbnRleHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnZlY3RvckNvbnRleHQgPSBvcHRfdmVjdG9yQ29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGZyYW1lIHN0YXRlLlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lU3RhdGUgPSBvcHRfZnJhbWVTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENhbnZhcyBjb250ZXh0LiBPbmx5IGF2YWlsYWJsZSB3aGVuIGEgQ2FudmFzIHJlbmRlcmVyIGlzIHVzZWQsIG51bGxcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gb3B0X2NvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBXZWJHTCBjb250ZXh0LiBPbmx5IGF2YWlsYWJsZSB3aGVuIGEgV2ViR0wgcmVuZGVyZXIgaXMgdXNlZCwgbnVsbFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3dlYmdsL0NvbnRleHR8bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZ2xDb250ZXh0ID0gb3B0X2dsQ29udGV4dDtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFJlbmRlckV2ZW50Ll9fcHJvdG9fXyA9IEV2ZW50O1xuICBSZW5kZXJFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgUmVuZGVyRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVuZGVyRXZlbnQ7XG5cbiAgcmV0dXJuIFJlbmRlckV2ZW50O1xufShFdmVudCkpO1xuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJFdmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3Bvc3Rjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBPU1RDT01QT1NFOiAncG9zdGNvbXBvc2UnLFxuICAvKipcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICAgKiBAYXBpXG4gICAqL1xuICBQUkVDT01QT1NFOiAncHJlY29tcG9zZScsXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUkVOREVSOiAncmVuZGVyJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvUmVwbGF5R3JvdXBcbiAqL1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciByZXBsYXkgZ3JvdXBzLlxuICovXG52YXIgUmVwbGF5R3JvdXAgPSBmdW5jdGlvbiBSZXBsYXlHcm91cCAoKSB7fTtcblxuUmVwbGF5R3JvdXAucHJvdG90eXBlLmdldFJlcGxheSA9IGZ1bmN0aW9uIGdldFJlcGxheSAoekluZGV4LCByZXBsYXlUeXBlKSB7fTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICovXG5SZXBsYXlHcm91cC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge307XG5cbmV4cG9ydCBkZWZhdWx0IFJlcGxheUdyb3VwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlHcm91cC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL1JlcGxheVR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQ0lSQ0xFOiAnQ2lyY2xlJyxcbiAgREVGQVVMVDogJ0RlZmF1bHQnLFxuICBJTUFHRTogJ0ltYWdlJyxcbiAgTElORV9TVFJJTkc6ICdMaW5lU3RyaW5nJyxcbiAgUE9MWUdPTjogJ1BvbHlnb24nLFxuICBURVhUOiAnVGV4dCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcGxheVR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9WZWN0b3JDb250ZXh0XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250ZXh0IGZvciBkcmF3aW5nIGdlb21ldHJpZXMuICBBIHZlY3RvciBjb250ZXh0IGlzIGF2YWlsYWJsZSBvbiByZW5kZXJcbiAqIGV2ZW50cyBhbmQgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAqIEBhcGlcbiAqL1xudmFyIFZlY3RvckNvbnRleHQgPSBmdW5jdGlvbiBWZWN0b3JDb250ZXh0ICgpIHt9O1xuXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3Q3VzdG9tID0gZnVuY3Rpb24gZHJhd0N1c3RvbSAoZ2VvbWV0cnksIGZlYXR1cmUsIHJlbmRlcmVyKSB7fTtcblxuLyoqXG4gKiBSZW5kZXIgYSBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBnZW9tZXRyeSBUaGUgZ2VvbWV0cnkgdG8gcmVuZGVyLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3R2VvbWV0cnkgPSBmdW5jdGlvbiBkcmF3R2VvbWV0cnkgKGdlb21ldHJ5KSB7fTtcblxuLyoqXG4gKiBTZXQgdGhlIHJlbmRlcmluZyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgVGhlIHJlbmRlcmluZyBzdHlsZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSBjaXJjbGVHZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiBkcmF3Q2lyY2xlIChjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV9IHN0eWxlIFN0eWxlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3RmVhdHVyZSA9IGZ1bmN0aW9uIGRyYXdGZWF0dXJlIChmZWF0dXJlLCBzdHlsZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb259IGdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5IEdlb21ldHJ5IGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBkcmF3R2VvbWV0cnlDb2xsZWN0aW9uIChnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gbGluZVN0cmluZ0dlb21ldHJ5IExpbmUgc3RyaW5nIGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd0xpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TGluZVN0cmluZyAobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL011bHRpTGluZVN0cmluZ3xtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5IE11bHRpTGluZVN0cmluZyBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TXVsdGlMaW5lU3RyaW5nIChtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50fG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gbXVsdGlQb2ludEdlb21ldHJ5IE11bHRpUG9pbnQgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3TXVsdGlQb2ludCA9IGZ1bmN0aW9uIGRyYXdNdWx0aVBvaW50IChtdWx0aVBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufSBtdWx0aVBvbHlnb25HZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5WZWN0b3JDb250ZXh0LnByb3RvdHlwZS5kcmF3TXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gZHJhd011bHRpUG9seWdvbiAobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vUG9pbnR8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBwb2ludEdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd1BvaW50ID0gZnVuY3Rpb24gZHJhd1BvaW50IChwb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1BvbHlnb258bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBwb2x5Z29uR2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24gKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCAoZ2VvbWV0cnksIGZlYXR1cmUpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL0ZpbGx9IGZpbGxTdHlsZSBGaWxsIHN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3Ryb2tlfSBzdHJva2VTdHlsZSBTdHJva2Ugc3R5bGUuXG4gKi9cblZlY3RvckNvbnRleHQucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHNldEZpbGxTdHJva2VTdHlsZSAoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvSW1hZ2V9IGltYWdlU3R5bGUgSW1hZ2Ugc3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwPX0gb3B0X2RlY2x1dHRlckdyb3VwIERlY2x1dHRlci5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0SW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIHNldEltYWdlU3R5bGUgKGltYWdlU3R5bGUsIG9wdF9kZWNsdXR0ZXJHcm91cCkge307XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvVGV4dH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwPX0gb3B0X2RlY2x1dHRlckdyb3VwIERlY2x1dHRlci5cbiAqL1xuVmVjdG9yQ29udGV4dC5wcm90b3R5cGUuc2V0VGV4dFN0eWxlID0gZnVuY3Rpb24gc2V0VGV4dFN0eWxlICh0ZXh0U3R5bGUsIG9wdF9kZWNsdXR0ZXJHcm91cCkge307XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvckNvbnRleHQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvckNvbnRleHQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXNcbiAqL1xuaW1wb3J0IHtnZXRGb250RmFtaWxpZXN9IGZyb20gJy4uL2Nzcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Y2xlYXJ9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgTFJVQ2FjaGUgZnJvbSAnLi4vc3RydWN0cy9MUlVDYWNoZS5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm19IGZyb20gJy4uL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IGZpbGxTdHlsZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IFtjdXJyZW50RmlsbFN0eWxlXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gW2N1cnJlbnRTdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY3VycmVudExpbmVDYXBdXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBjdXJyZW50TGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW50TGluZUpvaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRMaW5lV2lkdGhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRNaXRlckxpbWl0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0U3Ryb2tlXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gW2ZpbGxTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUNhcF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsaW5lSm9pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZVdpZHRoXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0XVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVDYXBcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lSm9pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVXaWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pdGVyTGltaXRcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IHN0cm9rZVN0eWxlXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZvbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGV4dEFsaWduXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHRCYXNlbGluZVxuICovXG5cblxuLyoqXG4gKiBDb250YWluZXIgZm9yIGRlY2x1dHRlcmVkIHJlcGxheSBpbnN0cnVjdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHJlbmRlcmVkIG9yXG4gKiBvbWl0dGVkIHRvZ2V0aGVyLCBpLmUuIHdoZW4gc3R5bGVzIHJlbmRlciBib3RoIGFuIGltYWdlIGFuZCB0ZXh0LCBvciBmb3IgdGhlXG4gKiBjaGFyYWN0ZXJzIHRoYXQgZm9ybSB0ZXh0IGFsb25nIGxpbmVzLiBUaGUgYmFzaWMgZWxlbWVudHMgb2YgdGhpcyBhcnJheSBhcmVcbiAqIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgY291bnRdYCwgd2hlcmUgdGhlIGZpcnN0IGZvdXIgZW50cmllcyBhcmUgdGhlXG4gKiByZW5kZXJlZCBleHRlbnQgb2YgdGhlIGdyb3VwIGluIHBpeGVsIHNwYWNlLiBgY291bnRgIGlzIHRoZSBudW1iZXIgb2Ygc3R5bGVzXG4gKiBpbiB0aGUgZ3JvdXAsIGkuZS4gMiB3aGVuIGFuIGltYWdlIGFuZCBhIHRleHQgYXJlIGdyb3VwZWQsIG9yIDEgb3RoZXJ3aXNlLlxuICogSW4gYWRkaXRpb24gdG8gdGhlc2UgZm91ciBlbGVtZW50cywgZGVjbHV0dGVyIGluc3RydWN0aW9uIGFycmF5cyAoaS5lLiB0aGVcbiAqIGFyZ3VtZW50cyB0byB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXN+ZHJhd0ltYWdlfSBhcmUgYXBwZW5kZWQgdG8gdGhlIGFycmF5LlxuICogQHR5cGVkZWYge0FycmF5LjwqPn0gRGVjbHV0dGVyR3JvdXBcbiAqL1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRGb250ID0gJzEwcHggc2Fucy1zZXJpZic7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHttb2R1bGU6b2wvY29sb3J+Q29sb3J9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdEZpbGxTdHlsZSA9IFswLCAwLCAwLCAxXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TGluZUNhcCA9ICdyb3VuZCc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TGluZURhc2ggPSBbXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0TGluZURhc2hPZmZzZXQgPSAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lSm9pbiA9ICdyb3VuZCc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdE1pdGVyTGltaXQgPSAxMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge21vZHVsZTpvbC9jb2xvcn5Db2xvcn1cbiAqL1xuZXhwb3J0IHZhciBkZWZhdWx0U3Ryb2tlU3R5bGUgPSBbMCwgMCwgMCwgMV07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdFRleHRBbGlnbiA9ICdjZW50ZXInO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRUZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRQYWRkaW5nID0gWzAsIDAsIDAsIDBdO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIGRlZmF1bHRMaW5lV2lkdGggPSAxO1xuXG5cbi8qKlxuICogVGhlIGxhYmVsIGNhY2hlIGZvciB0ZXh0IHJlbmRlcmluZy4gVG8gY2hhbmdlIHRoZSBkZWZhdWx0IGNhY2hlIHNpemUgb2YgMjA0OFxuICogZW50cmllcywgdXNlIHtAbGluayBtb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZSNzZXRTaXplfS5cbiAqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZS48SFRNTENhbnZhc0VsZW1lbnQ+fVxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIGxhYmVsQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG51bWJlcj59XG4gKi9cbmV4cG9ydCB2YXIgY2hlY2tlZEZvbnRzID0ge307XG5cblxuLyoqXG4gKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICovXG52YXIgbWVhc3VyZUNvbnRleHQgPSBudWxsO1xuXG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbnVtYmVyPn1cbiAqL1xuZXhwb3J0IHZhciB0ZXh0SGVpZ2h0cyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsYWJlbCBjYWNoZSB3aGVuIGEgZm9udCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBDU1MgZm9udCBzcGVjLlxuICovXG5leHBvcnQgdmFyIGNoZWNrRm9udCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHJldHJpZXMgPSA2MDtcbiAgdmFyIGNoZWNrZWQgPSBjaGVja2VkRm9udHM7XG4gIHZhciBzaXplID0gJzMycHggJztcbiAgdmFyIHJlZmVyZW5jZUZvbnRzID0gWydtb25vc3BhY2UnLCAnc2VyaWYnXTtcbiAgdmFyIGxlbiA9IHJlZmVyZW5jZUZvbnRzLmxlbmd0aDtcbiAgdmFyIHRleHQgPSAnd215dHppbFdNWVRaSUxAIy8mPyQlMTBcXHVGMDEzJztcbiAgdmFyIGludGVydmFsLCByZWZlcmVuY2VXaWR0aDtcblxuICBmdW5jdGlvbiBpc0F2YWlsYWJsZShmb250KSB7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNZWFzdXJlQ29udGV4dCgpO1xuICAgIHZhciBhdmFpbGFibGUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciByZWZlcmVuY2VGb250ID0gcmVmZXJlbmNlRm9udHNbaV07XG4gICAgICBjb250ZXh0LmZvbnQgPSBzaXplICsgcmVmZXJlbmNlRm9udDtcbiAgICAgIHJlZmVyZW5jZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgIGlmIChmb250ICE9IHJlZmVyZW5jZUZvbnQpIHtcbiAgICAgICAgY29udGV4dC5mb250ID0gc2l6ZSArIGZvbnQgKyAnLCcgKyByZWZlcmVuY2VGb250O1xuICAgICAgICB2YXIgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAvLyBJZiB3aWR0aCBhbmQgcmVmZXJlbmNlV2lkdGggYXJlIHRoZSBzYW1lLCB0aGVuIHRoZSBmYWxsYmFjayB3YXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmb250IHdlIHdhbnRlZCwgc28gdGhlIGZvbnQgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgICAgYXZhaWxhYmxlID0gYXZhaWxhYmxlICYmIHdpZHRoICE9IHJlZmVyZW5jZVdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXZhaWxhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgdmFyIGRvbmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGZvbnQgaW4gY2hlY2tlZCkge1xuICAgICAgaWYgKGNoZWNrZWRbZm9udF0gPCByZXRyaWVzKSB7XG4gICAgICAgIGlmIChpc0F2YWlsYWJsZShmb250KSkge1xuICAgICAgICAgIGNoZWNrZWRbZm9udF0gPSByZXRyaWVzO1xuICAgICAgICAgIGNsZWFyKHRleHRIZWlnaHRzKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsb2FkZWQgZm9udHMgYXJlIHBpY2tlZCB1cCBieSBTYWZhcmlcbiAgICAgICAgICBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgbGFiZWxDYWNoZS5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrY2hlY2tlZFtmb250XTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRTcGVjKSB7XG4gICAgdmFyIGZvbnRGYW1pbGllcyA9IGdldEZvbnRGYW1pbGllcyhmb250U3BlYyk7XG4gICAgaWYgKCFmb250RmFtaWxpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZm9udEZhbWlsaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZm9udEZhbWlsaWVzW2ldO1xuICAgICAgaWYgKCEoZm9udEZhbWlseSBpbiBjaGVja2VkKSkge1xuICAgICAgICBjaGVja2VkW2ZvbnRGYW1pbHldID0gcmV0cmllcztcbiAgICAgICAgaWYgKCFpc0F2YWlsYWJsZShmb250RmFtaWx5KSkge1xuICAgICAgICAgIGNoZWNrZWRbZm9udEZhbWlseV0gPSAwO1xuICAgICAgICAgIGlmIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGNoZWNrLCAzMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gTWVhc3VyZSBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBnZXRNZWFzdXJlQ29udGV4dCgpIHtcbiAgaWYgKCFtZWFzdXJlQ29udGV4dCkge1xuICAgIG1lYXN1cmVDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICB9XG4gIHJldHVybiBtZWFzdXJlQ29udGV4dDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc2l6ZX5TaXplfSBNZWFzdXJlbWVudC5cbiAqL1xuZXhwb3J0IHZhciBtZWFzdXJlVGV4dEhlaWdodCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHNwYW47XG4gIHZhciBoZWlnaHRzID0gdGV4dEhlaWdodHM7XG4gIHJldHVybiBmdW5jdGlvbihmb250KSB7XG4gICAgdmFyIGhlaWdodCA9IGhlaWdodHNbZm9udF07XG4gICAgaWYgKGhlaWdodCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghc3Bhbikge1xuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gJ00nO1xuICAgICAgICBzcGFuLnN0eWxlLm1hcmdpbiA9IHNwYW4uc3R5bGUucGFkZGluZyA9ICcwICFpbXBvcnRhbnQnO1xuICAgICAgICBzcGFuLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlICFpbXBvcnRhbnQnO1xuICAgICAgICBzcGFuLnN0eWxlLmxlZnQgPSAnLTk5OTk5cHggIWltcG9ydGFudCc7XG4gICAgICB9XG4gICAgICBzcGFuLnN0eWxlLmZvbnQgPSBmb250O1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGhlaWdodCA9IGhlaWdodHNbZm9udF0gPSBzcGFuLm9mZnNldEhlaWdodDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3Bhbik7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgRm9udC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhc3VyZVRleHRXaWR0aChmb250LCB0ZXh0KSB7XG4gIHZhciBtZWFzdXJlQ29udGV4dCA9IGdldE1lYXN1cmVDb250ZXh0KCk7XG4gIGlmIChmb250ICE9IG1lYXN1cmVDb250ZXh0LmZvbnQpIHtcbiAgICBtZWFzdXJlQ29udGV4dC5mb250ID0gZm9udDtcbiAgfVxuICByZXR1cm4gbWVhc3VyZUNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cblxuZXhwb3J0IHZhciByZXNldFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm18bnVsbH0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWCBPcmlnaW4gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHcgV2lkdGguXG4gKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdJbWFnZShjb250ZXh0LFxuICB0cmFuc2Zvcm0sIG9wYWNpdHksIGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCBzY2FsZSkge1xuICB2YXIgYWxwaGE7XG4gIGlmIChvcGFjaXR5ICE9IDEpIHtcbiAgICBhbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhICogb3BhY2l0eTtcbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCB3ICogc2NhbGUsIGggKiBzY2FsZSk7XG5cbiAgaWYgKGFscGhhKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICB9XG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybS5hcHBseShjb250ZXh0LCByZXNldFRyYW5zZm9ybSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FudmFzLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0ltYWdlUmVwbGF5XG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuLi9jYW52YXMvSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheSBmcm9tICcuLi9jYW52YXMvUmVwbGF5LmpzJztcblxudmFyIENhbnZhc0ltYWdlUmVwbGF5ID0gKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzSW1hZ2VSZXBsYXkodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgQ2FudmFzUmVwbGF5LmNhbGwodGhpcywgdG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclhfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcllfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMub3BhY2l0eV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luWF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luWV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zbmFwVG9QaXhlbF8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGhfID0gdW5kZWZpbmVkO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc0ltYWdlUmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzUmVwbGF5ICYmIENhbnZhc1JlcGxheS5wcm90b3R5cGUgKTtcbiAgQ2FudmFzSW1hZ2VSZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzSW1hZ2VSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZC5cbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5kcmF3Q29vcmRpbmF0ZXNfID0gZnVuY3Rpb24gZHJhd0Nvb3JkaW5hdGVzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5kcmF3UG9pbnQgPSBmdW5jdGlvbiBkcmF3UG9pbnQgKHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShwb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gcG9pbnRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gcG9pbnRHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBteUVuZCA9IHRoaXMuZHJhd0Nvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLnNuYXBUb1BpeGVsXywgdGhpcy53aWR0aF9cbiAgICBdKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmhpdERldGVjdGlvbkltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8sIHRoaXMuc25hcFRvUGl4ZWxfLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZVJlcGxheS5wcm90b3R5cGUuZHJhd011bHRpUG9pbnQgPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2ludCAobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBtdWx0aVBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdmFyIG15QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB2YXIgbXlFbmQgPSB0aGlzLmRyYXdDb29yZGluYXRlc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLnNuYXBUb1BpeGVsXywgdGhpcy53aWR0aF9cbiAgICBdKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmhpdERldGVjdGlvbkltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8sIHRoaXMuc25hcFRvUGl4ZWxfLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHRoaXMucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucygpO1xuICAgIC8vIEZJWE1FIHRoaXMgZG9lc24ndCByZWFsbHkgcHJvdGVjdCB1cyBhZ2FpbnN0IGZ1cnRoZXIgY2FsbHMgdG8gZHJhdypHZW9tZXRyeVxuICAgIHRoaXMuYW5jaG9yWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IG51bGw7XG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9wYWNpdHlfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcmlnaW5ZXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNuYXBUb1BpeGVsXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoXyA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlUmVwbGF5LnByb3RvdHlwZS5zZXRJbWFnZVN0eWxlID0gZnVuY3Rpb24gc2V0SW1hZ2VTdHlsZSAoaW1hZ2VTdHlsZSwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICB2YXIgYW5jaG9yID0gaW1hZ2VTdHlsZS5nZXRBbmNob3IoKTtcbiAgICB2YXIgc2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgIHZhciBoaXREZXRlY3Rpb25JbWFnZSA9IGltYWdlU3R5bGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoMSk7XG4gICAgdmFyIGltYWdlID0gaW1hZ2VTdHlsZS5nZXRJbWFnZSgxKTtcbiAgICB2YXIgb3JpZ2luID0gaW1hZ2VTdHlsZS5nZXRPcmlnaW4oKTtcbiAgICB0aGlzLmFuY2hvclhfID0gYW5jaG9yWzBdO1xuICAgIHRoaXMuYW5jaG9yWV8gPSBhbmNob3JbMV07XG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwfSAqLyAoZGVjbHV0dGVyR3JvdXApO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gaGl0RGV0ZWN0aW9uSW1hZ2U7XG4gICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgICB0aGlzLmhlaWdodF8gPSBzaXplWzFdO1xuICAgIHRoaXMub3BhY2l0eV8gPSBpbWFnZVN0eWxlLmdldE9wYWNpdHkoKTtcbiAgICB0aGlzLm9yaWdpblhfID0gb3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWV8gPSBvcmlnaW5bMV07XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSBpbWFnZVN0eWxlLmdldFJvdGF0ZVdpdGhWaWV3KCk7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSBpbWFnZVN0eWxlLmdldFJvdGF0aW9uKCk7XG4gICAgdGhpcy5zY2FsZV8gPSBpbWFnZVN0eWxlLmdldFNjYWxlKCk7XG4gICAgdGhpcy5zbmFwVG9QaXhlbF8gPSBpbWFnZVN0eWxlLmdldFNuYXBUb1BpeGVsKCk7XG4gICAgdGhpcy53aWR0aF8gPSBzaXplWzBdO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXNJbWFnZVJlcGxheTtcbn0oQ2FudmFzUmVwbGF5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1hZ2VSZXBsYXk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlUmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZVxuICovXG4vLyBGSVhNRSB0ZXN0LCBlc3BlY2lhbGx5IHBvbHlnb25zIHdpdGggaG9sZXMgYW5kIG11bHRpcG9seWdvbnNcbi8vIEZJWE1FIG5lZWQgdG8gaGFuZGxlIGxhcmdlIHRoaWNrIGZlYXR1cmVzICh3aGVyZSBwaXhlbCBzaXplIG1hdHRlcnMpXG4vLyBGSVhNRSBhZGQgb2Zmc2V0IGFuZCBlbmQgdG8gb2wvZ2VvbS9mbGF0L3RyYW5zZm9ybX50cmFuc2Zvcm0yRD9cblxuaW1wb3J0IHtlcXVhbHN9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uLy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtR2VvbTJEfSBmcm9tICcuLi8uLi9nZW9tL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IFZlY3RvckNvbnRleHQgZnJvbSAnLi4vVmVjdG9yQ29udGV4dC5qcyc7XG5pbXBvcnQge2RlZmF1bHRUZXh0QWxpZ24sIGRlZmF1bHRGaWxsU3R5bGUsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZURhc2gsIGRlZmF1bHRMaW5lRGFzaE9mZnNldCwgZGVmYXVsdExpbmVKb2luLCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TWl0ZXJMaW1pdCwgZGVmYXVsdFN0cm9rZVN0eWxlLCBkZWZhdWx0VGV4dEJhc2VsaW5lLCBkZWZhdWx0Rm9udH0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY29uY3JldGUgc3ViY2xhc3Mgb2Yge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvVmVjdG9yQ29udGV4dH0gdGhhdCBpbXBsZW1lbnRzXG4gKiBkaXJlY3QgcmVuZGVyaW5nIG9mIGZlYXR1cmVzIGFuZCBnZW9tZXRyaWVzIHRvIGFuIEhUTUw1IENhbnZhcyBjb250ZXh0LlxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGNyZWF0ZWQgaW50ZXJuYWxseSBieSB0aGUgbGlicmFyeSBhbmRcbiAqIHByb3ZpZGVkIHRvIGFwcGxpY2F0aW9uIGNvZGUgYXMgdmVjdG9yQ29udGV4dCBtZW1iZXIgb2YgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudH0gb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwb3N0Y29tcG9zZSwgcHJlY29tcG9zZSBhbmRcbiAqIHJlbmRlciBldmVudHMgZW1pdHRlZCBieSBsYXllcnMgYW5kIG1hcHMuXG4gKi9cbnZhciBDYW52YXNJbW1lZGlhdGVSZW5kZXJlciA9IChmdW5jdGlvbiAoVmVjdG9yQ29udGV4dCkge1xuICBmdW5jdGlvbiBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcihjb250ZXh0LCBwaXhlbFJhdGlvLCBleHRlbnQsIHRyYW5zZm9ybSwgdmlld1JvdGF0aW9uKSB7XG4gICAgVmVjdG9yQ29udGV4dC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dF8gPSBjb250ZXh0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gZXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gdHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+U3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0VGV4dFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuZmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+U3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlQW5jaG9yWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VBbmNob3JZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUhlaWdodF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcGFjaXR5XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9yaWdpblhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3JpZ2luWV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVNjYWxlXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTbmFwVG9QaXhlbF8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlV2lkdGhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTY2FsZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9yZW5kZXIvY2FudmFzflRleHRTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50bXBMb2NhbFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICB9XG5cbiAgaWYgKCBWZWN0b3JDb250ZXh0ICkgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIuX19wcm90b19fID0gVmVjdG9yQ29udGV4dDtcbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVmVjdG9yQ29udGV4dCAmJiBWZWN0b3JDb250ZXh0LnByb3RvdHlwZSApO1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0ltYWdlc18gPSBmdW5jdGlvbiBkcmF3SW1hZ2VzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCAyLCB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIGxvY2FsVHJhbnNmb3JtID0gdGhpcy50bXBMb2NhbFRyYW5zZm9ybV87XG4gICAgdmFyIGFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAodGhpcy5pbWFnZU9wYWNpdHlfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIHRoaXMuaW1hZ2VPcGFjaXR5XztcbiAgICB9XG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy5pbWFnZVJvdGF0aW9uXztcbiAgICBpZiAodGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgcm90YXRpb24gKz0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwaXhlbENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcGl4ZWxDb29yZGluYXRlc1tpXSAtIHRoaXMkMS5pbWFnZUFuY2hvclhfO1xuICAgICAgdmFyIHkgPSBwaXhlbENvb3JkaW5hdGVzW2kgKyAxXSAtIHRoaXMkMS5pbWFnZUFuY2hvcllfO1xuICAgICAgaWYgKHRoaXMkMS5pbWFnZVNuYXBUb1BpeGVsXykge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICB9XG4gICAgICBpZiAocm90YXRpb24gIT09IDAgfHwgdGhpcyQxLmltYWdlU2NhbGVfICE9IDEpIHtcbiAgICAgICAgdmFyIGNlbnRlclggPSB4ICsgdGhpcyQxLmltYWdlQW5jaG9yWF87XG4gICAgICAgIHZhciBjZW50ZXJZID0geSArIHRoaXMkMS5pbWFnZUFuY2hvcllfO1xuICAgICAgICBjb21wb3NlVHJhbnNmb3JtKGxvY2FsVHJhbnNmb3JtLFxuICAgICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgICAgdGhpcyQxLmltYWdlU2NhbGVfLCB0aGlzJDEuaW1hZ2VTY2FsZV8sXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgLWNlbnRlclgsIC1jZW50ZXJZKTtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgbG9jYWxUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcyQxLmltYWdlXywgdGhpcyQxLmltYWdlT3JpZ2luWF8sIHRoaXMkMS5pbWFnZU9yaWdpbllfLFxuICAgICAgICB0aGlzJDEuaW1hZ2VXaWR0aF8sIHRoaXMkMS5pbWFnZUhlaWdodF8sIHgsIHksXG4gICAgICAgIHRoaXMkMS5pbWFnZVdpZHRoXywgdGhpcyQxLmltYWdlSGVpZ2h0Xyk7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzLmltYWdlU2NhbGVfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbWFnZU9wYWNpdHlfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdUZXh0XyA9IGZ1bmN0aW9uIGRyYXdUZXh0XyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMudGV4dFN0YXRlXyB8fCB0aGlzLnRleHRfID09PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0RmlsbFN0YXRlXykge1xuICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLnRleHRGaWxsU3RhdGVfKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dFN0cm9rZVN0YXRlXykge1xuICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMudGV4dFN0cm9rZVN0YXRlXyk7XG4gICAgfVxuICAgIHRoaXMuc2V0Q29udGV4dFRleHRTdGF0ZV8odGhpcy50ZXh0U3RhdGVfKTtcbiAgICB2YXIgcGl4ZWxDb29yZGluYXRlcyA9IHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIHJvdGF0aW9uID0gdGhpcy50ZXh0Um90YXRpb25fO1xuICAgIGlmICh0aGlzLnRleHRSb3RhdGVXaXRoVmlld18pIHtcbiAgICAgIHJvdGF0aW9uICs9IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgdmFyIHggPSBwaXhlbENvb3JkaW5hdGVzW29mZnNldF0gKyB0aGlzJDEudGV4dE9mZnNldFhfO1xuICAgICAgdmFyIHkgPSBwaXhlbENvb3JkaW5hdGVzW29mZnNldCArIDFdICsgdGhpcyQxLnRleHRPZmZzZXRZXztcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzJDEudGV4dFNjYWxlXyAhPSAxKSB7XG4gICAgICAgIHZhciBsb2NhbFRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcyQxLnRtcExvY2FsVHJhbnNmb3JtXyxcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIHRoaXMkMS50ZXh0U2NhbGVfLCB0aGlzJDEudGV4dFNjYWxlXyxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAteCwgLXkpO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybS5hcHBseShjb250ZXh0LCBsb2NhbFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcyQxLnRleHRTdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMkMS50ZXh0XywgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcyQxLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcyQxLnRleHRfLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMudGV4dFNjYWxlXyAhPSAxKSB7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlIENsb3NlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUubW92ZVRvTGluZVRvXyA9IGZ1bmN0aW9uIG1vdmVUb0xpbmVUb18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2xvc2UpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgdmFyIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgY29udGV4dC5tb3ZlVG8ocGl4ZWxDb29yZGluYXRlc1swXSwgcGl4ZWxDb29yZGluYXRlc1sxXSk7XG4gICAgdmFyIGxlbmd0aCA9IHBpeGVsQ29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGlmIChjbG9zZSkge1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHBpeGVsQ29vcmRpbmF0ZXNbaV0sIHBpeGVsQ29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICB9XG4gICAgaWYgKGNsb3NlKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdSaW5nc18gPSBmdW5jdGlvbiBkcmF3UmluZ3NfIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMkMS5tb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBjaXJjbGUgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBmaWxsIGFuZCBzdHJva2Ugc3R5bGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0NpcmNsZX0gZ2VvbWV0cnkgQ2lyY2xlIGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdDaXJjbGUgPSBmdW5jdGlvbiBkcmF3Q2lyY2xlIChnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWxsU3RhdGVfIHx8IHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgdmFyIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm1HZW9tMkQoXG4gICAgICAgIGdlb21ldHJ5LCB0aGlzLnRyYW5zZm9ybV8sIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgICAgdmFyIGR4ID0gcGl4ZWxDb29yZGluYXRlc1syXSAtIHBpeGVsQ29vcmRpbmF0ZXNbMF07XG4gICAgICB2YXIgZHkgPSBwaXhlbENvb3JkaW5hdGVzWzNdIC0gcGl4ZWxDb29yZGluYXRlc1sxXTtcbiAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBwaXhlbENvb3JkaW5hdGVzWzBdLCBwaXhlbENvb3JkaW5hdGVzWzFdLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhnZW9tZXRyeS5nZXRDZW50ZXIoKSwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlbmRlcmluZyBzdHlsZS4gIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzIGFuIGltbWVkaWF0ZSByZW5kZXJpbmcgQVBJLFxuICAgKiBhbnkgYHpJbmRleGAgb24gdGhlIHByb3ZpZGVkIHN0eWxlIHdpbGwgYmUgaWdub3JlZC5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiBzZXRTdHlsZSAoc3R5bGUpIHtcbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZShzdHlsZS5nZXRGaWxsKCksIHN0eWxlLmdldFN0cm9rZSgpKTtcbiAgICB0aGlzLnNldEltYWdlU3R5bGUoc3R5bGUuZ2V0SW1hZ2UoKSk7XG4gICAgdGhpcy5zZXRUZXh0U3R5bGUoc3R5bGUuZ2V0VGV4dCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgQ2FsbFxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlI3NldFN0eWxlfSBmaXJzdCB0byBzZXQgdGhlIHJlbmRlcmluZyBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IFRoZSBnZW9tZXRyeSB0byByZW5kZXIuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0dlb21ldHJ5ID0gZnVuY3Rpb24gZHJhd0dlb21ldHJ5IChnZW9tZXRyeSkge1xuICAgIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgICAgIHRoaXMuZHJhd1BvaW50KC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vUG9pbnR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICB0aGlzLmRyYXdMaW5lU3RyaW5nKC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjpcbiAgICAgICAgdGhpcy5kcmF3UG9seWdvbigvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvbHlnb259ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgICAgICB0aGlzLmRyYXdNdWx0aVBvaW50KC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIHRoaXMuZHJhd011bHRpTGluZVN0cmluZygvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL011bHRpTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjpcbiAgICAgICAgdGhpcy5kcmF3TXVsdGlQb2x5Z29uKC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufSAqLyAoZ2VvbWV0cnkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOlxuICAgICAgICB0aGlzLmRyYXdHZW9tZXRyeUNvbGxlY3Rpb24oLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkNJUkNMRTpcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vQ2lyY2xlfSAqLyAoZ2VvbWV0cnkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgZmVhdHVyZSBpbnRvIHRoZSBjYW52YXMuICBOb3RlIHRoYXQgYW55IGB6SW5kZXhgIG9uIHRoZSBwcm92aWRlZFxuICAgKiBzdHlsZSB3aWxsIGJlIGlnbm9yZWQgLSBmZWF0dXJlcyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgaW4gdGhlIG9yZGVyIHRoYXRcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkLiAgSWYgeW91IG5lZWQgYHpJbmRleGAgc3VwcG9ydCwgeW91IHNob3VsZCBiZSB1c2luZyBhblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn5WZWN0b3JMYXllcn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0ZlYXR1cmUgPSBmdW5jdGlvbiBkcmF3RmVhdHVyZSAoZmVhdHVyZSwgc3R5bGUpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gICAgaWYgKCFnZW9tZXRyeSB8fCAhaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIEdlb21ldHJ5Q29sbGVjdGlvbiB0byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZXMgYXBwcm9wcmlhdGUgZm9yIGVhY2ggZ2VvbWV0cnkgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSBnZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3R2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gZHJhd0dlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzJDEuZHJhd0dlb21ldHJ5KGdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9pbnQgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9Qb2ludHxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3UG9pbnQgPSBmdW5jdGlvbiBkcmF3UG9pbnQgKGdlb21ldHJ5KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIE11bHRpUG9pbnQgZ2VvbWV0cnkgIGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kXG4gICAqIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2ludHxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IE11bHRpUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNdWx0aVBvaW50ID0gZnVuY3Rpb24gZHJhd011bHRpUG9pbnQgKGdlb21ldHJ5KSB7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIExpbmVTdHJpbmcgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZ2VvbWV0cnkgTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuZHJhd0xpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TGluZVN0cmluZyAoZ2VvbWV0cnkpIHtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIGdlb21ldHJ5LmdldFN0cmlkZSgpLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0TWlkcG9pbnQgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnQoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRNaWRwb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZVxuICAgKiBhbmQgdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBNdWx0aUxpbmVTdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TXVsdGlMaW5lU3RyaW5nIChnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGdlb21ldHJ5RXh0ZW50ID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KCk7XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnlFeHRlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgdGhpcy5zZXRDb250ZXh0U3Ryb2tlU3RhdGVfKHRoaXMuc3Ryb2tlU3RhdGVfKTtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGVuZHMgPSBnZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMkMS5tb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgdmFyIGZsYXRNaWRwb2ludHMgPSBnZW9tZXRyeS5nZXRGbGF0TWlkcG9pbnRzKCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0TWlkcG9pbnRzLCAwLCBmbGF0TWlkcG9pbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBQb2x5Z29uIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vUG9seWdvbnxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IFBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24gKGdlb21ldHJ5KSB7XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXyB8fCB0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5kcmF3UmluZ3NfKGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIDAsIGdlb21ldHJ5LmdldEVuZHMoKSwgZ2VvbWV0cnkuZ2V0U3RyaWRlKCkpO1xuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0SW50ZXJpb3JQb2ludCA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50KCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0SW50ZXJpb3JQb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgTXVsdGlQb2x5Z29uIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kXG4gICAqIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufSBnZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIucHJvdG90eXBlLmRyYXdNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBkcmF3TXVsdGlQb2x5Z29uIChnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXyB8fCB0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGVuZHNzID0gZ2VvbWV0cnkuZ2V0RW5kc3MoKTtcbiAgICAgIHZhciBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBlbmRzID0gZW5kc3NbaV07XG4gICAgICAgIG9mZnNldCA9IHRoaXMkMS5kcmF3UmluZ3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHZhciBmbGF0SW50ZXJpb3JQb2ludHMgPSBnZW9tZXRyeS5nZXRGbGF0SW50ZXJpb3JQb2ludHMoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRJbnRlcmlvclBvaW50cywgMCwgZmxhdEludGVyaW9yUG9pbnRzLmxlbmd0aCwgMik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdGF0ZX0gZmlsbFN0YXRlIEZpbGwgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGV4dEZpbGxTdGF0ZV8gPSBmdW5jdGlvbiBzZXRDb250ZXh0RmlsbFN0YXRlXyAoZmlsbFN0YXRlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBjb250ZXh0RmlsbFN0YXRlID0gdGhpcy5jb250ZXh0RmlsbFN0YXRlXztcbiAgICBpZiAoIWNvbnRleHRGaWxsU3RhdGUpIHtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIHRoaXMuY29udGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgIGZpbGxTdHlsZTogZmlsbFN0YXRlLmZpbGxTdHlsZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRGaWxsU3RhdGUuZmlsbFN0eWxlICE9IGZpbGxTdGF0ZS5maWxsU3R5bGUpIHtcbiAgICAgICAgY29udGV4dEZpbGxTdGF0ZS5maWxsU3R5bGUgPSBjb250ZXh0LmZpbGxTdHlsZSA9IGZpbGxTdGF0ZS5maWxsU3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzflN0cm9rZVN0YXRlfSBzdHJva2VTdGF0ZSBTdHJva2Ugc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyA9IGZ1bmN0aW9uIHNldENvbnRleHRTdHJva2VTdGF0ZV8gKHN0cm9rZVN0YXRlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBjb250ZXh0U3Ryb2tlU3RhdGUgPSB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV87XG4gICAgaWYgKCFjb250ZXh0U3Ryb2tlU3RhdGUpIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IHN0cm9rZVN0YXRlLmxpbmVDYXA7XG4gICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0YXRlLmxpbmVKb2luO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VTdGF0ZS5saW5lV2lkdGg7XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICBsaW5lQ2FwOiBzdHJva2VTdGF0ZS5saW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3RhdGUubGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUpvaW46IHN0cm9rZVN0YXRlLmxpbmVKb2luLFxuICAgICAgICBsaW5lV2lkdGg6IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCxcbiAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVDYXAgIT0gc3Ryb2tlU3RhdGUubGluZUNhcCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZUNhcCA9IGNvbnRleHQubGluZUNhcCA9IHN0cm9rZVN0YXRlLmxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCkge1xuICAgICAgICBpZiAoIWVxdWFscyhjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2gsIHN0cm9rZVN0YXRlLmxpbmVEYXNoKSkge1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3RhdGUubGluZURhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgIT0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPSBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID1cbiAgICAgICAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubGluZUpvaW4gIT0gc3Ryb2tlU3RhdGUubGluZUpvaW4pIHtcbiAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVKb2luID0gY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0YXRlLmxpbmVKb2luO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggIT0gc3Ryb2tlU3RhdGUubGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCAhPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0KSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5taXRlckxpbWl0ID0gY29udGV4dC5taXRlckxpbWl0ID1cbiAgICAgICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlICE9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPVxuICAgICAgICAgICAgc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzflRleHRTdGF0ZX0gdGV4dFN0YXRlIFRleHQgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGV4dFRleHRTdGF0ZV8gPSBmdW5jdGlvbiBzZXRDb250ZXh0VGV4dFN0YXRlXyAodGV4dFN0YXRlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBjb250ZXh0VGV4dFN0YXRlID0gdGhpcy5jb250ZXh0VGV4dFN0YXRlXztcbiAgICB2YXIgdGV4dEFsaWduID0gdGV4dFN0YXRlLnRleHRBbGlnbiA/XG4gICAgICB0ZXh0U3RhdGUudGV4dEFsaWduIDogZGVmYXVsdFRleHRBbGlnbjtcbiAgICBpZiAoIWNvbnRleHRUZXh0U3RhdGUpIHtcbiAgICAgIGNvbnRleHQuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmU7XG4gICAgICB0aGlzLmNvbnRleHRUZXh0U3RhdGVfID0ge1xuICAgICAgICBmb250OiB0ZXh0U3RhdGUuZm9udCxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFN0YXRlLnRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUuZm9udCAhPSB0ZXh0U3RhdGUuZm9udCkge1xuICAgICAgICBjb250ZXh0VGV4dFN0YXRlLmZvbnQgPSBjb250ZXh0LmZvbnQgPSB0ZXh0U3RhdGUuZm9udDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRBbGlnbiAhPSB0ZXh0QWxpZ24pIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QWxpZ24gPSBjb250ZXh0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VGV4dFN0YXRlLnRleHRCYXNlbGluZSAhPSB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lID0gY29udGV4dC50ZXh0QmFzZWxpbmUgPVxuICAgICAgICAgICAgdGV4dFN0YXRlLnRleHRCYXNlbGluZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFRvIGNsZWFyXG4gICAqIGVpdGhlciBmaWxsIG9yIHN0cm9rZSBzdHlsZXMsIHBhc3MgbnVsbCBmb3IgdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvRmlsbH0gZmlsbFN0eWxlIEZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0cm9rZX0gc3Ryb2tlU3R5bGUgU3Ryb2tlIHN0eWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRGaWxsU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiBzZXRGaWxsU3Ryb2tlU3R5bGUgKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpIHtcbiAgICBpZiAoIWZpbGxTdHlsZSkge1xuICAgICAgdGhpcy5maWxsU3RhdGVfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICB0aGlzLmZpbGxTdGF0ZV8gPSB7XG4gICAgICAgIGZpbGxTdHlsZTogYXNDb2xvckxpa2UoZmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICAgIGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc3Ryb2tlU3R5bGUpIHtcbiAgICAgIHRoaXMuc3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgdmFyIHN0cm9rZVN0eWxlTGluZUNhcCA9IHN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVKb2luID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZVdpZHRoID0gc3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgbGluZUNhcDogc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUNhcCA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lRGFzaCA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVKb2luOiBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDogdGhpcy5waXhlbFJhdGlvXyAqIChzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlV2lkdGggOiBkZWZhdWx0TGluZVdpZHRoKSxcbiAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VTdHlsZTogYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSlcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltYWdlIHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0byByZW1vdmVcbiAgICogdGhlIGltYWdlIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9JbWFnZX0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBDYW52YXNJbW1lZGlhdGVSZW5kZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VTdHlsZSA9IGZ1bmN0aW9uIHNldEltYWdlU3R5bGUgKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoIWltYWdlU3R5bGUpIHtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGltYWdlQW5jaG9yID0gaW1hZ2VTdHlsZS5nZXRBbmNob3IoKTtcbiAgICAgIC8vIEZJWE1FIHBpeGVsIHJhdGlvXG4gICAgICB2YXIgaW1hZ2VJbWFnZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2UoMSk7XG4gICAgICB2YXIgaW1hZ2VPcmlnaW4gPSBpbWFnZVN0eWxlLmdldE9yaWdpbigpO1xuICAgICAgdmFyIGltYWdlU2l6ZSA9IGltYWdlU3R5bGUuZ2V0U2l6ZSgpO1xuICAgICAgdGhpcy5pbWFnZUFuY2hvclhfID0gaW1hZ2VBbmNob3JbMF07XG4gICAgICB0aGlzLmltYWdlQW5jaG9yWV8gPSBpbWFnZUFuY2hvclsxXTtcbiAgICAgIHRoaXMuaW1hZ2VIZWlnaHRfID0gaW1hZ2VTaXplWzFdO1xuICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZUltYWdlO1xuICAgICAgdGhpcy5pbWFnZU9wYWNpdHlfID0gaW1hZ2VTdHlsZS5nZXRPcGFjaXR5KCk7XG4gICAgICB0aGlzLmltYWdlT3JpZ2luWF8gPSBpbWFnZU9yaWdpblswXTtcbiAgICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyA9IGltYWdlT3JpZ2luWzFdO1xuICAgICAgdGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIHRoaXMuaW1hZ2VSb3RhdGlvbl8gPSBpbWFnZVN0eWxlLmdldFJvdGF0aW9uKCk7XG4gICAgICB0aGlzLmltYWdlU2NhbGVfID0gaW1hZ2VTdHlsZS5nZXRTY2FsZSgpICogdGhpcy5waXhlbFJhdGlvXztcbiAgICAgIHRoaXMuaW1hZ2VTbmFwVG9QaXhlbF8gPSBpbWFnZVN0eWxlLmdldFNuYXBUb1BpeGVsKCk7XG4gICAgICB0aGlzLmltYWdlV2lkdGhfID0gaW1hZ2VTaXplWzBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0b1xuICAgKiByZW1vdmUgdGhlIHRleHQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1RleHR9IHRleHRTdHlsZSBUZXh0IHN0eWxlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0U3R5bGUgPSBmdW5jdGlvbiBzZXRUZXh0U3R5bGUgKHRleHRTdHlsZSkge1xuICAgIGlmICghdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLnRleHRfID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0RmlsbFN0eWxlQ29sb3IgPSB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZSh0ZXh0RmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICAgICAgdGV4dEZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGUgPSB0ZXh0U3R5bGUuZ2V0U3Ryb2tlKCk7XG4gICAgICBpZiAoIXRleHRTdHJva2VTdHlsZSkge1xuICAgICAgICB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZUNvbG9yID0gdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZUxpbmVEYXNoID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVEYXNoKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICB2YXIgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgICAgdmFyIHRleHRTdHJva2VTdHlsZVdpZHRoID0gdGV4dFN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0ID0gdGV4dFN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICAgIGxpbmVDYXA6IHRleHRTdHJva2VTdHlsZUxpbmVDYXAgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXAsXG4gICAgICAgICAgbGluZURhc2g6IHRleHRTdHJva2VTdHlsZUxpbmVEYXNoID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUxpbmVEYXNoIDogZGVmYXVsdExpbmVEYXNoLFxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgICAgICAgICBsaW5lSm9pbjogdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lSm9pbiA6IGRlZmF1bHRMaW5lSm9pbixcbiAgICAgICAgICBsaW5lV2lkdGg6IHRleHRTdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlV2lkdGggOiBkZWZhdWx0TGluZVdpZHRoLFxuICAgICAgICAgIG1pdGVyTGltaXQ6IHRleHRTdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0IDogZGVmYXVsdE1pdGVyTGltaXQsXG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IGFzQ29sb3JMaWtlKHRleHRTdHJva2VTdHlsZUNvbG9yID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHRleHRGb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKTtcbiAgICAgIHZhciB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICB2YXIgdGV4dE9mZnNldFkgPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WSgpO1xuICAgICAgdmFyIHRleHRSb3RhdGVXaXRoVmlldyA9IHRleHRTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgdmFyIHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdmFyIHRleHRTY2FsZSA9IHRleHRTdHlsZS5nZXRTY2FsZSgpO1xuICAgICAgdmFyIHRleHRUZXh0ID0gdGV4dFN0eWxlLmdldFRleHQoKTtcbiAgICAgIHZhciB0ZXh0VGV4dEFsaWduID0gdGV4dFN0eWxlLmdldFRleHRBbGlnbigpO1xuICAgICAgdmFyIHRleHRUZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCk7XG4gICAgICB0aGlzLnRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRGb250ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRleHRGb250IDogZGVmYXVsdEZvbnQsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dFRleHRBbGlnbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0VGV4dEFsaWduIDogZGVmYXVsdFRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0VGV4dEJhc2VsaW5lICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHRleHRUZXh0QmFzZWxpbmUgOiBkZWZhdWx0VGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRUZXh0ICE9PSB1bmRlZmluZWQgPyB0ZXh0VGV4dCA6ICcnO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8gPVxuICAgICAgICAgIHRleHRPZmZzZXRYICE9PSB1bmRlZmluZWQgPyAodGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRYKSA6IDA7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9XG4gICAgICAgICAgdGV4dE9mZnNldFkgIT09IHVuZGVmaW5lZCA/ICh0aGlzLnBpeGVsUmF0aW9fICogdGV4dE9mZnNldFkpIDogMDtcbiAgICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHRleHRSb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID8gdGV4dFJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG4gICAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSB0ZXh0Um90YXRpb24gIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGlvbiA6IDA7XG4gICAgICB0aGlzLnRleHRTY2FsZV8gPSB0aGlzLnBpeGVsUmF0aW9fICogKHRleHRTY2FsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgdGV4dFNjYWxlIDogMSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNJbW1lZGlhdGVSZW5kZXJlcjtcbn0oVmVjdG9yQ29udGV4dCkpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW1lZGlhdGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbnZhciBJbnN0cnVjdGlvbiA9IHtcbiAgQkVHSU5fR0VPTUVUUlk6IDAsXG4gIEJFR0lOX1BBVEg6IDEsXG4gIENJUkNMRTogMixcbiAgQ0xPU0VfUEFUSDogMyxcbiAgQ1VTVE9NOiA0LFxuICBEUkFXX0NIQVJTOiA1LFxuICBEUkFXX0lNQUdFOiA2LFxuICBFTkRfR0VPTUVUUlk6IDcsXG4gIEZJTEw6IDgsXG4gIE1PVkVfVE9fTElORV9UTzogOSxcbiAgU0VUX0ZJTExfU1RZTEU6IDEwLFxuICBTRVRfU1RST0tFX1NUWUxFOiAxMSxcbiAgU1RST0tFOiAxMlxufTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgdmFyIGZpbGxJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5GSUxMXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgdmFyIHN0cm9rZUluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLlNUUk9LRV07XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXkuPEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IHZhciBiZWdpblBhdGhJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5CRUdJTl9QQVRIXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48SW5zdHJ1Y3Rpb24+fVxuICovXG5leHBvcnQgdmFyIGNsb3NlUGF0aEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkNMT1NFX1BBVEhdO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEluc3RydWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnN0cnVjdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nUmVwbGF5XG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiwge3N0cm9rZUluc3RydWN0aW9uLCBiZWdpblBhdGhJbnN0cnVjdGlvbn0gZnJvbSAnLi4vY2FudmFzL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi4vY2FudmFzL1JlcGxheS5qcyc7XG5cbnZhciBDYW52YXNMaW5lU3RyaW5nUmVwbGF5ID0gKGZ1bmN0aW9uIChDYW52YXNSZXBsYXkpIHtcbiAgZnVuY3Rpb24gQ2FudmFzTGluZVN0cmluZ1JlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBDYW52YXNSZXBsYXkuY2FsbCh0aGlzLCB0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpO1xuICB9XG5cbiAgaWYgKCBDYW52YXNSZXBsYXkgKSBDYW52YXNMaW5lU3RyaW5nUmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzTGluZVN0cmluZ1JlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc0xpbmVTdHJpbmdSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGVuZC5cbiAgICovXG4gIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkucHJvdG90eXBlLmRyYXdGbGF0Q29vcmRpbmF0ZXNfID0gZnVuY3Rpb24gZHJhd0ZsYXRDb29yZGluYXRlc18gKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIHZhciBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIG15RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIG1vdmVUb0xpbmVUb0luc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTywgbXlCZWdpbiwgbXlFbmRdO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgIHJldHVybiBlbmQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5kcmF3TGluZVN0cmluZyA9IGZ1bmN0aW9uIGRyYXdMaW5lU3RyaW5nIChsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIHZhciBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgaWYgKHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQgfHwgbGluZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICBdLCBiZWdpblBhdGhJbnN0cnVjdGlvbik7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGxpbmVTdHJpbmdHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gbGluZVN0cmluZ0dlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0xpbmVTdHJpbmdSZXBsYXkucHJvdG90eXBlLmRyYXdNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBkcmF3TXVsdGlMaW5lU3RyaW5nIChtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICBdLCBiZWdpblBhdGhJbnN0cnVjdGlvbik7XG4gICAgdmFyIGVuZHMgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMkMS5kcmF3RmxhdENvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1tpXSwgc3RyaWRlKTtcbiAgICB9XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmxhc3RTdHJva2UgIT0gdW5kZWZpbmVkICYmIHN0YXRlLmxhc3RTdHJva2UgIT0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICB0aGlzLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMoKTtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2MuXG4gICAqL1xuICBDYW52YXNMaW5lU3RyaW5nUmVwbGF5LnByb3RvdHlwZS5hcHBseVN0cm9rZSA9IGZ1bmN0aW9uIGFwcGx5U3Ryb2tlIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUubGFzdFN0cm9rZSA9IDA7XG4gICAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcbn0oQ2FudmFzUmVwbGF5KSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGluZVN0cmluZ1JlcGxheS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9Qb2x5Z29uUmVwbGF5XG4gKi9cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uLy4uL2NvbG9yLmpzJztcbmltcG9ydCB7c25hcH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzJztcbmltcG9ydCB7ZGVmYXVsdEZpbGxTdHlsZX0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiwge1xuICBmaWxsSW5zdHJ1Y3Rpb24sIHN0cm9rZUluc3RydWN0aW9uLCBiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2xvc2VQYXRoSW5zdHJ1Y3Rpb25cbn0gZnJvbSAnLi4vY2FudmFzL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi4vY2FudmFzL1JlcGxheS5qcyc7XG5cblxudmFyIENhbnZhc1BvbHlnb25SZXBsYXkgPSAoZnVuY3Rpb24gKENhbnZhc1JlcGxheSkge1xuICBmdW5jdGlvbiBDYW52YXNQb2x5Z29uUmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG4gIH1cblxuICBpZiAoIENhbnZhc1JlcGxheSApIENhbnZhc1BvbHlnb25SZXBsYXkuX19wcm90b19fID0gQ2FudmFzUmVwbGF5O1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhbnZhc1JlcGxheSAmJiBDYW52YXNSZXBsYXkucHJvdG90eXBlICk7XG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUG9seWdvblJlcGxheTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBlbmRzIEVuZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmRyYXdGbGF0Q29vcmRpbmF0ZXNzXyA9IGZ1bmN0aW9uIGRyYXdGbGF0Q29vcmRpbmF0ZXNzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbCA9IHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBzdHJva2UgPSBzdGF0ZS5zdHJva2VTdHlsZSAhPSB1bmRlZmluZWQ7XG4gICAgdmFyIG51bUVuZHMgPSBlbmRzLmxlbmd0aDtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVuZHM7ICsraSkge1xuICAgICAgdmFyIGVuZCA9IGVuZHNbaV07XG4gICAgICB2YXIgbXlCZWdpbiA9IHRoaXMkMS5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB2YXIgbXlFbmQgPSB0aGlzJDEuYXBwZW5kRmxhdENvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdHJ1ZSwgIXN0cm9rZSk7XG4gICAgICB2YXIgbW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uTU9WRV9UT19MSU5FX1RPLCBteUJlZ2luLCBteUVuZF07XG4gICAgICB0aGlzJDEuaW5zdHJ1Y3Rpb25zLnB1c2gobW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcyQxLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBvbmx5IGNhbGwgY2xvc2VQYXRoKCkgd2hlbiB3ZSBoYXZlIGEgc3Ryb2tlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHJpbmcgaXMgY2xvc2VkIGFscmVhZHkgKHNlZSBhcHBlbmRGbGF0Q29vcmRpbmF0ZXMgYWJvdmUpLlxuICAgICAgICB0aGlzJDEuaW5zdHJ1Y3Rpb25zLnB1c2goY2xvc2VQYXRoSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB0aGlzJDEuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goY2xvc2VQYXRoSW5zdHJ1Y3Rpb24pO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoZmlsbCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzUG9seWdvblJlcGxheS5wcm90b3R5cGUuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uIGRyYXdDaXJjbGUgKGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIHZhciBzdHJva2VTdHlsZSA9IHN0YXRlLnN0cm9rZVN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlc18oY2lyY2xlR2VvbWV0cnkpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IGNpcmNsZUdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIHZhciBzdHJpZGUgPSBjaXJjbGVHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICB2YXIgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgdmFyIGNpcmNsZUluc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLkNJUkNMRSwgbXlCZWdpbl07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChiZWdpblBhdGhJbnN0cnVjdGlvbiwgY2lyY2xlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sIGNpcmNsZUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICB0aGlzLmVuZEdlb21ldHJ5KGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24gZHJhd1BvbHlnb24gKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKHBvbHlnb25HZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgICBdKTtcbiAgICB9XG4gICAgdmFyIGVuZHMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0RW5kcygpO1xuICAgIHZhciBmbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgc3RyaWRlID0gcG9seWdvbkdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgMCwgZW5kcywgc3RyaWRlKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNQb2x5Z29uUmVwbGF5LnByb3RvdHlwZS5kcmF3TXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gZHJhd011bHRpUG9seWdvbiAobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKG11bHRpUG9seWdvbkdlb21ldHJ5KTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnkobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIGlmIChzdGF0ZS5maWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFLFxuICAgICAgICBhc1N0cmluZyhkZWZhdWx0RmlsbFN0eWxlKVxuICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICAgIHN0YXRlLm1pdGVyTGltaXQsIHN0YXRlLmxpbmVEYXNoLCBzdGF0ZS5saW5lRGFzaE9mZnNldFxuICAgICAgXSk7XG4gICAgfVxuICAgIHZhciBlbmRzcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHN0cmlkZSA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMkMS5kcmF3RmxhdENvb3JkaW5hdGVzc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzW2ldLCBzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmVuZEdlb21ldHJ5KG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCAoKSB7XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgLy8gV2Ugd2FudCB0byBwcmVzZXJ2ZSB0b3BvbG9neSB3aGVuIGRyYXdpbmcgcG9seWdvbnMuICBQb2x5Z29ucyBhcmVcbiAgICAvLyBzaW1wbGlmaWVkIHVzaW5nIHF1YW50aXphdGlvbiBhbmQgcG9pbnQgZWxpbWluYXRpb24uIEhvd2V2ZXIsIHdlIG1pZ2h0XG4gICAgLy8gaGF2ZSByZWNlaXZlZCBhIG1peCBvZiBxdWFudGl6ZWQgYW5kIG5vbi1xdWFudGl6ZWQgZ2VvbWV0cmllcywgc28gZW5zdXJlXG4gICAgLy8gdGhhdCBhbGwgYXJlIHF1YW50aXplZCBieSBxdWFudGl6aW5nIGFsbCBjb29yZGluYXRlcyBpbiB0aGUgYmF0Y2guXG4gICAgdmFyIHRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlO1xuICAgIGlmICh0b2xlcmFuY2UgIT09IDApIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzW2ldID0gc25hcChjb29yZGluYXRlc1tpXSwgdG9sZXJhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICovXG4gIENhbnZhc1BvbHlnb25SZXBsYXkucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZXNfID0gZnVuY3Rpb24gc2V0RmlsbFN0cm9rZVN0eWxlc18gKGdlb21ldHJ5KSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGlmIChmaWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVGaWxsU3R5bGUoc3RhdGUsIHRoaXMuY3JlYXRlRmlsbCwgZ2VvbWV0cnkpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVTdHJva2VTdHlsZShzdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNQb2x5Z29uUmVwbGF5O1xufShDYW52YXNSZXBsYXkpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNQb2x5Z29uUmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2x5Z29uUmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1JlcGxheVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7ZXF1YWxzLCByZXZlcnNlU3ViQXJyYXl9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2J1ZmZlciwgY2xvbmUsIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAsIGNyZWF0ZUVtcHR5LCBjcmVhdGVPclVwZGF0ZSxcbiAgY3JlYXRlT3JVcGRhdGVFbXB0eSwgZXh0ZW5kLCBleHRlbmRDb29yZGluYXRlLCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFJlbGF0aW9uc2hpcCBmcm9tICcuLi8uLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXMsIGluZmxhdGVDb29yZGluYXRlc0FycmF5LCBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2xpbmVTdHJpbmdMZW5ndGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9sZW5ndGguanMnO1xuaW1wb3J0IHtkcmF3VGV4dE9uUGF0aH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RleHRwYXRoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IFZlY3RvckNvbnRleHQgZnJvbSAnLi4vVmVjdG9yQ29udGV4dC5qcyc7XG5pbXBvcnQge2RyYXdJbWFnZSwgcmVzZXRUcmFuc2Zvcm0sIGRlZmF1bHRQYWRkaW5nLCBkZWZhdWx0RmlsbFN0eWxlLCBkZWZhdWx0U3Ryb2tlU3R5bGUsXG4gIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZUNhcH0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuLi9jYW52YXMvSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IHtURVhUX0FMSUdOfSBmcm9tICcuLi9yZXBsYXkuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSxcbiAgc2V0RnJvbUFycmF5IGFzIHRyYW5zZm9ybVNldEZyb21BcnJheVxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICovXG52YXIgdG1wRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuXG4vKipcbiAqIEB0eXBlIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gKi9cbnZhciB0bXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuXG52YXIgQ2FudmFzUmVwbGF5ID0gKGZ1bmN0aW9uIChWZWN0b3JDb250ZXh0KSB7XG4gIGZ1bmN0aW9uIENhbnZhc1JlcGxheSh0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBWZWN0b3JDb250ZXh0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWUgPSBkZWNsdXR0ZXJUcmVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2UgPSB0b2xlcmFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50ID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHMgPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsaWduRmlsbF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48Kj59XG4gICAgICovXG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48Kj59XG4gICAgICovXG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5LjwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxudW1iZXIsbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXxBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT58QXJyYXkuPEFycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPj4+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZUNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5LjwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35GaWxsU3Ryb2tlU3RhdGV9ICovICh7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gMDtcblxuICB9XG5cbiAgaWYgKCBWZWN0b3JDb250ZXh0ICkgQ2FudmFzUmVwbGF5Ll9fcHJvdG9fXyA9IFZlY3RvckNvbnRleHQ7XG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBWZWN0b3JDb250ZXh0ICYmIFZlY3RvckNvbnRleHQucHJvdG90eXBlICk7XG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gcDEgMXN0IHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBwMiAybmQgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHAzIDNyZCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gcDQgNHRoIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gc3Ryb2tlSW5zdHJ1Y3Rpb24gU3Ryb2tlIGluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXlUZXh0QmFja2dyb3VuZF8gPSBmdW5jdGlvbiByZXBsYXlUZXh0QmFja2dyb3VuZF8gKGNvbnRleHQsIHAxLCBwMiwgcDMsIHA0LCBmaWxsSW5zdHJ1Y3Rpb24sIHN0cm9rZUluc3RydWN0aW9uKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUby5hcHBseShjb250ZXh0LCBwMSk7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDIpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHAzKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwNCk7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDEpO1xuICAgIGlmIChmaWxsSW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuYWxpZ25GaWxsXyA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGZpbGxJbnN0cnVjdGlvblsyXSk7XG4gICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0U3Ryb2tlU3R5bGVfKGNvbnRleHQsIC8qKiBAdHlwZSB7QXJyYXkuPCo+fSAqLyAoc3Ryb2tlSW5zdHJ1Y3Rpb24pKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3JYIEFuY2hvciBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yWSBBbmNob3IgWS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35EZWNsdXR0ZXJHcm91cH0gZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyIGdyb3VwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgT3BhY2l0eS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblggT3JpZ2luIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHRvIHBpeGVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGguXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gc3Ryb2tlSW5zdHJ1Y3Rpb24gU3Ryb2tlIGluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXlJbWFnZV8gPSBmdW5jdGlvbiByZXBsYXlJbWFnZV8gKFxuICAgIGNvbnRleHQsXG4gICAgeCxcbiAgICB5LFxuICAgIGltYWdlLFxuICAgIGFuY2hvclgsXG4gICAgYW5jaG9yWSxcbiAgICBkZWNsdXR0ZXJHcm91cCxcbiAgICBoZWlnaHQsXG4gICAgb3BhY2l0eSxcbiAgICBvcmlnaW5YLFxuICAgIG9yaWdpblksXG4gICAgcm90YXRpb24sXG4gICAgc2NhbGUsXG4gICAgc25hcFRvUGl4ZWwsXG4gICAgd2lkdGgsXG4gICAgcGFkZGluZyxcbiAgICBmaWxsSW5zdHJ1Y3Rpb24sXG4gICAgc3Ryb2tlSW5zdHJ1Y3Rpb25cbiAgKSB7XG4gICAgdmFyIGZpbGxTdHJva2UgPSBmaWxsSW5zdHJ1Y3Rpb24gfHwgc3Ryb2tlSW5zdHJ1Y3Rpb247XG4gICAgYW5jaG9yWCAqPSBzY2FsZTtcbiAgICBhbmNob3JZICo9IHNjYWxlO1xuICAgIHggLT0gYW5jaG9yWDtcbiAgICB5IC09IGFuY2hvclk7XG5cbiAgICB2YXIgdyA9ICh3aWR0aCArIG9yaWdpblggPiBpbWFnZS53aWR0aCkgPyBpbWFnZS53aWR0aCAtIG9yaWdpblggOiB3aWR0aDtcbiAgICB2YXIgaCA9IChoZWlnaHQgKyBvcmlnaW5ZID4gaW1hZ2UuaGVpZ2h0KSA/IGltYWdlLmhlaWdodCAtIG9yaWdpblkgOiBoZWlnaHQ7XG4gICAgdmFyIGJveFcgPSBwYWRkaW5nWzNdICsgdyAqIHNjYWxlICsgcGFkZGluZ1sxXTtcbiAgICB2YXIgYm94SCA9IHBhZGRpbmdbMF0gKyBoICogc2NhbGUgKyBwYWRkaW5nWzJdO1xuICAgIHZhciBib3hYID0geCAtIHBhZGRpbmdbM107XG4gICAgdmFyIGJveFkgPSB5IC0gcGFkZGluZ1swXTtcblxuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gKi9cbiAgICB2YXIgcDE7XG4gICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSAqL1xuICAgIHZhciBwMjtcbiAgICAvKiogQHR5cGUge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9ICovXG4gICAgdmFyIHAzO1xuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gKi9cbiAgICB2YXIgcDQ7XG4gICAgaWYgKGZpbGxTdHJva2UgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgIHAxID0gW2JveFgsIGJveFldO1xuICAgICAgcDIgPSBbYm94WCArIGJveFcsIGJveFldO1xuICAgICAgcDMgPSBbYm94WCArIGJveFcsIGJveFkgKyBib3hIXTtcbiAgICAgIHA0ID0gW2JveFgsIGJveFkgKyBib3hIXTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gbnVsbDtcbiAgICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICAgIHZhciBjZW50ZXJYID0geCArIGFuY2hvclg7XG4gICAgICB2YXIgY2VudGVyWSA9IHkgKyBhbmNob3JZO1xuICAgICAgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIGNlbnRlclgsIGNlbnRlclksIDEsIDEsIHJvdGF0aW9uLCAtY2VudGVyWCwgLWNlbnRlclkpO1xuXG4gICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KHRtcEV4dGVudCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwMSkpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZSh0bXBFeHRlbnQsIGFwcGx5VHJhbnNmb3JtKHRtcFRyYW5zZm9ybSwgcDIpKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUodG1wRXh0ZW50LCBhcHBseVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIHAzKSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwNCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVPclVwZGF0ZShib3hYLCBib3hZLCBib3hYICsgYm94VywgYm94WSArIGJveEgsIHRtcEV4dGVudCk7XG4gICAgfVxuICAgIHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICB2YXIgc3Ryb2tlUGFkZGluZyA9IHN0cm9rZUluc3RydWN0aW9uID8gKHN0cm9rZUluc3RydWN0aW9uWzJdICogc2NhbGUgLyAyKSA6IDA7XG4gICAgdmFyIGludGVyc2VjdHMgPVxuICAgICAgICB0bXBFeHRlbnRbMF0gLSBzdHJva2VQYWRkaW5nIDw9IGNhbnZhcy53aWR0aCAmJiB0bXBFeHRlbnRbMl0gKyBzdHJva2VQYWRkaW5nID49IDAgJiZcbiAgICAgICAgdG1wRXh0ZW50WzFdIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMuaGVpZ2h0ICYmIHRtcEV4dGVudFszXSArIHN0cm9rZVBhZGRpbmcgPj0gMDtcblxuICAgIGlmIChzbmFwVG9QaXhlbCkge1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjbHV0dGVyR3JvdXApIHtcbiAgICAgIGlmICghaW50ZXJzZWN0cyAmJiBkZWNsdXR0ZXJHcm91cFs0XSA9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkZWNsdXR0ZXJHcm91cCwgdG1wRXh0ZW50KTtcbiAgICAgIHZhciBkZWNsdXR0ZXJBcmdzID0gaW50ZXJzZWN0cyA/XG4gICAgICAgIFtjb250ZXh0LCB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uc2xpY2UoMCkgOiBudWxsLCBvcGFjaXR5LCBpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgc2NhbGVdIDpcbiAgICAgICAgbnVsbDtcbiAgICAgIGlmIChkZWNsdXR0ZXJBcmdzICYmIGZpbGxTdHJva2UpIHtcbiAgICAgICAgZGVjbHV0dGVyQXJncy5wdXNoKGZpbGxJbnN0cnVjdGlvbiwgc3Ryb2tlSW5zdHJ1Y3Rpb24sIHAxLCBwMiwgcDMsIHA0KTtcbiAgICAgIH1cbiAgICAgIGRlY2x1dHRlckdyb3VwLnB1c2goZGVjbHV0dGVyQXJncyk7XG4gICAgfSBlbHNlIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZSkge1xuICAgICAgICB0aGlzLnJlcGxheVRleHRCYWNrZ3JvdW5kXyhjb250ZXh0LCBwMSwgcDIsIHAzLCBwNCxcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5LjwqPn0gKi8gKGZpbGxJbnN0cnVjdGlvbiksXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheS48Kj59ICovIChzdHJva2VJbnN0cnVjdGlvbikpO1xuICAgICAgfVxuICAgICAgZHJhd0ltYWdlKGNvbnRleHQsIHRyYW5zZm9ybSwgb3BhY2l0eSwgaW1hZ2UsIG9yaWdpblgsIG9yaWdpblksIHcsIGgsIHgsIHksIHNjYWxlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZGFzaEFycmF5IERhc2ggYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBEYXNoIGFycmF5IHdpdGggcGl4ZWwgcmF0aW8gYXBwbGllZFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5hcHBseVBpeGVsUmF0aW8gPSBmdW5jdGlvbiBhcHBseVBpeGVsUmF0aW8gKGRhc2hBcnJheSkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHJldHVybiBwaXhlbFJhdGlvID09IDEgPyBkYXNoQXJyYXkgOiBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uKGRhc2gpIHtcbiAgICAgIHJldHVybiBkYXNoICogcGl4ZWxSYXRpbztcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VkIExhc3QgaW5wdXQgY29vcmRpbmF0ZSBlcXVhbHMgZmlyc3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcEZpcnN0IFNraXAgZmlyc3QgY29vcmRpbmF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZC5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuYXBwZW5kRmxhdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gYXBwZW5kRmxhdENvb3JkaW5hdGVzIChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNsb3NlZCwgc2tpcEZpcnN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIHZhciBteUVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHZhciBleHRlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkTWF4RXh0ZW50KCk7XG4gICAgaWYgKHNraXBGaXJzdCkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICB9XG4gICAgdmFyIGxhc3RDb29yZCA9IFtmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdXTtcbiAgICB2YXIgbmV4dENvb3JkID0gW05hTiwgTmFOXTtcbiAgICB2YXIgc2tpcHBlZCA9IHRydWU7XG5cbiAgICB2YXIgaSwgbGFzdFJlbCwgbmV4dFJlbDtcbiAgICBmb3IgKGkgPSBvZmZzZXQgKyBzdHJpZGU7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBuZXh0Q29vcmRbMF0gPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICBuZXh0Q29vcmRbMV0gPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgbmV4dFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBuZXh0Q29vcmQpO1xuICAgICAgaWYgKG5leHRSZWwgIT09IGxhc3RSZWwpIHtcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICB0aGlzJDEuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0Q29vcmRbMF07XG4gICAgICAgICAgdGhpcyQxLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMkMS5jb29yZGluYXRlc1tteUVuZCsrXSA9IG5leHRDb29yZFswXTtcbiAgICAgICAgdGhpcyQxLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzFdO1xuICAgICAgICBza2lwcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG5leHRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcpIHtcbiAgICAgICAgdGhpcyQxLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzBdO1xuICAgICAgICB0aGlzJDEuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMV07XG4gICAgICAgIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdENvb3JkWzBdID0gbmV4dENvb3JkWzBdO1xuICAgICAgbGFzdENvb3JkWzFdID0gbmV4dENvb3JkWzFdO1xuICAgICAgbGFzdFJlbCA9IG5leHRSZWw7XG4gICAgfVxuXG4gICAgLy8gTGFzdCBjb29yZGluYXRlIGVxdWFscyBmaXJzdCBvciBvbmx5IG9uZSBwb2ludCB0byBhcHBlbmQ6XG4gICAgaWYgKChjbG9zZWQgJiYgc2tpcHBlZCkgfHwgaSA9PT0gb2Zmc2V0ICsgc3RyaWRlKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzBdO1xuICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RDb29yZFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG15RW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJlcGxheUVuZHMgUmVwbGF5IGVuZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0LlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfID0gZnVuY3Rpb24gZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyAoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgcmVwbGF5RW5kcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgZW5kID0gZW5kc1tpXTtcbiAgICAgIHZhciByZXBsYXlFbmQgPSB0aGlzJDEuYXBwZW5kRmxhdENvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJlcGxheUVuZHMucHVzaChyZXBsYXlFbmQpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvYy5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuZHJhd0N1c3RvbSA9IGZ1bmN0aW9uIGRyYXdDdXN0b20gKGdlb21ldHJ5LCBmZWF0dXJlLCByZW5kZXJlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICB2YXIgc3RyaWRlID0gZ2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdmFyIHJlcGxheUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdmFyIGZsYXRDb29yZGluYXRlcywgcmVwbGF5RW5kLCByZXBsYXlFbmRzLCByZXBsYXlFbmRzcztcbiAgICB2YXIgb2Zmc2V0O1xuICAgIGlmICh0eXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufSAqLyAoZ2VvbWV0cnkpO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHJlcGxheUVuZHNzID0gW107XG4gICAgICB2YXIgZW5kc3MgPSBnZW9tZXRyeS5nZXRFbmRzcygpO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIG15RW5kcyA9IFtdO1xuICAgICAgICBvZmZzZXQgPSB0aGlzJDEuZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSwgbXlFbmRzKTtcbiAgICAgICAgcmVwbGF5RW5kc3MucHVzaChteUVuZHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICByZXBsYXlCZWdpbiwgcmVwbGF5RW5kc3MsIGdlb21ldHJ5LCByZW5kZXJlciwgaW5mbGF0ZU11bHRpQ29vcmRpbmF0ZXNBcnJheV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBHZW9tZXRyeVR5cGUuUE9MWUdPTiB8fCB0eXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgcmVwbGF5RW5kcyA9IFtdO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gKHR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04pID9cbiAgICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9Qb2x5Z29ufSAqLyAoZ2VvbWV0cnkpLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkgOlxuICAgICAgICBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsXG4gICAgICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vUG9seWdvbnxtb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd9ICovIChnZW9tZXRyeSkuZ2V0RW5kcygpLFxuICAgICAgICBzdHJpZGUsIHJlcGxheUVuZHMpO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICByZXBsYXlCZWdpbiwgcmVwbGF5RW5kcywgZ2VvbWV0cnksIHJlbmRlcmVyLCBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheV0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkcgfHwgdHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgcmVwbGF5RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICByZXBsYXlCZWdpbiwgcmVwbGF5RW5kLCBnZW9tZXRyeSwgcmVuZGVyZXIsIGluZmxhdGVDb29yZGluYXRlc10pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBHZW9tZXRyeVR5cGUuUE9JTlQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgdGhpcy5jb29yZGluYXRlcy5wdXNoKGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgICAgIHJlcGxheUVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NLFxuICAgICAgICByZXBsYXlCZWdpbiwgcmVwbGF5RW5kLCBnZW9tZXRyeSwgcmVuZGVyZXJdKTtcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5iZWdpbkdlb21ldHJ5ID0gZnVuY3Rpb24gYmVnaW5HZW9tZXRyeSAoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gW0NhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZLCBmZWF0dXJlLCAwXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8pO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlksIGZlYXR1cmUsIDBdO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmZpbGxfID0gZnVuY3Rpb24gZmlsbF8gKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5hbGlnbkZpbGxfKSB7XG4gICAgICB2YXIgb3JpZ2luID0gYXBwbHlUcmFuc2Zvcm0odGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8sIFswLCAwXSk7XG4gICAgICB2YXIgcmVwZWF0U2l6ZSA9IDUxMiAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKG9yaWdpblswXSAlIHJlcGVhdFNpemUsIG9yaWdpblsxXSAlIHJlcGVhdFNpemUpO1xuICAgICAgY29udGV4dC5yb3RhdGUodGhpcy52aWV3Um90YXRpb25fKTtcbiAgICB9XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuYWxpZ25GaWxsXykge1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgcmVzZXRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IGluc3RydWN0aW9uIEluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5zZXRTdHJva2VTdHlsZV8gPSBmdW5jdGlvbiBzZXRTdHJva2VTdHlsZV8gKGNvbnRleHQsIGluc3RydWN0aW9uKSB7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvbls0XSk7XG4gICAgY29udGV4dC5taXRlckxpbWl0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgaWYgKENBTlZBU19MSU5FX0RBU0gpIHtcbiAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzddKTtcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzZdKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwfSBkZWNsdXR0ZXJHcm91cCBEZWNsdXR0ZXIgZ3JvdXAuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnJlbmRlckRlY2x1dHRlcl8gPSBmdW5jdGlvbiByZW5kZXJEZWNsdXR0ZXJfIChkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGRlY2x1dHRlckdyb3VwICYmIGRlY2x1dHRlckdyb3VwLmxlbmd0aCA+IDUpIHtcbiAgICAgIHZhciBncm91cENvdW50ID0gZGVjbHV0dGVyR3JvdXBbNF07XG4gICAgICBpZiAoZ3JvdXBDb3VudCA9PSAxIHx8IGdyb3VwQ291bnQgPT0gZGVjbHV0dGVyR3JvdXAubGVuZ3RoIC0gNSkge1xuICAgICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL1JCdXNofkVudHJ5fSAqL1xuICAgICAgICB2YXIgYm94ID0ge1xuICAgICAgICAgIG1pblg6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMF0pLFxuICAgICAgICAgIG1pblk6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMV0pLFxuICAgICAgICAgIG1heFg6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbMl0pLFxuICAgICAgICAgIG1heFk6IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZGVjbHV0dGVyR3JvdXBbM10pLFxuICAgICAgICAgIHZhbHVlOiBmZWF0dXJlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5kZWNsdXR0ZXJUcmVlLmNvbGxpZGVzKGJveCkpIHtcbiAgICAgICAgICB0aGlzLmRlY2x1dHRlclRyZWUuaW5zZXJ0KGJveCk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDUsIGpqID0gZGVjbHV0dGVyR3JvdXAubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgICAgdmFyIGRlY2x1dHRlckRhdGEgPSAvKiogQHR5cGUge0FycmF5fSAqLyAoZGVjbHV0dGVyR3JvdXBbal0pO1xuICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEubGVuZ3RoID4gMTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEucmVwbGF5VGV4dEJhY2tncm91bmRfKGRlY2x1dHRlckRhdGFbMF0sXG4gICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJEYXRhWzEzXSwgZGVjbHV0dGVyRGF0YVsxNF0sIGRlY2x1dHRlckRhdGFbMTVdLCBkZWNsdXR0ZXJEYXRhWzE2XSxcbiAgICAgICAgICAgICAgICAgIGRlY2x1dHRlckRhdGFbMTFdLCBkZWNsdXR0ZXJEYXRhWzEyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZHJhd0ltYWdlLmFwcGx5KHVuZGVmaW5lZCwgZGVjbHV0dGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlY2x1dHRlckdyb3VwLmxlbmd0aCA9IDU7XG4gICAgICAgIGNyZWF0ZU9yVXBkYXRlRW1wdHkoZGVjbHV0dGVyR3JvdXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzXG4gICAqICAgICB0byBza2lwLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gaW5zdHJ1Y3Rpb25zIEluc3RydWN0aW9ucyBhcnJheS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSk6IFR8dW5kZWZpbmVkfVxuICAgKiAgICAgZmVhdHVyZUNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfaGl0RXh0ZW50IE9ubHkgY2hlY2sgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdGhpc1xuICAgKiAgICAgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXlfID0gZnVuY3Rpb24gcmVwbGF5XyAoXG4gICAgY29udGV4dCxcbiAgICB0cmFuc2Zvcm0sXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBpbnN0cnVjdGlvbnMsXG4gICAgZmVhdHVyZUNhbGxiYWNrLFxuICAgIG9wdF9oaXRFeHRlbnRcbiAgKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciBwaXhlbENvb3JkaW5hdGVzO1xuICAgIGlmICh0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfICYmIGVxdWFscyh0cmFuc2Zvcm0sIHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fKSkge1xuICAgICAgcGl4ZWxDb29yZGluYXRlcyA9IHRoaXMucGl4ZWxDb29yZGluYXRlc187XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5waXhlbENvb3JkaW5hdGVzXykge1xuICAgICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gW107XG4gICAgICB9XG4gICAgICBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMsIDAsIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoLCAyLFxuICAgICAgICB0cmFuc2Zvcm0sIHRoaXMucGl4ZWxDb29yZGluYXRlc18pO1xuICAgICAgdHJhbnNmb3JtU2V0RnJvbUFycmF5KHRoaXMucmVuZGVyZWRUcmFuc2Zvcm1fLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgICB2YXIgc2tpcEZlYXR1cmVzID0gIWlzRW1wdHkoc2tpcHBlZEZlYXR1cmVzSGFzaCk7XG4gICAgdmFyIGkgPSAwOyAvLyBpbnN0cnVjdGlvbiBpbmRleFxuICAgIHZhciBpaSA9IGluc3RydWN0aW9ucy5sZW5ndGg7IC8vIGVuZCBvZiBpbnN0cnVjdGlvbnNcbiAgICB2YXIgZCA9IDA7IC8vIGRhdGEgaW5kZXhcbiAgICB2YXIgZGQ7IC8vIGVuZCBvZiBwZXItaW5zdHJ1Y3Rpb24gZGF0YVxuICAgIHZhciBhbmNob3JYLCBhbmNob3JZLCBwcmV2WCwgcHJldlksIHJvdW5kWCwgcm91bmRZLCBkZWNsdXR0ZXJHcm91cCwgaW1hZ2U7XG4gICAgdmFyIHBlbmRpbmdGaWxsID0gMDtcbiAgICB2YXIgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgdmFyIGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIHZhciBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIHZhciBjb29yZGluYXRlQ2FjaGUgPSB0aGlzLmNvb3JkaW5hdGVDYWNoZV87XG4gICAgdmFyIHZpZXdSb3RhdGlvbiA9IHRoaXMudmlld1JvdGF0aW9uXztcblxuICAgIHZhciBzdGF0ZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlcn5TdGF0ZX0gKi8gKHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICByZXNvbHV0aW9uOiB0aGlzLnJlc29sdXRpb24sXG4gICAgICByb3RhdGlvbjogdmlld1JvdGF0aW9uXG4gICAgfSk7XG5cbiAgICAvLyBXaGVuIHRoZSBiYXRjaCBzaXplIGdldHMgdG9vIGJpZywgcGVyZm9ybWFuY2UgZGVjcmVhc2VzLiAyMDAgaXMgYSBnb29kXG4gICAgLy8gYmFsYW5jZSBiZXR3ZWVuIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBmaWxsL3N0cm9rZSBpbnN0cnVjdGlvbnMuXG4gICAgdmFyIGJhdGNoU2l6ZSA9IHRoaXMuaW5zdHJ1Y3Rpb25zICE9IGluc3RydWN0aW9ucyB8fCB0aGlzLm92ZXJsYXBzID8gMCA6IDIwMDtcbiAgICB2YXIgLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9ICovIGZlYXR1cmU7XG4gICAgdmFyIHgsIHk7XG4gICAgd2hpbGUgKGkgPCBpaSkge1xuICAgICAgdmFyIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdmFyIHR5cGUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9ufSAqLyAoaW5zdHJ1Y3Rpb25bMF0pO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlk6XG4gICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGlmICgoc2tpcEZlYXR1cmVzICYmXG4gICAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlc0hhc2hbZ2V0VWlkKGZlYXR1cmUpLnRvU3RyaW5nKCldKSB8fFxuICAgICAgICAgICAgICAhZmVhdHVyZS5nZXRHZW9tZXRyeSgpKSB7XG4gICAgICAgICAgICBpID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRfaGl0RXh0ZW50ICE9PSB1bmRlZmluZWQgJiYgIWludGVyc2VjdHMoXG4gICAgICAgICAgICBvcHRfaGl0RXh0ZW50LCBmZWF0dXJlLmdldEdlb21ldHJ5KCkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgICAgICBpID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSkgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkJFR0lOX1BBVEg6XG4gICAgICAgICAgaWYgKHBlbmRpbmdGaWxsID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzJDEuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGVuZGluZ0ZpbGwgJiYgIXBlbmRpbmdTdHJva2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBwcmV2WCA9IHByZXZZID0gTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICB2YXIgeDEgPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgIHZhciB5MSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgIHZhciB4MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDJdO1xuICAgICAgICAgIHZhciB5MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDNdO1xuICAgICAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDEgKyByLCB5MSk7XG4gICAgICAgICAgY29udGV4dC5hcmMoeDEsIHkxLCByLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkNMT1NFX1BBVEg6XG4gICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ1VTVE9NOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IGluc3RydWN0aW9uWzJdO1xuICAgICAgICAgIHZhciBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovIChpbnN0cnVjdGlvblszXSk7XG4gICAgICAgICAgdmFyIHJlbmRlcmVyID0gaW5zdHJ1Y3Rpb25bNF07XG4gICAgICAgICAgdmFyIGZuID0gaW5zdHJ1Y3Rpb24ubGVuZ3RoID09IDYgPyBpbnN0cnVjdGlvbls1XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBzdGF0ZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgIHN0YXRlLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgIGlmICghKGkgaW4gY29vcmRpbmF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZUNhY2hlW2ldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb29yZHMgPSBjb29yZGluYXRlQ2FjaGVbaV07XG4gICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICBmbihwaXhlbENvb3JkaW5hdGVzLCBkLCBkZCwgMiwgY29vcmRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29vcmRzWzBdID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICAgIGNvb3Jkc1sxXSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgICAgY29vcmRzLmxlbmd0aCA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbmRlcmVyKGNvb3Jkcywgc3RhdGUpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBkZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICAgIGltYWdlID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9ICovXG4gICAgICAgICAgICAgIChpbnN0cnVjdGlvblszXSk7XG4gICAgICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyBpbiBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgICAgICBhbmNob3JYID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls0XSk7XG4gICAgICAgICAgYW5jaG9yWSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNV0pO1xuICAgICAgICAgIGRlY2x1dHRlckdyb3VwID0gZmVhdHVyZUNhbGxiYWNrID8gbnVsbCA6IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RGVjbHV0dGVyR3JvdXB9ICovIChpbnN0cnVjdGlvbls2XSk7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls4XSk7XG4gICAgICAgICAgdmFyIG9yaWdpblggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICB2YXIgb3JpZ2luWSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTBdKTtcbiAgICAgICAgICB2YXIgcm90YXRlV2l0aFZpZXcgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxMV0pO1xuICAgICAgICAgIHZhciByb3RhdGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTJdKTtcbiAgICAgICAgICB2YXIgc2NhbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSk7XG4gICAgICAgICAgdmFyIHNuYXBUb1BpeGVsID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTRdKTtcbiAgICAgICAgICB2YXIgd2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzE1XSk7XG5cbiAgICAgICAgICB2YXIgcGFkZGluZyA9ICh2b2lkIDApLCBiYWNrZ3JvdW5kRmlsbCA9ICh2b2lkIDApLCBiYWNrZ3JvdW5kU3Ryb2tlID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uLmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzE2XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGluc3RydWN0aW9uWzE3XSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMThdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgICAgICAgYmFja2dyb3VuZEZpbGwgPSBiYWNrZ3JvdW5kU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgICAgICAgICByb3RhdGlvbiArPSB2aWV3Um90YXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoOyBkIDwgZGQ7IGQgKz0gMikge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxheUltYWdlXyhjb250ZXh0LFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzW2RdLCBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXSwgaW1hZ2UsIGFuY2hvclgsIGFuY2hvclksXG4gICAgICAgICAgICAgIGRlY2x1dHRlckdyb3VwLCBoZWlnaHQsIG9wYWNpdHksIG9yaWdpblgsIG9yaWdpblksIHJvdGF0aW9uLCBzY2FsZSxcbiAgICAgICAgICAgICAgc25hcFRvUGl4ZWwsIHdpZHRoLCBwYWRkaW5nLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA/IC8qKiBAdHlwZSB7QXJyYXkuPCo+fSAqLyAobGFzdEZpbGxJbnN0cnVjdGlvbikgOiBudWxsLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kU3Ryb2tlID8gLyoqIEB0eXBlIHtBcnJheS48Kj59ICovIChsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24pIDogbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMkMS5yZW5kZXJEZWNsdXR0ZXJfKGRlY2x1dHRlckdyb3VwLCBmZWF0dXJlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUzpcbiAgICAgICAgICB2YXIgYmVnaW4gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICB2YXIgZW5kID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgdmFyIGJhc2VsaW5lID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblszXSk7XG4gICAgICAgICAgZGVjbHV0dGVyR3JvdXAgPSBmZWF0dXJlQ2FsbGJhY2sgPyBudWxsIDogLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35EZWNsdXR0ZXJHcm91cH0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICB2YXIgb3ZlcmZsb3cgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzVdKTtcbiAgICAgICAgICB2YXIgZmlsbEtleSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bNl0pO1xuICAgICAgICAgIHZhciBtYXhBbmdsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIHZhciBtZWFzdXJlID0gLyoqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcpOm51bWJlcn0gKi8gKGluc3RydWN0aW9uWzhdKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0WSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOV0pO1xuICAgICAgICAgIHZhciBzdHJva2VLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzEwXSk7XG4gICAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMV0pO1xuICAgICAgICAgIHZhciB0ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxMl0pO1xuICAgICAgICAgIHZhciB0ZXh0S2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxM10pO1xuICAgICAgICAgIHZhciB0ZXh0U2NhbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzE0XSk7XG5cbiAgICAgICAgICB2YXIgcGF0aExlbmd0aCA9IGxpbmVTdHJpbmdMZW5ndGgocGl4ZWxDb29yZGluYXRlcywgYmVnaW4sIGVuZCwgMik7XG4gICAgICAgICAgdmFyIHRleHRMZW5ndGggPSBtZWFzdXJlKHRleHQpO1xuICAgICAgICAgIGlmIChvdmVyZmxvdyB8fCB0ZXh0TGVuZ3RoIDw9IHBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0QWxpZ24gPSAvKiogQHR5cGUge21vZHVsZTpvbH5yZW5kZXJ9ICovICh0aGlzJDEpLnRleHRTdGF0ZXNbdGV4dEtleV0udGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIHN0YXJ0TSA9IChwYXRoTGVuZ3RoIC0gdGV4dExlbmd0aCkgKiBURVhUX0FMSUdOW3RleHRBbGlnbl07XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBkcmF3VGV4dE9uUGF0aChcbiAgICAgICAgICAgICAgcGl4ZWxDb29yZGluYXRlcywgYmVnaW4sIGVuZCwgMiwgdGV4dCwgbWVhc3VyZSwgc3RhcnRNLCBtYXhBbmdsZSk7XG4gICAgICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSAodm9pZCAwKSwgY2MgPSAodm9pZCAwKSwgY2hhcnMgPSAodm9pZCAwKSwgbGFiZWwgPSAodm9pZCAwKSwgcGFydCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSAvKiogQHR5cGUge21vZHVsZTpvbH5yZW5kZXJ9ICovICh0aGlzJDEpLmdldEltYWdlKGNoYXJzLCB0ZXh0S2V5LCAnJywgc3Ryb2tlS2V5KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMl0pICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgKyAoMC41IC0gYmFzZWxpbmUpICogMiAqIHN0cm9rZVdpZHRoIC0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5yZXBsYXlJbWFnZV8oY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzBdKSwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzFdKSwgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclgsIGFuY2hvclksIGRlY2x1dHRlckdyb3VwLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFszXSksIHRleHRTY2FsZSwgZmFsc2UsIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSAvKiogQHR5cGUge21vZHVsZTpvbH5yZW5kZXJ9ICovICh0aGlzJDEpLmdldEltYWdlKGNoYXJzLCB0ZXh0S2V5LCBmaWxsS2V5LCAnJyk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JYID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzJdKTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCAtIG9mZnNldFk7XG4gICAgICAgICAgICAgICAgICB0aGlzJDEucmVwbGF5SW1hZ2VfKGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFswXSksIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsxXSksIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JYLCBhbmNob3JZLCBkZWNsdXR0ZXJHcm91cCwgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbM10pLCB0ZXh0U2NhbGUsIGZhbHNlLCBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBhZGRpbmcsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzJDEucmVuZGVyRGVjbHV0dGVyXyhkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWTpcbiAgICAgICAgICBpZiAoZmVhdHVyZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5GSUxMOlxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTzpcbiAgICAgICAgICBkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgZGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB4ID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICB5ID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgcm91bmRYID0gKHggKyAwLjUpIHwgMDtcbiAgICAgICAgICByb3VuZFkgPSAoeSArIDAuNSkgfCAwO1xuICAgICAgICAgIGlmIChyb3VuZFggIT09IHByZXZYIHx8IHJvdW5kWSAhPT0gcHJldlkpIHtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgcHJldlggPSByb3VuZFg7XG4gICAgICAgICAgICBwcmV2WSA9IHJvdW5kWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChkICs9IDI7IGQgPCBkZDsgZCArPSAyKSB7XG4gICAgICAgICAgICB4ID0gcGl4ZWxDb29yZGluYXRlc1tkXTtcbiAgICAgICAgICAgIHkgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICAgIHJvdW5kWCA9ICh4ICsgMC41KSB8IDA7XG4gICAgICAgICAgICByb3VuZFkgPSAoeSArIDAuNSkgfCAwO1xuICAgICAgICAgICAgaWYgKGQgPT0gZGQgLSAyIHx8IHJvdW5kWCAhPT0gcHJldlggfHwgcm91bmRZICE9PSBwcmV2WSkge1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgcHJldlggPSByb3VuZFg7XG4gICAgICAgICAgICAgIHByZXZZID0gcm91bmRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEU6XG4gICAgICAgICAgbGFzdEZpbGxJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIHRoaXMkMS5hbGlnbkZpbGxfID0gaW5zdHJ1Y3Rpb25bMl07XG5cbiAgICAgICAgICBpZiAocGVuZGluZ0ZpbGwpIHtcbiAgICAgICAgICAgIHRoaXMkMS5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsID0gMDtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRTpcbiAgICAgICAgICBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzJDEuc2V0U3Ryb2tlU3R5bGVfKGNvbnRleHQsIC8qKiBAdHlwZSB7QXJyYXkuPCo+fSAqLyAoaW5zdHJ1Y3Rpb24pKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uU1RST0tFOlxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHBlbmRpbmdTdHJva2UrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICsraTsgLy8gY29uc3VtZSB0aGUgaW5zdHJ1Y3Rpb24gYW55d2F5LCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwZW5kaW5nRmlsbCkge1xuICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmdTdHJva2UpIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzXG4gICAqICAgICB0byBza2lwLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkgKGNvbnRleHQsIHRyYW5zZm9ybSwgdmlld1JvdGF0aW9uLCBza2lwcGVkRmVhdHVyZXNIYXNoKSB7XG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuICAgIHRoaXMucmVwbGF5Xyhjb250ZXh0LCB0cmFuc2Zvcm0sXG4gICAgICBza2lwcGVkRmVhdHVyZXNIYXNoLCB0aGlzLmluc3RydWN0aW9ucywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlc1xuICAgKiAgICAgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSk6IFQ9fSBvcHRfZmVhdHVyZUNhbGxiYWNrXG4gICAqICAgICBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50PX0gb3B0X2hpdEV4dGVudCBPbmx5IGNoZWNrIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRoaXNcbiAgICogICAgIGV4dGVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmVwbGF5SGl0RGV0ZWN0aW9uID0gZnVuY3Rpb24gcmVwbGF5SGl0RGV0ZWN0aW9uIChcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3Um90YXRpb24sXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBvcHRfZmVhdHVyZUNhbGxiYWNrLFxuICAgIG9wdF9oaXRFeHRlbnRcbiAgKSB7XG4gICAgdGhpcy52aWV3Um90YXRpb25fID0gdmlld1JvdGF0aW9uO1xuICAgIHJldHVybiB0aGlzLnJlcGxheV8oY29udGV4dCwgdHJhbnNmb3JtLCBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMsIG9wdF9mZWF0dXJlQ2FsbGJhY2ssIG9wdF9oaXRFeHRlbnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXZlcnNlIHRoZSBoaXQgZGV0ZWN0aW9uIGluc3RydWN0aW9ucy5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUucmV2ZXJzZUhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IGZ1bmN0aW9uIHJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zO1xuICAgIC8vIHN0ZXAgMSAtIHJldmVyc2UgYXJyYXlcbiAgICBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucmV2ZXJzZSgpO1xuICAgIC8vIHN0ZXAgMiAtIHJldmVyc2UgaW5zdHJ1Y3Rpb25zIHdpdGhpbiBnZW9tZXRyeSBibG9ja3NcbiAgICB2YXIgaTtcbiAgICB2YXIgbiA9IGhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdmFyIGluc3RydWN0aW9uO1xuICAgIHZhciB0eXBlO1xuICAgIHZhciBiZWdpbiA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluc3RydWN0aW9uID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zW2ldO1xuICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb259ICovIChpbnN0cnVjdGlvblswXSk7XG4gICAgICBpZiAodHlwZSA9PSBDYW52YXNJbnN0cnVjdGlvbi5FTkRfR0VPTUVUUlkpIHtcbiAgICAgICAgYmVnaW4gPSBpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IENhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZKSB7XG4gICAgICAgIGluc3RydWN0aW9uWzJdID0gaTtcbiAgICAgICAgcmV2ZXJzZVN1YkFycmF5KHRoaXMkMS5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMsIGJlZ2luLCBpKTtcbiAgICAgICAgYmVnaW4gPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLnNldEZpbGxTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHNldEZpbGxTdHJva2VTdHlsZSAoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgdmFyIGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShmaWxsU3R5bGVDb2xvciA/XG4gICAgICAgIGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmZpbGxTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVDb2xvciA9IHN0cm9rZVN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKHN0cm9rZVN0eWxlQ29sb3IgP1xuICAgICAgICBzdHJva2VTdHlsZUNvbG9yIDogZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVDYXAgPSBzdHJva2VTdHlsZS5nZXRMaW5lQ2FwKCk7XG4gICAgICBzdGF0ZS5saW5lQ2FwID0gc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVDYXAgOiBkZWZhdWx0TGluZUNhcDtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgIHZhciBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQ7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVMaW5lSm9pbiA9IHN0cm9rZVN0eWxlLmdldExpbmVKb2luKCk7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9IHN0cm9rZVN0eWxlTGluZUpvaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW47XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPSBzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIHZhciBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICBzdGF0ZS5taXRlckxpbWl0ID0gc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZU1pdGVyTGltaXQgOiBkZWZhdWx0TWl0ZXJMaW1pdDtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVXaWR0aCA+IHRoaXMubWF4TGluZVdpZHRoKSB7XG4gICAgICAgIHRoaXMubWF4TGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgICAgICAvLyBpbnZhbGlkYXRlIHRoZSBidWZmZXJlZCBtYXggZXh0ZW50IGNhY2hlXG4gICAgICAgIHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lQ2FwID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZURhc2ggPSBudWxsO1xuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lSm9pbiA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHJldHVybiB7QXJyYXkuPCo+fSBGaWxsIGluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5jcmVhdGVGaWxsID0gZnVuY3Rpb24gY3JlYXRlRmlsbCAoc3RhdGUsIGdlb21ldHJ5KSB7XG4gICAgdmFyIGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICB2YXIgZmlsbEluc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFLCBmaWxsU3R5bGVdO1xuICAgIGlmICh0eXBlb2YgZmlsbFN0eWxlICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gRmlsbCBpcyBhIHBhdHRlcm4gb3IgZ3JhZGllbnQgLSBhbGlnbiBpdCFcbiAgICAgIGZpbGxJbnN0cnVjdGlvbi5wdXNoKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsbEluc3RydWN0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqL1xuICBDYW52YXNSZXBsYXkucHJvdG90eXBlLmFwcGx5U3Ryb2tlID0gZnVuY3Rpb24gYXBwbHlTdHJva2UgKHN0YXRlKSB7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNyZWF0ZVN0cm9rZShzdGF0ZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdHJva2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEByZXR1cm4ge0FycmF5LjwqPn0gU3Ryb2tlIGluc3RydWN0aW9uLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS5jcmVhdGVTdHJva2UgPSBmdW5jdGlvbiBjcmVhdGVTdHJva2UgKHN0YXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoICogdGhpcy5waXhlbFJhdGlvLCBzdGF0ZS5saW5lQ2FwLFxuICAgICAgc3RhdGUubGluZUpvaW4sIHN0YXRlLm1pdGVyTGltaXQsXG4gICAgICB0aGlzLmFwcGx5UGl4ZWxSYXRpbyhzdGF0ZS5saW5lRGFzaCksIHN0YXRlLmxpbmVEYXNoT2Zmc2V0ICogdGhpcy5waXhlbFJhdGlvXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6bW9kdWxlOm9sL3JlbmRlci9jYW52YXMvUmVwbGF5LCBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35GaWxsU3Ryb2tlU3RhdGUsIChtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUpKTpBcnJheS48Kj59IGNyZWF0ZUZpbGwgQ3JlYXRlIGZpbGwuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUudXBkYXRlRmlsbFN0eWxlID0gZnVuY3Rpb24gdXBkYXRlRmlsbFN0eWxlIChzdGF0ZSwgY3JlYXRlRmlsbCwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGlmICh0eXBlb2YgZmlsbFN0eWxlICE9PSAnc3RyaW5nJyB8fCBzdGF0ZS5jdXJyZW50RmlsbFN0eWxlICE9IGZpbGxTdHlsZSkge1xuICAgICAgaWYgKGZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goY3JlYXRlRmlsbC5jYWxsKHRoaXMsIHN0YXRlLCBnZW9tZXRyeSkpO1xuICAgICAgfVxuICAgICAgc3RhdGUuY3VycmVudEZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOm1vZHVsZTpvbC9yZW5kZXIvY2FudmFzL1JlcGxheSwgbW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RmlsbFN0cm9rZVN0YXRlKX0gYXBwbHlTdHJva2UgQXBwbHkgc3Ryb2tlLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5LnByb3RvdHlwZS51cGRhdGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIHVwZGF0ZVN0cm9rZVN0eWxlIChzdGF0ZSwgYXBwbHlTdHJva2UpIHtcbiAgICB2YXIgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICB2YXIgbGluZUNhcCA9IHN0YXRlLmxpbmVDYXA7XG4gICAgdmFyIGxpbmVEYXNoID0gc3RhdGUubGluZURhc2g7XG4gICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gc3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVKb2luID0gc3RhdGUubGluZUpvaW47XG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0YXRlLmxpbmVXaWR0aDtcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IHN0YXRlLm1pdGVyTGltaXQ7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSAhPSBzdHJva2VTdHlsZSB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZUNhcCAhPSBsaW5lQ2FwIHx8XG4gICAgICAgIChsaW5lRGFzaCAhPSBzdGF0ZS5jdXJyZW50TGluZURhc2ggJiYgIWVxdWFscyhzdGF0ZS5jdXJyZW50TGluZURhc2gsIGxpbmVEYXNoKSkgfHxcbiAgICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoT2Zmc2V0ICE9IGxpbmVEYXNoT2Zmc2V0IHx8XG4gICAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiAhPSBsaW5lSm9pbiB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZVdpZHRoICE9IGxpbmVXaWR0aCB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TWl0ZXJMaW1pdCAhPSBtaXRlckxpbWl0KSB7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIHN0YXRlLmN1cnJlbnRNaXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuZW5kR2VvbWV0cnkgPSBmdW5jdGlvbiBlbmRHZW9tZXRyeSAoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfWzJdID0gdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV8gPSBudWxsO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl9bMl0gPSB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yXyA9IG51bGw7XG4gICAgdmFyIGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uRU5EX0dFT01FVFJZLCBmZWF0dXJlXTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goZW5kR2VvbWV0cnlJbnN0cnVjdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyZWQgcmVuZGVyaW5nIGV4dGVudC4gIFJlbmRlcmluZyB3aWxsIGJlIGNsaXBwZWQgdG8gdGhlIGV4dGVudFxuICAgKiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuICBUbyBhY2NvdW50IGZvciBzeW1ib2xpemVycyB0aGF0IG1heSBpbnRlcnNlY3RcbiAgICogdGhpcyBleHRlbnQsIHdlIGNhbGN1bGF0ZSBhIGJ1ZmZlcmVkIGV4dGVudCAoZS5nLiBiYXNlZCBvbiBzdHJva2Ugd2lkdGgpLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gVGhlIGJ1ZmZlcmVkIHJlbmRlcmluZyBleHRlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENhbnZhc1JlcGxheS5wcm90b3R5cGUuZ2V0QnVmZmVyZWRNYXhFeHRlbnQgPSBmdW5jdGlvbiBnZXRCdWZmZXJlZE1heEV4dGVudCAoKSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xykge1xuICAgICAgdGhpcy5idWZmZXJlZE1heEV4dGVudF8gPSBjbG9uZSh0aGlzLm1heEV4dGVudCk7XG4gICAgICBpZiAodGhpcy5tYXhMaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMucmVzb2x1dGlvbiAqICh0aGlzLm1heExpbmVXaWR0aCArIDEpIC8gMjtcbiAgICAgICAgYnVmZmVyKHRoaXMuYnVmZmVyZWRNYXhFeHRlbnRfLCB3aWR0aCwgdGhpcy5idWZmZXJlZE1heEV4dGVudF8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5idWZmZXJlZE1heEV4dGVudF87XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1JlcGxheTtcbn0oVmVjdG9yQ29udGV4dCkpO1xuXG5cbi8qKlxuICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gKi9cbkNhbnZhc1JlcGxheS5wcm90b3R5cGUuZmluaXNoID0gVU5ERUZJTkVEO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlcGxheTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1JlcGxheUdyb3VwXG4gKi9cblxuaW1wb3J0IHtudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9ufSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7YnVmZmVyLCBjcmVhdGVFbXB0eSwgZXh0ZW5kQ29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IFJlcGxheUdyb3VwIGZyb20gJy4uL1JlcGxheUdyb3VwLmpzJztcbmltcG9ydCBSZXBsYXlUeXBlIGZyb20gJy4uL1JlcGxheVR5cGUuanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheSBmcm9tICcuLi9jYW52YXMvUmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNJbWFnZVJlcGxheSBmcm9tICcuLi9jYW52YXMvSW1hZ2VSZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc0xpbmVTdHJpbmdSZXBsYXkgZnJvbSAnLi4vY2FudmFzL0xpbmVTdHJpbmdSZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc1BvbHlnb25SZXBsYXkgZnJvbSAnLi4vY2FudmFzL1BvbHlnb25SZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc1RleHRSZXBsYXkgZnJvbSAnLi4vY2FudmFzL1RleHRSZXBsYXkuanMnO1xuaW1wb3J0IHtPUkRFUn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdC48bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlUeXBlLFxuICogICAgICAgICAgICAgICAgZnVuY3Rpb24obmV3OiBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9SZXBsYXksIG51bWJlciwgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnQsXG4gKiAgICAgICAgICAgICAgICBudW1iZXIsIG51bWJlciwgYm9vbGVhbiwgQXJyYXkuPG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwPik+fVxuICovXG52YXIgQkFUQ0hfQ09OU1RSVUNUT1JTID0ge1xuICAnQ2lyY2xlJzogQ2FudmFzUG9seWdvblJlcGxheSxcbiAgJ0RlZmF1bHQnOiBDYW52YXNSZXBsYXksXG4gICdJbWFnZSc6IENhbnZhc0ltYWdlUmVwbGF5LFxuICAnTGluZVN0cmluZyc6IENhbnZhc0xpbmVTdHJpbmdSZXBsYXksXG4gICdQb2x5Z29uJzogQ2FudmFzUG9seWdvblJlcGxheSxcbiAgJ1RleHQnOiBDYW52YXNUZXh0UmVwbGF5XG59O1xuXG5cbnZhciBDYW52YXNSZXBsYXlHcm91cCA9IChmdW5jdGlvbiAoUmVwbGF5R3JvdXApIHtcbiAgZnVuY3Rpb24gQ2FudmFzUmVwbGF5R3JvdXAoXG4gICAgdG9sZXJhbmNlLFxuICAgIG1heEV4dGVudCxcbiAgICByZXNvbHV0aW9uLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgb3ZlcmxhcHMsXG4gICAgZGVjbHV0dGVyVHJlZSxcbiAgICBvcHRfcmVuZGVyQnVmZmVyXG4gICkge1xuICAgIFJlcGxheUdyb3VwLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWNsdXR0ZXIgdHJlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVjbHV0dGVyVHJlZV8gPSBkZWNsdXR0ZXJUcmVlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkRlY2x1dHRlckdyb3VwfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlXyA9IHRvbGVyYW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50XyA9IG1heEV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdmVybGFwc18gPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsUmF0aW9fID0gcGl4ZWxSYXRpbztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25fID0gcmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJCdWZmZXJfID0gb3B0X3JlbmRlckJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgIU9iamVjdC48bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlUeXBlLCBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9SZXBsYXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheXNCeVpJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25UcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG4gIH1cblxuICBpZiAoIFJlcGxheUdyb3VwICkgQ2FudmFzUmVwbGF5R3JvdXAuX19wcm90b19fID0gUmVwbGF5R3JvdXA7XG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJlcGxheUdyb3VwICYmIFJlcGxheUdyb3VwLnByb3RvdHlwZSApO1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNSZXBsYXlHcm91cDtcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBncm91cCBHcm91cCB3aXRoIHByZXZpb3VzIHJlcGxheS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RGVjbHV0dGVyR3JvdXB9IERlY2x1dHRlciBpbnN0cnVjdGlvbiBncm91cC5cbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5hZGREZWNsdXR0ZXIgPSBmdW5jdGlvbiBhZGREZWNsdXR0ZXIgKGdyb3VwKSB7XG4gICAgdmFyIGRlY2x1dHRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJbNF0pKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICAgIGRlY2x1dHRlci5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjbHV0dGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbiBjbGlwIChjb250ZXh0LCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgZmxhdENsaXBDb29yZHMgPSB0aGlzLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGZsYXRDbGlwQ29vcmRzWzBdLCBmbGF0Q2xpcENvb3Jkc1sxXSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbMl0sIGZsYXRDbGlwQ29vcmRzWzNdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1s0XSwgZmxhdENsaXBDb29yZHNbNV0pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzZdLCBmbGF0Q2xpcENvb3Jkc1s3XSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9yZW5kZXIvUmVwbGF5VHlwZT59IHJlcGxheXMgUmVwbGF5cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIHJlcGxheXMgb2YgdGhlIHByb3ZpZGVkIHR5cGVzLlxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmhhc1JlcGxheXMgPSBmdW5jdGlvbiBoYXNSZXBsYXlzIChyZXBsYXlzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciB6SW5kZXggaW4gdGhpcyQxLnJlcGxheXNCeVpJbmRleF8pIHtcbiAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcyQxLnJlcGxheXNCeVpJbmRleF9bekluZGV4XTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHJlcGxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAocmVwbGF5c1tpXSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgektleSBpbiB0aGlzJDEucmVwbGF5c0J5WkluZGV4Xykge1xuICAgICAgdmFyIHJlcGxheXMgPSB0aGlzJDEucmVwbGF5c0J5WkluZGV4X1t6S2V5XTtcbiAgICAgIGZvciAodmFyIHJlcGxheUtleSBpbiByZXBsYXlzKSB7XG4gICAgICAgIHJlcGxheXNbcmVwbGF5S2V5XS5maW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlcyB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChtb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUpKTogVH0gY2FsbGJhY2sgRmVhdHVyZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RGVjbHV0dGVyR3JvdXA+fSBkZWNsdXR0ZXJSZXBsYXlzIERlY2x1dHRlciByZXBsYXlzLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgQ2FudmFzUmVwbGF5R3JvdXAucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgcmVzb2x1dGlvbixcbiAgICByb3RhdGlvbixcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBjYWxsYmFjayxcbiAgICBkZWNsdXR0ZXJSZXBsYXlzXG4gICkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cbiAgICBoaXRUb2xlcmFuY2UgPSBNYXRoLnJvdW5kKGhpdFRvbGVyYW5jZSk7XG4gICAgdmFyIGNvbnRleHRTaXplID0gaGl0VG9sZXJhbmNlICogMiArIDE7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5oaXREZXRlY3Rpb25UcmFuc2Zvcm1fLFxuICAgICAgaGl0VG9sZXJhbmNlICsgMC41LCBoaXRUb2xlcmFuY2UgKyAwLjUsXG4gICAgICAxIC8gcmVzb2x1dGlvbiwgLTEgLyByZXNvbHV0aW9uLFxuICAgICAgLXJvdGF0aW9uLFxuICAgICAgLWNvb3JkaW5hdGVbMF0sIC1jb29yZGluYXRlWzFdKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuaGl0RGV0ZWN0aW9uQ29udGV4dF87XG5cbiAgICBpZiAoY29udGV4dC5jYW52YXMud2lkdGggIT09IGNvbnRleHRTaXplIHx8IGNvbnRleHQuY2FudmFzLmhlaWdodCAhPT0gY29udGV4dFNpemUpIHtcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gY29udGV4dFNpemU7XG4gICAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBjb250ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY29udGV4dFNpemUsIGNvbnRleHRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdmFyIGhpdEV4dGVudDtcbiAgICBpZiAodGhpcy5yZW5kZXJCdWZmZXJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhpdEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGhpdEV4dGVudCwgY29vcmRpbmF0ZSk7XG4gICAgICBidWZmZXIoaGl0RXh0ZW50LCByZXNvbHV0aW9uICogKHRoaXMucmVuZGVyQnVmZmVyXyArIGhpdFRvbGVyYW5jZSksIGhpdEV4dGVudCk7XG4gICAgfVxuXG4gICAgdmFyIG1hc2sgPSBnZXRDaXJjbGVBcnJheShoaXRUb2xlcmFuY2UpO1xuICAgIHZhciBkZWNsdXR0ZXJlZEZlYXR1cmVzO1xuICAgIGlmICh0aGlzLmRlY2x1dHRlclRyZWVfKSB7XG4gICAgICBkZWNsdXR0ZXJlZEZlYXR1cmVzID0gdGhpcy5kZWNsdXR0ZXJUcmVlXy5hbGwoKS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcGxheVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSkuZGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dFNpemU7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRleHRTaXplOyBqKyspIHtcbiAgICAgICAgICBpZiAobWFza1tpXVtqXSkge1xuICAgICAgICAgICAgaWYgKGltYWdlRGF0YVsoaiAqIGNvbnRleHRTaXplICsgaSkgKiA0ICsgM10gPiAwKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgaWYgKCEoZGVjbHV0dGVyZWRGZWF0dXJlcyAmJiAocmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLklNQUdFIHx8IHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5URVhUKSkgfHxcbiAgICAgICAgICAgICAgICAgIGRlY2x1dHRlcmVkRmVhdHVyZXMuaW5kZXhPZihmZWF0dXJlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciB6cyA9IE9iamVjdC5rZXlzKHRoaXMucmVwbGF5c0J5WkluZGV4XykubWFwKE51bWJlcik7XG4gICAgenMuc29ydChudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uKTtcblxuICAgIHZhciBpLCBqLCByZXBsYXlzLCByZXBsYXksIHJlc3VsdDtcbiAgICBmb3IgKGkgPSB6cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHpJbmRleEtleSA9IHpzW2ldLnRvU3RyaW5nKCk7XG4gICAgICByZXBsYXlzID0gdGhpcyQxLnJlcGxheXNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICAgIGZvciAoaiA9IE9SREVSLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIHJlcGxheVR5cGUgPSBPUkRFUltqXTtcbiAgICAgICAgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICAgICAgaWYgKHJlcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMgJiZcbiAgICAgICAgICAgICAgKHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5JTUFHRSB8fCByZXBsYXlUeXBlID09IFJlcGxheVR5cGUuVEVYVCkpIHtcbiAgICAgICAgICAgIHZhciBkZWNsdXR0ZXIgPSBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV07XG4gICAgICAgICAgICBpZiAoIWRlY2x1dHRlcikge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV0gPSBbcmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVjbHV0dGVyLnB1c2gocmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXBsYXkucmVwbGF5SGl0RGV0ZWN0aW9uKGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sXG4gICAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsIGZlYXR1cmVDYWxsYmFjaywgaGl0RXh0ZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IENsaXAgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBDYW52YXNSZXBsYXlHcm91cC5wcm90b3R5cGUuZ2V0Q2xpcENvb3JkcyA9IGZ1bmN0aW9uIGdldENsaXBDb29yZHMgKHRyYW5zZm9ybSkge1xuICAgIHZhciBtYXhFeHRlbnQgPSB0aGlzLm1heEV4dGVudF87XG4gICAgdmFyIG1pblggPSBtYXhFeHRlbnRbMF07XG4gICAgdmFyIG1pblkgPSBtYXhFeHRlbnRbMV07XG4gICAgdmFyIG1heFggPSBtYXhFeHRlbnRbMl07XG4gICAgdmFyIG1heFkgPSBtYXhFeHRlbnRbM107XG4gICAgdmFyIGZsYXRDbGlwQ29vcmRzID0gW21pblgsIG1pblksIG1pblgsIG1heFksIG1heFgsIG1heFksIG1heFgsIG1pblldO1xuICAgIHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENsaXBDb29yZHMsIDAsIDgsIDIsIHRyYW5zZm9ybSwgZmxhdENsaXBDb29yZHMpO1xuICAgIHJldHVybiBmbGF0Q2xpcENvb3JkcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5nZXRSZXBsYXkgPSBmdW5jdGlvbiBnZXRSZXBsYXkgKHpJbmRleCwgcmVwbGF5VHlwZSkge1xuICAgIHZhciB6SW5kZXhLZXkgPSB6SW5kZXggIT09IHVuZGVmaW5lZCA/IHpJbmRleC50b1N0cmluZygpIDogJzAnO1xuICAgIHZhciByZXBsYXlzID0gdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV07XG4gICAgaWYgKHJlcGxheXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVwbGF5cyA9IHt9O1xuICAgICAgdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV0gPSByZXBsYXlzO1xuICAgIH1cbiAgICB2YXIgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICBpZiAocmVwbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEJBVENIX0NPTlNUUlVDVE9SU1tyZXBsYXlUeXBlXTtcbiAgICAgIHJlcGxheSA9IG5ldyBDb25zdHJ1Y3Rvcih0aGlzLnRvbGVyYW5jZV8sIHRoaXMubWF4RXh0ZW50XyxcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uXywgdGhpcy5waXhlbFJhdGlvXywgdGhpcy5vdmVybGFwc18sIHRoaXMuZGVjbHV0dGVyVHJlZV8pO1xuICAgICAgcmVwbGF5c1tyZXBsYXlUeXBlXSA9IHJlcGxheTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdC48bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlUeXBlLCBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9SZXBsYXk+Pn0gUmVwbGF5cy5cbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5nZXRSZXBsYXlzID0gZnVuY3Rpb24gZ2V0UmVwbGF5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVwbGF5c0J5WkluZGV4XztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSQxICgpIHtcbiAgICByZXR1cm4gaXNFbXB0eSh0aGlzLnJlcGxheXNCeVpJbmRleF8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlcyB0byBza2lwLlxuICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvcmVuZGVyL1JlcGxheVR5cGU+PX0gb3B0X3JlcGxheVR5cGVzIE9yZGVyZWQgcmVwbGF5IHR5cGVzIHRvIHJlcGxheS5cbiAgICogICAgIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvcmVwbGF5fk9SREVSfVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35EZWNsdXR0ZXJHcm91cD49fSBvcHRfZGVjbHV0dGVyUmVwbGF5cyBEZWNsdXR0ZXIgcmVwbGF5cy5cbiAgICovXG4gIENhbnZhc1JlcGxheUdyb3VwLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkgKFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIG9wdF9yZXBsYXlUeXBlcyxcbiAgICBvcHRfZGVjbHV0dGVyUmVwbGF5c1xuICApIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXG4gICAgLyoqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gKi9cbiAgICB2YXIgenMgPSBPYmplY3Qua2V5cyh0aGlzLnJlcGxheXNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG5cbiAgICAvLyBzZXR1cCBjbGlwcGluZyBzbyB0aGF0IHRoZSBwYXJ0cyBvZiBvdmVyLXNpbXBsaWZpZWQgZ2VvbWV0cmllcyBhcmUgbm90XG4gICAgLy8gdmlzaWJsZSBvdXRzaWRlIHRoZSBjdXJyZW50IGV4dGVudCB3aGVuIHBhbm5pbmdcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB0aGlzLmNsaXAoY29udGV4dCwgdHJhbnNmb3JtKTtcblxuICAgIHZhciByZXBsYXlUeXBlcyA9IG9wdF9yZXBsYXlUeXBlcyA/IG9wdF9yZXBsYXlUeXBlcyA6IE9SREVSO1xuICAgIHZhciBpLCBpaSwgaiwgamosIHJlcGxheXMsIHJlcGxheTtcbiAgICBmb3IgKGkgPSAwLCBpaSA9IHpzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHZhciB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgcmVwbGF5cyA9IHRoaXMkMS5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV07XG4gICAgICBmb3IgKGogPSAwLCBqaiA9IHJlcGxheVR5cGVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgdmFyIHJlcGxheVR5cGUgPSByZXBsYXlUeXBlc1tqXTtcbiAgICAgICAgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICAgICAgaWYgKHJlcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9wdF9kZWNsdXR0ZXJSZXBsYXlzICYmXG4gICAgICAgICAgICAgIChyZXBsYXlUeXBlID09IFJlcGxheVR5cGUuSU1BR0UgfHwgcmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLlRFWFQpKSB7XG4gICAgICAgICAgICB2YXIgZGVjbHV0dGVyID0gb3B0X2RlY2x1dHRlclJlcGxheXNbekluZGV4S2V5XTtcbiAgICAgICAgICAgIGlmICghZGVjbHV0dGVyKSB7XG4gICAgICAgICAgICAgIG9wdF9kZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV0gPSBbcmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVjbHV0dGVyLnB1c2gocmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYXkucmVwbGF5KGNvbnRleHQsIHRyYW5zZm9ybSwgdmlld1JvdGF0aW9uLCBza2lwcGVkRmVhdHVyZXNIYXNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzUmVwbGF5R3JvdXA7XG59KFJlcGxheUdyb3VwKSk7XG5cblxuLyoqXG4gKiBUaGlzIGNhY2hlIGlzIHVzZWQgZm9yIHN0b3JpbmcgY2FsY3VsYXRlZCBwaXhlbCBjaXJjbGVzIGZvciBpbmNyZWFzaW5nIHBlcmZvcm1hbmNlLlxuICogSXQgaXMgYSBzdGF0aWMgcHJvcGVydHkgdG8gYWxsb3cgZWFjaCBSZXBsYXlncm91cCB0byBhY2Nlc3MgaXQuXG4gKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIEFycmF5LjxBcnJheS48KGJvb2xlYW58dW5kZWZpbmVkKT4+Pn1cbiAqL1xudmFyIGNpcmNsZUFycmF5Q2FjaGUgPSB7XG4gIDA6IFtbdHJ1ZV1dXG59O1xuXG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmlsbHMgYSByb3cgaW4gdGhlIGFycmF5IGZyb20gdGhlIGdpdmVuIGNvb3JkaW5hdGUgdG8gdGhlXG4gKiBtaWRkbGUgd2l0aCBgdHJ1ZWAuXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48KGJvb2xlYW58dW5kZWZpbmVkKT4+fSBhcnJheSBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIGFsdGVyZWQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKi9cbmZ1bmN0aW9uIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFycmF5LCB4LCB5KSB7XG4gIHZhciBpO1xuICB2YXIgcmFkaXVzID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyAyKTtcbiAgaWYgKHggPj0gcmFkaXVzKSB7XG4gICAgZm9yIChpID0gcmFkaXVzOyBpIDwgeDsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHggPCByYWRpdXMpIHtcbiAgICBmb3IgKGkgPSB4ICsgMTsgaSA8IHJhZGl1czsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgY3JlYXRlcyBhIGNpcmNsZSBpbnNpZGUgYSBmaXR0aW5nIGFycmF5LiBQb2ludHMgaW5zaWRlIHRoZVxuICogY2lyY2xlIGFyZSBtYXJrZWQgYnkgdHJ1ZSwgcG9pbnRzIG9uIHRoZSBvdXRzaWRlIGFyZSB1bmRlZmluZWQuXG4gKiBJdCB1c2VzIHRoZSBtaWRwb2ludCBjaXJjbGUgYWxnb3JpdGhtLlxuICogQSBjYWNoZSBpcyB1c2VkIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjwoYm9vbGVhbnx1bmRlZmluZWQpPj59IEFuIGFycmF5IHdpdGggbWFya2VkIGNpcmNsZSBwb2ludHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaXJjbGVBcnJheShyYWRpdXMpIHtcbiAgaWYgKGNpcmNsZUFycmF5Q2FjaGVbcmFkaXVzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNpcmNsZUFycmF5Q2FjaGVbcmFkaXVzXTtcbiAgfVxuXG4gIHZhciBhcnJheVNpemUgPSByYWRpdXMgKiAyICsgMTtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShhcnJheVNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5U2l6ZTsgaSsrKSB7XG4gICAgYXJyW2ldID0gbmV3IEFycmF5KGFycmF5U2l6ZSk7XG4gIH1cblxuICB2YXIgeCA9IHJhZGl1cztcbiAgdmFyIHkgPSAwO1xuICB2YXIgZXJyb3IgPSAwO1xuXG4gIHdoaWxlICh4ID49IHkpIHtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyArIHgsIHJhZGl1cyArIHkpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeSwgcmFkaXVzICsgeCk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgLSB5LCByYWRpdXMgKyB4KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHgsIHJhZGl1cyArIHkpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzIC0geCwgcmFkaXVzIC0geSk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgLSB5LCByYWRpdXMgLSB4KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyArIHksIHJhZGl1cyAtIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeCwgcmFkaXVzIC0geSk7XG5cbiAgICB5Kys7XG4gICAgZXJyb3IgKz0gMSArIDIgKiB5O1xuICAgIGlmICgyICogKGVycm9yIC0geCkgKyAxID4gMCkge1xuICAgICAgeCAtPSAxO1xuICAgICAgZXJyb3IgKz0gMSAtIDIgKiB4O1xuICAgIH1cbiAgfVxuXG4gIGNpcmNsZUFycmF5Q2FjaGVbcmFkaXVzXSA9IGFycjtcbiAgcmV0dXJuIGFycjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCBBcnJheS48Kj4+fSBkZWNsdXR0ZXJSZXBsYXlzIERlY2x1dHRlciByZXBsYXlzLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxheURlY2x1dHRlcihkZWNsdXR0ZXJSZXBsYXlzLCBjb250ZXh0LCByb3RhdGlvbikge1xuICB2YXIgenMgPSBPYmplY3Qua2V5cyhkZWNsdXR0ZXJSZXBsYXlzKS5tYXAoTnVtYmVyKS5zb3J0KG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24pO1xuICB2YXIgc2tpcHBlZEZlYXR1cmVVaWRzID0ge307XG4gIGZvciAodmFyIHogPSAwLCB6eiA9IHpzLmxlbmd0aDsgeiA8IHp6OyArK3opIHtcbiAgICB2YXIgcmVwbGF5RGF0YSA9IGRlY2x1dHRlclJlcGxheXNbenNbel0udG9TdHJpbmcoKV07XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcmVwbGF5RGF0YS5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgIHZhciByZXBsYXkgPSByZXBsYXlEYXRhW2krK107XG4gICAgICB2YXIgdHJhbnNmb3JtID0gcmVwbGF5RGF0YVtpKytdO1xuICAgICAgcmVwbGF5LnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMpO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlcGxheUdyb3VwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBsYXlHcm91cC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9UZXh0UmVwbGF5XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7bWF0Y2hpbmdDaHVua30gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3N0cmFpZ2h0Y2h1bmsuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi8uLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge0NBTlZBU19MSU5FX0RBU0h9IGZyb20gJy4uLy4uL2hhcy5qcyc7XG5pbXBvcnQge2xhYmVsQ2FjaGUsIG1lYXN1cmVUZXh0V2lkdGgsIGRlZmF1bHRUZXh0QWxpZ24sIG1lYXN1cmVUZXh0SGVpZ2h0LCBkZWZhdWx0UGFkZGluZywgZGVmYXVsdExpbmVDYXAsIGRlZmF1bHRMaW5lRGFzaE9mZnNldCwgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRGaWxsU3R5bGUsIGNoZWNrRm9udCwgZGVmYXVsdEZvbnQsIGRlZmF1bHRMaW5lV2lkdGgsIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRUZXh0QmFzZWxpbmV9IGZyb20gJy4uL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW5zdHJ1Y3Rpb24gZnJvbSAnLi4vY2FudmFzL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi4vY2FudmFzL1JlcGxheS5qcyc7XG5pbXBvcnQge1RFWFRfQUxJR059IGZyb20gJy4uL3JlcGxheS5qcyc7XG5pbXBvcnQgVGV4dFBsYWNlbWVudCBmcm9tICcuLi8uLi9zdHlsZS9UZXh0UGxhY2VtZW50LmpzJztcblxudmFyIENhbnZhc1RleHRSZXBsYXkgPSAoZnVuY3Rpb24gKENhbnZhc1JlcGxheSkge1xuICBmdW5jdGlvbiBDYW52YXNUZXh0UmVwbGF5KHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIENhbnZhc1JlcGxheS5jYWxsKHRoaXMsIHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35EZWNsdXR0ZXJHcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckdyb3VwXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5LjxIVE1MQ2FudmFzRWxlbWVudD59XG4gICAgICovXG4gICAgdGhpcy5sYWJlbHNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRSb3RhdGlvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5maWxsU3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+U3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzflN0cm9rZVN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+VGV4dFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0YXRlXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+VGV4dFN0YXRlfSAqLyAoe30pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3JlbmRlci9jYW52YXN+VGV4dFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRLZXlfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5maWxsS2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlS2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCBudW1iZXI+Pn1cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoc18gPSB7fTtcblxuICAgIGxhYmVsQ2FjaGUucHJ1bmUoKTtcblxuICB9XG5cbiAgaWYgKCBDYW52YXNSZXBsYXkgKSBDYW52YXNUZXh0UmVwbGF5Ll9fcHJvdG9fXyA9IENhbnZhc1JlcGxheTtcbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNSZXBsYXkgJiYgQ2FudmFzUmVwbGF5LnByb3RvdHlwZSApO1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RleHRSZXBsYXk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5kcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0IChnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgdmFyIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgaWYgKHRoaXMudGV4dF8gPT09ICcnIHx8ICF0ZXh0U3RhdGUgfHwgKCFmaWxsU3RhdGUgJiYgIXN0cm9rZVN0YXRlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICB2YXIgZmxhdENvb3JkaW5hdGVzID0gbnVsbDtcbiAgICB2YXIgZW5kID0gMjtcbiAgICB2YXIgc3RyaWRlID0gMjtcbiAgICB2YXIgaSwgaWk7XG5cbiAgICBpZiAodGV4dFN0YXRlLnBsYWNlbWVudCA9PT0gVGV4dFBsYWNlbWVudC5MSU5FKSB7XG4gICAgICBpZiAoIWludGVyc2VjdHModGhpcy5nZXRCdWZmZXJlZE1heEV4dGVudCgpLCBnZW9tZXRyeS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGVuZHM7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHN0cmlkZSA9IGdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgICAgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkcpIHtcbiAgICAgICAgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORykge1xuICAgICAgICBlbmRzID0gZ2VvbWV0cnkuZ2V0RW5kcygpO1xuICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04pIHtcbiAgICAgICAgZW5kcyA9IGdlb21ldHJ5LmdldEVuZHMoKS5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OKSB7XG4gICAgICAgIHZhciBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICAgIGVuZHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgZW5kcy5wdXNoKGVuZHNzW2ldWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgIHZhciB0ZXh0QWxpZ24gPSB0ZXh0U3RhdGUudGV4dEFsaWduO1xuICAgICAgdmFyIGZsYXRPZmZzZXQgPSAwO1xuICAgICAgdmFyIGZsYXRFbmQ7XG4gICAgICBmb3IgKHZhciBvID0gMCwgb28gPSBlbmRzLmxlbmd0aDsgbyA8IG9vOyArK28pIHtcbiAgICAgICAgaWYgKHRleHRBbGlnbiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBtYXRjaGluZ0NodW5rKHRleHRTdGF0ZS5tYXhBbmdsZSwgZmxhdENvb3JkaW5hdGVzLCBmbGF0T2Zmc2V0LCBlbmRzW29dLCBzdHJpZGUpO1xuICAgICAgICAgIGZsYXRPZmZzZXQgPSByYW5nZVswXTtcbiAgICAgICAgICBmbGF0RW5kID0gcmFuZ2VbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEVuZCA9IGVuZHNbb107XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gZmxhdE9mZnNldDsgaSA8IGZsYXRFbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgdGhpcyQxLmNvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzW2ldLCBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSB0aGlzJDEuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICBmbGF0T2Zmc2V0ID0gZW5kc1tvXTtcbiAgICAgICAgdGhpcyQxLmRyYXdDaGFyc18oYmVnaW4sIGVuZCwgdGhpcyQxLmRlY2x1dHRlckdyb3VwXyk7XG4gICAgICAgIGJlZ2luID0gZW5kO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmRHZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5nZXRJbWFnZSh0aGlzLnRleHRfLCB0aGlzLnRleHRLZXlfLCB0aGlzLmZpbGxLZXlfLCB0aGlzLnN0cm9rZUtleV8pO1xuICAgICAgdmFyIHdpZHRoID0gbGFiZWwud2lkdGggLyB0aGlzLnBpeGVsUmF0aW87XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgZW5kID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5DSVJDTEU6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9DaXJjbGV9ICovIChnZW9tZXRyeSkuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRNaWRwb2ludHMoKTtcbiAgICAgICAgICBlbmQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vUG9seWdvbn0gKi8gKGdlb21ldHJ5KS5nZXRGbGF0SW50ZXJpb3JQb2ludCgpO1xuICAgICAgICAgIGlmICghdGV4dFN0YXRlLm92ZXJmbG93ICYmIGZsYXRDb29yZGluYXRlc1syXSAvIHRoaXMucmVzb2x1dGlvbiA8IHdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgICAgdmFyIGludGVyaW9yUG9pbnRzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb259ICovIChnZW9tZXRyeSkuZ2V0RmxhdEludGVyaW9yUG9pbnRzKCk7XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBpbnRlcmlvclBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGV4dFN0YXRlLm92ZXJmbG93IHx8IGludGVyaW9yUG9pbnRzW2kgKyAyXSAvIHRoaXMkMS5yZXNvbHV0aW9uID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgIGZsYXRDb29yZGluYXRlcy5wdXNoKGludGVyaW9yUG9pbnRzW2ldLCBpbnRlcmlvclBvaW50c1tpICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChlbmQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIGVuZCA9IHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgMCwgZW5kLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsIHx8IHRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlKHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCwgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpO1xuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVGaWxsU3R5bGUodGhpcy5zdGF0ZSwgdGhpcy5jcmVhdGVGaWxsLCBnZW9tZXRyeSk7XG4gICAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNyZWF0ZUZpbGwodGhpcy5zdGF0ZSwgZ2VvbWV0cnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHRoaXMuc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2godGhpcy5jcmVhdGVTdHJva2UodGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJlZ2luR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgICAgdGhpcy5kcmF3VGV4dEltYWdlXyhsYWJlbCwgYmVnaW4sIGVuZCk7XG4gICAgICB0aGlzLmVuZEdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0S2V5IFRleHQgc3R5bGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsbEtleSBGaWxsIHN0eWxlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZUtleSBTdHJva2Ugc3R5bGUga2V5LlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2UuXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICh0ZXh0LCB0ZXh0S2V5LCBmaWxsS2V5LCBzdHJva2VLZXkpIHtcbiAgICB2YXIgbGFiZWw7XG4gICAgdmFyIGtleSA9IHN0cm9rZUtleSArIHRleHRLZXkgKyB0ZXh0ICsgZmlsbEtleSArIHRoaXMucGl4ZWxSYXRpbztcblxuICAgIGlmICghbGFiZWxDYWNoZS5jb250YWluc0tleShrZXkpKSB7XG4gICAgICB2YXIgc3Ryb2tlU3RhdGUgPSBzdHJva2VLZXkgPyB0aGlzLnN0cm9rZVN0YXRlc1tzdHJva2VLZXldIHx8IHRoaXMudGV4dFN0cm9rZVN0YXRlXyA6IG51bGw7XG4gICAgICB2YXIgZmlsbFN0YXRlID0gZmlsbEtleSA/IHRoaXMuZmlsbFN0YXRlc1tmaWxsS2V5XSB8fCB0aGlzLnRleHRGaWxsU3RhdGVfIDogbnVsbDtcbiAgICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV0gfHwgdGhpcy50ZXh0U3RhdGVfO1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB2YXIgc2NhbGUgPSB0ZXh0U3RhdGUuc2NhbGUgKiBwaXhlbFJhdGlvO1xuICAgICAgdmFyIGFsaWduID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ25dO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3Ryb2tlS2V5ICYmIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIG51bUxpbmVzID0gbGluZXMubGVuZ3RoO1xuICAgICAgdmFyIHdpZHRocyA9IFtdO1xuICAgICAgdmFyIHdpZHRoID0gbWVhc3VyZVRleHRXaWR0aHModGV4dFN0YXRlLmZvbnQsIGxpbmVzLCB3aWR0aHMpO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodCh0ZXh0U3RhdGUuZm9udCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gbGluZUhlaWdodCAqIG51bUxpbmVzO1xuICAgICAgdmFyIHJlbmRlcldpZHRoID0gKHdpZHRoICsgc3Ryb2tlV2lkdGgpO1xuICAgICAgdmFyIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIE1hdGguY2VpbChyZW5kZXJXaWR0aCAqIHNjYWxlKSxcbiAgICAgICAgTWF0aC5jZWlsKChoZWlnaHQgKyBzdHJva2VXaWR0aCkgKiBzY2FsZSkpO1xuICAgICAgbGFiZWwgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGxhYmVsQ2FjaGUuc2V0KGtleSwgbGFiZWwpO1xuICAgICAgaWYgKHNjYWxlICE9IDEpIHtcbiAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gc3Ryb2tlU3RhdGUubGluZUNhcDtcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0cm9rZVN0YXRlLmxpbmVKb2luO1xuICAgICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCAmJiBzdHJva2VTdGF0ZS5saW5lRGFzaC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFyIGxlZnRSaWdodCA9ICgwLjUgLSBhbGlnbik7XG4gICAgICB2YXIgeCA9IGFsaWduICogbGFiZWwud2lkdGggLyBzY2FsZSArIGxlZnRSaWdodCAqIHN0cm9rZVdpZHRoO1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1MaW5lczsgKytpKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2ldLCB4ICsgbGVmdFJpZ2h0ICogd2lkdGhzW2ldLCAwLjUgKiAoc3Ryb2tlV2lkdGggKyBsaW5lSGVpZ2h0KSArIGkgKiBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxLZXkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bUxpbmVzOyArK2kpIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2ldLCB4ICsgbGVmdFJpZ2h0ICogd2lkdGhzW2ldLCAwLjUgKiAoc3Ryb2tlV2lkdGggKyBsaW5lSGVpZ2h0KSArIGkgKiBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFiZWxDYWNoZS5nZXQoa2V5KTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gbGFiZWwgTGFiZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBDYW52YXNUZXh0UmVwbGF5LnByb3RvdHlwZS5kcmF3VGV4dEltYWdlXyA9IGZ1bmN0aW9uIGRyYXdUZXh0SW1hZ2VfIChsYWJlbCwgYmVnaW4sIGVuZCkge1xuICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgdmFyIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIHZhciBhbGlnbiA9IFRFWFRfQUxJR05bdGV4dFN0YXRlLnRleHRBbGlnbiB8fCBkZWZhdWx0VGV4dEFsaWduXTtcbiAgICB2YXIgYmFzZWxpbmUgPSBURVhUX0FMSUdOW3RleHRTdGF0ZS50ZXh0QmFzZWxpbmVdO1xuICAgIHZhciBzdHJva2VXaWR0aCA9IHN0cm9rZVN0YXRlICYmIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICB2YXIgYW5jaG9yWCA9IGFsaWduICogbGFiZWwud2lkdGggLyBwaXhlbFJhdGlvICsgMiAqICgwLjUgLSBhbGlnbikgKiBzdHJva2VXaWR0aDtcbiAgICB2YXIgYW5jaG9yWSA9IGJhc2VsaW5lICogbGFiZWwuaGVpZ2h0IC8gcGl4ZWxSYXRpbyArIDIgKiAoMC41IC0gYmFzZWxpbmUpICogc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgYmVnaW4sIGVuZCxcbiAgICAgIGxhYmVsLCAoYW5jaG9yWCAtIHRoaXMudGV4dE9mZnNldFhfKSAqIHBpeGVsUmF0aW8sIChhbmNob3JZIC0gdGhpcy50ZXh0T2Zmc2V0WV8pICogcGl4ZWxSYXRpbyxcbiAgICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XywgdGhpcy50ZXh0Um90YXRpb25fLFxuICAgICAgMSwgdHJ1ZSwgbGFiZWwud2lkdGgsXG4gICAgICB0ZXh0U3RhdGUucGFkZGluZyA9PSBkZWZhdWx0UGFkZGluZyA/XG4gICAgICAgIGRlZmF1bHRQYWRkaW5nIDogdGV4dFN0YXRlLnBhZGRpbmcubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gcCAqIHBpeGVsUmF0aW87XG4gICAgICAgIH0pLFxuICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwsICEhdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2VcbiAgICBdKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBiZWdpbiwgZW5kLFxuICAgICAgbGFiZWwsIChhbmNob3JYIC0gdGhpcy50ZXh0T2Zmc2V0WF8pICogcGl4ZWxSYXRpbywgKGFuY2hvclkgLSB0aGlzLnRleHRPZmZzZXRZXykgKiBwaXhlbFJhdGlvLFxuICAgICAgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIGxhYmVsLmhlaWdodCwgMSwgMCwgMCwgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfLCB0aGlzLnRleHRSb3RhdGlvbl8sXG4gICAgICAxIC8gcGl4ZWxSYXRpbywgdHJ1ZSwgbGFiZWwud2lkdGgsIHRleHRTdGF0ZS5wYWRkaW5nLFxuICAgICAgISF0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwsICEhdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2VcbiAgICBdKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35EZWNsdXR0ZXJHcm91cH0gZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyIGdyb3VwLlxuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuZHJhd0NoYXJzXyA9IGZ1bmN0aW9uIGRyYXdDaGFyc18gKGJlZ2luLCBlbmQsIGRlY2x1dHRlckdyb3VwKSB7XG4gICAgdmFyIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIHZhciB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgdmFyIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG5cbiAgICB2YXIgc3Ryb2tlS2V5ID0gdGhpcy5zdHJva2VLZXlfO1xuICAgIGlmIChzdHJva2VTdGF0ZSkge1xuICAgICAgaWYgKCEoc3Ryb2tlS2V5IGluIHRoaXMuc3Ryb2tlU3RhdGVzKSkge1xuICAgICAgICB0aGlzLnN0cm9rZVN0YXRlc1tzdHJva2VLZXldID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35TdHJva2VTdGF0ZX0gKi8gKHtcbiAgICAgICAgICBzdHJva2VTdHlsZTogc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUsXG4gICAgICAgICAgbGluZUNhcDogc3Ryb2tlU3RhdGUubGluZUNhcCxcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgbGluZVdpZHRoOiBzdHJva2VTdGF0ZS5saW5lV2lkdGgsXG4gICAgICAgICAgbGluZUpvaW46IHN0cm9rZVN0YXRlLmxpbmVKb2luLFxuICAgICAgICAgIG1pdGVyTGltaXQ6IHN0cm9rZVN0YXRlLm1pdGVyTGltaXQsXG4gICAgICAgICAgbGluZURhc2g6IHN0cm9rZVN0YXRlLmxpbmVEYXNoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGV4dEtleSA9IHRoaXMudGV4dEtleV87XG4gICAgaWYgKCEodGhpcy50ZXh0S2V5XyBpbiB0aGlzLnRleHRTdGF0ZXMpKSB7XG4gICAgICB0aGlzLnRleHRTdGF0ZXNbdGhpcy50ZXh0S2V5X10gPSAvKiogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzflRleHRTdGF0ZX0gKi8gKHtcbiAgICAgICAgZm9udDogdGV4dFN0YXRlLmZvbnQsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dFN0YXRlLnRleHRBbGlnbiB8fCBkZWZhdWx0VGV4dEFsaWduLFxuICAgICAgICBzY2FsZTogdGV4dFN0YXRlLnNjYWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGZpbGxLZXkgPSB0aGlzLmZpbGxLZXlfO1xuICAgIGlmIChmaWxsU3RhdGUpIHtcbiAgICAgIGlmICghKGZpbGxLZXkgaW4gdGhpcy5maWxsU3RhdGVzKSkge1xuICAgICAgICB0aGlzLmZpbGxTdGF0ZXNbZmlsbEtleV0gPSAvKiogQHR5cGUge21vZHVsZTpvbC9yZW5kZXIvY2FudmFzfkZpbGxTdGF0ZX0gKi8gKHtcbiAgICAgICAgICBmaWxsU3R5bGU6IGZpbGxTdGF0ZS5maWxsU3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgdmFyIGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXTtcblxuICAgIHZhciBvZmZzZXRZID0gdGhpcy50ZXh0T2Zmc2V0WV8gKiBwaXhlbFJhdGlvO1xuICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0XztcbiAgICB2YXIgZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgIHZhciB0ZXh0U2NhbGUgPSB0ZXh0U3RhdGUuc2NhbGU7XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gc3Ryb2tlU3RhdGUgPyBzdHJva2VTdGF0ZS5saW5lV2lkdGggKiB0ZXh0U2NhbGUgLyAyIDogMDtcbiAgICB2YXIgd2lkdGhzID0gdGhpcy53aWR0aHNfW2ZvbnRdO1xuICAgIGlmICghd2lkdGhzKSB7XG4gICAgICB0aGlzLndpZHRoc19bZm9udF0gPSB3aWR0aHMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19DSEFSUyxcbiAgICAgIGJlZ2luLCBlbmQsIGJhc2VsaW5lLCBkZWNsdXR0ZXJHcm91cCxcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdywgZmlsbEtleSwgdGV4dFN0YXRlLm1heEFuZ2xlLFxuICAgICAgZnVuY3Rpb24odGV4dCkge1xuICAgICAgICB2YXIgd2lkdGggPSB3aWR0aHNbdGV4dF07XG4gICAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IHdpZHRoc1t0ZXh0XSA9IG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpZHRoICogdGV4dFNjYWxlICogcGl4ZWxSYXRpbztcbiAgICAgIH0sXG4gICAgICBvZmZzZXRZLCBzdHJva2VLZXksIHN0cm9rZVdpZHRoICogcGl4ZWxSYXRpbywgdGV4dCwgdGV4dEtleSwgMVxuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfQ0hBUlMsXG4gICAgICBiZWdpbiwgZW5kLCBiYXNlbGluZSwgZGVjbHV0dGVyR3JvdXAsXG4gICAgICB0ZXh0U3RhdGUub3ZlcmZsb3csIGZpbGxLZXksIHRleHRTdGF0ZS5tYXhBbmdsZSxcbiAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gd2lkdGhzW3RleHRdO1xuICAgICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSB3aWR0aHNbdGV4dF0gPSBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aCAqIHRleHRTY2FsZTtcbiAgICAgIH0sXG4gICAgICBvZmZzZXRZLCBzdHJva2VLZXksIHN0cm9rZVdpZHRoLCB0ZXh0LCB0ZXh0S2V5LCAxIC8gcGl4ZWxSYXRpb1xuICAgIF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGV4dFJlcGxheS5wcm90b3R5cGUuc2V0VGV4dFN0eWxlID0gZnVuY3Rpb24gc2V0VGV4dFN0eWxlICh0ZXh0U3R5bGUsIGRlY2x1dHRlckdyb3VwKSB7XG4gICAgdmFyIHRleHRTdGF0ZSwgZmlsbFN0YXRlLCBzdHJva2VTdGF0ZTtcbiAgICBpZiAoIXRleHRTdHlsZSkge1xuICAgICAgdGhpcy50ZXh0XyA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RGVjbHV0dGVyR3JvdXB9ICovIChkZWNsdXR0ZXJHcm91cCk7XG5cbiAgICAgIHZhciB0ZXh0RmlsbFN0eWxlID0gdGV4dFN0eWxlLmdldEZpbGwoKTtcbiAgICAgIGlmICghdGV4dEZpbGxTdHlsZSkge1xuICAgICAgICBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV87XG4gICAgICAgIGlmICghZmlsbFN0YXRlKSB7XG4gICAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXN+RmlsbFN0YXRlfSAqLyAoe30pO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxTdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShcbiAgICAgICAgICB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0U3Ryb2tlU3R5bGUgPSB0ZXh0U3R5bGUuZ2V0U3Ryb2tlKCk7XG4gICAgICBpZiAoIXRleHRTdHJva2VTdHlsZSkge1xuICAgICAgICBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICAgICAgaWYgKCFzdHJva2VTdGF0ZSkge1xuICAgICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35TdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZURhc2ggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVEYXNoT2Zmc2V0KCk7XG4gICAgICAgIHZhciBsaW5lV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIG1pdGVyTGltaXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKSB8fCBkZWZhdWx0TGluZUNhcDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2ggPSBsaW5lRGFzaCA/IGxpbmVEYXNoLnNsaWNlKCkgOiBkZWZhdWx0TGluZURhc2g7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ID1cbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TGluZURhc2hPZmZzZXQgOiBsaW5lRGFzaE9mZnNldDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKSB8fCBkZWZhdWx0TGluZUpvaW47XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA9XG4gICAgICAgICAgICBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRMaW5lV2lkdGggOiBsaW5lV2lkdGg7XG4gICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQgPVxuICAgICAgICAgICAgbWl0ZXJMaW1pdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pdGVyTGltaXQgOiBtaXRlckxpbWl0O1xuICAgICAgICBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA9IGFzQ29sb3JMaWtlKFxuICAgICAgICAgIHRleHRTdHJva2VTdHlsZS5nZXRDb2xvcigpIHx8IGRlZmF1bHRTdHJva2VTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICAgIHZhciBmb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKSB8fCBkZWZhdWx0Rm9udDtcbiAgICAgIGNoZWNrRm9udChmb250KTtcbiAgICAgIHZhciB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGUoKTtcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyA9IHRleHRTdHlsZS5nZXRPdmVyZmxvdygpO1xuICAgICAgdGV4dFN0YXRlLmZvbnQgPSBmb250O1xuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlID0gdGV4dFN0eWxlLmdldE1heEFuZ2xlKCk7XG4gICAgICB0ZXh0U3RhdGUucGxhY2VtZW50ID0gdGV4dFN0eWxlLmdldFBsYWNlbWVudCgpO1xuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgZGVmYXVsdFRleHRCYXNlbGluZTtcbiAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCA9IHRleHRTdHlsZS5nZXRCYWNrZ3JvdW5kRmlsbCgpO1xuICAgICAgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UgPSB0ZXh0U3R5bGUuZ2V0QmFja2dyb3VuZFN0cm9rZSgpO1xuICAgICAgdGV4dFN0YXRlLnBhZGRpbmcgPSB0ZXh0U3R5bGUuZ2V0UGFkZGluZygpIHx8IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgdGV4dFN0YXRlLnNjYWxlID0gdGV4dFNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogdGV4dFNjYWxlO1xuXG4gICAgICB2YXIgdGV4dE9mZnNldFggPSB0ZXh0U3R5bGUuZ2V0T2Zmc2V0WCgpO1xuICAgICAgdmFyIHRleHRPZmZzZXRZID0gdGV4dFN0eWxlLmdldE9mZnNldFkoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIHZhciB0ZXh0Um90YXRpb24gPSB0ZXh0U3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICAgIHRoaXMudGV4dF8gPSB0ZXh0U3R5bGUuZ2V0VGV4dCgpIHx8ICcnO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSB0ZXh0T2Zmc2V0WCA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRPZmZzZXRYO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WV8gPSB0ZXh0T2Zmc2V0WSA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRPZmZzZXRZO1xuICAgICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gdGV4dFJvdGF0ZVdpdGhWaWV3ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRleHRSb3RhdGVXaXRoVmlldztcbiAgICAgIHRoaXMudGV4dFJvdGF0aW9uXyA9IHRleHRSb3RhdGlvbiA9PT0gdW5kZWZpbmVkID8gMCA6IHRleHRSb3RhdGlvbjtcblxuICAgICAgdGhpcy5zdHJva2VLZXlfID0gc3Ryb2tlU3RhdGUgP1xuICAgICAgICAodHlwZW9mIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID09ICdzdHJpbmcnID8gc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgOiBnZXRVaWQoc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUpKSArXG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgKyBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCArICd8JyArIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCArXG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVKb2luICsgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCArICdbJyArIHN0cm9rZVN0YXRlLmxpbmVEYXNoLmpvaW4oKSArICddJyA6XG4gICAgICAgICcnO1xuICAgICAgdGhpcy50ZXh0S2V5XyA9IHRleHRTdGF0ZS5mb250ICsgdGV4dFN0YXRlLnNjYWxlICsgKHRleHRTdGF0ZS50ZXh0QWxpZ24gfHwgJz8nKTtcbiAgICAgIHRoaXMuZmlsbEtleV8gPSBmaWxsU3RhdGUgP1xuICAgICAgICAodHlwZW9mIGZpbGxTdGF0ZS5maWxsU3R5bGUgPT0gJ3N0cmluZycgPyBmaWxsU3RhdGUuZmlsbFN0eWxlIDogKCd8JyArIGdldFVpZChmaWxsU3RhdGUuZmlsbFN0eWxlKSkpIDpcbiAgICAgICAgJyc7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNUZXh0UmVwbGF5O1xufShDYW52YXNSZXBsYXkpKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsaW5lcyBMaW5lcyB0byBtZWFzdXJlLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gd2lkdGhzIEFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggdGhlIHdpZHRocyBvZlxuICogZWFjaCBsaW5lLlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBvZiB0aGUgd2hvbGUgdGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGhzKGZvbnQsIGxpbmVzLCB3aWR0aHMpIHtcbiAgdmFyIG51bUxpbmVzID0gbGluZXMubGVuZ3RoO1xuICB2YXIgd2lkdGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpbmVzOyArK2kpIHtcbiAgICB2YXIgY3VycmVudFdpZHRoID0gbWVhc3VyZVRleHRXaWR0aChmb250LCBsaW5lc1tpXSk7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3VycmVudFdpZHRoKTtcbiAgICB3aWR0aHMucHVzaChjdXJyZW50V2lkdGgpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNUZXh0UmVwbGF5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0UmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvcmVwbGF5XG4gKi9cbmltcG9ydCBSZXBsYXlUeXBlIGZyb20gJy4uL3JlbmRlci9SZXBsYXlUeXBlLmpzJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvcmVuZGVyL1JlcGxheVR5cGU+fVxuICovXG5leHBvcnQgdmFyIE9SREVSID0gW1xuICBSZXBsYXlUeXBlLlBPTFlHT04sXG4gIFJlcGxheVR5cGUuQ0lSQ0xFLFxuICBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HLFxuICBSZXBsYXlUeXBlLklNQUdFLFxuICBSZXBsYXlUeXBlLlRFWFQsXG4gIFJlcGxheVR5cGUuREVGQVVMVFxuXTtcblxuLyoqXG4gKiBAY29uc3RcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVF9BTElHTiA9IHt9O1xuVEVYVF9BTElHTlsnbGVmdCddID0gMDtcblRFWFRfQUxJR05bJ2VuZCddID0gMDtcblRFWFRfQUxJR05bJ2NlbnRlciddID0gMC41O1xuVEVYVF9BTElHTlsncmlnaHQnXSA9IDE7XG5URVhUX0FMSUdOWydzdGFydCddID0gMTtcblRFWFRfQUxJR05bJ3RvcCddID0gMDtcblRFWFRfQUxJR05bJ21pZGRsZSddID0gMC41O1xuVEVYVF9BTElHTlsnaGFuZ2luZyddID0gMC4yO1xuVEVYVF9BTElHTlsnYWxwaGFiZXRpYyddID0gMC44O1xuVEVYVF9BTElHTlsnaWRlb2dyYXBoaWMnXSA9IDAuODtcblRFWFRfQUxJR05bJ2JvdHRvbSddID0gMTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwbGF5LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9MYXllclxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4uL09ic2VydmFibGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtGQUxTRSwgVU5ERUZJTkVEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cbnZhciBMYXllclJlbmRlcmVyID0gKGZ1bmN0aW9uIChPYnNlcnZhYmxlKSB7XG4gIGZ1bmN0aW9uIExheWVyUmVuZGVyZXIobGF5ZXIpIHtcblxuICAgIE9ic2VydmFibGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9sYXllci9MYXllcn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyXyA9IGxheWVyO1xuXG4gIH1cblxuICBpZiAoIE9ic2VydmFibGUgKSBMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IE9ic2VydmFibGU7XG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JzZXJ2YWJsZSAmJiBPYnNlcnZhYmxlLnByb3RvdHlwZSApO1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgYWRkcyBsb2FkZWQgdGlsZXMgdG8gdGhlIHRpbGUgbG9va3VwLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvVGlsZX0gc291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgdGlsZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxudW1iZXIsIE9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvVGlsZT4+fSB0aWxlcyBMb29rdXAgb2YgbG9hZGVkIHRpbGVzIGJ5IHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlciwgbW9kdWxlOm9sL1RpbGVSYW5nZSk6Ym9vbGVhbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggYSB6b29tIGxldmVsIGFuZCBhIHRpbGUgcmFuZ2UgdG8gYWRkIGxvYWRlZCB0aWxlcyB0byB0aGUgbG9va3VwLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMb2FkZWRUaWxlRmluZGVyID0gZnVuY3Rpb24gY3JlYXRlTG9hZGVkVGlsZUZpbmRlciAoc291cmNlLCBwcm9qZWN0aW9uLCB0aWxlcykge1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFpvb20gbGV2ZWwuXG4gICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgcmFuZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbih6b29tLCB0aWxlUmFuZ2UpIHtcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2sodGlsZSkge1xuICAgICAgICAgIGlmICghdGlsZXNbem9vbV0pIHtcbiAgICAgICAgICAgIHRpbGVzW3pvb21dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRpbGVzW3pvb21dW3RpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCldID0gdGlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlLmZvckVhY2hMb2FkZWRUaWxlKHByb2plY3Rpb24sIHpvb20sIHRpbGVSYW5nZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9sYXllci9MYXllcn0gTGF5ZXIuXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXllciA9IGZ1bmN0aW9uIGdldExheWVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2ZW50IEltYWdlIGNoYW5nZSBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUltYWdlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZUltYWdlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB2YXIgaW1hZ2UgPSAvKiogQHR5cGUge21vZHVsZTpvbC9JbWFnZX0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKGltYWdlLmdldFN0YXRlKCkgPT09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBpZiBub3QgYWxyZWFkeSBsb2FkZWQsIGFuZCByZWdpc3RlciB0aGUgaW1hZ2UgY2hhbmdlXG4gICAqIGxpc3RlbmVyIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvSW1hZ2VCYXNlfSBpbWFnZSBJbWFnZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uIGxvYWRJbWFnZSAoaW1hZ2UpIHtcbiAgICB2YXIgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgaWYgKGltYWdlU3RhdGUgIT0gSW1hZ2VTdGF0ZS5MT0FERUQgJiYgaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICBsaXN0ZW4oaW1hZ2UsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlSW1hZ2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICBpbWFnZS5sb2FkKCk7XG4gICAgICBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIExheWVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlID0gZnVuY3Rpb24gcmVuZGVySWZSZWFkeUFuZFZpc2libGUgKCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIGxheWVyLmdldFNvdXJjZVN0YXRlKCkgPT0gU291cmNlU3RhdGUuUkVBRFkpIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlfSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5zY2hlZHVsZUV4cGlyZUNhY2hlID0gZnVuY3Rpb24gc2NoZWR1bGVFeHBpcmVDYWNoZSAoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSkge1xuICAgIGlmICh0aWxlU291cmNlLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1RpbGV9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG1hcCBNYXAuXG4gICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHBvc3RSZW5kZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKHRpbGVTb3VyY2UsIG1hcCwgZnJhbWVTdGF0ZSkge1xuICAgICAgICB2YXIgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGlsZVNvdXJjZUtleSBpbiBmcmFtZVN0YXRlLnVzZWRUaWxlcykge1xuICAgICAgICAgIHRpbGVTb3VyY2UuZXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbixcbiAgICAgICAgICAgIGZyYW1lU3RhdGUudXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKG51bGwsIHRpbGVTb3VyY2UpO1xuXG4gICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChcbiAgICAgICAgLyoqIEB0eXBlIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwflBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKHBvc3RSZW5kZXJGdW5jdGlvbilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvVGlsZVJhbmdlPj59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvVGlsZX0gdGlsZVNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVXNlZFRpbGVzID0gZnVuY3Rpb24gdXBkYXRlVXNlZFRpbGVzICh1c2VkVGlsZXMsIHRpbGVTb3VyY2UsIHosIHRpbGVSYW5nZSkge1xuICAgIC8vIEZJWE1FIHNob3VsZCB3ZSB1c2UgdGlsZXNUb0RyYXdCeVogaW5zdGVhZD9cbiAgICB2YXIgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKS50b1N0cmluZygpO1xuICAgIHZhciB6S2V5ID0gei50b1N0cmluZygpO1xuICAgIGlmICh0aWxlU291cmNlS2V5IGluIHVzZWRUaWxlcykge1xuICAgICAgaWYgKHpLZXkgaW4gdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldKSB7XG4gICAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt6S2V5XS5leHRlbmQodGlsZVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XVt6S2V5XSA9IHRpbGVSYW5nZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV1bektleV0gPSB0aWxlUmFuZ2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGlsZSBweXJhbWlkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSB0aWxlcyBhdCB0aGVcbiAgICogY3VycmVudCB6b29tIGFuZCBsb3dlciB6b29tIGxldmVsczpcbiAgICogLSByZWdpc3RlcnMgaWRsZSB0aWxlcyBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzIHNvIHRoYXQgdGhleSBhcmUgbm90XG4gICAqICAgZGlzY2FyZGVkIGJ5IHRoZSB0aWxlIHF1ZXVlXG4gICAqIC0gZW5xdWV1ZXMgbWlzc2luZyB0aWxlc1xuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvc291cmNlL1RpbGV9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRaIEN1cnJlbnQgWi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZWxvYWQgTG9hZCBsb3cgcmVzb2x1dGlvbiB0aWxlcyB1cCB0byAncHJlbG9hZCcgbGV2ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFQsIG1vZHVsZTpvbC9UaWxlKT19IG9wdF90aWxlQ2FsbGJhY2sgVGlsZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtUPX0gb3B0X3RoaXMgT2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYG9wdF90aWxlQ2FsbGJhY2tgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuICBMYXllclJlbmRlcmVyLnByb3RvdHlwZS5tYW5hZ2VUaWxlUHlyYW1pZCA9IGZ1bmN0aW9uIG1hbmFnZVRpbGVQeXJhbWlkIChcbiAgICBmcmFtZVN0YXRlLFxuICAgIHRpbGVTb3VyY2UsXG4gICAgdGlsZUdyaWQsXG4gICAgcGl4ZWxSYXRpbyxcbiAgICBwcm9qZWN0aW9uLFxuICAgIGV4dGVudCxcbiAgICBjdXJyZW50WixcbiAgICBwcmVsb2FkLFxuICAgIG9wdF90aWxlQ2FsbGJhY2ssXG4gICAgb3B0X3RoaXNcbiAgKSB7XG4gICAgdmFyIHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSkudG9TdHJpbmcoKTtcbiAgICBpZiAoISh0aWxlU291cmNlS2V5IGluIGZyYW1lU3RhdGUud2FudGVkVGlsZXMpKSB7XG4gICAgICBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldID0ge307XG4gICAgfVxuICAgIHZhciB3YW50ZWRUaWxlcyA9IGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV07XG4gICAgdmFyIHRpbGVRdWV1ZSA9IGZyYW1lU3RhdGUudGlsZVF1ZXVlO1xuICAgIHZhciBtaW5ab29tID0gdGlsZUdyaWQuZ2V0TWluWm9vbSgpO1xuICAgIHZhciB0aWxlLCB0aWxlUmFuZ2UsIHRpbGVSZXNvbHV0aW9uLCB4LCB5LCB6O1xuICAgIGZvciAoeiA9IG1pblpvb207IHogPD0gY3VycmVudFo7ICsreikge1xuICAgICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHosIHRpbGVSYW5nZSk7XG4gICAgICB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgICBmb3IgKHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICAgIGZvciAoeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFogLSB6IDw9IHByZWxvYWQpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aWxlU291cmNlLmdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgIHdhbnRlZFRpbGVzW3RpbGUuZ2V0S2V5KCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKCF0aWxlUXVldWUuaXNLZXlRdWV1ZWQodGlsZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAgICAgICB0aWxlUXVldWUuZW5xdWV1ZShbdGlsZSwgdGlsZVNvdXJjZUtleSxcbiAgICAgICAgICAgICAgICAgIHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlLnRpbGVDb29yZCksIHRpbGVSZXNvbHV0aW9uXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRfdGlsZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgb3B0X3RpbGVDYWxsYmFjay5jYWxsKG9wdF90aGlzLCB0aWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlsZVNvdXJjZS51c2VUaWxlKHosIHgsIHksIHByb2plY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTGF5ZXJSZW5kZXJlcjtcbn0oT2JzZXJ2YWJsZSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIChtb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUpLCBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBUfVxuICogICAgIGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1N9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAqIEB0ZW1wbGF0ZSBTLFRcbiAqL1xuTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBVTkRFRklORUQ7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlP1xuICovXG5MYXllclJlbmRlcmVyLnByb3RvdHlwZS5oYXNGZWF0dXJlQXRDb29yZGluYXRlID0gRkFMU0U7XG5cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL01hcFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUUsIFVOREVGSU5FRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7dmlzaWJsZUF0UmVzb2x1dGlvbn0gZnJvbSAnLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkltYWdlQ2FjaGV9IGZyb20gJy4uL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzJztcbmltcG9ydCB7Y29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLCBpbnZlcnQgYXMgaW52ZXJ0VHJhbnNmb3JtLCBzZXRGcm9tQXJyYXkgYXMgdHJhbnNmb3JtU2V0RnJvbUFycmF5fSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuXG5cbnZhciBNYXBSZW5kZXJlciA9IChmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICBmdW5jdGlvbiBNYXBSZW5kZXJlcihtYXApIHtcbiAgICBEaXNwb3NhYmxlLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFwXyA9IG1hcDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3JlbmRlcmVyL0xheWVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3JlbmRlcmVyL0xheWVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfID0gW107XG5cbiAgfVxuXG4gIGlmICggRGlzcG9zYWJsZSApIE1hcFJlbmRlcmVyLl9fcHJvdG9fXyA9IERpc3Bvc2FibGU7XG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIERpc3Bvc2FibGUgJiYgRGlzcG9zYWJsZS5wcm90b3R5cGUgKTtcbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFwUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGxheWVyIHJlbmRlcmVyIGNvbnN0cnVjdG9ycy5cbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL3JlbmRlcmVyL0xheWVyPn0gY29uc3RydWN0b3JzIExheWVyIHJlbmRlcmVycy5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckxheWVyUmVuZGVyZXJzID0gZnVuY3Rpb24gcmVnaXN0ZXJMYXllclJlbmRlcmVycyAoY29uc3RydWN0b3JzKSB7XG4gICAgdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXy5wdXNoLmFwcGx5KHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc18sIGNvbnN0cnVjdG9ycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVnaXN0ZXJlZCBsYXllciByZW5kZXJlciBjb25zdHJ1Y3RvcnMuXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvcmVuZGVyZXIvTGF5ZXI+fSBSZWdpc3RlcmVkIGxheWVyIHJlbmRlcmVycy5cbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5nZXRMYXllclJlbmRlcmVyQ29uc3RydWN0b3JzID0gZnVuY3Rpb24gZ2V0TGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5jYWxjdWxhdGVNYXRyaWNlczJEID0gZnVuY3Rpb24gY2FsY3VsYXRlTWF0cmljZXMyRCAoZnJhbWVTdGF0ZSkge1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtO1xuICAgIHZhciBwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSA9IGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm07XG5cbiAgICBjb21wb3NlVHJhbnNmb3JtKGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLFxuICAgICAgZnJhbWVTdGF0ZS5zaXplWzBdIC8gMiwgZnJhbWVTdGF0ZS5zaXplWzFdIC8gMixcbiAgICAgIDEgLyB2aWV3U3RhdGUucmVzb2x1dGlvbiwgLTEgLyB2aWV3U3RhdGUucmVzb2x1dGlvbixcbiAgICAgIC12aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAtdmlld1N0YXRlLmNlbnRlclswXSwgLXZpZXdTdGF0ZS5jZW50ZXJbMV0pO1xuXG4gICAgaW52ZXJ0VHJhbnNmb3JtKFxuICAgICAgdHJhbnNmb3JtU2V0RnJvbUFycmF5KHBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsYXllciByZW5kZXJlcnMuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlTGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiByZW1vdmVMYXllclJlbmRlcmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmxheWVyUmVuZGVyZXJzXykge1xuICAgICAgdGhpcyQxLnJlbW92ZUxheWVyUmVuZGVyZXJCeUtleV8oa2V5KS5kaXNwb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCAobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSxcbiAgICogICAgIG1vZHVsZTpvbC9sYXllci9MYXllcik6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgbW9kdWxlOm9sL2xheWVyL0xheWVyKTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoXG4gICAgY29vcmRpbmF0ZSxcbiAgICBmcmFtZVN0YXRlLFxuICAgIGhpdFRvbGVyYW5jZSxcbiAgICBjYWxsYmFjayxcbiAgICB0aGlzQXJnLFxuICAgIGxheWVyRmlsdGVyLFxuICAgIHRoaXNBcmcyXG4gICkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHZpZXdSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllciBMYXllci5cbiAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgIHZhciBrZXkgPSBnZXRVaWQoZmVhdHVyZSkudG9TdHJpbmcoKTtcbiAgICAgIHZhciBtYW5hZ2VkID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc1tnZXRVaWQobGF5ZXIpXS5tYW5hZ2VkO1xuICAgICAgaWYgKCEoa2V5IGluIGZyYW1lU3RhdGUuc2tpcHBlZEZlYXR1cmVVaWRzICYmICFtYW5hZ2VkKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBtYW5hZ2VkID8gbGF5ZXIgOiBudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgdmFyIHRyYW5zbGF0ZWRDb29yZGluYXRlID0gY29vcmRpbmF0ZTtcbiAgICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gICAgICB2YXIgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICAgICAgaWYgKHggPCBwcm9qZWN0aW9uRXh0ZW50WzBdIHx8IHggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgIHZhciB3b3JsZHNBd2F5ID0gTWF0aC5jZWlsKChwcm9qZWN0aW9uRXh0ZW50WzBdIC0geCkgLyB3b3JsZFdpZHRoKTtcbiAgICAgICAgdHJhbnNsYXRlZENvb3JkaW5hdGUgPSBbeCArIHdvcmxkV2lkdGggKiB3b3JsZHNBd2F5LCBjb29yZGluYXRlWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJTdGF0ZXMgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgdmFyIG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tpXTtcbiAgICAgIHZhciBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBpZiAodmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCB2aWV3UmVzb2x1dGlvbikgJiYgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpKSB7XG4gICAgICAgIHZhciBsYXllclJlbmRlcmVyID0gdGhpcyQxLmdldExheWVyUmVuZGVyZXIobGF5ZXIpO1xuICAgICAgICBpZiAobGF5ZXIuZ2V0U291cmNlKCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBsYXllclJlbmRlcmVyLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgICAgICAgbGF5ZXIuZ2V0U291cmNlKCkuZ2V0V3JhcFgoKSA/IHRyYW5zbGF0ZWRDb29yZGluYXRlIDogY29vcmRpbmF0ZSxcbiAgICAgICAgICAgIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUsIHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9waXhlbH5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgbW9kdWxlOm9sL2xheWVyL0xheWVyLCAoVWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheSkpOiBUfSBjYWxsYmFjayBMYXllclxuICAgKiAgICAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgbW9kdWxlOm9sL2xheWVyL0xheWVyKTogYm9vbGVhbn0gbGF5ZXJGaWx0ZXIgTGF5ZXIgZmlsdGVyXG4gICAqICAgICBmdW5jdGlvbiwgb25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uXG4gICAqICAgICByZXR1cm5zIGB0cnVlYCB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuICBCeSBkZWZhdWx0LCBhbGwgdmlzaWJsZVxuICAgKiAgICAgbGF5ZXJzIHdpbGwgYmUgdGVzdGVkLlxuICAgKiBAcGFyYW0ge1V9IHRoaXNBcmcyIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxheWVyRmlsdGVyYC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFMsVCxVXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0UGl4ZWwgKHBpeGVsLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnLCBsYXllckZpbHRlciwgdGhpc0FyZzIpIHt9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBVLCBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIpOiBib29sZWFufSBsYXllckZpbHRlciBMYXllciBmaWx0ZXJcbiAgICogICAgIGZ1bmN0aW9uLCBvbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb25cbiAgICogICAgIHJldHVybnMgYHRydWVgIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlXG4gICAqICAgICBsYXllcnMgd2lsbCBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7VX0gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZT9cbiAgICogQHRlbXBsYXRlIFVcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5oYXNGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gaGFzRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBsYXllckZpbHRlciwgdGhpc0FyZykge1xuICAgIHZhciBoYXNGZWF0dXJlID0gdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgVFJVRSwgdGhpcywgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcpO1xuXG4gICAgcmV0dXJuIGhhc0ZlYXR1cmUgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9IGxheWVyIExheWVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9yZW5kZXJlci9MYXllcn0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXJSZW5kZXJlciA9IGZ1bmN0aW9uIGdldExheWVyUmVuZGVyZXIgKGxheWVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGF5ZXJLZXkgPSBnZXRVaWQobGF5ZXIpLnRvU3RyaW5nKCk7XG4gICAgaWYgKGxheWVyS2V5IGluIHRoaXMubGF5ZXJSZW5kZXJlcnNfKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVuZGVyZXI7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHRoaXMkMS5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzX1tpXTtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZVsnaGFuZGxlcyddKGxheWVyKSkge1xuICAgICAgICAgIHJlbmRlcmVyID0gY2FuZGlkYXRlWydjcmVhdGUnXSh0aGlzJDEsIGxheWVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XSA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfW2xheWVyS2V5XSA9IGxpc3RlbihyZW5kZXJlcixcbiAgICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyUmVuZGVyZXJDaGFuZ2VfLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSByZW5kZXJlciBmb3IgbGF5ZXI6ICcgKyBsYXllci5nZXRUeXBlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyS2V5IExheWVyIGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvcmVuZGVyZXIvTGF5ZXJ9IExheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmdldExheWVyUmVuZGVyZXJCeUtleSA9IGZ1bmN0aW9uIGdldExheWVyUmVuZGVyZXJCeUtleSAobGF5ZXJLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvcmVuZGVyZXIvTGF5ZXI+fSBMYXllciByZW5kZXJlcnMuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiBnZXRMYXllclJlbmRlcmVycyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJSZW5kZXJlcnNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfSBNYXAuXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBhIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUxheWVyUmVuZGVyZXJDaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlTGF5ZXJSZW5kZXJlckNoYW5nZV8gKCkge1xuICAgIHRoaXMubWFwXy5yZW5kZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyS2V5IExheWVyIGtleS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3JlbmRlcmVyL0xheWVyfSBMYXllciByZW5kZXJlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfID0gZnVuY3Rpb24gcmVtb3ZlTGF5ZXJSZW5kZXJlckJ5S2V5XyAobGF5ZXJLZXkpIHtcbiAgICB2YXIgbGF5ZXJSZW5kZXJlciA9IHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XTtcbiAgICBkZWxldGUgdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuXG4gICAgdW5saXN0ZW5CeUtleSh0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfW2xheWVyS2V5XSk7XG4gICAgZGVsZXRlIHRoaXMubGF5ZXJSZW5kZXJlckxpc3RlbmVyc19bbGF5ZXJLZXldO1xuXG4gICAgcmV0dXJuIGxheWVyUmVuZGVyZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH0gbWFwIE1hcC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXBSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnNfID0gZnVuY3Rpb24gcmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnNfIChtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGxheWVyS2V5IGluIHRoaXMkMS5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIGlmICghZnJhbWVTdGF0ZSB8fCAhKGxheWVyS2V5IGluIGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXMpKSB7XG4gICAgICAgIHRoaXMkMS5yZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfKGxheWVyS2V5KS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlID0gZnVuY3Rpb24gc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUgKGZyYW1lU3RhdGUpIHtcbiAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaCgvKiogQHR5cGUge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAoZXhwaXJlSWNvbkNhY2hlKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IW1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgTWFwUmVuZGVyZXIucHJvdG90eXBlLnNjaGVkdWxlUmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnMgPSBmdW5jdGlvbiBzY2hlZHVsZVJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzIChmcmFtZVN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBsYXllcktleSBpbiB0aGlzJDEubGF5ZXJSZW5kZXJlcnNfKSB7XG4gICAgICBpZiAoIShsYXllcktleSBpbiBmcmFtZVN0YXRlLmxheWVyU3RhdGVzKSkge1xuICAgICAgICBmcmFtZVN0YXRlLnBvc3RSZW5kZXJGdW5jdGlvbnMucHVzaChcbiAgICAgICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAodGhpcyQxLnJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzXy5iaW5kKHRoaXMkMSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1hcFJlbmRlcmVyO1xufShEaXNwb3NhYmxlKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB9IG1hcCBNYXAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZXhwaXJlSWNvbkNhY2hlKG1hcCwgZnJhbWVTdGF0ZSkge1xuICBpY29uSW1hZ2VDYWNoZS5leHBpcmUoKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlci5cbiAqIEBwYXJhbSB7P21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAqL1xuTWFwUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gVU5ERUZJTkVEO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGV9IHN0YXRlMSBGaXJzdCBsYXllciBzdGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyflN0YXRlfSBzdGF0ZTIgU2Vjb25kIGxheWVyIHN0YXRlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgekluZGV4IGRpZmZlcmVuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlaSW5kZXgoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgcmV0dXJuIHN0YXRlMS56SW5kZXggLSBzdGF0ZTIuekluZGV4O1xufVxuZXhwb3J0IGRlZmF1bHQgTWFwUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hcC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL0ltYWdlTGF5ZXJcbiAqL1xuaW1wb3J0IHtFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTn0gZnJvbSAnLi4vLi4vcmVwcm9qL2NvbW1vbi5qcyc7XG5pbXBvcnQgSW1hZ2VDYW52YXMgZnJvbSAnLi4vLi4vSW1hZ2VDYW52YXMuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7ZXF1YWxzfSBmcm9tICcuLi8uLi9hcnJheS5qcyc7XG5pbXBvcnQge2dldEhlaWdodCwgZ2V0SW50ZXJzZWN0aW9uLCBnZXRXaWR0aCwgaXNFbXB0eX0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBWZWN0b3JSZW5kZXJUeXBlIGZyb20gJy4uLy4uL2xheWVyL1ZlY3RvclJlbmRlclR5cGUuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4uLy4uL29iai5qcyc7XG5pbXBvcnQge2xheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnN9IGZyb20gJy4vTWFwLmpzJztcbmltcG9ydCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciBmcm9tICcuL0ludGVybWVkaWF0ZUNhbnZhcy5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIGltYWdlIGxheWVycy5cbiAqIEBhcGlcbiAqL1xudmFyIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlciA9IChmdW5jdGlvbiAoSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyKGltYWdlTGF5ZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXG4gICAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIuY2FsbCh0aGlzLCBpbWFnZUxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvSW1hZ2VCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUFycmF5LjxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuc2tpcHBlZEZlYXR1cmVzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllcn1cbiAgICAgKi9cbiAgICB0aGlzLnZlY3RvclJlbmRlcmVyXyA9IG51bGw7XG5cbiAgICBpZiAoaW1hZ2VMYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5WRUNUT1IpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgY3RvciA9IGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNbaV07XG4gICAgICAgIGlmIChjdG9yICE9PSBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIgJiYgY3RvclsnaGFuZGxlcyddKGltYWdlTGF5ZXIpKSB7XG4gICAgICAgICAgdGhpcyQxLnZlY3RvclJlbmRlcmVyXyA9IG5ldyBjdG9yKGltYWdlTGF5ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyICkgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgJiYgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMudmVjdG9yUmVuZGVyZXJfKSB7XG4gICAgICB0aGlzLnZlY3RvclJlbmRlcmVyXy5kaXNwb3NlKCk7XG4gICAgfVxuICAgIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmltYWdlXyA/IG51bGwgOiB0aGlzLmltYWdlXy5nZXRJbWFnZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldEltYWdlVHJhbnNmb3JtICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVRyYW5zZm9ybV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuXG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcblxuICAgIHZhciBpbWFnZTtcbiAgICB2YXIgaW1hZ2VMYXllciA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL0ltYWdlfSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICB2YXIgaW1hZ2VTb3VyY2UgPSBpbWFnZUxheWVyLmdldFNvdXJjZSgpO1xuXG4gICAgdmFyIGhpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG5cbiAgICB2YXIgdmVjdG9yUmVuZGVyZXIgPSB0aGlzLnZlY3RvclJlbmRlcmVyXztcbiAgICB2YXIgcmVuZGVyZWRFeHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICBpZiAoIXZlY3RvclJlbmRlcmVyICYmIGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHJlbmRlcmVkRXh0ZW50LCBsYXllclN0YXRlLmV4dGVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFoaW50c1tWaWV3SGludC5BTklNQVRJTkddICYmICFoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10gJiZcbiAgICAgICAgIWlzRW1wdHkocmVuZGVyZWRFeHRlbnQpKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgICB2YXIgc291cmNlUHJvamVjdGlvbiA9IGltYWdlU291cmNlLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgaWYgKHNvdXJjZVByb2plY3Rpb24pIHtcbiAgICAgICAgICBwcm9qZWN0aW9uID0gc291cmNlUHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNraXBwZWRGZWF0dXJlcyA9IHRoaXMuc2tpcHBlZEZlYXR1cmVzXztcbiAgICAgIGlmICh2ZWN0b3JSZW5kZXJlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IHZlY3RvclJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIHZhciBpbWFnZUZyYW1lU3RhdGUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gKi8gKGFzc2lnbih7fSwgZnJhbWVTdGF0ZSwge1xuICAgICAgICAgIHNpemU6IFtcbiAgICAgICAgICAgIGdldFdpZHRoKHJlbmRlcmVkRXh0ZW50KSAvIHZpZXdSZXNvbHV0aW9uLFxuICAgICAgICAgICAgZ2V0SGVpZ2h0KHJlbmRlcmVkRXh0ZW50KSAvIHZpZXdSZXNvbHV0aW9uXG4gICAgICAgICAgXSxcbiAgICAgICAgICB2aWV3U3RhdGU6IC8qKiBAdHlwZSB7bW9kdWxlOm9sL1ZpZXd+U3RhdGV9ICovIChhc3NpZ24oe30sIGZyYW1lU3RhdGUudmlld1N0YXRlLCB7XG4gICAgICAgICAgICByb3RhdGlvbjogMFxuICAgICAgICAgIH0pKVxuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBuZXdTa2lwcGVkRmVhdHVyZXMgPSBPYmplY3Qua2V5cyhpbWFnZUZyYW1lU3RhdGUuc2tpcHBlZEZlYXR1cmVVaWRzKS5zb3J0KCk7XG4gICAgICAgIGltYWdlID0gbmV3IEltYWdlQ2FudmFzKHJlbmRlcmVkRXh0ZW50LCB2aWV3UmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgY29udGV4dC5jYW52YXMsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHZlY3RvclJlbmRlcmVyLnByZXBhcmVGcmFtZShpbWFnZUZyYW1lU3RhdGUsIGxheWVyU3RhdGUpICYmXG4gICAgICAgICAgICAgICh2ZWN0b3JSZW5kZXJlci5yZXBsYXlHcm91cENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgIWVxdWFscyhza2lwcGVkRmVhdHVyZXMsIG5ld1NraXBwZWRGZWF0dXJlcykpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGltYWdlRnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IGltYWdlRnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbztcbiAgICAgICAgICAgIHZlY3RvclJlbmRlcmVyLmNvbXBvc2UoY29udGV4dCwgaW1hZ2VGcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlcyA9IG5ld1NraXBwZWRGZWF0dXJlcztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gaW1hZ2VTb3VyY2UuZ2V0SW1hZ2UoXG4gICAgICAgICAgcmVuZGVyZWRFeHRlbnQsIHZpZXdSZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZSAmJiB0aGlzLmxvYWRJbWFnZShpbWFnZSkpIHtcbiAgICAgICAgdGhpcy5pbWFnZV8gPSBpbWFnZTtcbiAgICAgICAgdGhpcy5za2lwcGVkRmVhdHVyZXNfID0gc2tpcHBlZEZlYXR1cmVzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmltYWdlXykge1xuICAgICAgaW1hZ2UgPSB0aGlzLmltYWdlXztcbiAgICAgIHZhciBpbWFnZUV4dGVudCA9IGltYWdlLmdldEV4dGVudCgpO1xuICAgICAgdmFyIGltYWdlUmVzb2x1dGlvbiA9IGltYWdlLmdldFJlc29sdXRpb24oKTtcbiAgICAgIHZhciBpbWFnZVBpeGVsUmF0aW8gPSBpbWFnZS5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICB2YXIgc2NhbGUgPSBwaXhlbFJhdGlvICogaW1hZ2VSZXNvbHV0aW9uIC9cbiAgICAgICAgICAodmlld1Jlc29sdXRpb24gKiBpbWFnZVBpeGVsUmF0aW8pO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5pbWFnZVRyYW5zZm9ybV8sXG4gICAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyLFxuICAgICAgICBzY2FsZSwgc2NhbGUsXG4gICAgICAgIDAsXG4gICAgICAgIGltYWdlUGl4ZWxSYXRpbyAqIChpbWFnZUV4dGVudFswXSAtIHZpZXdDZW50ZXJbMF0pIC8gaW1hZ2VSZXNvbHV0aW9uLFxuICAgICAgICBpbWFnZVBpeGVsUmF0aW8gKiAodmlld0NlbnRlclsxXSAtIGltYWdlRXh0ZW50WzNdKSAvIGltYWdlUmVzb2x1dGlvbik7XG4gICAgICBjb21wb3NlVHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICAgIHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMiAtIHRyYW5zZm9ybVs0XSwgcGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyIC0gdHJhbnNmb3JtWzVdLFxuICAgICAgICBwaXhlbFJhdGlvIC8gdmlld1Jlc29sdXRpb24sIC1waXhlbFJhdGlvIC8gdmlld1Jlc29sdXRpb24sXG4gICAgICAgIDAsXG4gICAgICAgIC12aWV3Q2VudGVyWzBdLCAtdmlld0NlbnRlclsxXSk7XG5cbiAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uID0gaW1hZ2VSZXNvbHV0aW9uICogcGl4ZWxSYXRpbyAvIGltYWdlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICByZXR1cm4gISF0aGlzLmltYWdlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc0ltYWdlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSAoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGlmICh0aGlzLnZlY3RvclJlbmRlcmVyXykge1xuICAgICAgcmV0dXJuIHRoaXMudmVjdG9yUmVuZGVyZXJfLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlLmNhbGwodGhpcywgY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDYW52YXNJbWFnZUxheWVyUmVuZGVyZXI7XG59KEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyKSk7XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllciBUaGUgY2FuZGlkYXRlIGxheWVyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHJlbmRlcmVyIGNhbiByZW5kZXIgdGhlIGxheWVyLlxuICovXG5DYW52YXNJbWFnZUxheWVyUmVuZGVyZXJbJ2hhbmRsZXMnXSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5JTUFHRSB8fFxuICAgIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUiAmJlxuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn0gKi8gKGxheWVyKS5nZXRSZW5kZXJNb2RlKCkgPT09IFZlY3RvclJlbmRlclR5cGUuSU1BR0U7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbGF5ZXIgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXJlci9NYXB9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn0gbGF5ZXIgVGhlIGxheWVyIHRvIGJlIHJlbmRlcmVyZC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9yZW5kZXJlci9jYW52YXMvSW1hZ2VMYXllcn0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICovXG5DYW52YXNJbWFnZUxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyKC8qKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL0ltYWdlfSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzSW1hZ2VMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvSW50ZXJtZWRpYXRlQ2FudmFzXG4gKi9cbmltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlfSBmcm9tICcuLi8uLi9jb29yZGluYXRlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgaW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7VU5ERUZJTkVEfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IENhbnZhc0xheWVyUmVuZGVyZXIgZnJvbSAnLi4vY2FudmFzL0xheWVyLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbnZhciBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciA9IChmdW5jdGlvbiAoQ2FudmFzTGF5ZXJSZW5kZXJlcikge1xuICBmdW5jdGlvbiBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcihsYXllcikge1xuXG4gICAgQ2FudmFzTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIGxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlVG9DYW52YXNQaXhlbFRyYW5zZm9ybSA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8gPSBudWxsO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc0xheWVyUmVuZGVyZXIgKSBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5fX3Byb3RvX18gPSBDYW52YXNMYXllclJlbmRlcmVyO1xuICBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYW52YXNMYXllclJlbmRlcmVyICYmIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvc2VGcmFtZSA9IGZ1bmN0aW9uIGNvbXBvc2VGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge1xuXG4gICAgdGhpcy5wcmVDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgdmFyIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICAgIGlmIChpbWFnZSkge1xuXG4gICAgICAvLyBjbGlwcGVkIHJlbmRlcmluZyBpZiBsYXllciBleHRlbnQgaXMgc2V0XG4gICAgICB2YXIgZXh0ZW50ID0gbGF5ZXJTdGF0ZS5leHRlbnQ7XG4gICAgICB2YXIgY2xpcHBlZCA9IGV4dGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIWNvbnRhaW5zRXh0ZW50KGV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpICYmXG4gICAgICAgICAgaW50ZXJzZWN0cyhleHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KTtcbiAgICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICAgIHRoaXMuY2xpcChjb250ZXh0LCBmcmFtZVN0YXRlLCAvKiogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSAqLyAoZXh0ZW50KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWFnZVRyYW5zZm9ybSA9IHRoaXMuZ2V0SW1hZ2VUcmFuc2Zvcm0oKTtcbiAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBjb250ZXh0LnNhdmUgLyBjb250ZXh0LnJlc3RvcmUgaXMgbm90IHVzZWRcbiAgICAgIC8vIHRvIHNhdmUgYW5kIHJlc3RvcmUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgdGhlIG9wYWNpdHkuXG4gICAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udGV4dC1zYXZlLXJlc3RvcmUtdmVyc3VzLXZhcmlhYmxlXG4gICAgICB2YXIgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcblxuICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGNvbnRleHQuc2V0VHJhbnNmb3JtIGlzIG9ubHkgdXNlZFxuICAgICAgLy8gd2hlbiB0aGUgdmlldyBpcyByb3RhdGVkLiBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FudmFzLXRyYW5zZm9ybVxuICAgICAgdmFyIGR4ID0gaW1hZ2VUcmFuc2Zvcm1bNF07XG4gICAgICB2YXIgZHkgPSBpbWFnZVRyYW5zZm9ybVs1XTtcbiAgICAgIHZhciBkdyA9IGltYWdlLndpZHRoICogaW1hZ2VUcmFuc2Zvcm1bMF07XG4gICAgICB2YXIgZGggPSBpbWFnZS5oZWlnaHQgKiBpbWFnZVRyYW5zZm9ybVszXTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAraW1hZ2Uud2lkdGgsICtpbWFnZS5oZWlnaHQsXG4gICAgICAgIE1hdGgucm91bmQoZHgpLCBNYXRoLnJvdW5kKGR5KSwgTWF0aC5yb3VuZChkdyksIE1hdGgucm91bmQoZGgpKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblxuICAgICAgaWYgKGNsaXBwZWQpIHtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wb3N0Q29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKCkge307XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IEltYWdlIHRyYW5zZm9ybS5cbiAgICovXG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldEltYWdlVHJhbnNmb3JtICgpIHt9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgdmFyIHNvdXJjZSA9IGxheWVyLmdldFNvdXJjZSgpO1xuICAgIHZhciByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgc2tpcHBlZEZlYXR1cmVVaWRzID0gZnJhbWVTdGF0ZS5za2lwcGVkRmVhdHVyZVVpZHM7XG4gICAgcmV0dXJuIHNvdXJjZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgIGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBoaXRUb2xlcmFuY2UsIHNraXBwZWRGZWF0dXJlVWlkcyxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCBmZWF0dXJlLCBsYXllcik7XG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBmb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBpZiAoIXRoaXMuZ2V0SW1hZ2UoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5nZXRMYXllcigpLmdldFNvdXJjZSgpLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlICE9PSBVTkRFRklORUQpIHtcbiAgICAgIC8vIGZvciBJbWFnZUNhbnZhcyBzb3VyY2VzIHVzZSB0aGUgb3JpZ2luYWwgaGl0LWRldGVjdGlvbiBsb2dpYyxcbiAgICAgIC8vIHNvIHRoYXQgZm9yIGV4YW1wbGUgYWxzbyB0cmFuc3BhcmVudCBwb2x5Z29ucyBhcmUgZGV0ZWN0ZWRcbiAgICAgIHJldHVybiBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBpeGVsID0gYXBwbHlUcmFuc2Zvcm0odGhpcy5jb29yZGluYXRlVG9DYW52YXNQaXhlbFRyYW5zZm9ybSwgY29vcmRpbmF0ZS5zbGljZSgpKTtcbiAgICAgIHNjYWxlQ29vcmRpbmF0ZShwaXhlbCwgZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbiAvIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uKTtcblxuICAgICAgaWYgKCF0aGlzLmhpdENhbnZhc0NvbnRleHRfKSB7XG4gICAgICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8gPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoMSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgdGhpcy5oaXRDYW52YXNDb250ZXh0Xy5kcmF3SW1hZ2UodGhpcy5nZXRJbWFnZSgpLCBwaXhlbFswXSwgcGl4ZWxbMV0sIDEsIDEsIDAsIDAsIDEsIDEpO1xuXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gdGhpcy5oaXRDYW52YXNDb250ZXh0Xy5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcbiAgICAgIGlmIChpbWFnZURhdGFbM10gPiAwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0TGF5ZXIoKSwgaW1hZ2VEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcbn0oQ2FudmFzTGF5ZXJSZW5kZXJlcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnRlcm1lZGlhdGVDYW52YXMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9MYXllclxuICovXG5pbXBvcnQge2dldEJvdHRvbUxlZnQsIGdldEJvdHRvbVJpZ2h0LCBnZXRUb3BMZWZ0LCBnZXRUb3BSaWdodH0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7VFJVRX0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudCBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7cm90YXRlQXRPZmZzZXR9IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyIGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzJztcbmltcG9ydCBMYXllclJlbmRlcmVyIGZyb20gJy4uL0xheWVyLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxudmFyIENhbnZhc0xheWVyUmVuZGVyZXIgPSAoZnVuY3Rpb24gKExheWVyUmVuZGVyZXIpIHtcbiAgZnVuY3Rpb24gQ2FudmFzTGF5ZXJSZW5kZXJlcihsYXllcikge1xuXG4gICAgTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIGxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgfVxuXG4gIGlmICggTGF5ZXJSZW5kZXJlciApIENhbnZhc0xheWVyUmVuZGVyZXIuX19wcm90b19fID0gTGF5ZXJSZW5kZXJlcjtcbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMYXllclJlbmRlcmVyICYmIExheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzTGF5ZXJSZW5kZXJlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBDbGlwIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uIGNsaXAgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGV4dGVudCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciB3aWR0aCA9IGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGhlaWdodCA9IGZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW87XG4gICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgdmFyIHRvcExlZnQgPSBnZXRUb3BMZWZ0KC8qKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9ICovIChleHRlbnQpKTtcbiAgICB2YXIgdG9wUmlnaHQgPSBnZXRUb3BSaWdodCgvKiogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSAqLyAoZXh0ZW50KSk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gZ2V0Qm90dG9tUmlnaHQoLyoqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gKi8gKGV4dGVudCkpO1xuICAgIHZhciBib3R0b21MZWZ0ID0gZ2V0Qm90dG9tTGVmdCgvKiogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSAqLyAoZXh0ZW50KSk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8odG9wTGVmdFswXSAqIHBpeGVsUmF0aW8sIHRvcExlZnRbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmxpbmVUbyh0b3BSaWdodFswXSAqIHBpeGVsUmF0aW8sIHRvcFJpZ2h0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5saW5lVG8oYm90dG9tUmlnaHRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21SaWdodFsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGJvdHRvbUxlZnRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21MZWZ0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9FdmVudFR5cGV9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyA9IGZ1bmN0aW9uIGRpc3BhdGNoQ29tcG9zZUV2ZW50XyAodHlwZSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIHZhciB3aWR0aCA9IGZyYW1lU3RhdGUuc2l6ZVswXSAqIGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIHZhciBoZWlnaHQgPSBmcmFtZVN0YXRlLnNpemVbMV0gKiBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIC1yb3RhdGlvbiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBvcHRfdHJhbnNmb3JtICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBvcHRfdHJhbnNmb3JtIDogdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKFxuICAgICAgICBjb250ZXh0LCBmcmFtZVN0YXRlLnBpeGVsUmF0aW8sIGZyYW1lU3RhdGUuZXh0ZW50LCB0cmFuc2Zvcm0sXG4gICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uKTtcbiAgICAgIHZhciBjb21wb3NlRXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgcmVuZGVyLCBmcmFtZVN0YXRlLFxuICAgICAgICBjb250ZXh0LCBudWxsKTtcbiAgICAgIGxheWVyLmRpc3BhdGNoRXZlbnQoY29tcG9zZUV2ZW50KTtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgbW9kdWxlOm9sL2xheWVyL0xheWVyLCAoVWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheSkpOiBUfSBjYWxsYmFjayBMYXllclxuICAgKiAgICAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaExheWVyQXRDb29yZGluYXRlIChjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGhhc0ZlYXR1cmUgPSB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgVFJVRSwgdGhpcyk7XG5cbiAgICBpZiAoaGFzRmVhdHVyZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5nZXRMYXllcigpLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wb3N0Q29tcG9zZSA9IGZ1bmN0aW9uIHBvc3RDb21wb3NlIChjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kaXNwYXRjaENvbXBvc2VFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlBPU1RDT01QT1NFLCBjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlQ29tcG9zZSA9IGZ1bmN0aW9uIHByZUNvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUFJFQ09NUE9TRSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtPX0gb3B0X3RyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3BhdGNoUmVuZGVyRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaFJlbmRlckV2ZW50IChjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kaXNwYXRjaENvbXBvc2VFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlJFTkRFUiwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCBPZmZzZXQgb24gdGhlIHgtYXhpcyBpbiB2aWV3IGNvb3JkaW5hdGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gVHJhbnNmb3JtLlxuICAgKi9cbiAgQ2FudmFzTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtIChmcmFtZVN0YXRlLCBvZmZzZXRYKSB7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciBkeDEgPSBwaXhlbFJhdGlvICogZnJhbWVTdGF0ZS5zaXplWzBdIC8gMjtcbiAgICB2YXIgZHkxID0gcGl4ZWxSYXRpbyAqIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDI7XG4gICAgdmFyIHN4ID0gcGl4ZWxSYXRpbyAvIHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIHZhciBzeSA9IC1zeDtcbiAgICB2YXIgYW5nbGUgPSAtdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIHZhciBkeDIgPSAtdmlld1N0YXRlLmNlbnRlclswXSArIG9mZnNldFg7XG4gICAgdmFyIGR5MiA9IC12aWV3U3RhdGUuY2VudGVyWzFdO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtXywgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKTtcbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICovXG4gIENhbnZhc0xheWVyUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvc2VGcmFtZSA9IGZ1bmN0aW9uIGNvbXBvc2VGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge307XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+U3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgY29tcG9zZUZyYW1lIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqL1xuICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiBwcmVwYXJlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHt9O1xuXG4gIHJldHVybiBDYW52YXNMYXllclJlbmRlcmVyO1xufShMYXllclJlbmRlcmVyKSk7XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0xheWVyUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheWVyLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvTWFwXG4gKi9cbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7aW5jbHVkZXMsIHN0YWJsZVNvcnR9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7Q0xBU1NfVU5TRUxFQ1RBQkxFfSBmcm9tICcuLi8uLi9jc3MuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge3Zpc2libGVBdFJlc29sdXRpb259IGZyb20gJy4uLy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudCBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnQuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7cm90YXRlQXRPZmZzZXR9IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyIGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzJztcbmltcG9ydCBNYXBSZW5kZXJlciwge3NvcnRCeVpJbmRleH0gZnJvbSAnLi4vTWFwLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi8uLi9zb3VyY2UvU3RhdGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvcmVuZGVyZXIvTGF5ZXI+fVxuICovXG5leHBvcnQgdmFyIGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMgPSBbXTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgbWFwIHJlbmRlcmVyLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzTWFwUmVuZGVyZXIgPSAoZnVuY3Rpb24gKE1hcFJlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIENhbnZhc01hcFJlbmRlcmVyKG1hcCkge1xuICAgIE1hcFJlbmRlcmVyLmNhbGwodGhpcywgbWFwKTtcblxuICAgIHZhciBjb250YWluZXIgPSBtYXAuZ2V0Vmlld3BvcnQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSB0aGlzLmNvbnRleHRfLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzXy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmNhbnZhc18uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHRoaXMuY2FudmFzXy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmNhbnZhc18uY2xhc3NOYW1lID0gQ0xBU1NfVU5TRUxFQ1RBQkxFO1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5jYW52YXNfLCBjb250YWluZXIuY2hpbGROb2Rlc1swXSB8fCBudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IGNyZWF0ZVRyYW5zZm9ybSgpO1xuXG4gIH1cblxuICBpZiAoIE1hcFJlbmRlcmVyICkgQ2FudmFzTWFwUmVuZGVyZXIuX19wcm90b19fID0gTWFwUmVuZGVyZXI7XG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcFJlbmRlcmVyICYmIE1hcFJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNNYXBSZW5kZXJlcjtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL0V2ZW50VHlwZX0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9QbHVnZ2FibGVNYXB+RnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5kaXNwYXRjaENvbXBvc2VFdmVudF8gPSBmdW5jdGlvbiBkaXNwYXRjaENvbXBvc2VFdmVudF8gKHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgaWYgKG1hcC5oYXNMaXN0ZW5lcih0eXBlKSkge1xuICAgICAgdmFyIGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgICB2YXIgcm90YXRpb24gPSB2aWV3U3RhdGUucm90YXRpb247XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlKTtcblxuICAgICAgdmFyIHZlY3RvckNvbnRleHQgPSBuZXcgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIoY29udGV4dCwgcGl4ZWxSYXRpbyxcbiAgICAgICAgZXh0ZW50LCB0cmFuc2Zvcm0sIHJvdGF0aW9uKTtcbiAgICAgIHZhciBjb21wb3NlRXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgdmVjdG9yQ29udGV4dCxcbiAgICAgICAgZnJhbWVTdGF0ZSwgY29udGV4dCwgbnVsbCk7XG4gICAgICBtYXAuZGlzcGF0Y2hFdmVudChjb21wb3NlRXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gICAqL1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0VHJhbnNmb3JtIChmcmFtZVN0YXRlKSB7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBkeDEgPSB0aGlzLmNhbnZhc18ud2lkdGggLyAyO1xuICAgIHZhciBkeTEgPSB0aGlzLmNhbnZhc18uaGVpZ2h0IC8gMjtcbiAgICB2YXIgc3ggPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW8gLyB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgc3kgPSAtc3g7XG4gICAgdmFyIGFuZ2xlID0gLXZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICB2YXIgZHgyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMF07XG4gICAgdmFyIGR5MiA9IC12aWV3U3RhdGUuY2VudGVyWzFdO1xuICAgIHJldHVybiBjb21wb3NlVHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtXywgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc01hcFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIHJlbmRlckZyYW1lIChmcmFtZVN0YXRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblxuICAgIGlmICghZnJhbWVTdGF0ZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgICB0aGlzLmNhbnZhc18uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5yZW5kZXJlZFZpc2libGVfID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIHZhciBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbyk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbyk7XG4gICAgaWYgKHRoaXMuY2FudmFzXy53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmNhbnZhc18uaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXNfLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc18uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcblxuICAgIHRoaXMuY2FsY3VsYXRlTWF0cmljZXMyRChmcmFtZVN0YXRlKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hDb21wb3NlRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QUkVDT01QT1NFLCBmcmFtZVN0YXRlKTtcblxuICAgIHZhciBsYXllclN0YXRlc0FycmF5ID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIHN0YWJsZVNvcnQobGF5ZXJTdGF0ZXNBcnJheSwgc29ydEJ5WkluZGV4KTtcblxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCByb3RhdGlvbiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICB9XG5cbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIHZhciBpLCBpaSwgbGF5ZXIsIGxheWVyUmVuZGVyZXIsIGxheWVyU3RhdGU7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgbGF5ZXJSZW5kZXJlciA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3JlbmRlcmVyL2NhbnZhcy9MYXllcn0gKi8gKHRoaXMkMS5nZXRMYXllclJlbmRlcmVyKGxheWVyKSk7XG4gICAgICBpZiAoIXZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgdmlld1Jlc29sdXRpb24pIHx8XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5zb3VyY2VTdGF0ZSAhPSBTb3VyY2VTdGF0ZS5SRUFEWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXllclJlbmRlcmVyLnByZXBhcmVGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlKSkge1xuICAgICAgICBsYXllclJlbmRlcmVyLmNvbXBvc2VGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hDb21wb3NlRXZlbnRfKFJlbmRlckV2ZW50VHlwZS5QT1NUQ09NUE9TRSwgZnJhbWVTdGF0ZSk7XG5cbiAgICBpZiAoIXRoaXMucmVuZGVyZWRWaXNpYmxlXykge1xuICAgICAgdGhpcy5jYW52YXNfLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5zY2hlZHVsZVJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzKGZyYW1lU3RhdGUpO1xuICAgIHRoaXMuc2NoZWR1bGVFeHBpcmVJY29uQ2FjaGUoZnJhbWVTdGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUuZm9yRWFjaExheWVyQXRQaXhlbCA9IGZ1bmN0aW9uIGZvckVhY2hMYXllckF0UGl4ZWwgKHBpeGVsLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnLCBsYXllckZpbHRlciwgdGhpc0FyZzIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciB2aWV3UmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuXG4gICAgdmFyIGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIHZhciBudW1MYXllcnMgPSBsYXllclN0YXRlcy5sZW5ndGg7XG5cbiAgICB2YXIgY29vcmRpbmF0ZSA9IGFwcGx5VHJhbnNmb3JtKFxuICAgICAgZnJhbWVTdGF0ZS5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgcGl4ZWwuc2xpY2UoKSk7XG5cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGxheWVyU3RhdGUgPSBsYXllclN0YXRlc1tpXTtcbiAgICAgIHZhciBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBpZiAodmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCB2aWV3UmVzb2x1dGlvbikgJiYgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpKSB7XG4gICAgICAgIHZhciBsYXllclJlbmRlcmVyID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyZXIvY2FudmFzL0xheWVyfSAqLyAodGhpcyQxLmdldExheWVyUmVuZGVyZXIobGF5ZXIpKTtcbiAgICAgICAgcmVzdWx0ID0gbGF5ZXJSZW5kZXJlci5mb3JFYWNoTGF5ZXJBdENvb3JkaW5hdGUoXG4gICAgICAgICAgY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNNYXBSZW5kZXJlci5wcm90b3R5cGUucmVnaXN0ZXJMYXllclJlbmRlcmVycyA9IGZ1bmN0aW9uIHJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMgKGNvbnN0cnVjdG9ycykge1xuICAgIE1hcFJlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckxheWVyUmVuZGVyZXJzLmNhbGwodGhpcywgY29uc3RydWN0b3JzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb25zdHJ1Y3RvcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdmFyIGN0b3IgPSBjb25zdHJ1Y3RvcnNbaV07XG4gICAgICBpZiAoIWluY2x1ZGVzKGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMsIGN0b3IpKSB7XG4gICAgICAgIGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMucHVzaChjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc01hcFJlbmRlcmVyO1xufShNYXBSZW5kZXJlcikpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc01hcFJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXAuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFRpbGVSYW5nZSBmcm9tICcuLi8uLi9UaWxlUmFuZ2UuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi8uLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgY3JlYXRlRW1wdHksIGVxdWFscywgZ2V0SW50ZXJzZWN0aW9uLCBpc0VtcHR5fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyIGZyb20gJy4uL2NhbnZhcy9JbnRlcm1lZGlhdGVDYW52YXMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciB0aWxlIGxheWVycy5cbiAqIEBhcGlcbiAqL1xudmFyIENhbnZhc1RpbGVMYXllclJlbmRlcmVyID0gKGZ1bmN0aW9uIChJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcih0aWxlTGF5ZXIsIG9wdF9ub0NvbnRleHQpIHtcblxuICAgIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyLmNhbGwodGhpcywgdGlsZUxheWVyKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dCA9IG9wdF9ub0NvbnRleHQgPyBudWxsIDogY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vdmVyc2FtcGxpbmdfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXkuPG1vZHVsZTpvbC9UaWxlPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy50bXBFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGVSYW5nZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRpbGVSYW5nZV8gPSBuZXcgVGlsZVJhbmdlKDAsIDAsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IDA7XG5cbiAgfVxuXG4gIGlmICggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgKSBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIgJiYgSW50ZXJtZWRpYXRlQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlfSB0aWxlIFRpbGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRpbGUgaXMgZHJhd2FibGUuXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaXNEcmF3YWJsZVRpbGVfID0gZnVuY3Rpb24gaXNEcmF3YWJsZVRpbGVfICh0aWxlKSB7XG4gICAgdmFyIHRpbGVTdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICB2YXIgdXNlSW50ZXJpbVRpbGVzT25FcnJvciA9IHRoaXMuZ2V0TGF5ZXIoKS5nZXRVc2VJbnRlcmltVGlsZXNPbkVycm9yKCk7XG4gICAgcmV0dXJuIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRU1QVFkgfHxcbiAgICAgICAgdGlsZVN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiAmJiAhdXNlSW50ZXJpbVRpbGVzT25FcnJvcjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshbW9kdWxlOm9sL1RpbGV9IFRpbGUuXG4gICAqL1xuICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uIGdldFRpbGUgKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3NvdXJjZS9UaWxlfSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuRVJST1IpIHtcbiAgICAgIGlmICghbGF5ZXIuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpKSB7XG4gICAgICAgIC8vIFdoZW4gdXNlSW50ZXJpbVRpbGVzT25FcnJvciBpcyBmYWxzZSwgd2UgY29uc2lkZXIgdGhlIGVycm9yIHRpbGUgYXMgbG9hZGVkLlxuICAgICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5MT0FERUQpO1xuICAgICAgfSBlbHNlIGlmIChsYXllci5nZXRQcmVsb2FkKCkgPiAwKSB7XG4gICAgICAgIC8vIFByZWxvYWRlZCB0aWxlcyBmb3IgbG93ZXIgcmVzb2x1dGlvbnMgbWlnaHQgaGF2ZSBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICB0aGlzLm5ld1RpbGVzXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0RyYXdhYmxlVGlsZV8odGlsZSkpIHtcbiAgICAgIHRpbGUgPSB0aWxlLmdldEludGVyaW1UaWxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHByb2plY3Rpb24gPSB2aWV3U3RhdGUucHJvamVjdGlvbjtcbiAgICB2YXIgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICB2YXIgdmlld0NlbnRlciA9IHZpZXdTdGF0ZS5jZW50ZXI7XG5cbiAgICB2YXIgdGlsZUxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIHZhciB0aWxlU291cmNlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc291cmNlL1RpbGV9ICovICh0aWxlTGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIHZhciBzb3VyY2VSZXZpc2lvbiA9IHRpbGVTb3VyY2UuZ2V0UmV2aXNpb24oKTtcbiAgICB2YXIgdGlsZUdyaWQgPSB0aWxlU291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICB2YXIgeiA9IHRpbGVHcmlkLmdldFpGb3JSZXNvbHV0aW9uKHZpZXdSZXNvbHV0aW9uLCB0aGlzLnpEaXJlY3Rpb24pO1xuICAgIHZhciB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgdmFyIG92ZXJzYW1wbGluZyA9IE1hdGgucm91bmQodmlld1Jlc29sdXRpb24gLyB0aWxlUmVzb2x1dGlvbikgfHwgMTtcbiAgICB2YXIgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG5cbiAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudCwgbGF5ZXJTdGF0ZS5leHRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNFbXB0eShleHRlbnQpKSB7XG4gICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCB0aGUgcmVuZGVyaW5nIG9mIHRoZSBsYXllci5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIHZhciBpbWFnZUV4dGVudCA9IHRpbGVHcmlkLmdldFRpbGVSYW5nZUV4dGVudCh6LCB0aWxlUmFuZ2UpO1xuXG4gICAgdmFyIHRpbGVQaXhlbFJhdGlvID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlciwgT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9UaWxlPj59XG4gICAgICovXG4gICAgdmFyIHRpbGVzVG9EcmF3QnlaID0ge307XG4gICAgdGlsZXNUb0RyYXdCeVpbel0gPSB7fTtcblxuICAgIHZhciBmaW5kTG9hZGVkVGlsZXMgPSB0aGlzLmNyZWF0ZUxvYWRlZFRpbGVGaW5kZXIoXG4gICAgICB0aWxlU291cmNlLCBwcm9qZWN0aW9uLCB0aWxlc1RvRHJhd0J5Wik7XG5cbiAgICB2YXIgaGludHMgPSBmcmFtZVN0YXRlLnZpZXdIaW50cztcbiAgICB2YXIgYW5pbWF0aW5nT3JJbnRlcmFjdGluZyA9IGhpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgaGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddO1xuXG4gICAgdmFyIHRtcEV4dGVudCA9IHRoaXMudG1wRXh0ZW50O1xuICAgIHZhciB0bXBUaWxlUmFuZ2UgPSB0aGlzLnRtcFRpbGVSYW5nZV87XG4gICAgdGhpcy5uZXdUaWxlc18gPSBmYWxzZTtcbiAgICB2YXIgdGlsZSwgeCwgeTtcbiAgICBmb3IgKHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICBmb3IgKHkgPSB0aWxlUmFuZ2UubWluWTsgeSA8PSB0aWxlUmFuZ2UubWF4WTsgKyt5KSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gZnJhbWVTdGF0ZS50aW1lID4gMTYgJiYgYW5pbWF0aW5nT3JJbnRlcmFjdGluZykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRpbGUgPSB0aGlzJDEuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMkMS5pc0RyYXdhYmxlVGlsZV8odGlsZSkpIHtcbiAgICAgICAgICB2YXIgdWlkID0gZ2V0VWlkKHRoaXMkMSk7XG4gICAgICAgICAgaWYgKHRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICAgICAgICB0aWxlc1RvRHJhd0J5Wlt6XVt0aWxlLnRpbGVDb29yZC50b1N0cmluZygpXSA9IHRpbGU7XG4gICAgICAgICAgICB2YXIgaW5UcmFuc2l0aW9uID0gdGlsZS5pblRyYW5zaXRpb24odWlkKTtcbiAgICAgICAgICAgIGlmICghdGhpcyQxLm5ld1RpbGVzXyAmJiAoaW5UcmFuc2l0aW9uIHx8IHRoaXMkMS5yZW5kZXJlZFRpbGVzLmluZGV4T2YodGlsZSkgPT09IC0xKSkge1xuICAgICAgICAgICAgICB0aGlzJDEubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpID09PSAxKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBsb29rIGZvciBhbHQgdGlsZXMgaWYgYWxwaGEgaXMgMVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkVGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UoXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQsIHRtcFRpbGVSYW5nZSwgdG1wRXh0ZW50KTtcbiAgICAgICAgdmFyIGNvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoaWxkVGlsZVJhbmdlKSB7XG4gICAgICAgICAgY292ZXJlZCA9IGZpbmRMb2FkZWRUaWxlcyh6ICsgMSwgY2hpbGRUaWxlUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY292ZXJlZCkge1xuICAgICAgICAgIHRpbGVHcmlkLmZvckVhY2hUaWxlQ29vcmRQYXJlbnRUaWxlUmFuZ2UoXG4gICAgICAgICAgICB0aWxlLnRpbGVDb29yZCwgZmluZExvYWRlZFRpbGVzLCBudWxsLCB0bXBUaWxlUmFuZ2UsIHRtcEV4dGVudCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZFJlc29sdXRpb24gPSB0aWxlUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8gLyB0aWxlUGl4ZWxSYXRpbyAqIG92ZXJzYW1wbGluZztcbiAgICBpZiAoISh0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiAmJiBEYXRlLm5vdygpIC0gZnJhbWVTdGF0ZS50aW1lID4gMTYgJiYgYW5pbWF0aW5nT3JJbnRlcmFjdGluZykgJiYgKFxuICAgICAgdGhpcy5uZXdUaWxlc18gfHxcbiAgICAgICAgICAhKHRoaXMucmVuZGVyZWRFeHRlbnRfICYmIGNvbnRhaW5zRXh0ZW50KHRoaXMucmVuZGVyZWRFeHRlbnRfLCBleHRlbnQpKSB8fFxuICAgICAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiAhPSBzb3VyY2VSZXZpc2lvbiB8fFxuICAgICAgICAgIG92ZXJzYW1wbGluZyAhPSB0aGlzLm92ZXJzYW1wbGluZ18gfHxcbiAgICAgICAgICAhYW5pbWF0aW5nT3JJbnRlcmFjdGluZyAmJiByZW5kZXJlZFJlc29sdXRpb24gIT0gdGhpcy5yZW5kZXJlZFJlc29sdXRpb25cbiAgICApKSB7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQodGlsZVJhbmdlLmdldFdpZHRoKCkgKiB0aWxlUGl4ZWxTaXplWzBdIC8gb3ZlcnNhbXBsaW5nKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQodGlsZVJhbmdlLmdldEhlaWdodCgpICogdGlsZVBpeGVsU2l6ZVsxXSAvIG92ZXJzYW1wbGluZyk7XG4gICAgICAgIHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPSB3aWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgICAgIHRoaXMub3ZlcnNhbXBsaW5nXyA9IG92ZXJzYW1wbGluZztcbiAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVkRXh0ZW50XyAmJiAhZXF1YWxzKGltYWdlRXh0ZW50LCB0aGlzLnJlbmRlcmVkRXh0ZW50XykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdmVyc2FtcGxpbmcgPSB0aGlzLm92ZXJzYW1wbGluZ187XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA9IDA7XG4gICAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgICAgdmFyIHpzID0gT2JqZWN0LmtleXModGlsZXNUb0RyYXdCeVopLm1hcChOdW1iZXIpO1xuICAgICAgenMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSB6KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0geikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGN1cnJlbnRSZXNvbHV0aW9uLCBjdXJyZW50U2NhbGUsIGN1cnJlbnRUaWxlUGl4ZWxTaXplLCBjdXJyZW50WiwgaSwgaWk7XG4gICAgICB2YXIgdGlsZUV4dGVudCwgdGlsZUd1dHRlciwgdGlsZXNUb0RyYXcsIHcsIGg7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHpzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY3VycmVudFogPSB6c1tpXTtcbiAgICAgICAgY3VycmVudFRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoY3VycmVudFosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgICBjdXJyZW50UmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oY3VycmVudFopO1xuICAgICAgICBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgICB0aWxlR3V0dGVyID0gdGlsZVBpeGVsUmF0aW8gKiB0aWxlU291cmNlLmdldEd1dHRlcihwcm9qZWN0aW9uKTtcbiAgICAgICAgdGlsZXNUb0RyYXcgPSB0aWxlc1RvRHJhd0J5WltjdXJyZW50Wl07XG4gICAgICAgIGZvciAodmFyIHRpbGVDb29yZEtleSBpbiB0aWxlc1RvRHJhdykge1xuICAgICAgICAgIHRpbGUgPSB0aWxlc1RvRHJhd1t0aWxlQ29vcmRLZXldO1xuICAgICAgICAgIHRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS5nZXRUaWxlQ29vcmQoKSwgdG1wRXh0ZW50KTtcbiAgICAgICAgICB4ID0gKHRpbGVFeHRlbnRbMF0gLSBpbWFnZUV4dGVudFswXSkgLyB0aWxlUmVzb2x1dGlvbiAqIHRpbGVQaXhlbFJhdGlvIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIHkgPSAoaW1hZ2VFeHRlbnRbM10gLSB0aWxlRXh0ZW50WzNdKSAvIHRpbGVSZXNvbHV0aW9uICogdGlsZVBpeGVsUmF0aW8gLyBvdmVyc2FtcGxpbmc7XG4gICAgICAgICAgdyA9IGN1cnJlbnRUaWxlUGl4ZWxTaXplWzBdICogY3VycmVudFNjYWxlIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIGggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAvIG92ZXJzYW1wbGluZztcbiAgICAgICAgICB0aGlzJDEuZHJhd1RpbGVJbWFnZSh0aWxlLCBmcmFtZVN0YXRlLCBsYXllclN0YXRlLCB4LCB5LCB3LCBoLCB0aWxlR3V0dGVyLCB6ID09PSBjdXJyZW50Wik7XG4gICAgICAgICAgdGhpcyQxLnJlbmRlcmVkVGlsZXMucHVzaCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gPSBzb3VyY2VSZXZpc2lvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uID0gdGlsZVJlc29sdXRpb24gKiBwaXhlbFJhdGlvIC8gdGlsZVBpeGVsUmF0aW8gKiBvdmVyc2FtcGxpbmc7XG4gICAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGltYWdlRXh0ZW50O1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uIC8gdmlld1Jlc29sdXRpb247XG4gICAgdmFyIHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5pbWFnZVRyYW5zZm9ybV8sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIsIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMixcbiAgICAgIHNjYWxlLCBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAodGhpcy5yZW5kZXJlZEV4dGVudF9bMF0gLSB2aWV3Q2VudGVyWzBdKSAvIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uICogcGl4ZWxSYXRpbyxcbiAgICAgICh2aWV3Q2VudGVyWzFdIC0gdGhpcy5yZW5kZXJlZEV4dGVudF9bM10pIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gKiBwaXhlbFJhdGlvKTtcbiAgICBjb21wb3NlVHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIgLSB0cmFuc2Zvcm1bNF0sIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMiAtIHRyYW5zZm9ybVs1XSxcbiAgICAgIHBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbiwgLXBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbixcbiAgICAgIDAsXG4gICAgICAtdmlld0NlbnRlclswXSwgLXZpZXdDZW50ZXJbMV0pO1xuXG5cbiAgICB0aGlzLnVwZGF0ZVVzZWRUaWxlcyhmcmFtZVN0YXRlLnVzZWRUaWxlcywgdGlsZVNvdXJjZSwgeiwgdGlsZVJhbmdlKTtcbiAgICB0aGlzLm1hbmFnZVRpbGVQeXJhbWlkKGZyYW1lU3RhdGUsIHRpbGVTb3VyY2UsIHRpbGVHcmlkLCBwaXhlbFJhdGlvLFxuICAgICAgcHJvamVjdGlvbiwgZXh0ZW50LCB6LCB0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA+IDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyflN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBMZWZ0IG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUb3Agb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3IFdpZHRoIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgVGlsZSBndXR0ZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhbnNpdGlvbiBBcHBseSBhbiBhbHBoYSB0cmFuc2l0aW9uLlxuICAgKi9cbiAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRyYXdUaWxlSW1hZ2UgPSBmdW5jdGlvbiBkcmF3VGlsZUltYWdlICh0aWxlLCBmcmFtZVN0YXRlLCBsYXllclN0YXRlLCB4LCB5LCB3LCBoLCBndXR0ZXIsIHRyYW5zaXRpb24pIHtcbiAgICB2YXIgaW1hZ2UgPSB0aWxlLmdldEltYWdlKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgIHZhciBhbHBoYSA9IHRyYW5zaXRpb24gPyB0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA6IDE7XG4gICAgaWYgKGFscGhhID09PSAxICYmICF0aGlzLmdldExheWVyKCkuZ2V0U291cmNlKCkuZ2V0T3BhcXVlKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24pKSB7XG4gICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgICB2YXIgYWxwaGFDaGFuZ2VkID0gYWxwaGEgIT09IHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAoYWxwaGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgdGhpcy5jb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIGd1dHRlciwgZ3V0dGVyLFxuICAgICAgaW1hZ2Uud2lkdGggLSAyICogZ3V0dGVyLCBpbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLCB4LCB5LCB3LCBoKTtcblxuICAgIGlmIChhbHBoYUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChhbHBoYSAhPT0gMSkge1xuICAgICAgZnJhbWVTdGF0ZS5hbmltYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIHRpbGUuZW5kVHJhbnNpdGlvbih1aWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICByZXR1cm4gY29udGV4dCA/IGNvbnRleHQuY2FudmFzIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldEltYWdlVHJhbnNmb3JtICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVRyYW5zZm9ybV87XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1RpbGVMYXllclJlbmRlcmVyO1xufShJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcikpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVGlsZUxheWVyUmVuZGVyZXJbJ2hhbmRsZXMnXSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5USUxFO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIHJlbmRlcmVyLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyZXIvTWFwfSBtYXBSZW5kZXJlciBUaGUgbWFwIHJlbmRlcmVyLlxuICogQHBhcmFtIHttb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcmVuZGVyZXIvY2FudmFzL1RpbGVMYXllcn0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICovXG5DYW52YXNUaWxlTGF5ZXJSZW5kZXJlclsnY3JlYXRlJ10gPSBmdW5jdGlvbihtYXBSZW5kZXJlciwgbGF5ZXIpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge21vZHVsZTpvbC9sYXllci9UaWxlfSAqLyAobGF5ZXIpKTtcbn07XG5cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9sYXllci9UaWxlfG1vZHVsZTpvbC9sYXllci9WZWN0b3JUaWxlfVxuICovXG5DYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXI7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVMYXllci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi8uLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3Rlbn0gZnJvbSAnLi4vLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgcmJ1c2ggZnJvbSAncmJ1c2gnO1xuaW1wb3J0IHtidWZmZXIsIGNyZWF0ZUVtcHR5LCBjb250YWluc0V4dGVudCwgZ2V0V2lkdGh9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCByb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5R3JvdXAgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQgQ2FudmFzTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9jYW52YXMvTGF5ZXIuanMnO1xuaW1wb3J0IHtkZWZhdWx0T3JkZXIgYXMgZGVmYXVsdFJlbmRlck9yZGVyLCBnZXRUb2xlcmFuY2UgYXMgZ2V0UmVuZGVyVG9sZXJhbmNlLCBnZXRTcXVhcmVkVG9sZXJhbmNlIGFzIGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UsIHJlbmRlckZlYXR1cmV9IGZyb20gJy4uL3ZlY3Rvci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQ2FudmFzIHJlbmRlcmVyIGZvciB2ZWN0b3IgbGF5ZXJzLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciA9IChmdW5jdGlvbiAoQ2FudmFzTGF5ZXJSZW5kZXJlcikge1xuICBmdW5jdGlvbiBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyKHZlY3RvckxheWVyKSB7XG5cbiAgICBDYW52YXNMYXllclJlbmRlcmVyLmNhbGwodGhpcywgdmVjdG9yTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogRGVjbHV0dGVyIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWVfID0gdmVjdG9yTGF5ZXIuZ2V0RGVjbHV0dGVyKCkgPyByYnVzaCg5LCB1bmRlZmluZWQpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fID0gTmFOO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obW9kdWxlOm9sL0ZlYXR1cmUsIG1vZHVsZTpvbC9GZWF0dXJlKTogbnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIG5ldyByZXBsYXkgZ3JvdXAgaGFkIHRvIGJlIGNyZWF0ZWQgYnkgYHByZXBhcmVGcmFtZSgpYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG5cbiAgICBsaXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuXG4gIH1cblxuICBpZiAoIENhbnZhc0xheWVyUmVuZGVyZXIgKSBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLl9fcHJvdG9fXyA9IENhbnZhc0xheWVyUmVuZGVyZXI7XG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzTGF5ZXJSZW5kZXJlciAmJiBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZSApO1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXI7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIHVubGlzdGVuKGxhYmVsQ2FjaGUsIEV2ZW50VHlwZS5DTEVBUiwgdGhpcy5oYW5kbGVGb250c0NoYW5nZWRfLCB0aGlzKTtcbiAgICBDYW52YXNMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvUGx1Z2dhYmxlTWFwfkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyflN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UgKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBleHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICB2YXIgc2tpcHBlZEZlYXR1cmVVaWRzID0gbGF5ZXJTdGF0ZS5tYW5hZ2VkID9cbiAgICAgIGZyYW1lU3RhdGUuc2tpcHBlZEZlYXR1cmVVaWRzIDoge307XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIHZhciBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgdmFyIHJvdGF0aW9uID0gdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIHZhciBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICB2YXIgdmVjdG9yU291cmNlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn0gKi8gKHRoaXMuZ2V0TGF5ZXIoKS5nZXRTb3VyY2UoKSk7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG5cbiAgICAvLyBjbGlwcGVkIHJlbmRlcmluZyBpZiBsYXllciBleHRlbnQgaXMgc2V0XG4gICAgdmFyIGNsaXBFeHRlbnQgPSBsYXllclN0YXRlLmV4dGVudDtcbiAgICB2YXIgY2xpcHBlZCA9IGNsaXBFeHRlbnQgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgdGhpcy5jbGlwKGNvbnRleHQsIGZyYW1lU3RhdGUsIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9ICovIChjbGlwRXh0ZW50KSk7XG4gICAgfVxuICAgIHZhciByZXBsYXlHcm91cCA9IHRoaXMucmVwbGF5R3JvdXBfO1xuICAgIGlmIChyZXBsYXlHcm91cCAmJiAhcmVwbGF5R3JvdXAuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGhpcy5kZWNsdXR0ZXJUcmVlXykge1xuICAgICAgICB0aGlzLmRlY2x1dHRlclRyZWVfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge21vZHVsZTpvbC9sYXllci9WZWN0b3J9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgICAgdmFyIGRyYXdPZmZzZXRYID0gMDtcbiAgICAgIHZhciBkcmF3T2Zmc2V0WSA9IDA7XG4gICAgICB2YXIgcmVwbGF5Q29udGV4dDtcbiAgICAgIHZhciB0cmFuc3BhcmVudExheWVyID0gbGF5ZXJTdGF0ZS5vcGFjaXR5ICE9PSAxO1xuICAgICAgdmFyIGhhc1JlbmRlckxpc3RlbmVycyA9IGxheWVyLmhhc0xpc3RlbmVyKFJlbmRlckV2ZW50VHlwZS5SRU5ERVIpO1xuICAgICAgaWYgKHRyYW5zcGFyZW50TGF5ZXIgfHwgaGFzUmVuZGVyTGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBkcmF3V2lkdGggPSBjb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGRyYXdIZWlnaHQgPSBjb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgIHZhciBkcmF3U2l6ZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KGRyYXdXaWR0aCAqIGRyYXdXaWR0aCArIGRyYXdIZWlnaHQgKiBkcmF3SGVpZ2h0KSk7XG4gICAgICAgICAgZHJhd09mZnNldFggPSAoZHJhd1NpemUgLSBkcmF3V2lkdGgpIC8gMjtcbiAgICAgICAgICBkcmF3T2Zmc2V0WSA9IChkcmF3U2l6ZSAtIGRyYXdIZWlnaHQpIC8gMjtcbiAgICAgICAgICBkcmF3V2lkdGggPSBkcmF3SGVpZ2h0ID0gZHJhd1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzaXplIGFuZCBjbGVhclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLndpZHRoID0gZHJhd1dpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IGRyYXdIZWlnaHQ7XG4gICAgICAgIHJlcGxheUNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYXlDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFscGhhID0gcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgIGlmICghdHJhbnNwYXJlbnRMYXllcikge1xuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgY29udGV4dC5zYXZlIC8gY29udGV4dC5yZXN0b3JlIGlzIG5vdCB1c2VkXG4gICAgICAgIC8vIHRvIHNhdmUgYW5kIHJlc3RvcmUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgdGhlIG9wYWNpdHkuXG4gICAgICAgIC8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS9jb250ZXh0LXNhdmUtcmVzdG9yZS12ZXJzdXMtdmFyaWFibGVcbiAgICAgICAgcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcGxheUNvbnRleHQgIT0gY29udGV4dCkge1xuICAgICAgICByZXBsYXlDb250ZXh0LnRyYW5zbGF0ZShkcmF3T2Zmc2V0WCwgZHJhd09mZnNldFkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBmcmFtZVN0YXRlLnNpemVbMF0gKiBwaXhlbFJhdGlvO1xuICAgICAgdmFyIGhlaWdodCA9IGZyYW1lU3RhdGUuc2l6ZVsxXSAqIHBpeGVsUmF0aW87XG4gICAgICByb3RhdGVBdE9mZnNldChyZXBsYXlDb250ZXh0LCAtcm90YXRpb24sXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzKTtcbiAgICAgIGlmICh2ZWN0b3JTb3VyY2UuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZXh0ZW50KSkge1xuICAgICAgICB2YXIgc3RhcnRYID0gZXh0ZW50WzBdO1xuICAgICAgICB2YXIgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgICAgICB2YXIgd29ybGQgPSAwO1xuICAgICAgICB2YXIgb2Zmc2V0WDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0WCA8IHByb2plY3Rpb25FeHRlbnRbMF0pIHtcbiAgICAgICAgICAtLXdvcmxkO1xuICAgICAgICAgIG9mZnNldFggPSB3b3JsZFdpZHRoICogd29ybGQ7XG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcyQxLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCBvZmZzZXRYKTtcbiAgICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzKTtcbiAgICAgICAgICBzdGFydFggKz0gd29ybGRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB3b3JsZCA9IDA7XG4gICAgICAgIHN0YXJ0WCA9IGV4dGVudFsyXTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0WCA+IHByb2plY3Rpb25FeHRlbnRbMl0pIHtcbiAgICAgICAgICArK3dvcmxkO1xuICAgICAgICAgIG9mZnNldFggPSB3b3JsZFdpZHRoICogd29ybGQ7XG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcyQxLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCBvZmZzZXRYKTtcbiAgICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzKTtcbiAgICAgICAgICBzdGFydFggLT0gd29ybGRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm90YXRlQXRPZmZzZXQocmVwbGF5Q29udGV4dCwgcm90YXRpb24sXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmIChoYXNSZW5kZXJMaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KHJlcGxheUNvbnRleHQsIGZyYW1lU3RhdGUsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGF5Q29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgICAgdmFyIG1haW5Db250ZXh0QWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBsYXllclN0YXRlLm9wYWNpdHk7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UocmVwbGF5Q29udGV4dC5jYW52YXMsIC1kcmF3T2Zmc2V0WCwgLWRyYXdPZmZzZXRZKTtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbWFpbkNvbnRleHRBbHBoYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShyZXBsYXlDb250ZXh0LmNhbnZhcywgLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxheUNvbnRleHQudHJhbnNsYXRlKC1kcmF3T2Zmc2V0WCwgLWRyYXdPZmZzZXRZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgIHJlcGxheUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xpcHBlZCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY29tcG9zZUZyYW1lID0gZnVuY3Rpb24gY29tcG9zZUZyYW1lIChmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIDApO1xuICAgIHRoaXMucHJlQ29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMuY29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKTtcbiAgICB0aGlzLnBvc3RDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUsIHRyYW5zZm9ybSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlIChjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgaWYgKCF0aGlzLnJlcGxheUdyb3VwXykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgICB2YXIgbGF5ZXIgPSAvKiogQHR5cGUge21vZHVsZTpvbC9sYXllci9WZWN0b3J9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuICAgICAgdmFyIGZlYXR1cmVzID0ge307XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXBsYXlHcm91cF8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgcmVzb2x1dGlvbiwgcm90YXRpb24sIGhpdFRvbGVyYW5jZSwge30sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGdldFVpZChmZWF0dXJlKS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICghKGtleSBpbiBmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbnVsbCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBFdmVudC5cbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUZvbnRzQ2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVGb250c0NoYW5nZWRfIChldmVudCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIHRoaXMucmVwbGF5R3JvdXBfKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBJbWFnZSBzdHlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfIChldmVudCkge1xuICAgIHRoaXMucmVuZGVySWZSZWFkeUFuZFZpc2libGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIHByZXBhcmVGcmFtZSAoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHZhciB2ZWN0b3JMYXllciA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgdmFyIHZlY3RvclNvdXJjZSA9IHZlY3RvckxheWVyLmdldFNvdXJjZSgpO1xuXG4gICAgdmFyIGFuaW1hdGluZyA9IGZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR107XG4gICAgdmFyIGludGVyYWN0aW5nID0gZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuSU5URVJBQ1RJTkddO1xuICAgIHZhciB1cGRhdGVXaGlsZUFuaW1hdGluZyA9IHZlY3RvckxheWVyLmdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nKCk7XG4gICAgdmFyIHVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgPSB2ZWN0b3JMYXllci5nZXRVcGRhdGVXaGlsZUludGVyYWN0aW5nKCk7XG5cbiAgICBpZiAoIXRoaXMuZGlydHlfICYmICghdXBkYXRlV2hpbGVBbmltYXRpbmcgJiYgYW5pbWF0aW5nKSB8fFxuICAgICAgICAoIXVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgJiYgaW50ZXJhY3RpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVTdGF0ZUV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgIHZhciB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuICAgIHZhciByZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHZlY3RvckxheWVyUmV2aXNpb24gPSB2ZWN0b3JMYXllci5nZXRSZXZpc2lvbigpO1xuICAgIHZhciB2ZWN0b3JMYXllclJlbmRlckJ1ZmZlciA9IHZlY3RvckxheWVyLmdldFJlbmRlckJ1ZmZlcigpO1xuICAgIHZhciB2ZWN0b3JMYXllclJlbmRlck9yZGVyID0gdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyT3JkZXIoKTtcblxuICAgIGlmICh2ZWN0b3JMYXllclJlbmRlck9yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZlY3RvckxheWVyUmVuZGVyT3JkZXIgPSBkZWZhdWx0UmVuZGVyT3JkZXI7XG4gICAgfVxuXG4gICAgdmFyIGV4dGVudCA9IGJ1ZmZlcihmcmFtZVN0YXRlRXh0ZW50LFxuICAgICAgdmVjdG9yTGF5ZXJSZW5kZXJCdWZmZXIgKiByZXNvbHV0aW9uKTtcbiAgICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uLmdldEV4dGVudCgpO1xuXG4gICAgaWYgKHZlY3RvclNvdXJjZS5nZXRXcmFwWCgpICYmIHZpZXdTdGF0ZS5wcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAgICAgIWNvbnRhaW5zRXh0ZW50KHByb2plY3Rpb25FeHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KSkge1xuICAgICAgLy8gRm9yIHRoZSByZXBsYXkgZ3JvdXAsIHdlIG5lZWQgYW4gZXh0ZW50IHRoYXQgaW50ZXJzZWN0cyB0aGUgcmVhbCB3b3JsZFxuICAgICAgLy8gKC0xODDCsCB0byArMTgwwrApLiBUbyBzdXBwb3J0IGdlb21ldHJpZXMgaW4gYSBjb29yZGluYXRlIHJhbmdlIGZyb20gLTU0MMKwXG4gICAgICAvLyB0byArNTQwwrAsIHdlIGFkZCBhdCBsZWFzdCAxIHdvcmxkIHdpZHRoIG9uIGVhY2ggc2lkZSBvZiB0aGUgcHJvamVjdGlvblxuICAgICAgLy8gZXh0ZW50LiBJZiB0aGUgdmlld3BvcnQgaXMgd2lkZXIgdGhhbiB0aGUgd29ybGQsIHdlIG5lZWQgdG8gYWRkIGhhbGYgb2ZcbiAgICAgIC8vIHRoZSB2aWV3cG9ydCB3aWR0aCB0byBtYWtlIHN1cmUgd2UgY292ZXIgdGhlIHdob2xlIHZpZXdwb3J0LlxuICAgICAgdmFyIHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIHZhciBndXR0ZXIgPSBNYXRoLm1heChnZXRXaWR0aChleHRlbnQpIC8gMiwgd29ybGRXaWR0aCk7XG4gICAgICBleHRlbnRbMF0gPSBwcm9qZWN0aW9uRXh0ZW50WzBdIC0gZ3V0dGVyO1xuICAgICAgZXh0ZW50WzJdID0gcHJvamVjdGlvbkV4dGVudFsyXSArIGd1dHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlydHlfICYmXG4gICAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9PSByZXNvbHV0aW9uICYmXG4gICAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPT0gdmVjdG9yTGF5ZXJSZXZpc2lvbiAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVkUmVuZGVyT3JkZXJfID09IHZlY3RvckxheWVyUmVuZGVyT3JkZXIgJiZcbiAgICAgICAgY29udGFpbnNFeHRlbnQodGhpcy5yZW5kZXJlZEV4dGVudF8sIGV4dGVudCkpIHtcbiAgICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICB0aGlzLmRpcnR5XyA9IGZhbHNlO1xuXG4gICAgdmFyIHJlcGxheUdyb3VwID0gbmV3IENhbnZhc1JlcGxheUdyb3VwKFxuICAgICAgZ2V0UmVuZGVyVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pLCBleHRlbnQsIHJlc29sdXRpb24sXG4gICAgICBwaXhlbFJhdGlvLCB2ZWN0b3JTb3VyY2UuZ2V0T3ZlcmxhcHMoKSwgdGhpcy5kZWNsdXR0ZXJUcmVlXywgdmVjdG9yTGF5ZXIuZ2V0UmVuZGVyQnVmZmVyKCkpO1xuICAgIHZlY3RvclNvdXJjZS5sb2FkRmVhdHVyZXMoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHRoaXMge21vZHVsZTpvbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXJ9XG4gICAgICovXG4gICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIHZhciBzdHlsZXM7XG4gICAgICB2YXIgc3R5bGVGdW5jdGlvbiA9IGZlYXR1cmUuZ2V0U3R5bGVGdW5jdGlvbigpIHx8IHZlY3RvckxheWVyLmdldFN0eWxlRnVuY3Rpb24oKTtcbiAgICAgIGlmIChzdHlsZUZ1bmN0aW9uKSB7XG4gICAgICAgIHN0eWxlcyA9IHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIHZhciBkaXJ0eSA9IHRoaXMucmVuZGVyRmVhdHVyZShcbiAgICAgICAgICBmZWF0dXJlLCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdHlsZXMsIHJlcGxheUdyb3VwKTtcbiAgICAgICAgdGhpcy5kaXJ0eV8gPSB0aGlzLmRpcnR5XyB8fCBkaXJ0eTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgaWYgKHZlY3RvckxheWVyUmVuZGVyT3JkZXIpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gKi9cbiAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgdmVjdG9yU291cmNlLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgZmVhdHVyZXMuc29ydCh2ZWN0b3JMYXllclJlbmRlck9yZGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgcmVuZGVyKGZlYXR1cmVzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmVjdG9yU291cmNlLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCByZW5kZXIsIHRoaXMpO1xuICAgIH1cbiAgICByZXBsYXlHcm91cC5maW5pc2goKTtcblxuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IHZlY3RvckxheWVyUmV2aXNpb247XG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IHZlY3RvckxheWVyUmVuZGVyT3JkZXI7XG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSByZXBsYXlHcm91cDtcblxuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHsobW9kdWxlOm9sL3N0eWxlL1N0eWxlfEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+KX0gc3R5bGVzIFRoZSBzdHlsZSBvciBhcnJheSBvZiBzdHlsZXMuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGFuIGltYWdlIGlzIGxvYWRpbmcuXG4gICAqL1xuICBDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZWF0dXJlID0gZnVuY3Rpb24gcmVuZGVyRmVhdHVyZSQxIChmZWF0dXJlLCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdHlsZXMsIHJlcGxheUdyb3VwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXNbaV0sXG4gICAgICAgICAgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzJDEuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8sIHRoaXMkMSkgfHwgbG9hZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZGluZyA9IHJlbmRlckZlYXR1cmUoXG4gICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXMsXG4gICAgICAgIGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyksXG4gICAgICAgIHRoaXMuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZGluZztcbiAgfTtcblxuICByZXR1cm4gQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcbn0oQ2FudmFzTGF5ZXJSZW5kZXJlcikpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlcmVyL01hcH0gbWFwUmVuZGVyZXIgVGhlIG1hcCByZW5kZXJlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYmUgcmVuZGVyZXJkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JMYXllcn0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICovXG5DYW52YXNWZWN0b3JMYXllclJlbmRlcmVyWydjcmVhdGUnXSA9IGZ1bmN0aW9uKG1hcFJlbmRlcmVyLCBsYXllcikge1xuICByZXR1cm4gbmV3IENhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXIoLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yfSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yTGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi8uLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uLy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uLy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHJidXNoIGZyb20gJ3JidXNoJztcbmltcG9ydCB7YnVmZmVyLCBjb250YWluc0Nvb3JkaW5hdGUsIGVxdWFscywgZ2V0SW50ZXJzZWN0aW9uLCBnZXRUb3BMZWZ0LCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFZlY3RvclRpbGVSZW5kZXJUeXBlIGZyb20gJy4uLy4uL2xheWVyL1ZlY3RvclRpbGVSZW5kZXJUeXBlLmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudCBhcyBlcXVpdmFsZW50UHJvamVjdGlvbn0gZnJvbSAnLi4vLi4vcHJvai5qcyc7XG5pbXBvcnQgVW5pdHMgZnJvbSAnLi4vLi4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuLi8uLi9yZW5kZXIvUmVwbGF5VHlwZS5qcyc7XG5pbXBvcnQge2xhYmVsQ2FjaGUsIHJvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXlHcm91cCwge3JlcGxheURlY2x1dHRlcn0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQge09SREVSfSBmcm9tICcuLi8uLi9yZW5kZXIvcmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9jYW52YXMvVGlsZUxheWVyLmpzJztcbmltcG9ydCB7Z2V0U3F1YXJlZFRvbGVyYW5jZSBhcyBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlLCByZW5kZXJGZWF0dXJlfSBmcm9tICcuLi92ZWN0b3IuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSxcbiAgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtLFxuICByZXNldCBhcyByZXNldFRyYW5zZm9ybSxcbiAgc2NhbGUgYXMgc2NhbGVUcmFuc2Zvcm0sXG4gIHRyYW5zbGF0ZSBhcyB0cmFuc2xhdGVUcmFuc2Zvcm1cbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6b2wvcmVuZGVyL1JlcGxheVR5cGU+Pn1cbiAqL1xudmFyIElNQUdFX1JFUExBWVMgPSB7XG4gICdpbWFnZSc6IFtSZXBsYXlUeXBlLlBPTFlHT04sIFJlcGxheVR5cGUuQ0lSQ0xFLFxuICAgIFJlcGxheVR5cGUuTElORV9TVFJJTkcsIFJlcGxheVR5cGUuSU1BR0UsIFJlcGxheVR5cGUuVEVYVF0sXG4gICdoeWJyaWQnOiBbUmVwbGF5VHlwZS5QT0xZR09OLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HXVxufTtcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIEFycmF5Ljxtb2R1bGU6b2wvcmVuZGVyL1JlcGxheVR5cGU+Pn1cbiAqL1xudmFyIFZFQ1RPUl9SRVBMQVlTID0ge1xuICAnaW1hZ2UnOiBbUmVwbGF5VHlwZS5ERUZBVUxUXSxcbiAgJ2h5YnJpZCc6IFtSZXBsYXlUeXBlLklNQUdFLCBSZXBsYXlUeXBlLlRFWFQsIFJlcGxheVR5cGUuREVGQVVMVF0sXG4gICd2ZWN0b3InOiBPUkRFUlxufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdmVjdG9yIHRpbGUgbGF5ZXJzLlxuICogQGFwaVxuICovXG52YXIgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIgPSAoZnVuY3Rpb24gKENhbnZhc1RpbGVMYXllclJlbmRlcmVyKSB7XG4gIGZ1bmN0aW9uIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyKGxheWVyKSB7XG5cbiAgICBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5jYWxsKHRoaXMsIGxheWVyLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIERlY2x1dHRlciB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlXyA9IGxheWVyLmdldERlY2x1dHRlcigpID8gcmJ1c2goOSwgdW5kZWZpbmVkKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50bXBUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvLyBVc2UgbG93ZXIgcmVzb2x1dGlvbiBmb3IgcHVyZSB2ZWN0b3IgcmVuZGVyaW5nLiBDbG9zZXN0IHJlc29sdXRpb24gb3RoZXJ3aXNlLlxuICAgIHRoaXMuekRpcmVjdGlvbiA9IGxheWVyLmdldFJlbmRlck1vZGUoKSA9PSBWZWN0b3JUaWxlUmVuZGVyVHlwZS5WRUNUT1IgPyAxIDogMDtcblxuICAgIGxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG5cbiAgfVxuXG4gIGlmICggQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgKSBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5fX3Byb3RvX18gPSBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcjtcbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgJiYgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlICk7XG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmRpc3Bvc2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCAoKSB7XG4gICAgdW5saXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuICAgIENhbnZhc1RpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIHZhciB0aWxlID0gQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmdldFRpbGUuY2FsbCh0aGlzLCB6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09PSBUaWxlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLmNyZWF0ZVJlcGxheUdyb3VwXyh0aWxlLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUaWxlSW1hZ2VfKHRpbGUsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiBwcmVwYXJlRnJhbWUgKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgdmFyIGxheWVyUmV2aXNpb24gPSBsYXllci5nZXRSZXZpc2lvbigpO1xuICAgIGlmICh0aGlzLnJlbmRlcmVkTGF5ZXJSZXZpc2lvbl8gIT0gbGF5ZXJSZXZpc2lvbikge1xuICAgICAgdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVuZGVyTW9kZSA9IGxheWVyLmdldFJlbmRlck1vZGUoKTtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0ICYmIHJlbmRlck1vZGUgIT0gVmVjdG9yVGlsZVJlbmRlclR5cGUuVkVDVE9SKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGV4dCAmJiByZW5kZXJNb2RlID09IFZlY3RvclRpbGVSZW5kZXJUeXBlLlZFQ1RPUikge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVkTGF5ZXJSZXZpc2lvbl8gPSBsYXllclJldmlzaW9uO1xuICAgIHJldHVybiBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucHJlcGFyZUZyYW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1ZlY3RvckltYWdlVGlsZX0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlUmVwbGF5R3JvdXBfID0gZnVuY3Rpb24gY3JlYXRlUmVwbGF5R3JvdXBfICh0aWxlLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgdmFyIHJldmlzaW9uID0gbGF5ZXIuZ2V0UmV2aXNpb24oKTtcbiAgICB2YXIgcmVuZGVyT3JkZXIgPSAvKiogQHR5cGUge21vZHVsZTpvbC9yZW5kZXJ+T3JkZXJGdW5jdGlvbn0gKi8gKGxheWVyLmdldFJlbmRlck9yZGVyKCkpIHx8IG51bGw7XG5cbiAgICB2YXIgcmVwbGF5U3RhdGUgPSB0aWxlLmdldFJlcGxheVN0YXRlKGxheWVyKTtcbiAgICBpZiAoIXJlcGxheVN0YXRlLmRpcnR5ICYmIHJlcGxheVN0YXRlLnJlbmRlcmVkUmV2aXNpb24gPT0gcmV2aXNpb24gJiZcbiAgICAgICAgcmVwbGF5U3RhdGUucmVuZGVyZWRSZW5kZXJPcmRlciA9PSByZW5kZXJPcmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yVGlsZX0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICB2YXIgc291cmNlVGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWQoKTtcbiAgICB2YXIgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIHZhciByZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlLnRpbGVDb29yZFswXSk7XG4gICAgdmFyIHRpbGVFeHRlbnQgPSB0aWxlLmV4dGVudDtcblxuICAgIHZhciB6SW5kZXhLZXlzID0ge307XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIHQsIHR0ICkge1xuICAgICAgdmFyIHNvdXJjZVRpbGUgPSB0aWxlLmdldFRpbGUodGlsZS50aWxlS2V5c1t0XSk7XG4gICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlVGlsZUNvb3JkID0gc291cmNlVGlsZS50aWxlQ29vcmQ7XG4gICAgICB2YXIgc291cmNlVGlsZUV4dGVudCA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudChzb3VyY2VUaWxlQ29vcmQpO1xuICAgICAgdmFyIHNoYXJlZEV4dGVudCA9IGdldEludGVyc2VjdGlvbih0aWxlRXh0ZW50LCBzb3VyY2VUaWxlRXh0ZW50KTtcbiAgICAgIHZhciBidWZmZXJlZEV4dGVudCA9IGVxdWFscyhzb3VyY2VUaWxlRXh0ZW50LCBzaGFyZWRFeHRlbnQpID8gbnVsbCA6XG4gICAgICAgIGJ1ZmZlcihzaGFyZWRFeHRlbnQsIGxheWVyLmdldFJlbmRlckJ1ZmZlcigpICogcmVzb2x1dGlvbiwgdGhpcyQxLnRtcEV4dGVudCk7XG4gICAgICB2YXIgdGlsZVByb2plY3Rpb24gPSBzb3VyY2VUaWxlLmdldFByb2plY3Rpb24oKTtcbiAgICAgIHZhciByZXByb2plY3QgPSBmYWxzZTtcbiAgICAgIGlmICghZXF1aXZhbGVudFByb2plY3Rpb24ocHJvamVjdGlvbiwgdGlsZVByb2plY3Rpb24pKSB7XG4gICAgICAgIHJlcHJvamVjdCA9IHRydWU7XG4gICAgICAgIHNvdXJjZVRpbGUuc2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJlcGxheVN0YXRlLmRpcnR5ID0gZmFsc2U7XG4gICAgICB2YXIgcmVwbGF5R3JvdXAgPSBuZXcgQ2FudmFzUmVwbGF5R3JvdXAoMCwgc2hhcmVkRXh0ZW50LCByZXNvbHV0aW9uLFxuICAgICAgICBwaXhlbFJhdGlvLCBzb3VyY2UuZ2V0T3ZlcmxhcHMoKSwgdGhpcyQxLmRlY2x1dHRlclRyZWVfLCBsYXllci5nZXRSZW5kZXJCdWZmZXIoKSk7XG4gICAgICB2YXIgc3F1YXJlZFRvbGVyYW5jZSA9IGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqIEB0aGlzIHttb2R1bGU6b2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvclRpbGVMYXllcn1cbiAgICAgICAqL1xuICAgICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIHN0eWxlcztcbiAgICAgICAgdmFyIHN0eWxlRnVuY3Rpb24gPSBmZWF0dXJlLmdldFN0eWxlRnVuY3Rpb24oKSB8fCBsYXllci5nZXRTdHlsZUZ1bmN0aW9uKCk7XG4gICAgICAgIGlmIChzdHlsZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgc3R5bGVzID0gc3R5bGVGdW5jdGlvbihmZWF0dXJlLCByZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgdmFyIGRpcnR5ID0gdGhpcy5yZW5kZXJGZWF0dXJlKGZlYXR1cmUsIHNxdWFyZWRUb2xlcmFuY2UsIHN0eWxlcywgcmVwbGF5R3JvdXApO1xuICAgICAgICAgIHRoaXMuZGlydHlfID0gdGhpcy5kaXJ0eV8gfHwgZGlydHk7XG4gICAgICAgICAgcmVwbGF5U3RhdGUuZGlydHkgPSByZXBsYXlTdGF0ZS5kaXJ0eSB8fCBkaXJ0eTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGZlYXR1cmVzID0gc291cmNlVGlsZS5nZXRGZWF0dXJlcygpO1xuICAgICAgaWYgKHJlbmRlck9yZGVyICYmIHJlbmRlck9yZGVyICE9PSByZXBsYXlTdGF0ZS5yZW5kZXJlZFJlbmRlck9yZGVyKSB7XG4gICAgICAgIGZlYXR1cmVzLnNvcnQocmVuZGVyT3JkZXIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICBpZiAocmVwcm9qZWN0KSB7XG4gICAgICAgICAgaWYgKHRpbGVQcm9qZWN0aW9uLmdldFVuaXRzKCkgPT0gVW5pdHMuVElMRV9QSVhFTFMpIHtcbiAgICAgICAgICAgIC8vIHByb2plY3RlZCB0aWxlIGV4dGVudFxuICAgICAgICAgICAgdGlsZVByb2plY3Rpb24uc2V0V29ybGRFeHRlbnQoc291cmNlVGlsZUV4dGVudCk7XG4gICAgICAgICAgICAvLyB0aWxlIGV4dGVudCBpbiB0aWxlIHBpeGVsIHNwYWNlXG4gICAgICAgICAgICB0aWxlUHJvamVjdGlvbi5zZXRFeHRlbnQoc291cmNlVGlsZS5nZXRFeHRlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS50cmFuc2Zvcm0odGlsZVByb2plY3Rpb24sIHByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmZmVyZWRFeHRlbnQgfHwgaW50ZXJzZWN0cyhidWZmZXJlZEV4dGVudCwgZmVhdHVyZS5nZXRHZW9tZXRyeSgpLmdldEV4dGVudCgpKSkge1xuICAgICAgICAgIHJlbmRlci5jYWxsKHRoaXMkMSwgZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcGxheUdyb3VwLmZpbmlzaCgpO1xuICAgICAgZm9yICh2YXIgciBpbiByZXBsYXlHcm91cC5nZXRSZXBsYXlzKCkpIHtcbiAgICAgICAgekluZGV4S2V5c1tyXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBzb3VyY2VUaWxlLnNldFJlcGxheUdyb3VwKGxheWVyLCB0aWxlLnRpbGVDb29yZC50b1N0cmluZygpLCByZXBsYXlHcm91cCk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkgbG9vcCggdCwgdHQgKTtcbiAgICByZXBsYXlTdGF0ZS5yZW5kZXJlZFJldmlzaW9uID0gcmV2aXNpb247XG4gICAgcmVwbGF5U3RhdGUucmVuZGVyZWRSZW5kZXJPcmRlciA9IHJlbmRlck9yZGVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlID0gZnVuY3Rpb24gZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUgKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzb2x1dGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgdmFyIHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgaGl0VG9sZXJhbmNlID0gaGl0VG9sZXJhbmNlID09IHVuZGVmaW5lZCA/IDAgOiBoaXRUb2xlcmFuY2U7XG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBib29sZWFuPn0gKi9cbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9WZWN0b3JJbWFnZVRpbGU+fSAqL1xuICAgIHZhciByZW5kZXJlZFRpbGVzID0gdGhpcy5yZW5kZXJlZFRpbGVzO1xuXG4gICAgdmFyIGJ1ZmZlcmVkRXh0ZW50LCBmb3VuZDtcbiAgICB2YXIgaSwgaWksIHJlcGxheUdyb3VwO1xuICAgIGZvciAoaSA9IDAsIGlpID0gcmVuZGVyZWRUaWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB2YXIgdGlsZSA9IHJlbmRlcmVkVGlsZXNbaV07XG4gICAgICBidWZmZXJlZEV4dGVudCA9IGJ1ZmZlcih0aWxlLmV4dGVudCwgaGl0VG9sZXJhbmNlICogcmVzb2x1dGlvbiwgYnVmZmVyZWRFeHRlbnQpO1xuICAgICAgaWYgKCFjb250YWluc0Nvb3JkaW5hdGUoYnVmZmVyZWRFeHRlbnQsIGNvb3JkaW5hdGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgdCA9IDAsIHR0ID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IHQgPCB0dDsgKyt0KSB7XG4gICAgICAgIHZhciBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYXlHcm91cCA9IHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsIHRpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCkpO1xuICAgICAgICBmb3VuZCA9IGZvdW5kIHx8IHJlcGxheUdyb3VwLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBoaXRUb2xlcmFuY2UsIHt9LFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgICAgICogQHJldHVybiB7P30gQ2FsbGJhY2sgcmVzdWx0LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRVaWQoZmVhdHVyZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBmZWF0dXJlcykpIHtcbiAgICAgICAgICAgICAgZmVhdHVyZXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGZlYXR1cmUsIGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9WZWN0b3JUaWxlfSB0aWxlIFRpbGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5nZXRSZXBsYXlUcmFuc2Zvcm1fID0gZnVuY3Rpb24gZ2V0UmVwbGF5VHJhbnNmb3JtXyAodGlsZSwgZnJhbWVTdGF0ZSkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICB2YXIgc291cmNlID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc291cmNlL1ZlY3RvclRpbGV9ICovIChsYXllci5nZXRTb3VyY2UoKSk7XG4gICAgdmFyIHRpbGVHcmlkID0gc291cmNlLmdldFRpbGVHcmlkKCk7XG4gICAgdmFyIHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuICAgIHZhciB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICB2YXIgdmlld1N0YXRlID0gZnJhbWVTdGF0ZS52aWV3U3RhdGU7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgdmFyIHJlbmRlclJlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbiAvIHBpeGVsUmF0aW87XG4gICAgdmFyIHRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzLnRtcEV4dGVudCk7XG4gICAgdmFyIGNlbnRlciA9IHZpZXdTdGF0ZS5jZW50ZXI7XG4gICAgdmFyIG9yaWdpbiA9IGdldFRvcExlZnQodGlsZUV4dGVudCk7XG4gICAgdmFyIHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgdmFyIG9mZnNldFggPSBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMik7XG4gICAgdmFyIG9mZnNldFkgPSBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMik7XG4gICAgcmV0dXJuIGNvbXBvc2VUcmFuc2Zvcm0odGhpcy50bXBUcmFuc2Zvcm1fLFxuICAgICAgb2Zmc2V0WCwgb2Zmc2V0WSxcbiAgICAgIHRpbGVSZXNvbHV0aW9uIC8gcmVuZGVyUmVzb2x1dGlvbiwgdGlsZVJlc29sdXRpb24gLyByZW5kZXJSZXNvbHV0aW9uLFxuICAgICAgdmlld1N0YXRlLnJvdGF0aW9uLFxuICAgICAgKG9yaWdpblswXSAtIGNlbnRlclswXSkgLyB0aWxlUmVzb2x1dGlvbixcbiAgICAgIChjZW50ZXJbMV0gLSBvcmlnaW5bMV0pIC8gdGlsZVJlc29sdXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKi9cbiAgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLmhhbmRsZUZvbnRzQ2hhbmdlZF8gPSBmdW5jdGlvbiBoYW5kbGVGb250c0NoYW5nZWRfIChldmVudCkge1xuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBJbWFnZSBzdHlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8gPSBmdW5jdGlvbiBoYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyAoZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucG9zdENvbXBvc2UgPSBmdW5jdGlvbiBwb3N0Q29tcG9zZSAoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIHZhciByZW5kZXJNb2RlID0gbGF5ZXIuZ2V0UmVuZGVyTW9kZSgpO1xuICAgIGlmIChyZW5kZXJNb2RlICE9IFZlY3RvclRpbGVSZW5kZXJUeXBlLklNQUdFKSB7XG4gICAgICB2YXIgZGVjbHV0dGVyUmVwbGF5cyA9IGxheWVyLmdldERlY2x1dHRlcigpID8ge30gOiBudWxsO1xuICAgICAgdmFyIHNvdXJjZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL3NvdXJjZS9WZWN0b3JUaWxlfSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgICAgdmFyIHJlcGxheVR5cGVzID0gVkVDVE9SX1JFUExBWVNbcmVuZGVyTW9kZV07XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIHZhciByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgICAgdmFyIHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgICB2YXIgb2Zmc2V0WCwgb2Zmc2V0WTtcbiAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICBvZmZzZXRYID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIpO1xuICAgICAgICBvZmZzZXRZID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVsxXSAvIDIpO1xuICAgICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCAtcm90YXRpb24sIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMpIHtcbiAgICAgICAgdGhpcy5kZWNsdXR0ZXJUcmVlXy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdmFyIHRpbGVzID0gdGhpcy5yZW5kZXJlZFRpbGVzO1xuICAgICAgdmFyIHRpbGVHcmlkID0gc291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICAgIHZhciBjbGlwcyA9IFtdO1xuICAgICAgdmFyIHpzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gdGlsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHRpbGUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9WZWN0b3JJbWFnZVRpbGV9ICovICh0aWxlc1tpXSk7XG4gICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkFCT1JUKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuICAgICAgICB2YXIgd29ybGRPZmZzZXQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCB0aGlzJDEudG1wRXh0ZW50KVswXSAtIHRpbGUuZXh0ZW50WzBdO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciB0ID0gMCwgdHQgPSB0aWxlLnRpbGVLZXlzLmxlbmd0aDsgdCA8IHR0OyArK3QpIHtcbiAgICAgICAgICB2YXIgc291cmNlVGlsZSA9IHRpbGUuZ2V0VGlsZSh0aWxlLnRpbGVLZXlzW3RdKTtcbiAgICAgICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVwbGF5R3JvdXAgPSBzb3VyY2VUaWxlLmdldFJlcGxheUdyb3VwKGxheWVyLCB0aWxlQ29vcmQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgaWYgKCFyZXBsYXlHcm91cCB8fCAhcmVwbGF5R3JvdXAuaGFzUmVwbGF5cyhyZXBsYXlUeXBlcykpIHtcbiAgICAgICAgICAgIC8vIHNvdXJjZVRpbGUgd2FzIG5vdCB5ZXQgbG9hZGVkIHdoZW4gdGhpcy5jcmVhdGVSZXBsYXlHcm91cF8oKSB3YXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCwgb3IgaXQgaGFzIG5vIHJlcGxheXMgb2YgdGhlIHR5cGVzIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMkMS5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgd29ybGRPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3VycmVudFogPSBzb3VyY2VUaWxlLnRpbGVDb29yZFswXTtcbiAgICAgICAgICB2YXIgY3VycmVudENsaXAgPSByZXBsYXlHcm91cC5nZXRDbGlwQ29vcmRzKHRyYW5zZm9ybSk7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBjbGlwIG1hc2sgZm9yIHJlZ2lvbnMgaW4gdGhpcyBsb3cgcmVzb2x1dGlvbiB0aWxlIHRoYXQgYXJlXG4gICAgICAgICAgLy8gYWxyZWFkeSBmaWxsZWQgYnkgYSBoaWdoZXIgcmVzb2x1dGlvbiB0aWxlXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gY2xpcHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgICAgdmFyIGNsaXAgPSBjbGlwc1tqXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50WiA8IHpzW2pdKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIC8vIGNvdW50ZXItY2xvY2t3aXNlIChvdXRlciByaW5nKSBmb3IgY3VycmVudCB0aWxlXG4gICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGN1cnJlbnRDbGlwWzBdLCBjdXJyZW50Q2xpcFsxXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzJdLCBjdXJyZW50Q2xpcFszXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzRdLCBjdXJyZW50Q2xpcFs1XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGN1cnJlbnRDbGlwWzZdLCBjdXJyZW50Q2xpcFs3XSk7XG4gICAgICAgICAgICAgIC8vIGNsb2Nrd2lzZSAoaW5uZXIgcmluZykgZm9yIGhpZ2hlciByZXNvbHV0aW9uIHRpbGVcbiAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oY2xpcFs2XSwgY2xpcFs3XSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbNF0sIGNsaXBbNV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzJdLCBjbGlwWzNdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFswXSwgY2xpcFsxXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwge30sIHJlcGxheVR5cGVzLCBkZWNsdXR0ZXJSZXBsYXlzKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgICBjbGlwcy5wdXNoKGN1cnJlbnRDbGlwKTtcbiAgICAgICAgICB6cy5wdXNoKGN1cnJlbnRaKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMpIHtcbiAgICAgICAgcmVwbGF5RGVjbHV0dGVyKGRlY2x1dHRlclJlcGxheXMsIGNvbnRleHQsIHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCByb3RhdGlvbixcbiAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFgpLCAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIucHJvdG90eXBlLnBvc3RDb21wb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0geyhtb2R1bGU6b2wvc3R5bGUvU3R5bGV8QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT4pfSBzdHlsZXMgVGhlIHN0eWxlIG9yIGFycmF5IG9mIHN0eWxlcy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYW4gaW1hZ2UgaXMgbG9hZGluZy5cbiAgICovXG4gIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZWF0dXJlID0gZnVuY3Rpb24gcmVuZGVyRmVhdHVyZSQxIChmZWF0dXJlLCBzcXVhcmVkVG9sZXJhbmNlLCBzdHlsZXMsIHJlcGxheUdyb3VwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHN0eWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXNbaV0sIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICAgICAgdGhpcyQxLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzJDEpIHx8IGxvYWRpbmc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICByZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGVzLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1ZlY3RvckltYWdlVGlsZX0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGlsZUltYWdlXyA9IGZ1bmN0aW9uIHJlbmRlclRpbGVJbWFnZV8gKHRpbGUsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICB2YXIgcmVwbGF5U3RhdGUgPSB0aWxlLmdldFJlcGxheVN0YXRlKGxheWVyKTtcbiAgICB2YXIgcmV2aXNpb24gPSBsYXllci5nZXRSZXZpc2lvbigpO1xuICAgIHZhciByZXBsYXlzID0gSU1BR0VfUkVQTEFZU1tsYXllci5nZXRSZW5kZXJNb2RlKCldO1xuICAgIGlmIChyZXBsYXlzICYmIHJlcGxheVN0YXRlLnJlbmRlcmVkVGlsZVJldmlzaW9uICE9PSByZXZpc2lvbikge1xuICAgICAgcmVwbGF5U3RhdGUucmVuZGVyZWRUaWxlUmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICAgIHZhciB0aWxlQ29vcmQgPSB0aWxlLndyYXBwZWRUaWxlQ29vcmQ7XG4gICAgICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgIHZhciBzb3VyY2UgPSAvKiogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yVGlsZX0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICAgIHZhciB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB2YXIgcmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgICB2YXIgY29udGV4dCA9IHRpbGUuZ2V0Q29udGV4dChsYXllcik7XG4gICAgICB2YXIgc2l6ZSA9IHNvdXJjZS5nZXRUaWxlUGl4ZWxTaXplKHosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgY29udGV4dC5jYW52YXMud2lkdGggPSBzaXplWzBdO1xuICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgICAgIHZhciB0aWxlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHZhciBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbaV0pO1xuICAgICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGl4ZWxTY2FsZSA9IHBpeGVsUmF0aW8gLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gcmVzZXRUcmFuc2Zvcm0odGhpcyQxLnRtcFRyYW5zZm9ybV8pO1xuICAgICAgICBzY2FsZVRyYW5zZm9ybSh0cmFuc2Zvcm0sIHBpeGVsU2NhbGUsIC1waXhlbFNjYWxlKTtcbiAgICAgICAgdHJhbnNsYXRlVHJhbnNmb3JtKHRyYW5zZm9ybSwgLXRpbGVFeHRlbnRbMF0sIC10aWxlRXh0ZW50WzNdKTtcbiAgICAgICAgdmFyIHJlcGxheUdyb3VwID0gc291cmNlVGlsZS5nZXRSZXBsYXlHcm91cChsYXllciwgdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShjb250ZXh0LCB0cmFuc2Zvcm0sIDAsIHt9LCByZXBsYXlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xufShDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcikpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9sYXllci9MYXllcn0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJbJ2hhbmRsZXMnXSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5WRUNUT1JfVElMRTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlcmVyL01hcH0gbWFwUmVuZGVyZXIgVGhlIG1hcCByZW5kZXJlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2xheWVyL0xheWVyfSBsYXllciBUaGUgbGF5ZXIgdG8gYmUgcmVuZGVyZXJkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXJ9IFRoZSBsYXllciByZW5kZXJlci5cbiAqL1xuQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIoLyoqIEB0eXBlIHttb2R1bGU6b2wvbGF5ZXIvVmVjdG9yVGlsZX0gKi8gKGxheWVyKSk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JUaWxlTGF5ZXIuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL3ZlY3RvclxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgSW1hZ2VTdGF0ZSBmcm9tICcuLi9JbWFnZVN0YXRlLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFJlcGxheVR5cGUgZnJvbSAnLi4vcmVuZGVyL1JlcGxheVR5cGUuanMnO1xuXG5cbi8qKlxuICogVG9sZXJhbmNlIGZvciBnZW9tZXRyeSBzaW1wbGlmaWNhdGlvbiBpbiBkZXZpY2UgcGl4ZWxzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIFNJTVBMSUZZX1RPTEVSQU5DRSA9IDAuNTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdC48bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlUeXBlLFxuICogICAgICAgICAgICAgICAgZnVuY3Rpb24obW9kdWxlOm9sL3JlbmRlci9SZXBsYXlHcm91cCwgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGU6b2wvc3R5bGUvU3R5bGUsIE9iamVjdCk+fVxuICovXG52YXIgR0VPTUVUUllfUkVOREVSRVJTID0ge1xuICAnUG9pbnQnOiByZW5kZXJQb2ludEdlb21ldHJ5LFxuICAnTGluZVN0cmluZyc6IHJlbmRlckxpbmVTdHJpbmdHZW9tZXRyeSxcbiAgJ1BvbHlnb24nOiByZW5kZXJQb2x5Z29uR2VvbWV0cnksXG4gICdNdWx0aVBvaW50JzogcmVuZGVyTXVsdGlQb2ludEdlb21ldHJ5LFxuICAnTXVsdGlMaW5lU3RyaW5nJzogcmVuZGVyTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksXG4gICdNdWx0aVBvbHlnb24nOiByZW5kZXJNdWx0aVBvbHlnb25HZW9tZXRyeSxcbiAgJ0dlb21ldHJ5Q29sbGVjdGlvbic6IHJlbmRlckdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5LFxuICAnQ2lyY2xlJzogcmVuZGVyQ2lyY2xlR2VvbWV0cnlcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZTEgRmVhdHVyZSAxLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUyIEZlYXR1cmUgMi5cbiAqIEByZXR1cm4ge251bWJlcn0gT3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0T3JkZXIoZmVhdHVyZTEsIGZlYXR1cmUyKSB7XG4gIHJldHVybiBnZXRVaWQoZmVhdHVyZTEpIC0gZ2V0VWlkKGZlYXR1cmUyKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBwaXhlbCB0b2xlcmFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcXVhcmVkVG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pIHtcbiAgdmFyIHRvbGVyYW5jZSA9IGdldFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKTtcbiAgcmV0dXJuIHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEByZXR1cm4ge251bWJlcn0gUGl4ZWwgdG9sZXJhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9sZXJhbmNlKHJlc29sdXRpb24sIHBpeGVsUmF0aW8pIHtcbiAgcmV0dXJuIFNJTVBMSUZZX1RPTEVSQU5DRSAqIHJlc29sdXRpb24gLyBwaXhlbFJhdGlvO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL1JlcGxheUdyb3VwfSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0NpcmNsZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNpcmNsZUdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGwoKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgY2lyY2xlUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkNJUkNMRSk7XG4gICAgY2lyY2xlUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBjaXJjbGVSZXBsYXkuZHJhd0NpcmNsZShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlHcm91cH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50KX0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1R9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGlzdGVuZXJgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHN0eWxlIGlzIGxvYWRpbmcuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRmVhdHVyZShyZXBsYXlHcm91cCwgZmVhdHVyZSwgc3R5bGUsIHNxdWFyZWRUb2xlcmFuY2UsIGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gIHZhciBsb2FkaW5nID0gZmFsc2U7XG4gIHZhciBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICB2YXIgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuTE9BREVEIHx8IGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5FUlJPUikge1xuICAgICAgaW1hZ2VTdHlsZS51bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICAgIGltYWdlU3R5bGUubG9hZCgpO1xuICAgICAgfVxuICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgICAgaW1hZ2VTdHlsZS5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lciwgdGhpc0FyZyk7XG4gICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSk7XG5cbiAgcmV0dXJuIGxvYWRpbmc7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSkge1xuICB2YXIgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gIGlmICghZ2VvbWV0cnkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNpbXBsaWZpZWRHZW9tZXRyeSA9IGdlb21ldHJ5LmdldFNpbXBsaWZpZWRHZW9tZXRyeShzcXVhcmVkVG9sZXJhbmNlKTtcbiAgdmFyIHJlbmRlcmVyID0gc3R5bGUuZ2V0UmVuZGVyZXIoKTtcbiAgaWYgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZW9tZXRyeVJlbmRlcmVyID0gR0VPTUVUUllfUkVOREVSRVJTW3NpbXBsaWZpZWRHZW9tZXRyeS5nZXRUeXBlKCldO1xuICAgIGdlb21ldHJ5UmVuZGVyZXIocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBpZiAoZ2VvbWV0cnkuZ2V0VHlwZSgpID09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbn0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICByZW5kZXJHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cmllc1tpXSwgc3R5bGUsIGZlYXR1cmUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5ERUZBVUxUKTtcbiAgcmVwbGF5LmRyYXdDdXN0b20oLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi8gKGdlb21ldHJ5KSwgZmVhdHVyZSwgc3R5bGUuZ2V0UmVuZGVyZXIoKSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5LmdldEdlb21ldHJpZXNBcnJheSgpO1xuICB2YXIgaSwgaWk7XG4gIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgdmFyIGdlb21ldHJ5UmVuZGVyZXIgPVxuICAgICAgICBHRU9NRVRSWV9SRU5ERVJFUlNbZ2VvbWV0cmllc1tpXS5nZXRUeXBlKCldO1xuICAgIGdlb21ldHJ5UmVuZGVyZXIocmVwbGF5R3JvdXAsIGdlb21ldHJpZXNbaV0sIHN0eWxlLCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL1JlcGxheUdyb3VwfSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpbmVTdHJpbmdHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgbGluZVN0cmluZ1JlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5MSU5FX1NUUklORyk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUobnVsbCwgc3Ryb2tlU3R5bGUpO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuZHJhd0xpbmVTdHJpbmcoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIHZhciB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICB2YXIgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vTXVsdGlMaW5lU3RyaW5nfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgbGluZVN0cmluZ1JlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5MSU5FX1NUUklORyk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUobnVsbCwgc3Ryb2tlU3R5bGUpO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuZHJhd011bHRpTGluZVN0cmluZyhnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlHcm91cH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvbHlnb259IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aVBvbHlnb25HZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIHZhciBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIHZhciBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUgfHwgZmlsbFN0eWxlKSB7XG4gICAgdmFyIHBvbHlnb25SZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuUE9MWUdPTik7XG4gICAgcG9seWdvblJlcGxheS5zZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSk7XG4gICAgcG9seWdvblJlcGxheS5kcmF3TXVsdGlQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVuZGVyL1JlcGxheUdyb3VwfSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL1BvaW50fG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJQb2ludEdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGlmIChpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKSAhPSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW1hZ2VSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuSU1BR0UpO1xuICAgIGltYWdlUmVwbGF5LnNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgaW1hZ2VSZXBsYXkuZHJhd1BvaW50KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoISFpbWFnZVN0eWxlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3JlbmRlci9SZXBsYXlHcm91cH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50fG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfG1vZHVsZTpvbC9yZW5kZXIvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICB2YXIgaW1hZ2VTdHlsZSA9IHN0eWxlLmdldEltYWdlKCk7XG4gIGlmIChpbWFnZVN0eWxlKSB7XG4gICAgaWYgKGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpICE9IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbWFnZVJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5JTUFHRSk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICBpbWFnZVJlcGxheS5kcmF3TXVsdGlQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgdmFyIHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIHZhciB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKCEhaW1hZ2VTdHlsZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9yZW5kZXIvUmVwbGF5R3JvdXB9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vUG9seWdvbnxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9seWdvbkdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgdmFyIGZpbGxTdHlsZSA9IHN0eWxlLmdldEZpbGwoKTtcbiAgdmFyIHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICB2YXIgcG9seWdvblJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5QT0xZR09OKTtcbiAgICBwb2x5Z29uUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBwb2x5Z29uUmVwbGF5LmRyYXdQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICB2YXIgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgdmFyIHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3IuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvalxuICovXG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtjb250YWluc0Nvb3JkaW5hdGUsIGNyZWF0ZUVtcHR5LCBleHRlbmQsIGdldEhlaWdodCwgZ2V0VG9wTGVmdCwgZ2V0V2lkdGh9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7c29sdmVMaW5lYXJTeXN0ZW19IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFBvaW50UmVzb2x1dGlvbiwgdHJhbnNmb3JtfSBmcm9tICcuL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBpZGVhbCByZXNvbHV0aW9uIHRvIHVzZSBmcm9tIHRoZSBzb3VyY2UgaW4gb3JkZXIgdG8gYWNoaWV2ZVxuICogcGl4ZWwgbWFwcGluZyBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byAxOjEgZHVyaW5nIHJlcHJvamVjdGlvbi5cbiAqIFRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgcmVnYXJkbGVzcyBvZiB3aGF0IHJlc29sdXRpb25zXG4gKiBhcmUgYWN0dWFsbHkgYXZhaWxhYmxlIGluIHRoZSBkYXRhc2V0IChUaWxlR3JpZCwgSW1hZ2UsIC4uLikuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSB0YXJnZXRDZW50ZXIgVGFyZ2V0IGNlbnRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmVzdCByZXNvbHV0aW9uIHRvIHVzZS4gQ2FuIGJlICstSW5maW5pdHksIE5hTiBvciAwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLFxuICB0YXJnZXRDZW50ZXIsIHRhcmdldFJlc29sdXRpb24pIHtcblxuICB2YXIgc291cmNlQ2VudGVyID0gdHJhbnNmb3JtKHRhcmdldENlbnRlciwgdGFyZ2V0UHJvaiwgc291cmNlUHJvaik7XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBpZGVhbCByZXNvbHV0aW9uIG9mIHRoZSBzb3VyY2UgZGF0YVxuICB2YXIgc291cmNlUmVzb2x1dGlvbiA9IGdldFBvaW50UmVzb2x1dGlvbih0YXJnZXRQcm9qLCB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRDZW50ZXIpO1xuXG4gIHZhciB0YXJnZXRNZXRlcnNQZXJVbml0ID0gdGFyZ2V0UHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmICh0YXJnZXRNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uICo9IHRhcmdldE1ldGVyc1BlclVuaXQ7XG4gIH1cbiAgdmFyIHNvdXJjZU1ldGVyc1BlclVuaXQgPSBzb3VyY2VQcm9qLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgaWYgKHNvdXJjZU1ldGVyc1BlclVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVJlc29sdXRpb24gLz0gc291cmNlTWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8vIEJhc2VkIG9uIHRoZSBwcm9qZWN0aW9uIHByb3BlcnRpZXMsIHRoZSBwb2ludCByZXNvbHV0aW9uIGF0IHRoZSBzcGVjaWZpZWRcbiAgLy8gY29vcmRpbmF0ZXMgbWF5IGJlIHNsaWdodGx5IGRpZmZlcmVudC4gV2UgbmVlZCB0byByZXZlcnNlLWNvbXBlbnNhdGUgdGhpc1xuICAvLyBpbiBvcmRlciB0byBhY2hpZXZlIG9wdGltYWwgcmVzdWx0cy5cblxuICB2YXIgc291cmNlRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgaWYgKCFzb3VyY2VFeHRlbnQgfHwgY29udGFpbnNDb29yZGluYXRlKHNvdXJjZUV4dGVudCwgc291cmNlQ2VudGVyKSkge1xuICAgIHZhciBjb21wZW5zYXRpb25GYWN0b3IgPSBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cblxuLyoqXG4gKiBFbmxhcmdlIHRoZSBjbGlwcGluZyB0cmlhbmdsZSBwb2ludCBieSAxIHBpeGVsIHRvIGVuc3VyZSB0aGUgZWRnZXMgb3ZlcmxhcFxuICogaW4gb3JkZXIgdG8gbWFzayBnYXBzIGNhdXNlZCBieSBhbnRpYWxpYXNpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWCBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHggY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWSBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHkgY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBOZXcgcG9pbnQgMSBweCBmYXJ0aGVyIGZyb20gdGhlIGNlbnRyb2lkLlxuICovXG5mdW5jdGlvbiBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB4LCB5KSB7XG4gIHZhciBkWCA9IHggLSBjZW50cm9pZFg7XG4gIHZhciBkWSA9IHkgLSBjZW50cm9pZFk7XG4gIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG4gIHJldHVybiBbTWF0aC5yb3VuZCh4ICsgZFggLyBkaXN0YW5jZSksIE1hdGgucm91bmQoeSArIGRZIC8gZGlzdGFuY2UpXTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHNvdXJjZSBkYXRhIGludG8gbmV3IGNhbnZhcyBiYXNlZCBvbiB0aGUgdHJpYW5ndWxhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIGNhbnZhcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzb3VyY2VSZXNvbHV0aW9uIFNvdXJjZSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gc291cmNlRXh0ZW50IEV4dGVudCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UmVzb2x1dGlvbiBUYXJnZXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb259IHRyaWFuZ3VsYXRpb25cbiAqIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXkuPHtleHRlbnQ6IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50LFxuICogICAgICAgICAgICAgICAgIGltYWdlOiAoSFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KX0+fSBzb3VyY2VzXG4gKiBBcnJheSBvZiBzb3VyY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVuZGVyRWRnZXMgUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgd2l0aCByZXByb2plY3RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sXG4gIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUV4dGVudCwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0RXh0ZW50LFxuICB0cmlhbmd1bGF0aW9uLCBzb3VyY2VzLCBndXR0ZXIsIG9wdF9yZW5kZXJFZGdlcykge1xuXG4gIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHdpZHRoKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBoZWlnaHQpKTtcblxuICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29udGV4dC5jYW52YXM7XG4gIH1cblxuICBjb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG4gIHZhciBzb3VyY2VEYXRhRXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNyYywgaSwgYXJyKSB7XG4gICAgZXh0ZW5kKHNvdXJjZURhdGFFeHRlbnQsIHNyYy5leHRlbnQpO1xuICB9KTtcblxuICB2YXIgY2FudmFzV2lkdGhJblVuaXRzID0gZ2V0V2lkdGgoc291cmNlRGF0YUV4dGVudCk7XG4gIHZhciBjYW52YXNIZWlnaHRJblVuaXRzID0gZ2V0SGVpZ2h0KHNvdXJjZURhdGFFeHRlbnQpO1xuICB2YXIgc3RpdGNoQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNXaWR0aEluVW5pdHMgLyBzb3VyY2VSZXNvbHV0aW9uKSxcbiAgICBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBjYW52YXNIZWlnaHRJblVuaXRzIC8gc291cmNlUmVzb2x1dGlvbikpO1xuXG4gIHZhciBzdGl0Y2hTY2FsZSA9IHBpeGVsUmF0aW8gLyBzb3VyY2VSZXNvbHV0aW9uO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzcmMsIGksIGFycikge1xuICAgIHZhciB4UG9zID0gc3JjLmV4dGVudFswXSAtIHNvdXJjZURhdGFFeHRlbnRbMF07XG4gICAgdmFyIHlQb3MgPSAtKHNyYy5leHRlbnRbM10gLSBzb3VyY2VEYXRhRXh0ZW50WzNdKTtcbiAgICB2YXIgc3JjV2lkdGggPSBnZXRXaWR0aChzcmMuZXh0ZW50KTtcbiAgICB2YXIgc3JjSGVpZ2h0ID0gZ2V0SGVpZ2h0KHNyYy5leHRlbnQpO1xuXG4gICAgc3RpdGNoQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICBzcmMuaW1hZ2UsXG4gICAgICBndXR0ZXIsIGd1dHRlcixcbiAgICAgIHNyYy5pbWFnZS53aWR0aCAtIDIgKiBndXR0ZXIsIHNyYy5pbWFnZS5oZWlnaHQgLSAyICogZ3V0dGVyLFxuICAgICAgeFBvcyAqIHN0aXRjaFNjYWxlLCB5UG9zICogc3RpdGNoU2NhbGUsXG4gICAgICBzcmNXaWR0aCAqIHN0aXRjaFNjYWxlLCBzcmNIZWlnaHQgKiBzdGl0Y2hTY2FsZSk7XG4gIH0pO1xuXG4gIHZhciB0YXJnZXRUb3BMZWZ0ID0gZ2V0VG9wTGVmdCh0YXJnZXRFeHRlbnQpO1xuXG4gIHRyaWFuZ3VsYXRpb24uZ2V0VHJpYW5nbGVzKCkuZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgLyogQ2FsY3VsYXRlIGFmZmluZSB0cmFuc2Zvcm0gKHNyYyAtPiBkc3QpXG4gICAgICogUmVzdWx0aW5nIG1hdHJpeCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZVxuICAgICAqIGZyb20gYHNvdXJjZVByb2plY3Rpb25gIHRvIGRlc3RpbmF0aW9uIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRvIG9wdGltaXplIG51bWJlciBvZiBjb250ZXh0IGNhbGxzIGFuZCBpbmNyZWFzZSBudW1lcmljYWwgc3RhYmlsaXR5LFxuICAgICAqIHdlIGFsc28gZG8gdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICAgICAqIHRyYW5zKC10b3BMZWZ0RXh0ZW50Q29ybmVyKSwgc2NhbGUoMSAvIHRhcmdldFJlc29sdXRpb24pLCBzY2FsZSgxLCAtMSlcbiAgICAgKiBoZXJlIGJlZm9yZSBzb2x2aW5nIHRoZSBsaW5lYXIgc3lzdGVtIHNvIFt1aSwgdmldIGFyZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIFNyYyBwb2ludHM6IHhpLCB5aVxuICAgICAqIERzdCBwb2ludHM6IHVpLCB2aVxuICAgICAqIEFmZmluZSBjb2VmZmljaWVudHM6IGFpalxuICAgICAqXG4gICAgICogfCB4MCB5MCAxICAwICAwIDAgfCAgIHxhMDB8ICAgfHUwfFxuICAgICAqIHwgeDEgeTEgMSAgMCAgMCAwIHwgICB8YTAxfCAgIHx1MXxcbiAgICAgKiB8IHgyIHkyIDEgIDAgIDAgMCB8IHggfGEwMnwgPSB8dTJ8XG4gICAgICogfCAgMCAgMCAwIHgwIHkwIDEgfCAgIHxhMTB8ICAgfHYwfFxuICAgICAqIHwgIDAgIDAgMCB4MSB5MSAxIHwgICB8YTExfCAgIHx2MXxcbiAgICAgKiB8ICAwICAwIDAgeDIgeTIgMSB8ICAgfGExMnwgICB8djJ8XG4gICAgICovXG4gICAgdmFyIHNvdXJjZSA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICB2YXIgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgIHZhciB4MCA9IHNvdXJjZVswXVswXSwgeTAgPSBzb3VyY2VbMF1bMV07XG4gICAgdmFyIHgxID0gc291cmNlWzFdWzBdLCB5MSA9IHNvdXJjZVsxXVsxXTtcbiAgICB2YXIgeDIgPSBzb3VyY2VbMl1bMF0sIHkyID0gc291cmNlWzJdWzFdO1xuICAgIHZhciB1MCA9ICh0YXJnZXRbMF1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgdmFyIHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICB2YXIgdjEgPSAtKHRhcmdldFsxXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICB2YXIgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIHZhciB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSBzb3VyY2UgcG9pbnRzIHRvIGltcHJvdmUgbnVtZXJpY2FsIHN0YWJpbGl0eVxuICAgIC8vIG9mIGFsbCB0aGUgc3Vic2VxdWVudCBjYWxjdWxhdGlvbnMuIFRoZSBbeDAsIHkwXSBpcyB1c2VkIGhlcmUuXG4gICAgLy8gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2ltcGxpZnkgdGhlIGxpbmVhciBzeXN0ZW0uXG4gICAgdmFyIHNvdXJjZU51bWVyaWNhbFNoaWZ0WCA9IHgwO1xuICAgIHZhciBzb3VyY2VOdW1lcmljYWxTaGlmdFkgPSB5MDtcbiAgICB4MCA9IDA7XG4gICAgeTAgPSAwO1xuICAgIHgxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG4gICAgeDIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcblxuICAgIHZhciBhdWdtZW50ZWRNYXRyaXggPSBbXG4gICAgICBbeDEsIHkxLCAwLCAwLCB1MSAtIHUwXSxcbiAgICAgIFt4MiwgeTIsIDAsIDAsIHUyIC0gdTBdLFxuICAgICAgWzAsIDAsIHgxLCB5MSwgdjEgLSB2MF0sXG4gICAgICBbMCwgMCwgeDIsIHkyLCB2MiAtIHYwXVxuICAgIF07XG4gICAgdmFyIGFmZmluZUNvZWZzID0gc29sdmVMaW5lYXJTeXN0ZW0oYXVnbWVudGVkTWF0cml4KTtcbiAgICBpZiAoIWFmZmluZUNvZWZzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB2YXIgY2VudHJvaWRYID0gKHUwICsgdTEgKyB1MikgLyAzO1xuICAgIHZhciBjZW50cm9pZFkgPSAodjAgKyB2MSArIHYyKSAvIDM7XG4gICAgdmFyIHAwID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTAsIHYwKTtcbiAgICB2YXIgcDEgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MSwgdjEpO1xuICAgIHZhciBwMiA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUyLCB2Mik7XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhwMVswXSwgcDFbMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHAwWzBdLCBwMFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocDJbMF0sIHAyWzFdKTtcbiAgICBjb250ZXh0LmNsaXAoKTtcblxuICAgIGNvbnRleHQudHJhbnNmb3JtKFxuICAgICAgYWZmaW5lQ29lZnNbMF0sIGFmZmluZUNvZWZzWzJdLCBhZmZpbmVDb2Vmc1sxXSwgYWZmaW5lQ29lZnNbM10sIHUwLCB2MCk7XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShzb3VyY2VEYXRhRXh0ZW50WzBdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRYLFxuICAgICAgc291cmNlRGF0YUV4dGVudFszXSAtIHNvdXJjZU51bWVyaWNhbFNoaWZ0WSk7XG5cbiAgICBjb250ZXh0LnNjYWxlKHNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvLFxuICAgICAgLXNvdXJjZVJlc29sdXRpb24gLyBwaXhlbFJhdGlvKTtcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHN0aXRjaENvbnRleHQuY2FudmFzLCAwLCAwKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfSk7XG5cbiAgaWYgKG9wdF9yZW5kZXJFZGdlcykge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuXG4gICAgdHJpYW5ndWxhdGlvbi5nZXRUcmlhbmdsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgICB2YXIgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICB2YXIgdTEgPSAodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICB2YXIgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgdmFyIHYyID0gLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh1MSwgdjEpO1xuICAgICAgY29udGV4dC5saW5lVG8odTAsIHYwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUyLCB2Mik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9KTtcblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmNhbnZhcztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwcm9qLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovSW1hZ2VcbiAqL1xuaW1wb3J0IHtFUlJPUl9USFJFU0hPTER9IGZyb20gJy4vY29tbW9uLmpzJztcblxuaW1wb3J0IEltYWdlQmFzZSBmcm9tICcuLi9JbWFnZUJhc2UuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldENlbnRlciwgZ2V0SW50ZXJzZWN0aW9uLCBnZXRIZWlnaHQsIGdldFdpZHRofSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uLCByZW5kZXIgYXMgcmVuZGVyUmVwcm9qZWN0ZWR9IGZyb20gJy4uL3JlcHJvai5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuLi9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL2V4dGVudH5FeHRlbnQsIG51bWJlciwgbnVtYmVyKSA6IG1vZHVsZTpvbC9JbWFnZUJhc2V9IEZ1bmN0aW9uVHlwZVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCBpbWFnZS5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9JbWFnZX5JbWFnZVNvdXJjZX0uXG4gKi9cbnZhciBSZXByb2pJbWFnZSA9IChmdW5jdGlvbiAoSW1hZ2VCYXNlKSB7XG4gIGZ1bmN0aW9uIFJlcHJvakltYWdlKHNvdXJjZVByb2osIHRhcmdldFByb2osIHRhcmdldEV4dGVudCwgdGFyZ2V0UmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgZ2V0SW1hZ2VGdW5jdGlvbikge1xuICAgIHZhciBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIHZhciBtYXhUYXJnZXRFeHRlbnQgPSB0YXJnZXRQcm9qLmdldEV4dGVudCgpO1xuXG4gICAgdmFyIGxpbWl0ZWRUYXJnZXRFeHRlbnQgPSBtYXhUYXJnZXRFeHRlbnQgP1xuICAgICAgZ2V0SW50ZXJzZWN0aW9uKHRhcmdldEV4dGVudCwgbWF4VGFyZ2V0RXh0ZW50KSA6IHRhcmdldEV4dGVudDtcblxuICAgIHZhciB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIobGltaXRlZFRhcmdldEV4dGVudCk7XG4gICAgdmFyIHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgdGFyZ2V0Q2VudGVyLCB0YXJnZXRSZXNvbHV0aW9uKTtcblxuICAgIHZhciBlcnJvclRocmVzaG9sZEluUGl4ZWxzID0gRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgdmFyIHRyaWFuZ3VsYXRpb24gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIGxpbWl0ZWRUYXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzKTtcblxuICAgIHZhciBzb3VyY2VFeHRlbnQgPSB0cmlhbmd1bGF0aW9uLmNhbGN1bGF0ZVNvdXJjZUV4dGVudCgpO1xuICAgIHZhciBzb3VyY2VJbWFnZSA9IGdldEltYWdlRnVuY3Rpb24oc291cmNlRXh0ZW50LCBzb3VyY2VSZXNvbHV0aW9uLCBwaXhlbFJhdGlvKTtcbiAgICB2YXIgc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURFRDtcbiAgICBpZiAoc291cmNlSW1hZ2UpIHtcbiAgICAgIHN0YXRlID0gSW1hZ2VTdGF0ZS5JRExFO1xuICAgIH1cbiAgICB2YXIgc291cmNlUGl4ZWxSYXRpbyA9IHNvdXJjZUltYWdlID8gc291cmNlSW1hZ2UuZ2V0UGl4ZWxSYXRpbygpIDogMTtcblxuICAgIEltYWdlQmFzZS5jYWxsKHRoaXMsIHRhcmdldEV4dGVudCwgdGFyZ2V0UmVzb2x1dGlvbiwgc291cmNlUGl4ZWxSYXRpbywgc3RhdGUpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4U291cmNlRXh0ZW50XyA9IG1heFNvdXJjZUV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFtb2R1bGU6b2wvcmVwcm9qL1RyaWFuZ3VsYXRpb259XG4gICAgICovXG4gICAgdGhpcy50cmlhbmd1bGF0aW9uXyA9IHRyaWFuZ3VsYXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRSZXNvbHV0aW9uXyA9IHRhcmdldFJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldEV4dGVudF8gPSB0YXJnZXRFeHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvSW1hZ2VCYXNlfVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlSW1hZ2VfID0gc291cmNlSW1hZ2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VQaXhlbFJhdGlvXyA9IHNvdXJjZVBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlTGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgfVxuXG4gIGlmICggSW1hZ2VCYXNlICkgUmVwcm9qSW1hZ2UuX19wcm90b19fID0gSW1hZ2VCYXNlO1xuICBSZXByb2pJbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbWFnZUJhc2UgJiYgSW1hZ2VCYXNlLnByb3RvdHlwZSApO1xuICBSZXByb2pJbWFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXByb2pJbWFnZTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlcHJvakltYWdlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IEltYWdlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy51bmxpc3RlblNvdXJjZV8oKTtcbiAgICB9XG4gICAgSW1hZ2VCYXNlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlcHJvakltYWdlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgUmVwcm9qSW1hZ2UucHJvdG90eXBlLmdldFByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRQcm9qZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRQcm9qXztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlcHJvakltYWdlLnByb3RvdHlwZS5yZXByb2plY3RfID0gZnVuY3Rpb24gcmVwcm9qZWN0XyAoKSB7XG4gICAgdmFyIHNvdXJjZVN0YXRlID0gdGhpcy5zb3VyY2VJbWFnZV8uZ2V0U3RhdGUoKTtcbiAgICBpZiAoc291cmNlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHZhciB3aWR0aCA9IGdldFdpZHRoKHRoaXMudGFyZ2V0RXh0ZW50XykgLyB0aGlzLnRhcmdldFJlc29sdXRpb25fO1xuICAgICAgdmFyIGhlaWdodCA9IGdldEhlaWdodCh0aGlzLnRhcmdldEV4dGVudF8pIC8gdGhpcy50YXJnZXRSZXNvbHV0aW9uXztcblxuICAgICAgdGhpcy5jYW52YXNfID0gcmVuZGVyUmVwcm9qZWN0ZWQod2lkdGgsIGhlaWdodCwgdGhpcy5zb3VyY2VQaXhlbFJhdGlvXyxcbiAgICAgICAgdGhpcy5zb3VyY2VJbWFnZV8uZ2V0UmVzb2x1dGlvbigpLCB0aGlzLm1heFNvdXJjZUV4dGVudF8sXG4gICAgICAgIHRoaXMudGFyZ2V0UmVzb2x1dGlvbl8sIHRoaXMudGFyZ2V0RXh0ZW50XywgdGhpcy50cmlhbmd1bGF0aW9uXywgW3tcbiAgICAgICAgICBleHRlbnQ6IHRoaXMuc291cmNlSW1hZ2VfLmdldEV4dGVudCgpLFxuICAgICAgICAgIGltYWdlOiB0aGlzLnNvdXJjZUltYWdlXy5nZXRJbWFnZSgpXG4gICAgICAgIH1dLCAwKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHNvdXJjZVN0YXRlO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVwcm9qSW1hZ2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkICgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBJbWFnZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBJbWFnZVN0YXRlLkxPQURJTkc7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcblxuICAgICAgdmFyIHNvdXJjZVN0YXRlID0gdGhpcy5zb3VyY2VJbWFnZV8uZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChzb3VyY2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRCB8fCBzb3VyY2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3VyY2VMaXN0ZW5lcktleV8gPSBsaXN0ZW4odGhpcy5zb3VyY2VJbWFnZV8sXG4gICAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVN0YXRlID0gdGhpcy5zb3VyY2VJbWFnZV8uZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkxPQURFRCB8fCBzb3VyY2VTdGF0ZSA9PSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICAgICAgICAgIHRoaXMudW5saXN0ZW5Tb3VyY2VfKCk7XG4gICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZUltYWdlXy5sb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgUmVwcm9qSW1hZ2UucHJvdG90eXBlLnVubGlzdGVuU291cmNlXyA9IGZ1bmN0aW9uIHVubGlzdGVuU291cmNlXyAoKSB7XG4gICAgdW5saXN0ZW5CeUtleSgvKiogQHR5cGUgeyFtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX0gKi8gKHRoaXMuc291cmNlTGlzdGVuZXJLZXlfKSk7XG4gICAgdGhpcy5zb3VyY2VMaXN0ZW5lcktleV8gPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZXByb2pJbWFnZTtcbn0oSW1hZ2VCYXNlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVwcm9qSW1hZ2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUltYWdlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovVGlsZVxuICovXG5pbXBvcnQge0VSUk9SX1RIUkVTSE9MRH0gZnJvbSAnLi9jb21tb24uanMnO1xuXG5pbXBvcnQgVGlsZSBmcm9tICcuLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0QXJlYSwgZ2V0Q2VudGVyLCBnZXRJbnRlcnNlY3Rpb259IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcbmltcG9ydCB7Y2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbiwgcmVuZGVyIGFzIHJlbmRlclJlcHJvamVjdGVkfSBmcm9tICcuLi9yZXByb2ouanMnO1xuaW1wb3J0IFRyaWFuZ3VsYXRpb24gZnJvbSAnLi4vcmVwcm9qL1RyaWFuZ3VsYXRpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcikgOiBtb2R1bGU6b2wvVGlsZX0gRnVuY3Rpb25UeXBlXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIGVuY2Fwc3VsYXRpbmcgc2luZ2xlIHJlcHJvamVjdGVkIHRpbGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlflRpbGVJbWFnZX0uXG4gKlxuICovXG52YXIgUmVwcm9qVGlsZSA9IChmdW5jdGlvbiAoVGlsZSkge1xuICBmdW5jdGlvbiBSZXByb2pUaWxlKFxuICAgIHNvdXJjZVByb2osXG4gICAgc291cmNlVGlsZUdyaWQsXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICB0aWxlQ29vcmQsXG4gICAgd3JhcHBlZFRpbGVDb29yZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGd1dHRlcixcbiAgICBnZXRUaWxlRnVuY3Rpb24sXG4gICAgb3B0X2Vycm9yVGhyZXNob2xkLFxuICAgIG9wdF9yZW5kZXJFZGdlc1xuICApIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIFRpbGUuY2FsbCh0aGlzLCB0aWxlQ29vcmQsIFRpbGVTdGF0ZS5JRExFKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJFZGdlc18gPSBvcHRfcmVuZGVyRWRnZXMgIT09IHVuZGVmaW5lZCA/IG9wdF9yZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlR3JpZF8gPSBzb3VyY2VUaWxlR3JpZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFRpbGVHcmlkXyA9IHRhcmdldFRpbGVHcmlkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9XG4gICAgICovXG4gICAgdGhpcy53cmFwcGVkVGlsZUNvb3JkXyA9IHdyYXBwZWRUaWxlQ29vcmQgPyB3cmFwcGVkVGlsZUNvb3JkIDogdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5Ljxtb2R1bGU6b2wvVGlsZT59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VUaWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VaXyA9IDA7XG5cbiAgICB2YXIgdGFyZ2V0RXh0ZW50ID0gdGFyZ2V0VGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRoaXMud3JhcHBlZFRpbGVDb29yZF8pO1xuICAgIHZhciBtYXhUYXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgICB2YXIgbGltaXRlZFRhcmdldEV4dGVudCA9IG1heFRhcmdldEV4dGVudCA/XG4gICAgICBnZXRJbnRlcnNlY3Rpb24odGFyZ2V0RXh0ZW50LCBtYXhUYXJnZXRFeHRlbnQpIDogdGFyZ2V0RXh0ZW50O1xuXG4gICAgaWYgKGdldEFyZWEobGltaXRlZFRhcmdldEV4dGVudCkgPT09IDApIHtcbiAgICAgIC8vIFRpbGUgaXMgY29tcGxldGVseSBvdXRzaWRlIHJhbmdlIC0+IEVNUFRZXG4gICAgICAvLyBUT0RPOiBpcyBpdCBhY3R1YWxseSBjb3JyZWN0IHRoYXQgdGhlIHNvdXJjZSBldmVuIGNyZWF0ZXMgdGhlIHRpbGUgP1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUHJvakV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gICAgaWYgKHNvdXJjZVByb2pFeHRlbnQpIHtcbiAgICAgIGlmICghbWF4U291cmNlRXh0ZW50KSB7XG4gICAgICAgIG1heFNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2pFeHRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24obWF4U291cmNlRXh0ZW50LCBzb3VyY2VQcm9qRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdKTtcblxuICAgIHZhciB0YXJnZXRDZW50ZXIgPSBnZXRDZW50ZXIobGltaXRlZFRhcmdldEV4dGVudCk7XG4gICAgdmFyIHNvdXJjZVJlc29sdXRpb24gPSBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKFxuICAgICAgc291cmNlUHJvaiwgdGFyZ2V0UHJvaiwgdGFyZ2V0Q2VudGVyLCB0YXJnZXRSZXNvbHV0aW9uKTtcblxuICAgIGlmICghaXNGaW5pdGUoc291cmNlUmVzb2x1dGlvbikgfHwgc291cmNlUmVzb2x1dGlvbiA8PSAwKSB7XG4gICAgICAvLyBpbnZhbGlkIHNvdXJjZVJlc29sdXRpb24gLT4gRU1QVFlcbiAgICAgIC8vIHByb2JhYmx5IGVkZ2VzIG9mIHRoZSBwcm9qZWN0aW9ucyB3aGVuIG5vIGV4dGVudCBpcyBkZWZpbmVkXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvclRocmVzaG9sZEluUGl4ZWxzID0gb3B0X2Vycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X2Vycm9yVGhyZXNob2xkIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IW1vZHVsZTpvbC9yZXByb2ovVHJpYW5ndWxhdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyaWFuZ3VsYXRpb25fID0gbmV3IFRyaWFuZ3VsYXRpb24oXG4gICAgICBzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCBsaW1pdGVkVGFyZ2V0RXh0ZW50LCBtYXhTb3VyY2VFeHRlbnQsXG4gICAgICBzb3VyY2VSZXNvbHV0aW9uICogZXJyb3JUaHJlc2hvbGRJblBpeGVscyk7XG5cbiAgICBpZiAodGhpcy50cmlhbmd1bGF0aW9uXy5nZXRUcmlhbmdsZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIG5vIHZhbGlkIHRyaWFuZ2xlcyAtPiBFTVBUWVxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZVpfID0gc291cmNlVGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24oc291cmNlUmVzb2x1dGlvbik7XG4gICAgdmFyIHNvdXJjZUV4dGVudCA9IHRoaXMudHJpYW5ndWxhdGlvbl8uY2FsY3VsYXRlU291cmNlRXh0ZW50KCk7XG5cbiAgICBpZiAobWF4U291cmNlRXh0ZW50KSB7XG4gICAgICBpZiAoc291cmNlUHJvai5jYW5XcmFwWCgpKSB7XG4gICAgICAgIHNvdXJjZUV4dGVudFsxXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbM10pO1xuICAgICAgICBzb3VyY2VFeHRlbnRbM10gPSBjbGFtcChcbiAgICAgICAgICBzb3VyY2VFeHRlbnRbM10sIG1heFNvdXJjZUV4dGVudFsxXSwgbWF4U291cmNlRXh0ZW50WzNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUV4dGVudCA9IGdldEludGVyc2VjdGlvbihzb3VyY2VFeHRlbnQsIG1heFNvdXJjZUV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFnZXRBcmVhKHNvdXJjZUV4dGVudCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2VSYW5nZSA9IHNvdXJjZVRpbGVHcmlkLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICAgIHNvdXJjZUV4dGVudCwgdGhpcy5zb3VyY2VaXyk7XG5cbiAgICAgIGZvciAodmFyIHNyY1ggPSBzb3VyY2VSYW5nZS5taW5YOyBzcmNYIDw9IHNvdXJjZVJhbmdlLm1heFg7IHNyY1grKykge1xuICAgICAgICBmb3IgKHZhciBzcmNZID0gc291cmNlUmFuZ2UubWluWTsgc3JjWSA8PSBzb3VyY2VSYW5nZS5tYXhZOyBzcmNZKyspIHtcbiAgICAgICAgICB2YXIgdGlsZSA9IGdldFRpbGVGdW5jdGlvbih0aGlzJDEuc291cmNlWl8sIHNyY1gsIHNyY1ksIHBpeGVsUmF0aW8pO1xuICAgICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICB0aGlzJDEuc291cmNlVGlsZXNfLnB1c2godGlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVRpbGVzXy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIFRpbGUgKSBSZXByb2pUaWxlLl9fcHJvdG9fXyA9IFRpbGU7XG4gIFJlcHJvalRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGlsZSAmJiBUaWxlLnByb3RvdHlwZSApO1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcHJvalRpbGU7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICB9XG4gICAgVGlsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBDYW52YXMgZWxlbWVudCBmb3IgdGhpcyB0aWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgUmVwcm9qVGlsZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFJlcHJvalRpbGUucHJvdG90eXBlLnJlcHJvamVjdF8gPSBmdW5jdGlvbiByZXByb2plY3RfICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgICBpZiAodGlsZSAmJiB0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBzb3VyY2VzLnB1c2goe1xuICAgICAgICAgIGV4dGVudDogdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGUudGlsZUNvb3JkKSxcbiAgICAgICAgICBpbWFnZTogdGlsZS5nZXRJbWFnZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb3VyY2VUaWxlc18ubGVuZ3RoID0gMDtcblxuICAgIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FUlJPUjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHogPSB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRUaWxlU2l6ZSh6KTtcbiAgICAgIHZhciB3aWR0aCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzBdO1xuICAgICAgdmFyIGhlaWdodCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzFdO1xuICAgICAgdmFyIHRhcmdldFJlc29sdXRpb24gPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHopO1xuICAgICAgdmFyIHNvdXJjZVJlc29sdXRpb24gPSB0aGlzLnNvdXJjZVRpbGVHcmlkXy5nZXRSZXNvbHV0aW9uKHRoaXMuc291cmNlWl8pO1xuXG4gICAgICB2YXIgdGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKHdpZHRoLCBoZWlnaHQsIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb24sIHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRFeHRlbnQsIHRoaXMudHJpYW5ndWxhdGlvbl8sIHNvdXJjZXMsXG4gICAgICAgIHRoaXMuZ3V0dGVyXywgdGhpcy5yZW5kZXJFZGdlc18pO1xuXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgICB2YXIgbGVmdFRvTG9hZCA9IDA7XG5cbiAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBbXTtcbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFIHx8IHN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICAgICAgbGVmdFRvTG9hZCsrO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZUxpc3RlbktleSA9IGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuRU1QVFkpIHtcbiAgICAgICAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5wdXNoKHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRpbGUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKHN0YXRlID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgdGlsZS5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGVmdFRvTG9hZCA9PT0gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMucmVwcm9qZWN0Xy5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBSZXByb2pUaWxlLnByb3RvdHlwZS51bmxpc3RlblNvdXJjZXNfID0gZnVuY3Rpb24gdW5saXN0ZW5Tb3VyY2VzXyAoKSB7XG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSZXByb2pUaWxlO1xufShUaWxlKSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVwcm9qVGlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGlsZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25cbiAqL1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgY3JlYXRlRW1wdHksIGV4dGVuZENvb3JkaW5hdGUsIGdldEJvdHRvbUxlZnQsIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LCBnZXRUb3BSaWdodCwgZ2V0V2lkdGgsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBTaW5nbGUgdHJpYW5nbGU7IGNvbnNpc3RzIG9mIDMgc291cmNlIHBvaW50cyBhbmQgMyB0YXJnZXQgcG9pbnRzLlxuICogQHR5cGVkZWYge09iamVjdH0gVHJpYW5nbGVcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+fSB0YXJnZXRcbiAqL1xuXG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2Ygc3ViZGl2aXNpb24gc3RlcHMgZHVyaW5nIHJhc3RlciByZXByb2plY3Rpb24gdHJpYW5ndWxhdGlvbi5cbiAqIFByZXZlbnRzIGhpZ2ggbWVtb3J5IHVzYWdlIGFuZCBsYXJnZSBudW1iZXIgb2YgcHJvajQgY2FsbHMgKGZvciBjZXJ0YWluXG4gKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGFyZWFzKS4gQXQgbW9zdCBgMiooMl50aGlzKWAgdHJpYW5nbGVzIGFyZSBjcmVhdGVkIGZvclxuICogZWFjaCB0cmlhbmd1bGF0ZWQgZXh0ZW50ICh0aWxlL2ltYWdlKS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnZhciBNQVhfU1VCRElWSVNJT04gPSAxMDtcblxuXG4vKipcbiAqIE1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRyaWFuZ2xlIHJlbGF0aXZlIHRvIHdvcmxkIHdpZHRoLiBXaGVuIHRyYW5zZm9ybWluZ1xuICogY29ybmVycyBvZiB3b3JsZCBleHRlbnQgYmV0d2VlbiBjZXJ0YWluIHByb2plY3Rpb25zLCB0aGUgcmVzdWx0aW5nXG4gKiB0cmlhbmd1bGF0aW9uIHNlZW1zIHRvIGhhdmUgemVybyBlcnJvciBhbmQgbm8gc3ViZGl2aXNpb24gaXMgcGVyZm9ybWVkLiBJZlxuICogdGhlIHRyaWFuZ2xlIHdpZHRoIGlzIG1vcmUgdGhhbiB0aGlzIChyZWxhdGl2ZSB0byB3b3JsZCB3aWR0aDsgMC0xKSxcbiAqIHN1YmRpdmlzb24gaXMgZm9yY2VkICh1cCB0byBgTUFYX1NVQkRJVklTSU9OYCkuIERlZmF1bHQgaXMgYDAuMjVgLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIE1BWF9UUklBTkdMRV9XSURUSCA9IDAuMjU7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBjb250YWluaW5nIHRyaWFuZ3VsYXRpb24gb2YgdGhlIGdpdmVuIHRhcmdldCBleHRlbnQuXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyBzb3VyY2UgZGF0YSBhbmQgdGhlIHJlcHJvamVjdGlvbiBpdHNlbGYuXG4gKi9cbnZhciBUcmlhbmd1bGF0aW9uID0gZnVuY3Rpb24gVHJpYW5ndWxhdGlvbihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCB0YXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCwgZXJyb3JUaHJlc2hvbGQpIHtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNvdXJjZVByb2pfID0gc291cmNlUHJvajtcblxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRhcmdldFByb2pfID0gdGFyZ2V0UHJvajtcblxuICAvKiogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59ICovXG4gIHZhciB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICB2YXIgdHJhbnNmb3JtSW52ID0gZ2V0VHJhbnNmb3JtKHRoaXMudGFyZ2V0UHJval8sIHRoaXMuc291cmNlUHJval8pO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGMgQSBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50cmFuc2Zvcm1JbnZfID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICBpZiAoIXRyYW5zZm9ybUludkNhY2hlW2tleV0pIHtcbiAgICAgIHRyYW5zZm9ybUludkNhY2hlW2tleV0gPSB0cmFuc2Zvcm1JbnYoYyk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1heFNvdXJjZUV4dGVudF8gPSBtYXhTb3VyY2VFeHRlbnQ7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVycm9yVGhyZXNob2xkU3F1YXJlZF8gPSBlcnJvclRocmVzaG9sZCAqIGVycm9yVGhyZXNob2xkO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9yZXByb2ovVHJpYW5ndWxhdGlvbn5UcmlhbmdsZT59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyaWFuZ2xlc18gPSBbXTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHRyaWFuZ3VsYXRpb24gY3Jvc3NlcyBlZGdlIG9mIHRoZSBzb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLndyYXBzWEluU291cmNlXyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuY2FuV3JhcFhJblNvdXJjZV8gPSB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICEhbWF4U291cmNlRXh0ZW50ICYmXG4gICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgIChnZXRXaWR0aChtYXhTb3VyY2VFeHRlbnQpID09IGdldFdpZHRoKHRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkpKTtcblxuICAvKipcbiAgICogQHR5cGUgez9udW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID0gdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSA/XG4gICAgZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSkgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpID9cbiAgICBnZXRXaWR0aCh0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpKSA6IG51bGw7XG5cbiAgdmFyIGRlc3RpbmF0aW9uVG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcbiAgdmFyIGRlc3RpbmF0aW9uVG9wUmlnaHQgPSBnZXRUb3BSaWdodCh0YXJnZXRFeHRlbnQpO1xuICB2YXIgZGVzdGluYXRpb25Cb3R0b21SaWdodCA9IGdldEJvdHRvbVJpZ2h0KHRhcmdldEV4dGVudCk7XG4gIHZhciBkZXN0aW5hdGlvbkJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KHRhcmdldEV4dGVudCk7XG4gIHZhciBzb3VyY2VUb3BMZWZ0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uVG9wTGVmdCk7XG4gIHZhciBzb3VyY2VUb3BSaWdodCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcFJpZ2h0KTtcbiAgdmFyIHNvdXJjZUJvdHRvbVJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tUmlnaHQpO1xuICB2YXIgc291cmNlQm90dG9tTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvbkJvdHRvbUxlZnQpO1xuXG4gIHRoaXMuYWRkUXVhZF8oXG4gICAgZGVzdGluYXRpb25Ub3BMZWZ0LCBkZXN0aW5hdGlvblRvcFJpZ2h0LFxuICAgIGRlc3RpbmF0aW9uQm90dG9tUmlnaHQsIGRlc3RpbmF0aW9uQm90dG9tTGVmdCxcbiAgICBzb3VyY2VUb3BMZWZ0LCBzb3VyY2VUb3BSaWdodCwgc291cmNlQm90dG9tUmlnaHQsIHNvdXJjZUJvdHRvbUxlZnQsXG4gICAgTUFYX1NVQkRJVklTSU9OKTtcblxuICBpZiAodGhpcy53cmFwc1hJblNvdXJjZV8pIHtcbiAgICB2YXIgbGVmdEJvdW5kID0gSW5maW5pdHk7XG4gICAgdGhpcy50cmlhbmdsZXNfLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgICAgbGVmdEJvdW5kID0gTWF0aC5taW4obGVmdEJvdW5kLFxuICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSwgdHJpYW5nbGUuc291cmNlWzJdWzBdKTtcbiAgICB9KTtcblxuICAgIC8vIFNoaWZ0IHRyaWFuZ2xlcyB0byBiZSBhcyBjbG9zZSB0byBgbGVmdEJvdW5kYCBhcyBwb3NzaWJsZVxuICAgIC8vIChpZiB0aGUgZGlzdGFuY2UgaXMgbW9yZSB0aGFuIGB3b3JsZFdpZHRoIC8gMmAgaXQgY2FuIGJlIGNsb3Nlci5cbiAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSkge1xuICAgICAgaWYgKE1hdGgubWF4KHRyaWFuZ2xlLnNvdXJjZVswXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzBdLFxuICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMl1bMF0pIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgdmFyIG5ld1RyaWFuZ2xlID0gW1t0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVswXVsxXV0sXG4gICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsxXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzFdXSxcbiAgICAgICAgICBbdHJpYW5nbGUuc291cmNlWzJdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMl1bMV1dXTtcbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVswXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVsxXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzFdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuZXdUcmlhbmdsZVsyXVswXSAtIGxlZnRCb3VuZCkgPiB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIC8gMikge1xuICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSYXJlbHkgKGlmIHRoZSBleHRlbnQgY29udGFpbnMgYm90aCB0aGUgZGF0ZWxpbmUgYW5kIHByaW1lIG1lcmlkaWFuKVxuICAgICAgICAvLyB0aGUgc2hpZnQgY2FuIGluIHR1cm4gYnJlYWsgc29tZSB0cmlhbmdsZXMuXG4gICAgICAgIC8vIERldGVjdCB0aGlzIGhlcmUgYW5kIGRvbid0IHNoaWZ0IGluIHN1Y2ggY2FzZXMuXG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4oXG4gICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0sIG5ld1RyaWFuZ2xlWzFdWzBdLCBuZXdUcmlhbmdsZVsyXVswXSk7XG4gICAgICAgIHZhciBtYXhYID0gTWF0aC5tYXgoXG4gICAgICAgICAgbmV3VHJpYW5nbGVbMF1bMF0sIG5ld1RyaWFuZ2xlWzFdWzBdLCBuZXdUcmlhbmdsZVsyXVswXSk7XG4gICAgICAgIGlmICgobWF4WCAtIG1pblgpIDwgdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2UgPSBuZXdUcmlhbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xufTtcblxuLyoqXG4gKiBBZGRzIHRyaWFuZ2xlIHRvIHRoZSB0cmlhbmd1bGF0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhIFRoZSB0YXJnZXQgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBiU3JjIFRoZSBzb3VyY2UgYiBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjU3JjIFRoZSBzb3VyY2UgYyBjb29yZGluYXRlLlxuICogQHByaXZhdGVcbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuYWRkVHJpYW5nbGVfID0gZnVuY3Rpb24gYWRkVHJpYW5nbGVfIChhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKSB7XG4gIHRoaXMudHJpYW5nbGVzXy5wdXNoKHtcbiAgICBzb3VyY2U6IFthU3JjLCBiU3JjLCBjU3JjXSxcbiAgICB0YXJnZXQ6IFthLCBiLCBjXVxuICB9KTtcbn07XG5cbi8qKlxuICogQWRkcyBxdWFkIChwb2ludHMgaW4gY2xvY2std2lzZSBvcmRlcikgdG8gdGhlIHRyaWFuZ3VsYXRpb25cbiAqIChhbmQgcmVwcm9qZWN0cyB0aGUgdmVydGljZXMpIGlmIHZhbGlkLlxuICogUGVyZm9ybXMgcXVhZCBzdWJkaXZpc2lvbiBpZiBuZWVkZWQgdG8gaW5jcmVhc2UgcHJlY2lzaW9uLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYiBUaGUgdGFyZ2V0IGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZCBUaGUgdGFyZ2V0IGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY1NyYyBUaGUgc291cmNlIGMgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gZFNyYyBUaGUgc291cmNlIGQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTdWJkaXZpc2lvbiBNYXhpbWFsIGFsbG93ZWQgc3ViZGl2aXNpb24gb2YgdGhlIHF1YWQuXG4gKiBAcHJpdmF0ZVxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5hZGRRdWFkXyA9IGZ1bmN0aW9uIGFkZFF1YWRfIChhLCBiLCBjLCBkLCBhU3JjLCBiU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbikge1xuXG4gIHZhciBzb3VyY2VRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2FTcmMsIGJTcmMsIGNTcmMsIGRTcmNdKTtcbiAgdmFyIHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF8gP1xuICAgIGdldFdpZHRoKHNvdXJjZVF1YWRFeHRlbnQpIC8gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyA6IG51bGw7XG4gIHZhciBzb3VyY2VXb3JsZFdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnNvdXJjZVdvcmxkV2lkdGhfKTtcblxuICAvLyB3aGVuIHRoZSBxdWFkIGlzIHdyYXBwZWQgaW4gdGhlIHNvdXJjZSBwcm9qZWN0aW9uXG4gIC8vIGl0IGNvdmVycyBtb3N0IG9mIHRoZSBwcm9qZWN0aW9uIGV4dGVudCwgYnV0IG5vdCBmdWxseVxuICB2YXIgd3JhcHNYID0gdGhpcy5zb3VyY2VQcm9qXy5jYW5XcmFwWCgpICYmXG4gICAgICAgICAgICAgICBzb3VyY2VDb3ZlcmFnZVggPiAwLjUgJiYgc291cmNlQ292ZXJhZ2VYIDwgMTtcblxuICB2YXIgbmVlZHNTdWJkaXZpc2lvbiA9IGZhbHNlO1xuXG4gIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICBpZiAodGhpcy50YXJnZXRQcm9qXy5pc0dsb2JhbCgpICYmIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8pIHtcbiAgICAgIHZhciB0YXJnZXRRdWFkRXh0ZW50ID0gYm91bmRpbmdFeHRlbnQoW2EsIGIsIGMsIGRdKTtcbiAgICAgIHZhciB0YXJnZXRDb3ZlcmFnZVggPSBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uIHw9XG4gICAgICAgICAgdGFyZ2V0Q292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIO1xuICAgIH1cbiAgICBpZiAoIXdyYXBzWCAmJiB0aGlzLnNvdXJjZVByb2pfLmlzR2xvYmFsKCkgJiYgc291cmNlQ292ZXJhZ2VYKSB7XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uIHw9XG4gICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmVlZHNTdWJkaXZpc2lvbiAmJiB0aGlzLm1heFNvdXJjZUV4dGVudF8pIHtcbiAgICBpZiAoIWludGVyc2VjdHMoc291cmNlUXVhZEV4dGVudCwgdGhpcy5tYXhTb3VyY2VFeHRlbnRfKSkge1xuICAgICAgLy8gd2hvbGUgcXVhZCBvdXRzaWRlIHNvdXJjZSBwcm9qZWN0aW9uIGV4dGVudCAtPiBpZ25vcmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICBpZiAoIWlzRmluaXRlKGFTcmNbMF0pIHx8ICFpc0Zpbml0ZShhU3JjWzFdKSB8fFxuICAgICAgICAhaXNGaW5pdGUoYlNyY1swXSkgfHwgIWlzRmluaXRlKGJTcmNbMV0pIHx8XG4gICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgIWlzRmluaXRlKGRTcmNbMF0pIHx8ICFpc0Zpbml0ZShkU3JjWzFdKSkge1xuICAgICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgaWYgKCFuZWVkc1N1YmRpdmlzaW9uKSB7XG4gICAgICB2YXIgY2VudGVyID0gWyhhWzBdICsgY1swXSkgLyAyLCAoYVsxXSArIGNbMV0pIC8gMl07XG4gICAgICB2YXIgY2VudGVyU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGNlbnRlcik7XG5cbiAgICAgIHZhciBkeDtcbiAgICAgIGlmICh3cmFwc1gpIHtcbiAgICAgICAgdmFyIGNlbnRlclNyY0VzdGltWCA9XG4gICAgICAgICAgICAobW9kdWxvKGFTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpICtcbiAgICAgICAgICAgICBtb2R1bG8oY1NyY1swXSwgc291cmNlV29ybGRXaWR0aCkpIC8gMjtcbiAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLVxuICAgICAgICAgICAgbW9kdWxvKGNlbnRlclNyY1swXSwgc291cmNlV29ybGRXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgfVxuICAgICAgdmFyIGR5ID0gKGFTcmNbMV0gKyBjU3JjWzFdKSAvIDIgLSBjZW50ZXJTcmNbMV07XG4gICAgICB2YXIgY2VudGVyU3JjRXJyb3JTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgIH1cbiAgICBpZiAobmVlZHNTdWJkaXZpc2lvbikge1xuICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgLy8gc3BsaXQgaG9yaXpvbnRhbGx5ICh0b3AgJiBib3R0b20pXG4gICAgICAgIHZhciBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICB2YXIgYmNTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYmMpO1xuICAgICAgICB2YXIgZGEgPSBbKGRbMF0gKyBhWzBdKSAvIDIsIChkWzFdICsgYVsxXSkgLyAyXTtcbiAgICAgICAgdmFyIGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGEsIGIsIGJjLCBkYSwgYVNyYywgYlNyYywgYmNTcmMsIGRhU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgIGRhLCBiYywgYywgZCwgZGFTcmMsIGJjU3JjLCBjU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseSAobGVmdCAmIHJpZ2h0KVxuICAgICAgICB2YXIgYWIgPSBbKGFbMF0gKyBiWzBdKSAvIDIsIChhWzFdICsgYlsxXSkgLyAyXTtcbiAgICAgICAgdmFyIGFiU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGFiKTtcbiAgICAgICAgdmFyIGNkID0gWyhjWzBdICsgZFswXSkgLyAyLCAoY1sxXSArIGRbMV0pIC8gMl07XG4gICAgICAgIHZhciBjZFNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZCk7XG5cbiAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICBhLCBhYiwgY2QsIGQsIGFTcmMsIGFiU3JjLCBjZFNyYywgZFNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICBhYiwgYiwgYywgY2QsIGFiU3JjLCBiU3JjLCBjU3JjLCBjZFNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAod3JhcHNYKSB7XG4gICAgaWYgKCF0aGlzLmNhbldyYXBYSW5Tb3VyY2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuYWRkVHJpYW5nbGVfKGEsIGMsIGQsIGFTcmMsIGNTcmMsIGRTcmMpO1xuICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBleHRlbnQgb2YgdGhlICdzb3VyY2UnIGNvb3JkaW5hdGVzIGZyb20gYWxsIHRoZSB0cmlhbmdsZXMuXG4gKlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IENhbGN1bGF0ZWQgZXh0ZW50LlxuICovXG5Ucmlhbmd1bGF0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVTb3VyY2VFeHRlbnQgPSBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VFeHRlbnQgKCkge1xuICB2YXIgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgdmFyIHNyYyA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzBdKTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzFdKTtcbiAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzJdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGV4dGVudDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9yZXByb2ovVHJpYW5ndWxhdGlvbn5UcmlhbmdsZT59IEFycmF5IG9mIHRoZSBjYWxjdWxhdGVkIHRyaWFuZ2xlcy5cbiAqL1xuVHJpYW5ndWxhdGlvbi5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzID0gZnVuY3Rpb24gZ2V0VHJpYW5nbGVzICgpIHtcbiAgcmV0dXJuIHRoaXMudHJpYW5nbGVzXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyaWFuZ3VsYXRpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyaWFuZ3VsYXRpb24uanMubWFwIiwiLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gYWxsb3dlZCB0aHJlc2hvbGQgIChpbiBwaXhlbHMpIGZvciByZXByb2plY3Rpb25cbiAqIHRyaWFuZ3VsYXRpb24uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIEVSUk9SX1RIUkVTSE9MRCA9IDAuNTtcblxuLyoqXG4gKiBFbmFibGUgYXV0b21hdGljIHJlcHJvamVjdGlvbiBvZiByYXN0ZXIgc291cmNlcy4gRGVmYXVsdCBpcyBgdHJ1ZWAuXG4gKiBUT0RPOiBkZWNpZGUgaWYgd2Ugd2FudCB0byBleHBvc2UgdGhpcyBhcyBhIGJ1aWxkIGZsYWcgb3IgcmVtb3ZlIGl0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IHZhciBFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiA9IHRydWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVzb2x1dGlvbmNvbnN0cmFpbnRcbiAqL1xuaW1wb3J0IHtsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi9hcnJheS5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChudW1iZXJ8dW5kZWZpbmVkKSwgbnVtYmVyLCBudW1iZXIpOiAobnVtYmVyfHVuZGVmaW5lZCl9IFR5cGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvcmVzb2x1dGlvbmNvbnN0cmFpbnR+VHlwZX0gWm9vbSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKHJlc29sdXRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgeiA9IGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICB6ID0gY2xhbXAoeiArIGRlbHRhLCAwLCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgaWYgKHogIT0gaW5kZXggJiYgaW5kZXggPCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIHBvd2VyID0gcmVzb2x1dGlvbnNbaW5kZXhdIC8gcmVzb2x1dGlvbnNbaW5kZXggKyAxXTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbnNbaW5kZXhdIC8gTWF0aC5wb3cocG93ZXIsIHogLSBpbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcG93ZXIgUG93ZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBNYXhpbXVtIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhMZXZlbCBNYXhpbXVtIGxldmVsLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3Jlc29sdXRpb25jb25zdHJhaW50flR5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9Qb3dlcihwb3dlciwgbWF4UmVzb2x1dGlvbiwgb3B0X21heExldmVsKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gLWRpcmVjdGlvbiAvIDIgKyAwLjU7XG4gICAgICAgIHZhciBvbGRMZXZlbCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIHJlc29sdXRpb24pIC8gTWF0aC5sb2cocG93ZXIpICsgb2Zmc2V0KTtcbiAgICAgICAgdmFyIG5ld0xldmVsID0gTWF0aC5tYXgob2xkTGV2ZWwgKyBkZWx0YSwgMCk7XG4gICAgICAgIGlmIChvcHRfbWF4TGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld0xldmVsID0gTWF0aC5taW4obmV3TGV2ZWwsIG9wdF9tYXhMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgbmV3TGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x1dGlvbmNvbnN0cmFpbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JvdGF0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobnVtYmVyfHVuZGVmaW5lZCksIG51bWJlcik6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlKHJvdGF0aW9uLCBkZWx0YSkge1xuICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbmUocm90YXRpb24sIGRlbHRhKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJvdGF0aW9uICsgZGVsdGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG4gTi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9yb3RhdGlvbmNvbnN0cmFpbnR+VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb04obikge1xuICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIG47XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocm90YXRpb24sIGRlbHRhKSB7XG4gICAgICBpZiAocm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByb3RhdGlvbiA9IE1hdGguZmxvb3IoKHJvdGF0aW9uICsgZGVsdGEpIC8gdGhldGEgKyAwLjUpICogdGhldGE7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF90b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3JvdGF0aW9uY29uc3RyYWludH5UeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvWmVybyhvcHRfdG9sZXJhbmNlKSB7XG4gIHZhciB0b2xlcmFuY2UgPSBvcHRfdG9sZXJhbmNlIHx8IHRvUmFkaWFucyg1KTtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyb3RhdGlvbiwgZGVsdGEpIHtcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhyb3RhdGlvbiArIGRlbHRhKSA8PSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcm90YXRpb24gKyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm90YXRpb25jb25zdHJhaW50LmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zaXplXG4gKi9cblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGEgc2l6ZTogYFt3aWR0aCwgaGVpZ2h0XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IFNpemVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlcmVkIHNpemUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGFtb3VudCBieSB3aGljaCB0byBidWZmZXIuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gVGhlIGJ1ZmZlcmVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoc2l6ZSwgbnVtLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gc2l6ZVswXSArIDIgKiBudW07XG4gIG9wdF9zaXplWzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBvcHRfc2l6ZTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpemUgc2NhbGVkIGJ5IGEgcmF0aW8uIFRoZSByZXN1bHQgd2lsbCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFJhdGlvLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3NpemUgT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFRoZSBzY2FsZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNpemUsIHJhdGlvLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBvcHRfc2l6ZVsxXSA9IChzaXplWzFdICogcmF0aW8gKyAwLjUpIHwgMDtcbiAgcmV0dXJuIG9wdF9zaXplO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBgbW9kdWxlOm9sL3NpemV+U2l6ZWAgYXJyYXkgZm9yIHRoZSBwYXNzZWQgaW4gbnVtYmVyIChtZWFuaW5nOiBzcXVhcmUpIG9yXG4gKiBgbW9kdWxlOm9sL3NpemV+U2l6ZWAgYXJyYXkuXG4gKiAobWVhbmluZzogbm9uLXNxdWFyZSksXG4gKiBAcGFyYW0ge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBzaXplIFdpZHRoIGFuZCBoZWlnaHQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3NpemV+U2l6ZX0gU2l6ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2l6ZShzaXplLCBvcHRfc2l6ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHJldHVybiBzaXplO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRfc2l6ZSA9IFtzaXplLCBzaXplXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0X3NpemVbMF0gPSBvcHRfc2l6ZVsxXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRfc2l6ZTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaXplLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvSW1hZ2VcbiAqL1xuaW1wb3J0IHtFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTn0gZnJvbSAnLi4vcmVwcm9qL2NvbW1vbi5qcyc7XG5cbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudH0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQgUmVwcm9qSW1hZ2UgZnJvbSAnLi4vcmVwcm9qL0ltYWdlLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi4vc291cmNlL1NvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG52YXIgSW1hZ2VTb3VyY2VFdmVudFR5cGUgPSB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGltYWdlIHN0YXJ0cyBsb2FkaW5nLlxuICAgKiBAZXZlbnQgb2wvc291cmNlL0ltYWdlfkltYWdlU291cmNlRXZlbnQjaW1hZ2Vsb2Fkc3RhcnRcbiAgICogQGFwaVxuICAgKi9cbiAgSU1BR0VMT0FEU1RBUlQ6ICdpbWFnZWxvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGltYWdlIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvSW1hZ2V+SW1hZ2VTb3VyY2VFdmVudCNpbWFnZWxvYWRlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgSU1BR0VMT0FERU5EOiAnaW1hZ2Vsb2FkZW5kJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGlmIGltYWdlIGxvYWRpbmcgcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9JbWFnZX5JbWFnZVNvdXJjZUV2ZW50I2ltYWdlbG9hZGVycm9yXG4gICAqIEBhcGlcbiAgICovXG4gIElNQUdFTE9BREVSUk9SOiAnaW1hZ2Vsb2FkZXJyb3InXG5cbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9JbWFnZX5JbWFnZVNvdXJjZX0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqL1xudmFyIEltYWdlU291cmNlRXZlbnQgPSAoZnVuY3Rpb24gKEV2ZW50KSB7XG4gIGZ1bmN0aW9uIEltYWdlU291cmNlRXZlbnQodHlwZSwgaW1hZ2UpIHtcblxuICAgIEV2ZW50LmNhbGwodGhpcywgdHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgcmVsYXRlZCB0byB0aGUgZXZlbnQuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9JbWFnZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuXG4gIH1cblxuICBpZiAoIEV2ZW50ICkgSW1hZ2VTb3VyY2VFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgSW1hZ2VTb3VyY2VFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdmVudCAmJiBFdmVudC5wcm90b3R5cGUgKTtcbiAgSW1hZ2VTb3VyY2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZVNvdXJjZUV2ZW50O1xuXG4gIHJldHVybiBJbWFnZVNvdXJjZUV2ZW50O1xufShFdmVudCkpO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvblxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gW3Jlc29sdXRpb25zXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGEgc2luZ2xlIGltYWdlLlxuICogQGFwaVxuICovXG52YXIgSW1hZ2VTb3VyY2UgPSAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICBmdW5jdGlvbiBJbWFnZVNvdXJjZShvcHRpb25zKSB7XG4gICAgU291cmNlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGV4dGVudDogb3B0aW9ucy5leHRlbnQsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5yZXNvbHV0aW9ucyA6IG51bGw7XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9yZXByb2ovSW1hZ2V9XG4gICAgICovXG4gICAgdGhpcy5yZXByb2plY3RlZEltYWdlXyA9IG51bGw7XG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvamVjdGVkUmV2aXNpb25fID0gMDtcbiAgfVxuXG4gIGlmICggU291cmNlICkgSW1hZ2VTb3VyY2UuX19wcm90b19fID0gU291cmNlO1xuICBJbWFnZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTb3VyY2UgJiYgU291cmNlLnByb3RvdHlwZSApO1xuICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbWFnZVNvdXJjZTtcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFJlc29sdXRpb25zLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEltYWdlU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uLlxuICAgKi9cbiAgSW1hZ2VTb3VyY2UucHJvdG90eXBlLmZpbmROZWFyZXN0UmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0UmVzb2x1dGlvbiAocmVzb2x1dGlvbikge1xuICAgIGlmICh0aGlzLnJlc29sdXRpb25zXykge1xuICAgICAgdmFyIGlkeCA9IGxpbmVhckZpbmROZWFyZXN0KHRoaXMucmVzb2x1dGlvbnNfLCByZXNvbHV0aW9uLCAwKTtcbiAgICAgIHJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb25zX1tpZHhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvSW1hZ2VCYXNlfSBTaW5nbGUgaW1hZ2UuXG4gICAqL1xuICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZVByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OIHx8XG4gICAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8XG4gICAgICAgICFwcm9qZWN0aW9uIHx8XG4gICAgICAgIGVxdWl2YWxlbnQoc291cmNlUHJvamVjdGlvbiwgcHJvamVjdGlvbikpIHtcbiAgICAgIGlmIChzb3VyY2VQcm9qZWN0aW9uKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBzb3VyY2VQcm9qZWN0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1hZ2VJbnRlcm5hbChleHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5yZXByb2plY3RlZEltYWdlXykge1xuICAgICAgICBpZiAodGhpcy5yZXByb2plY3RlZFJldmlzaW9uXyA9PSB0aGlzLmdldFJldmlzaW9uKCkgJiZcbiAgICAgICAgICAgIGVxdWl2YWxlbnQoXG4gICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0ZWRJbWFnZV8uZ2V0UHJvamVjdGlvbigpLCBwcm9qZWN0aW9uKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXByb2plY3RlZEltYWdlXy5nZXRSZXNvbHV0aW9uKCkgPT0gcmVzb2x1dGlvbiAmJlxuICAgICAgICAgICAgZXF1YWxzKHRoaXMucmVwcm9qZWN0ZWRJbWFnZV8uZ2V0RXh0ZW50KCksIGV4dGVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXByb2plY3RlZEltYWdlXztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcHJvamVjdGVkSW1hZ2VfLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yZXByb2plY3RlZEltYWdlXyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVwcm9qZWN0ZWRJbWFnZV8gPSBuZXcgUmVwcm9qSW1hZ2UoXG4gICAgICAgIHNvdXJjZVByb2plY3Rpb24sIHByb2plY3Rpb24sIGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyxcbiAgICAgICAgZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1hZ2VJbnRlcm5hbChleHRlbnQsIHJlc29sdXRpb24sXG4gICAgICAgICAgICBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMucmVwcm9qZWN0ZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJlcHJvamVjdGVkSW1hZ2VfO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL0ltYWdlQmFzZX0gU2luZ2xlIGltYWdlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuZ2V0SW1hZ2VJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldEltYWdlSW50ZXJuYWwgKGV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge307XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBpbWFnZSBjaGFuZ2UgZXZlbnRzLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9ldmVudHMvRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBJbWFnZVNvdXJjZS5wcm90b3R5cGUuaGFuZGxlSW1hZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVJbWFnZUNoYW5nZSAoZXZlbnQpIHtcbiAgICB2YXIgaW1hZ2UgPSAvKiogQHR5cGUge21vZHVsZTpvbC9JbWFnZX0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgc3dpdGNoIChpbWFnZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBjYXNlIEltYWdlU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgIG5ldyBJbWFnZVNvdXJjZUV2ZW50KEltYWdlU291cmNlRXZlbnRUeXBlLklNQUdFTE9BRFNUQVJULFxuICAgICAgICAgICAgaW1hZ2UpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEltYWdlU3RhdGUuTE9BREVEOlxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgbmV3IEltYWdlU291cmNlRXZlbnQoSW1hZ2VTb3VyY2VFdmVudFR5cGUuSU1BR0VMT0FERU5ELFxuICAgICAgICAgICAgaW1hZ2UpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEltYWdlU3RhdGUuRVJST1I6XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgSW1hZ2VTb3VyY2VFdmVudChJbWFnZVNvdXJjZUV2ZW50VHlwZS5JTUFHRUxPQURFUlJPUixcbiAgICAgICAgICAgIGltYWdlKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gcGFzc1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gSW1hZ2VTb3VyY2U7XG59KFNvdXJjZSkpO1xuXG5cbi8qKlxuICogRGVmYXVsdCBpbWFnZSBsb2FkIGZ1bmN0aW9uIGZvciBpbWFnZSBzb3VyY2VzIHRoYXQgdXNlIG1vZHVsZTpvbC9JbWFnZX5JbWFnZSBpbWFnZVxuICogaW5zdGFuY2VzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvSW1hZ2V9IGltYWdlIEltYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0SW1hZ2VMb2FkRnVuY3Rpb24oaW1hZ2UsIHNyYykge1xuICBpbWFnZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9JbWFnZUNhbnZhc1xuICovXG5cbmltcG9ydCBJbWFnZUNhbnZhcyBmcm9tICcuLi9JbWFnZUNhbnZhcy5qcyc7XG5pbXBvcnQge2NvbnRhaW5zRXh0ZW50LCBnZXRIZWlnaHQsIGdldFdpZHRoLCBzY2FsZUZyb21DZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgSW1hZ2VTb3VyY2UgZnJvbSAnLi4vc291cmNlL0ltYWdlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjYW52YXMgZWxlbWVudCAoYHtIVE1MQ2FudmFzRWxlbWVudH1gKVxuICogdXNlZCBieSB0aGUgc291cmNlIGFzIGFuIGltYWdlLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gYXJlOlxuICoge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB0aGUgaW1hZ2UgZXh0ZW50LCBge251bWJlcn1gIHRoZSBpbWFnZSByZXNvbHV0aW9uLFxuICogYHtudW1iZXJ9YCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvLCB7QGxpbmsgbW9kdWxlOm9sL3NpemV+U2l6ZX0gdGhlIGltYWdlIHNpemUsIGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHRoZSBpbWFnZSBwcm9qZWN0aW9uLiBUaGUgY2FudmFzIHJldHVybmVkIGJ5XG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhY2hlZCBieSB0aGUgc291cmNlLiBUaGUgdGhpcyBrZXl3b3JkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIHJlZmVyZW5jZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL0ltYWdlQ2FudmFzfS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczptb2R1bGU6b2wvSW1hZ2VDYW52YXMsIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50LCBudW1iZXIsXG4gKiAgICAgbnVtYmVyLCBtb2R1bGU6b2wvc2l6ZX5TaXplLCBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uKTogSFRNTENhbnZhc0VsZW1lbnR9IEZ1bmN0aW9uVHlwZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL0ltYWdlQ2FudmFzfkZ1bmN0aW9uVHlwZX0gW2NhbnZhc0Z1bmN0aW9uXSBDYW52YXMgZnVuY3Rpb24uXG4gKiBUaGUgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBjYW52YXMgZWxlbWVudCB1c2VkIGJ5IHRoZSBzb3VyY2VcbiAqIGFzIGFuIGltYWdlLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24gYXJlOiBge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fWAgdGhlXG4gKiBpbWFnZSBleHRlbnQsIGB7bnVtYmVyfWAgdGhlIGltYWdlIHJlc29sdXRpb24sIGB7bnVtYmVyfWAgdGhlIGRldmljZSBwaXhlbFxuICogcmF0aW8sIGB7bW9kdWxlOm9sL3NpemV+U2l6ZX1gIHRoZSBpbWFnZSBzaXplLCBhbmQgYHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259YCB0aGUgaW1hZ2VcbiAqIHByb2plY3Rpb24uIFRoZSBjYW52YXMgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBpcyBjYWNoZWQgYnkgdGhlIHNvdXJjZS4gSWZcbiAqIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24gaXMgbGF0ZXIgY2hhbmdlZCB0aGVuXG4gKiBgY2hhbmdlZGAgc2hvdWxkIGJlIGNhbGxlZCBvbiB0aGUgc291cmNlIGZvciB0aGUgc291cmNlIHRvXG4gKiBpbnZhbGlkYXRlIHRoZSBjdXJyZW50IGNhY2hlZCBpbWFnZS4gU2VlIEBsaW5rOiB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV+T2JzZXJ2YWJsZSNjaGFuZ2VkfVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYXRpbz0xLjVdIFJhdGlvLiAxIG1lYW5zIGNhbnZhc2VzIGFyZSB0aGUgc2l6ZSBvZiB0aGUgbWFwIHZpZXdwb3J0LCAyIG1lYW5zIHR3aWNlIHRoZVxuICogd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbWFwIHZpZXdwb3J0LCBhbmQgc28gb24uIE11c3QgYmUgYDFgIG9yIGhpZ2hlci5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IFtyZXNvbHV0aW9uc10gUmVzb2x1dGlvbnMuXG4gKiBJZiBzcGVjaWZpZWQsIG5ldyBjYW52YXNlcyB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZXNlIHJlc29sdXRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV0gU291cmNlIHN0YXRlLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBpbWFnZSBzb3VyY2VzIHdoZXJlIGEgY2FudmFzIGVsZW1lbnQgaXMgdGhlIGltYWdlLlxuICogQGFwaVxuICovXG52YXIgSW1hZ2VDYW52YXNTb3VyY2UgPSAoZnVuY3Rpb24gKEltYWdlU291cmNlKSB7XG4gIGZ1bmN0aW9uIEltYWdlQ2FudmFzU291cmNlKG9wdGlvbnMpIHtcblxuICAgIEltYWdlU291cmNlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHJlc29sdXRpb25zOiBvcHRpb25zLnJlc29sdXRpb25zLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGVcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHttb2R1bGU6b2wvc291cmNlL0ltYWdlQ2FudmFzfkZ1bmN0aW9uVHlwZX1cbiAgICAqL1xuICAgIHRoaXMuY2FudmFzRnVuY3Rpb25fID0gb3B0aW9ucy5jYW52YXNGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHttb2R1bGU6b2wvSW1hZ2VDYW52YXN9XG4gICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqL1xuICAgIHRoaXMucmF0aW9fID0gb3B0aW9ucy5yYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmF0aW8gOiAxLjU7XG5cbiAgfVxuXG4gIGlmICggSW1hZ2VTb3VyY2UgKSBJbWFnZUNhbnZhc1NvdXJjZS5fX3Byb3RvX18gPSBJbWFnZVNvdXJjZTtcbiAgSW1hZ2VDYW52YXNTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW1hZ2VTb3VyY2UgJiYgSW1hZ2VTb3VyY2UucHJvdG90eXBlICk7XG4gIEltYWdlQ2FudmFzU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEltYWdlQ2FudmFzU291cmNlO1xuXG4gIC8qKlxuICAqIEBpbmhlcml0RG9jXG4gICovXG4gIEltYWdlQ2FudmFzU291cmNlLnByb3RvdHlwZS5nZXRJbWFnZUludGVybmFsID0gZnVuY3Rpb24gZ2V0SW1hZ2VJbnRlcm5hbCAoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgcmVzb2x1dGlvbiA9IHRoaXMuZmluZE5lYXJlc3RSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzXztcbiAgICBpZiAoY2FudmFzICYmXG4gICAgICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9PSB0aGlzLmdldFJldmlzaW9uKCkgJiZcbiAgICAgICBjYW52YXMuZ2V0UmVzb2x1dGlvbigpID09IHJlc29sdXRpb24gJiZcbiAgICAgICBjYW52YXMuZ2V0UGl4ZWxSYXRpbygpID09IHBpeGVsUmF0aW8gJiZcbiAgICAgICBjb250YWluc0V4dGVudChjYW52YXMuZ2V0RXh0ZW50KCksIGV4dGVudCkpIHtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgZXh0ZW50ID0gZXh0ZW50LnNsaWNlKCk7XG4gICAgc2NhbGVGcm9tQ2VudGVyKGV4dGVudCwgdGhpcy5yYXRpb18pO1xuICAgIHZhciB3aWR0aCA9IGdldFdpZHRoKGV4dGVudCkgLyByZXNvbHV0aW9uO1xuICAgIHZhciBoZWlnaHQgPSBnZXRIZWlnaHQoZXh0ZW50KSAvIHJlc29sdXRpb247XG4gICAgdmFyIHNpemUgPSBbd2lkdGggKiBwaXhlbFJhdGlvLCBoZWlnaHQgKiBwaXhlbFJhdGlvXTtcblxuICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy5jYW52YXNGdW5jdGlvbl8oXG4gICAgICBleHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHNpemUsIHByb2plY3Rpb24pO1xuICAgIGlmIChjYW52YXNFbGVtZW50KSB7XG4gICAgICBjYW52YXMgPSBuZXcgSW1hZ2VDYW52YXMoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBjYW52YXNFbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXNfID0gY2FudmFzO1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuXG4gIHJldHVybiBJbWFnZUNhbnZhc1NvdXJjZTtcbn0oSW1hZ2VTb3VyY2UpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZUNhbnZhc1NvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2VDYW52YXMuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9PU01cbiAqL1xuXG5pbXBvcnQgWFlaIGZyb20gJy4uL3NvdXJjZS9YWVouanMnO1xuXG5cbi8qKlxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRhaW5pbmcgYSBsaW5rIHRvIHRoZSBPcGVuU3RyZWV0TWFwIENvcHlyaWdodCBhbmQgTGljZW5zZVxuICogcGFnZS5cbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IHZhciBBVFRSSUJVVElPTiA9ICcmY29weTsgJyArXG4gICAgICAnPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+ICcgK1xuICAgICAgJ2NvbnRyaWJ1dG9ycy4nO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTE5XSBNYXggem9vbS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT10cnVlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkPTEuNV0gTWF4aW11bSBhbGxvd2VkIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcGl4ZWxzKS5cbiAqIEhpZ2hlciB2YWx1ZXMgY2FuIGluY3JlYXNlIHJlcHJvamVjdGlvbiBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmw9J2h0dHBzOi8ve2EtY30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnXSBVUkwgdGVtcGxhdGUuXG4gKiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRoZSBPcGVuU3RyZWV0TWFwIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG52YXIgT1NNID0gKGZ1bmN0aW9uIChYWVopIHtcbiAgZnVuY3Rpb24gT1NNKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGF0dHJpYnV0aW9ucztcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRpb25zID0gb3B0aW9ucy5hdHRyaWJ1dGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFtBVFRSSUJVVElPTl07XG4gICAgfVxuXG4gICAgdmFyIGNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiAnYW5vbnltb3VzJztcblxuICAgIHZhciB1cmwgPSBvcHRpb25zLnVybCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudXJsIDogJ2h0dHBzOi8ve2EtY30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnO1xuXG4gICAgWFlaLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBhdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFxdWUgOiB0cnVlLFxuICAgICAgbWF4Wm9vbTogb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heFpvb20gOiAxOSxcbiAgICAgIHJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkOiBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWFxuICAgIH0pO1xuXG4gIH1cblxuICBpZiAoIFhZWiApIE9TTS5fX3Byb3RvX18gPSBYWVo7XG4gIE9TTS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBYWVogJiYgWFlaLnByb3RvdHlwZSApO1xuICBPU00ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT1NNO1xuXG4gIHJldHVybiBPU007XG59KFhZWikpO1xuXG5leHBvcnQgZGVmYXVsdCBPU007XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9TTS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1NvdXJjZVxuICovXG5cbmltcG9ydCB7VU5ERUZJTkVEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBzb3VyY2VcbiAqIGF0dHJpYnV0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24obW9kdWxlOm9sL1BsdWdnYWJsZU1hcH5GcmFtZVN0YXRlKTogKHN0cmluZ3xBcnJheS48c3RyaW5nPil9IEF0dHJpYnV0aW9uXG4gKi9cblxuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYXR0cmlidXRpb24gaW5mb3JtYXRpb24gZm9yIGRhdGEgc291cmNlcy5cbiAqXG4gKiBJdCByZXByZXNlbnRzIGVpdGhlclxuICogKiBhIHNpbXBsZSBzdHJpbmcgKGUuZy4gYCfCqSBBY21lIEluYy4nYClcbiAqICogYW4gYXJyYXkgb2Ygc2ltcGxlIHN0cmluZ3MgKGUuZy4gYFsnwqkgQWNtZSBJbmMuJywgJ8KpIEJhY21lIEluYy4nXWApXG4gKiAqIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgKGB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259YClcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfEFycmF5LjxzdHJpbmc+fG1vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbkxpa2VcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyfkxheWVyfSBzb3VyY2VzLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSBjaGFuZ2VzLlxuICogQGFwaVxuICovXG52YXIgU291cmNlID0gKGZ1bmN0aW9uIChCYXNlT2JqZWN0KSB7XG4gIGZ1bmN0aW9uIFNvdXJjZShvcHRpb25zKSB7XG5cbiAgICBCYXNlT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAgICAqL1xuICAgIHRoaXMucHJvamVjdGlvbl8gPSBnZXRQcm9qZWN0aW9uKG9wdGlvbnMucHJvamVjdGlvbik7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7P21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9ufVxuICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGlvbnNfID0gdGhpcy5hZGFwdEF0dHJpYnV0aW9uc18ob3B0aW9ucy5hdHRyaWJ1dGlvbnMpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9XG4gICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG9wdGlvbnMuc3RhdGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnN0YXRlIDogU291cmNlU3RhdGUuUkVBRFk7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqL1xuICAgIHRoaXMud3JhcFhfID0gb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlO1xuXG4gIH1cblxuICBpZiAoIEJhc2VPYmplY3QgKSBTb3VyY2UuX19wcm90b19fID0gQmFzZU9iamVjdDtcbiAgU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJhc2VPYmplY3QgJiYgQmFzZU9iamVjdC5wcm90b3R5cGUgKTtcbiAgU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZTtcblxuICAvKipcbiAgKiBUdXJucyB0aGUgYXR0cmlidXRpb25zIG9wdGlvbiBpbnRvIGFuIGF0dHJpYnV0aW9ucyBmdW5jdGlvbi5cbiAgKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICAqIEByZXR1cm4gez9tb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn0gQW4gYXR0cmlidXRpb24gZnVuY3Rpb24gKG9yIG51bGwpLlxuICAqL1xuICBTb3VyY2UucHJvdG90eXBlLmFkYXB0QXR0cmlidXRpb25zXyA9IGZ1bmN0aW9uIGFkYXB0QXR0cmlidXRpb25zXyAoYXR0cmlidXRpb25MaWtlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGlvbkxpa2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGlvbkxpa2UpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0aW9uTGlrZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIFthdHRyaWJ1dGlvbkxpa2VdO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICogR2V0IHRoZSBhdHRyaWJ1dGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNvdXJjZS5cbiAgKiBAcmV0dXJuIHs/bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259IEF0dHJpYnV0aW9uIGZ1bmN0aW9uLlxuICAqL1xuICBTb3VyY2UucHJvdG90eXBlLmdldEF0dHJpYnV0aW9ucyA9IGZ1bmN0aW9uIGdldEF0dHJpYnV0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRpb25zXztcbiAgfTtcblxuICAvKipcbiAgKiBHZXQgdGhlIHByb2plY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgKiBAcmV0dXJuIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBQcm9qZWN0aW9uLlxuICAqIEBhcGlcbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0UHJvamVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdGlvbl87XG4gIH07XG5cbiAgLyoqXG4gICogQGFic3RyYWN0XG4gICogQHJldHVybiB7QXJyYXkuPG51bWJlcj58dW5kZWZpbmVkfSBSZXNvbHV0aW9ucy5cbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHt9O1xuXG4gIC8qKlxuICAqIEdldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZSwgc2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1N0YXRlflN0YXRlfSBmb3IgcG9zc2libGUgc3RhdGVzLlxuICAqIEByZXR1cm4ge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFN0YXRlLlxuICAqIEBhcGlcbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV87XG4gIH07XG5cbiAgLyoqXG4gICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9IFdyYXAgWC5cbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5nZXRXcmFwWCA9IGZ1bmN0aW9uIGdldFdyYXBYICgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwWF87XG4gIH07XG5cbiAgLyoqXG4gICogUmVmcmVzaGVzIHRoZSBzb3VyY2UgYW5kIGZpbmFsbHkgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICAqIEBhcGlcbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCAoKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICogU2V0IHRoZSBhdHRyaWJ1dGlvbnMgb2YgdGhlIHNvdXJjZS5cbiAgKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU291cmNlfkF0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9ucyBBdHRyaWJ1dGlvbnMuXG4gICogICAgIENhbiBiZSBwYXNzZWQgYXMgYHN0cmluZ2AsIGBBcnJheTxzdHJpbmc+YCwgYHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn1gLFxuICAqICAgICBvciBgdW5kZWZpbmVkYC5cbiAgKiBAYXBpXG4gICovXG4gIFNvdXJjZS5wcm90b3R5cGUuc2V0QXR0cmlidXRpb25zID0gZnVuY3Rpb24gc2V0QXR0cmlidXRpb25zIChhdHRyaWJ1dGlvbnMpIHtcbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSB0aGlzLmFkYXB0QXR0cmlidXRpb25zXyhhdHRyaWJ1dGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZS5cbiAgKiBAcGFyYW0ge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAqIEBwcm90ZWN0ZWRcbiAgKi9cbiAgU291cmNlLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlIChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVfID0gc3RhdGU7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNvdXJjZTtcbn0oQmFzZU9iamVjdCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVVaWRzIFNraXBwZWQgZmVhdHVyZSB1aWRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICogQHRlbXBsYXRlIFRcbiAqL1xuU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSA9IFVOREVGSU5FRDtcblxuXG5leHBvcnQgZGVmYXVsdCBTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvdXJjZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1N0YW1lblxuICovXG5cbmltcG9ydCB7QVRUUklCVVRJT04gYXMgT1NNX0FUVFJJQlVUSU9OfSBmcm9tICcuLi9zb3VyY2UvT1NNLmpzJztcbmltcG9ydCBYWVogZnJvbSAnLi4vc291cmNlL1hZWi5qcyc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAqL1xudmFyIEFUVFJJQlVUSU9OUyA9IFtcbiAgJ01hcCB0aWxlcyBieSA8YSBocmVmPVwiaHR0cHM6Ly9zdGFtZW4uY29tL1wiPlN0YW1lbiBEZXNpZ248L2E+LCAnICtcbiAgICAgICAgJ3VuZGVyIDxhIGhyZWY9XCJodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wL1wiPkNDIEJZJyArXG4gICAgICAgICcgMy4wPC9hPi4nLFxuICBPU01fQVRUUklCVVRJT05cbl07XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIHtleHRlbnNpb246IHN0cmluZywgb3BhcXVlOiBib29sZWFufT59XG4gKi9cbnZhciBMYXllckNvbmZpZyA9IHtcbiAgJ3RlcnJhaW4nOiB7XG4gICAgZXh0ZW5zaW9uOiAnanBnJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfSxcbiAgJ3RlcnJhaW4tYmFja2dyb3VuZCc6IHtcbiAgICBleHRlbnNpb246ICdqcGcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9LFxuICAndGVycmFpbi1sYWJlbHMnOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IGZhbHNlXG4gIH0sXG4gICd0ZXJyYWluLWxpbmVzJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiBmYWxzZVxuICB9LFxuICAndG9uZXItYmFja2dyb3VuZCc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9LFxuICAndG9uZXInOiB7XG4gICAgZXh0ZW5zaW9uOiAncG5nJyxcbiAgICBvcGFxdWU6IHRydWVcbiAgfSxcbiAgJ3RvbmVyLWh5YnJpZCc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogZmFsc2VcbiAgfSxcbiAgJ3RvbmVyLWxhYmVscyc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogZmFsc2VcbiAgfSxcbiAgJ3RvbmVyLWxpbmVzJzoge1xuICAgIGV4dGVuc2lvbjogJ3BuZycsXG4gICAgb3BhcXVlOiBmYWxzZVxuICB9LFxuICAndG9uZXItbGl0ZSc6IHtcbiAgICBleHRlbnNpb246ICdwbmcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9LFxuICAnd2F0ZXJjb2xvcic6IHtcbiAgICBleHRlbnNpb246ICdqcGcnLFxuICAgIG9wYXF1ZTogdHJ1ZVxuICB9XG59O1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCB7bWluWm9vbTogbnVtYmVyLCBtYXhab29tOiBudW1iZXJ9Pn1cbiAqL1xudmFyIFByb3ZpZGVyQ29uZmlnID0ge1xuICAndGVycmFpbic6IHtcbiAgICBtaW5ab29tOiA0LFxuICAgIG1heFpvb206IDE4XG4gIH0sXG4gICd0b25lcic6IHtcbiAgICBtaW5ab29tOiAwLFxuICAgIG1heFpvb206IDIwXG4gIH0sXG4gICd3YXRlcmNvbG9yJzoge1xuICAgIG1pblpvb206IDEsXG4gICAgbWF4Wm9vbTogMTZcbiAgfVxufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xheWVyXSBMYXllci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbV0gTWluaW11bSB6b29tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tXSBNYXhpbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcGFxdWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXVxuICogT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aGUgU3RhbWVuIHRpbGUgc2VydmVyLlxuICogQGFwaVxuICovXG52YXIgU3RhbWVuID0gKGZ1bmN0aW9uIChYWVopIHtcbiAgZnVuY3Rpb24gU3RhbWVuKG9wdGlvbnMpIHtcbiAgICB2YXIgaSA9IG9wdGlvbnMubGF5ZXIuaW5kZXhPZignLScpO1xuICAgIHZhciBwcm92aWRlciA9IGkgPT0gLTEgPyBvcHRpb25zLmxheWVyIDogb3B0aW9ucy5sYXllci5zbGljZSgwLCBpKTtcbiAgICB2YXIgcHJvdmlkZXJDb25maWcgPSBQcm92aWRlckNvbmZpZ1twcm92aWRlcl07XG5cbiAgICB2YXIgbGF5ZXJDb25maWcgPSBMYXllckNvbmZpZ1tvcHRpb25zLmxheWVyXTtcblxuICAgIHZhciB1cmwgPSBvcHRpb25zLnVybCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51cmwgOlxuICAgICAgJ2h0dHBzOi8vc3RhbWVuLXRpbGVzLXthLWR9LmEuc3NsLmZhc3RseS5uZXQvJyArIG9wdGlvbnMubGF5ZXIgK1xuICAgICAgICAnL3t6fS97eH0ve3l9LicgKyBsYXllckNvbmZpZy5leHRlbnNpb247XG5cbiAgICBYWVouY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IEFUVFJJQlVUSU9OUyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogJ2Fub255bW91cycsXG4gICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20gIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogcHJvdmlkZXJDb25maWcubWF4Wm9vbSxcbiAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiBwcm92aWRlckNvbmZpZy5taW5ab29tLFxuICAgICAgb3BhcXVlOiBsYXllckNvbmZpZy5vcGFxdWUsXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHVybDogdXJsLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFhcbiAgICB9KTtcblxuICB9XG5cbiAgaWYgKCBYWVogKSBTdGFtZW4uX19wcm90b19fID0gWFlaO1xuICBTdGFtZW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggWFlaICYmIFhZWi5wcm90b3R5cGUgKTtcbiAgU3RhbWVuLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YW1lbjtcblxuICByZXR1cm4gU3RhbWVuO1xufShYWVopKTtcblxuZXhwb3J0IGRlZmF1bHQgU3RhbWVuO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGFtZW4uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9TdGF0ZVxuICovXG5cbi8qKlxuICogU3RhdGUgb2YgdGhlIHNvdXJjZSwgb25lIG9mICd1bmRlZmluZWQnLCAnbG9hZGluZycsICdyZWFkeScgb3IgJ2Vycm9yJy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5ERUZJTkVEOiAndW5kZWZpbmVkJyxcbiAgTE9BRElORzogJ2xvYWRpbmcnLFxuICBSRUFEWTogJ3JlYWR5JyxcbiAgRVJST1I6ICdlcnJvcidcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVGlsZVxuICovXG5cbmltcG9ydCB7VU5ERUZJTkVEfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IFRpbGVDYWNoZSBmcm9tICcuLi9UaWxlQ2FjaGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHt0b1NpemUsIHNjYWxlIGFzIHNjYWxlU2l6ZX0gZnJvbSAnLi4vc2l6ZS5qcyc7XG5pbXBvcnQgU291cmNlIGZyb20gJy4uL3NvdXJjZS9Tb3VyY2UuanMnO1xuaW1wb3J0IHtnZXRLZXlaWFksIHdpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge3dyYXBYLCBnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gW3RpbGVHcmlkXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgaW1hZ2VzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZC5cbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVTb3VyY2UgPSAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICBmdW5jdGlvbiBUaWxlU291cmNlKG9wdGlvbnMpIHtcblxuICAgIFNvdXJjZS5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBleHRlbnQ6IG9wdGlvbnMuZXh0ZW50LFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wYXF1ZV8gPSBvcHRpb25zLm9wYXF1ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFxdWUgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVQaXhlbFJhdGlvXyA9IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnRpbGVQaXhlbFJhdGlvIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUdyaWQgPSBvcHRpb25zLnRpbGVHcmlkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRpbGVHcmlkIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGVDYWNoZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDYWNoZSA9IG5ldyBUaWxlQ2FjaGUob3B0aW9ucy5jYWNoZVNpemUpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgICAqL1xuICAgIHRoaXMudG1wU2l6ZSA9IFswLCAwXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleV8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL1RpbGV+T3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVPcHRpb25zID0ge3RyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbn07XG5cbiAgfVxuXG4gIGlmICggU291cmNlICkgVGlsZVNvdXJjZS5fX3Byb3RvX18gPSBTb3VyY2U7XG4gIFRpbGVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU291cmNlICYmIFNvdXJjZS5wcm90b3R5cGUgKTtcbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlU291cmNlO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDYW4gZXhwaXJlIGNhY2hlLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBjYW5FeHBpcmVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlLmNhbkV4cGlyZUNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL1RpbGVSYW5nZT59IHVzZWRUaWxlcyBVc2VkIHRpbGVzLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBleHBpcmVDYWNoZSAocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgdmFyIHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZUNhY2hlKSB7XG4gICAgICB0aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodXNlZFRpbGVzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9UaWxlKTooYm9vbGVhbnx1bmRlZmluZWQpfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoXG4gICAqICAgICBsb2FkZWQgdGlsZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRoZSB0aWxlIHdpbGwgbm90IGJlXG4gICAqICAgICBjb25zaWRlcmVkIGxvYWRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgcmFuZ2UgaXMgZnVsbHkgY292ZXJlZCB3aXRoIGxvYWRlZCB0aWxlcy5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmZvckVhY2hMb2FkZWRUaWxlID0gZnVuY3Rpb24gZm9yRWFjaExvYWRlZFRpbGUgKHByb2plY3Rpb24sIHosIHRpbGVSYW5nZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGlsZUNhY2hlID0gdGhpcy5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmICghdGlsZUNhY2hlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNvdmVyZWQgPSB0cnVlO1xuICAgIHZhciB0aWxlLCB0aWxlQ29vcmRLZXksIGxvYWRlZDtcbiAgICBmb3IgKHZhciB4ID0gdGlsZVJhbmdlLm1pblg7IHggPD0gdGlsZVJhbmdlLm1heFg7ICsreCkge1xuICAgICAgZm9yICh2YXIgeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5WlhZKHosIHgsIHkpO1xuICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRpbGVDYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICAgICAgdGlsZSA9IC8qKiBAdHlwZSB7IW1vZHVsZTpvbC9UaWxlfSAqLyAodGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICAgICAgICBsb2FkZWQgPSB0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgbG9hZGVkID0gKGNhbGxiYWNrKHRpbGUpICE9PSBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3ZlcmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRHdXR0ZXIgPSBmdW5jdGlvbiBnZXRHdXR0ZXIgKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBrZXkgdG8gYmUgdXNlZCBmb3IgYWxsIHRpbGVzIGluIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGtleSBmb3IgYWxsIHRpbGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkgKCkge1xuICAgIHJldHVybiB0aGlzLmtleV87XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gc2V0S2V5IChrZXkpIHtcbiAgICBpZiAodGhpcy5rZXlfICE9PSBrZXkpIHtcbiAgICAgIHRoaXMua2V5XyA9IGtleTtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IE9wYXF1ZS5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldE9wYXF1ZSA9IGZ1bmN0aW9uIGdldE9wYXF1ZSAocHJvamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLm9wYXF1ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIGdldFJlc29sdXRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZC5nZXRSZXNvbHV0aW9ucygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshbW9kdWxlOm9sL1RpbGV9IFRpbGUuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gZ2V0VGlsZSAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge307XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBncmlkIG9mIHRoZSB0aWxlIHNvdXJjZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaWxlIGdyaWQuXG4gICAqIEBhcGlcbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVHcmlkID0gZnVuY3Rpb24gZ2V0VGlsZUdyaWQgKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGlsZSBncmlkLlxuICAgKi9cbiAgVGlsZVNvdXJjZS5wcm90b3R5cGUuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uJDEgKHByb2plY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMudGlsZUdyaWQpIHtcbiAgICAgIHJldHVybiBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlQ2FjaGV9IFRpbGUgY2FjaGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXNQcm9qICYmICFlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBwaXhlbCByYXRpbyBmb3IgdGhpcyBzb3VyY2UuIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcbiAgICogbWV0aG9kLCB3aGljaCBpcyBtZWFudCB0byByZXR1cm4gYSBzdXBwb3J0ZWQgcGl4ZWwgcmF0aW8gdGhhdCBtYXRjaGVzIHRoZVxuICAgKiBwcm92aWRlZCBgcGl4ZWxSYXRpb2AgYXMgY2xvc2UgYXMgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcGl4ZWwgcmF0aW8uXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlUGl4ZWxSYXRpbyA9IGZ1bmN0aW9uIGdldFRpbGVQaXhlbFJhdGlvIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVBpeGVsUmF0aW9fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFRpbGUgc2l6ZS5cbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLmdldFRpbGVQaXhlbFNpemUgPSBmdW5jdGlvbiBnZXRUaWxlUGl4ZWxTaXplICh6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgdmFyIHRpbGVQaXhlbFJhdGlvID0gdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcbiAgICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGlsZUdyaWQuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZSk7XG4gICAgaWYgKHRpbGVQaXhlbFJhdGlvID09IDEpIHtcbiAgICAgIHJldHVybiB0aWxlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjYWxlU2l6ZSh0aWxlU2l6ZSwgdGlsZVBpeGVsUmF0aW8sIHRoaXMudG1wU2l6ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbj19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUgdG8gYmUgcGFzc2VkIHRvIHRoZSB0aWxlVXJsRnVuY3Rpb24gb3JcbiAgICogICAgIG51bGwgaWYgbm8gdGlsZSBVUkwgc2hvdWxkIGJlIGNyZWF0ZWQgZm9yIHRoZSBwYXNzZWQgYHRpbGVDb29yZGAuXG4gICAqL1xuICBUaWxlU291cmNlLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24gKHRpbGVDb29yZCwgb3B0X3Byb2plY3Rpb24pIHtcbiAgICB2YXIgcHJvamVjdGlvbiA9IG9wdF9wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X3Byb2plY3Rpb24gOiB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICB2YXIgdGlsZUdyaWQgPSB0aGlzLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGhpcy5nZXRXcmFwWCgpICYmIHByb2plY3Rpb24uaXNHbG9iYWwoKSkge1xuICAgICAgdGlsZUNvb3JkID0gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpID8gdGlsZUNvb3JkIDogbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFRpbGVTb3VyY2UucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoICgpIHtcbiAgICB0aGlzLnRpbGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9O1xuXG4gIHJldHVybiBUaWxlU291cmNlO1xufShTb3VyY2UpKTtcblxuXG4vKipcbiAqIE1hcmtzIGEgdGlsZSBjb29yZCBhcyBiZWluZyB1c2VkLCB3aXRob3V0IHRyaWdnZXJpbmcgYSBsb2FkLlxuICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKi9cblRpbGVTb3VyY2UucHJvdG90eXBlLnVzZVRpbGUgPSBVTkRFRklORUQ7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlflRpbGVTb3VyY2V9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCB2YXIgVGlsZVNvdXJjZUV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBUaWxlU291cmNlRXZlbnQodHlwZSwgdGlsZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aWxlIHJlbGF0ZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvVGlsZX1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy50aWxlID0gdGlsZTtcblxuICB9XG5cbiAgaWYgKCBFdmVudCApIFRpbGVTb3VyY2VFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgVGlsZVNvdXJjZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSApO1xuICBUaWxlU291cmNlRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGlsZVNvdXJjZUV2ZW50O1xuXG4gIHJldHVybiBUaWxlU291cmNlRXZlbnQ7XG59KEV2ZW50KSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBzdGFydHMgbG9hZGluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BRFNUQVJUOiAndGlsZWxvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBmaW5pc2hlcyBsb2FkaW5nLCBlaXRoZXIgd2hlbiBpdHMgZGF0YSBpcyBsb2FkZWQsXG4gICAqIG9yIHdoZW4gbG9hZGluZyB3YXMgYWJvcnRlZCBiZWNhdXNlIHRoZSB0aWxlIGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERU5EOiAndGlsZWxvYWRlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgaWYgdGlsZSBsb2FkaW5nIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZXJyb3JcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFUlJPUjogJ3RpbGVsb2FkZXJyb3InXG5cbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbGVFdmVudFR5cGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlSW1hZ2VcbiAqL1xuaW1wb3J0IHtFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTn0gZnJvbSAnLi4vcmVwcm9qL2NvbW1vbi5qcyc7XG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgSW1hZ2VUaWxlIGZyb20gJy4uL0ltYWdlVGlsZS5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQsIGdldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBSZXByb2pUaWxlIGZyb20gJy4uL3JlcHJvai9UaWxlLmpzJztcbmltcG9ydCBVcmxUaWxlIGZyb20gJy4uL3NvdXJjZS9VcmxUaWxlLmpzJztcbmltcG9ydCB7Z2V0S2V5LCBnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplPTIwNDhdIENhY2hlIHNpemUuXG4gKiBAcHJvcGVydHkge251bGx8c3RyaW5nfSBbY3Jvc3NPcmlnaW5dIFRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBmb3IgbG9hZGVkIGltYWdlcy4gIE5vdGUgdGhhdFxuICogeW91IG11c3QgcHJvdmlkZSBhIGBjcm9zc09yaWdpbmAgdmFsdWUgaWYgeW91IGFyZSB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgb3IgaWYgeW91IHdhbnQgdG9cbiAqIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci4gIFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2UgZm9yIG1vcmUgZGV0YWlsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc291cmNlL1N0YXRlfSBbc3RhdGVdIFNvdXJjZSBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL0ltYWdlVGlsZX5UaWxlQ2xhc3N9IFt0aWxlQ2xhc3NdIENsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgaW1hZ2UgdGlsZXMuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvSW1hZ2VUaWxlfkltYWdlVGlsZX0uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gW3RpbGVHcmlkXSBUaWxlIGdyaWQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW89MV0gVGhlIHBpeGVsIHJhdGlvIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlXG4gKiBzZXJ2aWNlIGFkdmVydGl6ZXMgMjU2cHggYnkgMjU2cHggdGlsZXMgYnV0IGFjdHVhbGx5IHNlbmRzIDUxMnB4XG4gKiBieSA1MTJweCBpbWFnZXMgKGZvciByZXRpbmEvaGlkcGkgZGV2aWNlcykgdGhlbiBgdGlsZVBpeGVsUmF0aW9gXG4gKiBzaG91bGQgYmUgc2V0IHRvIGAyYC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGdldCB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF0gVVJMIHRlbXBsYXRlLiBNdXN0IGluY2x1ZGUgYHt4fWAsIGB7eX1gIG9yIGB7LXl9YCwgYW5kIGB7en1gIHBsYWNlaG9sZGVycy5cbiAqIEEgYHs/LT99YCB0ZW1wbGF0ZSBwYXR0ZXJuLCBmb3IgZXhhbXBsZSBgc3ViZG9tYWlue2EtZn0uZG9tYWluLmNvbWAsIG1heSBiZVxuICogdXNlZCBpbnN0ZWFkIG9mIGRlZmluaW5nIGVhY2ggb25lIHNlcGFyYXRlbHkgaW4gdGhlIGB1cmxzYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS4gVGhlIGRlZmF1bHQsIGlzIHRvXG4gKiByZXF1ZXN0IG91dC1vZi1ib3VuZHMgdGlsZXMgZnJvbSB0aGUgc2VydmVyLiBXaGVuIHNldCB0byBgZmFsc2VgLCBvbmx5IG9uZVxuICogd29ybGQgd2lsbCBiZSByZW5kZXJlZC4gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlcyB3aWxsIGJlIHJlcXVlc3RlZCBmb3Igb25lXG4gKiB3b3JsZCBvbmx5LCBidXQgdGhleSB3aWxsIGJlIHdyYXBwZWQgaG9yaXpvbnRhbGx5IHRvIHJlbmRlciBtdWx0aXBsZSB3b3JsZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb25dIER1cmF0aW9uIG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24gZm9yIHJlbmRlcmluZy5cbiAqIFRvIGRpc2FibGUgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiwgcGFzcyBgdHJhbnNpdGlvbjogMGAuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKlxuICogQGZpcmVzIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVJbWFnZSA9IChmdW5jdGlvbiAoVXJsVGlsZSkge1xuICBmdW5jdGlvbiBUaWxlSW1hZ2Uob3B0aW9ucykge1xuXG4gICAgVXJsVGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBjYWNoZVNpemU6IG9wdGlvbnMuY2FjaGVTaXplLFxuICAgICAgZXh0ZW50OiBvcHRpb25zLmV4dGVudCxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZUxvYWRGdW5jdGlvbjogb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uID9cbiAgICAgICAgb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uIDogZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICB0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb25cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luID1cbiAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc09yaWdpbiA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG5ldzogbW9kdWxlOm9sL0ltYWdlVGlsZSwgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQsIG1vZHVsZTpvbC9UaWxlU3RhdGUsIHN0cmluZyxcbiAgICAgKiAgICAgICAgP3N0cmluZywgbW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9uLCBtb2R1bGU6b2wvVGlsZX5PcHRpb25zPSl9XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2xhc3MgPSBvcHRpb25zLnRpbGVDbGFzcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMudGlsZUNsYXNzIDogSW1hZ2VUaWxlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9UaWxlQ2FjaGU+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZD59XG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8gPSBvcHRpb25zLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCBVcmxUaWxlICkgVGlsZUltYWdlLl9fcHJvdG9fXyA9IFVybFRpbGU7XG4gIFRpbGVJbWFnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBVcmxUaWxlICYmIFVybFRpbGUucHJvdG90eXBlICk7XG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUaWxlSW1hZ2U7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmNhbkV4cGlyZUNhY2hlID0gZnVuY3Rpb24gY2FuRXhwaXJlQ2FjaGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgcmV0dXJuIFVybFRpbGUucHJvdG90eXBlLmNhbkV4cGlyZUNhY2hlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzJDEudGlsZUNhY2hlRm9yUHJvamVjdGlvbltrZXldLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmV4cGlyZUNhY2hlID0gZnVuY3Rpb24gZXhwaXJlQ2FjaGUgKHByb2plY3Rpb24sIHVzZWRUaWxlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgVXJsVGlsZS5wcm90b3R5cGUuZXhwaXJlQ2FjaGUuY2FsbCh0aGlzLCBwcm9qZWN0aW9uLCB1c2VkVGlsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdXNlZFRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblxuICAgIHRoaXMudGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRoaXMudGlsZUNhY2hlID09IHVzZWRUaWxlQ2FjaGUgPyB1c2VkVGlsZXMgOiB7fSk7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcyQxLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHZhciB0aWxlQ2FjaGUgPSB0aGlzJDEudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF07XG4gICAgICB0aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodGlsZUNhY2hlID09IHVzZWRUaWxlQ2FjaGUgPyB1c2VkVGlsZXMgOiB7fSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRHdXR0ZXIgPSBmdW5jdGlvbiBnZXRHdXR0ZXIgKHByb2plY3Rpb24pIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHdXR0ZXJJbnRlcm5hbCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEd1dHRlci5cbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuZ2V0R3V0dGVySW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRHdXR0ZXJJbnRlcm5hbCAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldE9wYXF1ZSA9IGZ1bmN0aW9uIGdldE9wYXF1ZSAocHJvamVjdGlvbikge1xuICAgIGlmIChFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiAmJlxuICAgICAgICB0aGlzLmdldFByb2plY3Rpb24oKSAmJiBwcm9qZWN0aW9uICYmICFlcXVpdmFsZW50KHRoaXMuZ2V0UHJvamVjdGlvbigpLCBwcm9qZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVXJsVGlsZS5wcm90b3R5cGUuZ2V0T3BhcXVlLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24gPSBmdW5jdGlvbiBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24kMSAocHJvamVjdGlvbikge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24uY2FsbCh0aGlzLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgdmFyIHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKS50b1N0cmluZygpO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUgeyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9ICovICh0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbiAocHJvamVjdGlvbikge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHJldHVybiBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlQ2FjaGVGb3JQcm9qZWN0aW9uLmNhbGwodGhpcywgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIHZhciB0aGlzUHJvaiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpOyBpZiAoIXRoaXNQcm9qIHx8IGVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlQ2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIShwcm9qS2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW3Byb2pLZXldID0gbmV3IFRpbGVDYWNoZSh0aGlzLnRpbGVDYWNoZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBzZXQgb24gdGhlIHRpbGUuXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvVGlsZX0gVGlsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIFRpbGVJbWFnZS5wcm90b3R5cGUuY3JlYXRlVGlsZV8gPSBmdW5jdGlvbiBjcmVhdGVUaWxlXyAoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KSB7XG4gICAgdmFyIHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICB2YXIgdXJsVGlsZUNvb3JkID0gdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24oXG4gICAgICB0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgIHZhciB0aWxlVXJsID0gdXJsVGlsZUNvb3JkID9cbiAgICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uKHVybFRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRpbGUgPSBuZXcgdGhpcy50aWxlQ2xhc3MoXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyBUaWxlU3RhdGUuSURMRSA6IFRpbGVTdGF0ZS5FTVBUWSxcbiAgICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IHRpbGVVcmwgOiAnJyxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zKTtcbiAgICB0aWxlLmtleSA9IGtleTtcbiAgICBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiBnZXRUaWxlICh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZVByb2plY3Rpb24gPSAvKiogQHR5cGUgeyFtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSAqLyAodGhpcy5nZXRQcm9qZWN0aW9uKCkpO1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gfHxcbiAgICAgICAgIXNvdXJjZVByb2plY3Rpb24gfHwgIXByb2plY3Rpb24gfHwgZXF1aXZhbGVudChzb3VyY2VQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKHosIHgsIHksIHBpeGVsUmF0aW8sIHNvdXJjZVByb2plY3Rpb24gfHwgcHJvamVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIHZhciB0aWxlQ29vcmQgPSBbeiwgeCwgeV07XG4gICAgICB2YXIgdGlsZTtcbiAgICAgIHZhciB0aWxlQ29vcmRLZXkgPSBnZXRLZXkodGlsZUNvb3JkKTtcbiAgICAgIGlmIChjYWNoZS5jb250YWluc0tleSh0aWxlQ29vcmRLZXkpKSB7XG4gICAgICAgIHRpbGUgPSAvKiogQHR5cGUgeyFtb2R1bGU6b2wvVGlsZX0gKi8gKGNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5rZXkgPT0ga2V5KSB7XG4gICAgICAgIHJldHVybiB0aWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZVRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oc291cmNlUHJvamVjdGlvbik7XG4gICAgICAgIHZhciB0YXJnZXRUaWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgd3JhcHBlZFRpbGVDb29yZCA9XG4gICAgICAgICAgICB0aGlzLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIHByb2plY3Rpb24pO1xuICAgICAgICB2YXIgbmV3VGlsZSA9IG5ldyBSZXByb2pUaWxlKFxuICAgICAgICAgIHNvdXJjZVByb2plY3Rpb24sIHNvdXJjZVRpbGVHcmlkLFxuICAgICAgICAgIHByb2plY3Rpb24sIHRhcmdldFRpbGVHcmlkLFxuICAgICAgICAgIHRpbGVDb29yZCwgd3JhcHBlZFRpbGVDb29yZCwgdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzLmdldEd1dHRlckludGVybmFsKCksXG4gICAgICAgICAgZnVuY3Rpb24oeiwgeCwgeSwgcGl4ZWxSYXRpbykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZUludGVybmFsKHosIHgsIHksIHBpeGVsUmF0aW8sIHNvdXJjZVByb2plY3Rpb24pO1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZF8sXG4gICAgICAgICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18pO1xuICAgICAgICBuZXdUaWxlLmtleSA9IGtleTtcblxuICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgIG5ld1RpbGUuaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgICAgIG5ld1RpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgICAgIGNhY2hlLnJlcGxhY2UodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQodGlsZUNvb3JkS2V5LCBuZXdUaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3VGlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0geyFtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4geyFtb2R1bGU6b2wvVGlsZX0gVGlsZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVGlsZUltYWdlLnByb3RvdHlwZS5nZXRUaWxlSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRUaWxlSW50ZXJuYWwgKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICB2YXIgdGlsZSA9IG51bGw7XG4gICAgdmFyIHRpbGVDb29yZEtleSA9IGdldEtleVpYWSh6LCB4LCB5KTtcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBpZiAoIXRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG4gICAgICB0aGlzLnRpbGVDYWNoZS5zZXQodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZSA9IHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgICAgaWYgKHRpbGUua2V5ICE9IGtleSkge1xuICAgICAgICAvLyBUaGUgc291cmNlJ3MgcGFyYW1zIGNoYW5nZWQuIElmIHRoZSB0aWxlIGhhcyBhbiBpbnRlcmltIHRpbGUgYW5kIGlmIHdlXG4gICAgICAgIC8vIGNhbiB1c2UgaXQgdGhlbiB3ZSB1c2UgaXQuIE90aGVyd2lzZSB3ZSBjcmVhdGUgYSBuZXcgdGlsZS4gIEluIGJvdGhcbiAgICAgICAgLy8gY2FzZXMgd2UgYXR0ZW1wdCB0byBhc3NpZ24gYW4gaW50ZXJpbSB0aWxlIHRvIHRoZSBuZXcgdGlsZS5cbiAgICAgICAgdmFyIGludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgICAgdGlsZSA9IHRoaXMuY3JlYXRlVGlsZV8oeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbiwga2V5KTtcblxuICAgICAgICAvL21ha2UgdGhlIG5ldyB0aWxlIHRoZSBoZWFkIG9mIHRoZSBsaXN0LFxuICAgICAgICBpZiAoaW50ZXJpbVRpbGUuZ2V0U3RhdGUoKSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgICAgIC8vdGhlIG9sZCB0aWxlIGhhc24ndCBiZWd1biBsb2FkaW5nIHlldCwgYW5kIGlzIG5vdyBvdXRkYXRlZCwgc28gd2UgY2FuIHNpbXBseSBkaXNjYXJkIGl0XG4gICAgICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IGludGVyaW1UaWxlLmludGVyaW1UaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbGUuaW50ZXJpbVRpbGUgPSBpbnRlcmltVGlsZTtcbiAgICAgICAgfVxuICAgICAgICB0aWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgICAgdGhpcy50aWxlQ2FjaGUucmVwbGFjZSh0aWxlQ29vcmRLZXksIHRpbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRvIHJlbmRlciByZXByb2plY3Rpb24gZWRnZXMgb3Igbm90ICh1c3VhbGx5IGZvciBkZWJ1Z2dpbmcpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlciBSZW5kZXIgdGhlIGVkZ2VzLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLnNldFJlbmRlclJlcHJvamVjdGlvbkVkZ2VzID0gZnVuY3Rpb24gc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMgKHJlbmRlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiB8fFxuICAgICAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9PSByZW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSByZW5kZXI7XG4gICAgZm9yICh2YXIgaWQgaW4gdGhpcyQxLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMkMS50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2lkXS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdGlsZSBncmlkIHRvIHVzZSB3aGVuIHJlcHJvamVjdGluZyB0aGUgdGlsZXMgdG8gdGhlIGdpdmVuXG4gICAqIHByb2plY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgY2Fubm90IGJlIGNyZWF0ZWRcbiAgICogKGUuZy4gcHJvamVjdGlvbiBoYXMgbm8gZXh0ZW50IGRlZmluZWQpIG9yXG4gICAqIGZvciBvcHRpbWl6YXRpb24gcmVhc29ucyAoY3VzdG9tIHRpbGUgc2l6ZSwgcmVzb2x1dGlvbnMsIC4uLikuXG4gICAqXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVncmlkIFRpbGUgZ3JpZCB0byB1c2UgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBUaWxlSW1hZ2UucHJvdG90eXBlLnNldFRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IGZ1bmN0aW9uIHNldFRpbGVHcmlkRm9yUHJvamVjdGlvbiAocHJvamVjdGlvbiwgdGlsZWdyaWQpIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHZhciBwcm9qID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIGlmIChwcm9qKSB7XG4gICAgICAgIHZhciBwcm9qS2V5ID0gZ2V0VWlkKHByb2opLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb24pKSB7XG4gICAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSB0aWxlZ3JpZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGlsZUltYWdlO1xufShVcmxUaWxlKSk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9JbWFnZVRpbGV9IGltYWdlVGlsZSBJbWFnZSB0aWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUltYWdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlSW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9VcmxUaWxlXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7ZXhwYW5kVXJsLCBjcmVhdGVGcm9tVGVtcGxhdGVzLCBudWxsVGlsZVVybEZ1bmN0aW9ufSBmcm9tICcuLi90aWxldXJsZnVuY3Rpb24uanMnO1xuaW1wb3J0IFRpbGVTb3VyY2UsIHtUaWxlU291cmNlRXZlbnR9IGZyb20gJy4uL3NvdXJjZS9UaWxlLmpzJztcbmltcG9ydCBUaWxlRXZlbnRUeXBlIGZyb20gJy4uL3NvdXJjZS9UaWxlRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0S2V5WlhZfSBmcm9tICcuLi90aWxlY29vcmQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemVdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlXVxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvU3RhdGV9IFtzdGF0ZV1cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFt0aWxlVXJsRnVuY3Rpb25dXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VybF1cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz59IFt1cmxzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgdGlsZXMgZGl2aWRlZCBpbnRvIGEgdGlsZSBncmlkIG92ZXIgaHR0cC5cbiAqXG4gKiBAZmlyZXMgbW9kdWxlOm9sL3NvdXJjZS9UaWxlRXZlbnRcbiAqL1xudmFyIFVybFRpbGUgPSAoZnVuY3Rpb24gKFRpbGVTb3VyY2UpIHtcbiAgZnVuY3Rpb24gVXJsVGlsZShvcHRpb25zKSB7XG5cbiAgICBUaWxlU291cmNlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBleHRlbnQ6IG9wdGlvbnMuZXh0ZW50LFxuICAgICAgb3BhcXVlOiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgdGlsZUdyaWQ6IG9wdGlvbnMudGlsZUdyaWQsXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24gPSBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbiA/XG4gICAgICB0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uLmJpbmQodGhpcykgOiBudWxsVGlsZVVybEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHshQXJyYXkuPHN0cmluZz58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVybHMgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMudXJscykge1xuICAgICAgdGhpcy5zZXRVcmxzKG9wdGlvbnMudXJscyk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxudW1iZXIsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRpbmdLZXlzXyA9IHt9O1xuXG4gIH1cblxuICBpZiAoIFRpbGVTb3VyY2UgKSBVcmxUaWxlLl9fcHJvdG9fXyA9IFRpbGVTb3VyY2U7XG4gIFVybFRpbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGlsZVNvdXJjZSAmJiBUaWxlU291cmNlLnByb3RvdHlwZSApO1xuICBVcmxUaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVybFRpbGU7XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbn0gVGlsZUxvYWRGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5nZXRUaWxlTG9hZEZ1bmN0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUxvYWRGdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZUxvYWRGdW5jdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aWxlIFVSTCBmdW5jdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gVGlsZVVybEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIFVybFRpbGUucHJvdG90eXBlLmdldFRpbGVVcmxGdW5jdGlvbiA9IGZ1bmN0aW9uIGdldFRpbGVVcmxGdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVVybEZ1bmN0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFVSTHMgdXNlZCBmb3IgdGhpcyBzb3VyY2UuXG4gICAqIFdoZW4gYSB0aWxlVXJsRnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIHVybCBvciB1cmxzLFxuICAgKiBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4geyFBcnJheS48c3RyaW5nPnxudWxsfSBVUkxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5nZXRVcmxzID0gZnVuY3Rpb24gZ2V0VXJscyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJscztcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRpbGUgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuaGFuZGxlVGlsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRpbGVDaGFuZ2UgKGV2ZW50KSB7XG4gICAgdmFyIHRpbGUgPSAvKiogQHR5cGUge21vZHVsZTpvbC9UaWxlfSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICB2YXIgdWlkID0gZ2V0VWlkKHRpbGUpO1xuICAgIHZhciB0aWxlU3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgdmFyIHR5cGU7XG4gICAgaWYgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy50aWxlTG9hZGluZ0tleXNfW3VpZF0gPSB0cnVlO1xuICAgICAgdHlwZSA9IFRpbGVFdmVudFR5cGUuVElMRUxPQURTVEFSVDtcbiAgICB9IGVsc2UgaWYgKHVpZCBpbiB0aGlzLnRpbGVMb2FkaW5nS2V5c18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXTtcbiAgICAgIHR5cGUgPSB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVSUk9SIDpcbiAgICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuQUJPUlQpID9cbiAgICAgICAgICBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERU5EIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVGlsZVNvdXJjZUV2ZW50KHR5cGUsIHRpbGUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGlsZSBsb2FkIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uIFRpbGUgbG9hZCBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuc2V0VGlsZUxvYWRGdW5jdGlvbiA9IGZ1bmN0aW9uIHNldFRpbGVMb2FkRnVuY3Rpb24gKHRpbGVMb2FkRnVuY3Rpb24pIHtcbiAgICB0aGlzLnRpbGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMudGlsZUxvYWRGdW5jdGlvbiA9IHRpbGVMb2FkRnVuY3Rpb247XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gdGlsZVVybEZ1bmN0aW9uIFRpbGUgVVJMIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9rZXkgT3B0aW9uYWwgbmV3IHRpbGUga2V5IGZvciB0aGUgc291cmNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5zZXRUaWxlVXJsRnVuY3Rpb24gPSBmdW5jdGlvbiBzZXRUaWxlVXJsRnVuY3Rpb24gKHRpbGVVcmxGdW5jdGlvbiwgb3B0X2tleSkge1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICAgIHRoaXMudGlsZUNhY2hlLnBydW5lRXhjZXB0TmV3ZXN0WigpO1xuICAgIGlmICh0eXBlb2Ygb3B0X2tleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc2V0S2V5KG9wdF9rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS5zZXRVcmwgPSBmdW5jdGlvbiBzZXRVcmwgKHVybCkge1xuICAgIHZhciB1cmxzID0gdGhpcy51cmxzID0gZXhwYW5kVXJsKHVybCk7XG4gICAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24odGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbiA/XG4gICAgICB0aGlzLmZpeGVkVGlsZVVybEZ1bmN0aW9uLmJpbmQodGhpcykgOlxuICAgICAgY3JlYXRlRnJvbVRlbXBsYXRlcyh1cmxzLCB0aGlzLnRpbGVHcmlkKSwgdXJsKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBVUkxzIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHVybHMgVVJMcy5cbiAgICogQGFwaVxuICAgKi9cbiAgVXJsVGlsZS5wcm90b3R5cGUuc2V0VXJscyA9IGZ1bmN0aW9uIHNldFVybHMgKHVybHMpIHtcbiAgICB0aGlzLnVybHMgPSB1cmxzO1xuICAgIHZhciBrZXkgPSB1cmxzLmpvaW4oJ1xcbicpO1xuICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKHRoaXMuZml4ZWRUaWxlVXJsRnVuY3Rpb24gP1xuICAgICAgdGhpcy5maXhlZFRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpIDpcbiAgICAgIGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIGtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBVcmxUaWxlLnByb3RvdHlwZS51c2VUaWxlID0gZnVuY3Rpb24gdXNlVGlsZSAoeiwgeCwgeSkge1xuICAgIHZhciB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVXJsVGlsZTtcbn0oVGlsZVNvdXJjZSkpO1xuXG5cbi8qKlxuICogQHR5cGUge21vZHVsZTpvbC9UaWxlflVybEZ1bmN0aW9ufHVuZGVmaW5lZH1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVXJsVGlsZS5wcm90b3R5cGUuZml4ZWRUaWxlVXJsRnVuY3Rpb247XG5cbmV4cG9ydCBkZWZhdWx0IFVybFRpbGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVybFRpbGUuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9WZWN0b3JcbiAqL1xuXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbiBmcm9tICcuLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uRXZlbnRUeXBlIGZyb20gJy4uL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IE9iamVjdEV2ZW50VHlwZSBmcm9tICcuLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtjb250YWluc0V4dGVudCwgZXF1YWxzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHt4aHJ9IGZyb20gJy4uL2ZlYXR1cmVsb2FkZXIuanMnO1xuaW1wb3J0IHtUUlVFLCBVTkRFRklORUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge2FsbCBhcyBhbGxTdHJhdGVneX0gZnJvbSAnLi4vbG9hZGluZ3N0cmF0ZWd5LmpzJztcbmltcG9ydCB7aXNFbXB0eSwgZ2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFNvdXJjZSBmcm9tICcuLi9zb3VyY2UvU291cmNlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuLi9zb3VyY2UvU3RhdGUuanMnO1xuaW1wb3J0IFZlY3RvckV2ZW50VHlwZSBmcm9tICcuLi9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzJztcbmltcG9ydCBSQnVzaCBmcm9tICcuLi9zdHJ1Y3RzL1JCdXNoLmpzJztcblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBhbmQgYSByZXNvbHV0aW9uIGFzIGFyZ3VtZW50cywgYW5kXG4gKiByZXR1cm5zIGFuIGFycmF5IG9mIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gd2l0aCB0aGUgZXh0ZW50cyB0byBsb2FkLiBVc3VhbGx5IHRoaXNcbiAqIGlzIG9uZSBvZiB0aGUgc3RhbmRhcmQge0BsaW5rIG1vZHVsZTpvbC9sb2FkaW5nc3RyYXRlZ3l9IHN0cmF0ZWdpZXMuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50LCBudW1iZXIpOiBBcnJheS48bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ+fSBMb2FkaW5nU3RyYXRlZ3lcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYnkge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICovXG5leHBvcnQgdmFyIFZlY3RvclNvdXJjZUV2ZW50ID0gKGZ1bmN0aW9uIChFdmVudCkge1xuICBmdW5jdGlvbiBWZWN0b3JTb3VyY2VFdmVudCh0eXBlLCBvcHRfZmVhdHVyZSkge1xuXG4gICAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmZWF0dXJlIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9GZWF0dXJlfHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlID0gb3B0X2ZlYXR1cmU7XG5cbiAgfVxuXG4gIGlmICggRXZlbnQgKSBWZWN0b3JTb3VyY2VFdmVudC5fX3Byb3RvX18gPSBFdmVudDtcbiAgVmVjdG9yU291cmNlRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnQgJiYgRXZlbnQucHJvdG90eXBlICk7XG4gIFZlY3RvclNvdXJjZUV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlY3RvclNvdXJjZUV2ZW50O1xuXG4gIHJldHVybiBWZWN0b3JTb3VyY2VFdmVudDtcbn0oRXZlbnQpKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT58bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn0gW2ZlYXR1cmVzXVxuICogRmVhdHVyZXMuIElmIHByb3ZpZGVkIGFzIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0sIHRoZSBmZWF0dXJlcyBpbiB0aGUgc291cmNlXG4gKiBhbmQgdGhlIGNvbGxlY3Rpb24gd2lsbCBzdGF5IGluIHN5bmMuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9mb3JtYXQvRmVhdHVyZX0gW2Zvcm1hdF0gVGhlIGZlYXR1cmUgZm9ybWF0IHVzZWQgYnkgdGhlIFhIUlxuICogZmVhdHVyZSBsb2FkZXIgd2hlbiBgdXJsYCBpcyBzZXQuIFJlcXVpcmVkIGlmIGB1cmxgIGlzIHNldCwgb3RoZXJ3aXNlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVMb2FkZXJ9IFtsb2FkZXJdXG4gKiBUaGUgbG9hZGVyIGZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBmZWF0dXJlcywgZnJvbSBhIHJlbW90ZSBzb3VyY2UgZm9yIGV4YW1wbGUuXG4gKiBJZiB0aGlzIGlzIG5vdCBzZXQgYW5kIGB1cmxgIGlzIHNldCwgdGhlIHNvdXJjZSB3aWxsIGNyZWF0ZSBhbmQgdXNlIGFuIFhIUlxuICogZmVhdHVyZSBsb2FkZXIuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtWZWN0b3J9IGZyb20gJ29sL3NvdXJjZSc7XG4gKiBpbXBvcnQge0dlb0pTT059IGZyb20gJ29sL2Zvcm1hdCc7XG4gKiBpbXBvcnQge2Jib3h9IGZyb20gJ29sL2xvYWRpbmdzdHJhdGVneSc7XG4gKlxuICogdmFyIHZlY3RvclNvdXJjZSA9IG5ldyBWZWN0b3Ioe1xuICogICBmb3JtYXQ6IG5ldyBHZW9KU09OKCksXG4gKiAgIGxvYWRlcjogZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gKiAgICAgIHZhciBwcm9qID0gcHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gKiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9haG9jZXZhci5jb20vZ2Vvc2VydmVyL3dmcz9zZXJ2aWNlPVdGUyYnICtcbiAqICAgICAgICAgICd2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT1vc206d2F0ZXJfYXJlYXMmJyArXG4gKiAgICAgICAgICAnb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24mc3JzbmFtZT0nICsgcHJvaiArICcmJyArXG4gKiAgICAgICAgICAnYmJveD0nICsgZXh0ZW50LmpvaW4oJywnKSArICcsJyArIHByb2o7XG4gKiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAqICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gKiAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgdmVjdG9yU291cmNlLnJlbW92ZUxvYWRlZEV4dGVudChleHRlbnQpO1xuICogICAgICB9XG4gKiAgICAgIHhoci5vbmVycm9yID0gb25FcnJvcjtcbiAqICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCkge1xuICogICAgICAgICAgdmVjdG9yU291cmNlLmFkZEZlYXR1cmVzKFxuICogICAgICAgICAgICAgIHZlY3RvclNvdXJjZS5nZXRGb3JtYXQoKS5yZWFkRmVhdHVyZXMoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBvbkVycm9yKCk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICAgIHhoci5zZW5kKCk7XG4gKiAgICB9LFxuICogICAgc3RyYXRlZ3k6IGJib3hcbiAqICB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmxhcHM9dHJ1ZV0gVGhpcyBzb3VyY2UgbWF5IGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAqIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIChlLmcuIGZvciBzb3VyY2VzIHdpdGggcG9seWdvbnMgdGhhdCByZXByZXNlbnQgYWRtaW5pc3RyYXRpdmVcbiAqIGJvdW5kYXJpZXMgb3IgVG9wb0pTT04gc291cmNlcykgYWxsb3dzIHRoZSByZW5kZXJlciB0byBvcHRpbWlzZSBmaWxsIGFuZFxuICogc3Ryb2tlIG9wZXJhdGlvbnMuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfkxvYWRpbmdTdHJhdGVneX0gW3N0cmF0ZWd5XSBUaGUgbG9hZGluZyBzdHJhdGVneSB0byB1c2UuXG4gKiBCeSBkZWZhdWx0IGFuIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fmFsbH1cbiAqIHN0cmF0ZWd5IGlzIHVzZWQsIGEgb25lLW9mZiBzdHJhdGVneSB3aGljaCBsb2FkcyBhbGwgZmVhdHVyZXMgYXQgb25jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxmdW5jdGlvbn0gW3VybF1cbiAqIFNldHRpbmcgdGhpcyBvcHRpb24gaW5zdHJ1Y3RzIHRoZSBzb3VyY2UgdG8gbG9hZCBmZWF0dXJlcyB1c2luZyBhbiBYSFIgbG9hZGVyXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn54aHJ9KS4gVXNlIGEgYHN0cmluZ2AgYW5kIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xvYWRpbmdzdHJhdGVneX5hbGx9IGZvciBhIG9uZS1vZmYgZG93bmxvYWQgb2YgYWxsIGZlYXR1cmVzIGZyb21cbiAqIHRoZSBnaXZlbiBVUkwuIFVzZSBhIHtAbGluayBtb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlVXJsZnVuY3Rpb259IHRvIGdlbmVyYXRlIHRoZSB1cmwgd2l0aFxuICogb3RoZXIgbG9hZGluZyBzdHJhdGVnaWVzLlxuICogUmVxdWlyZXMgYGZvcm1hdGAgdG8gYmUgc2V0IGFzIHdlbGwuXG4gKiBXaGVuIGRlZmF1bHQgWEhSIGZlYXR1cmUgbG9hZGVyIGlzIHByb3ZpZGVkLCB0aGUgZmVhdHVyZXMgd2lsbFxuICogYmUgdHJhbnNmb3JtZWQgZnJvbSB0aGUgZGF0YSBwcm9qZWN0aW9uIHRvIHRoZSB2aWV3IHByb2plY3Rpb25cbiAqIGR1cmluZyBwYXJzaW5nLiBJZiB5b3VyIHJlbW90ZSBkYXRhIHNvdXJjZSBkb2VzIG5vdCBhZHZlcnRpc2UgaXRzIHByb2plY3Rpb25cbiAqIHByb3Blcmx5LCB0aGlzIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgaW5jb3JyZWN0LiBGb3Igc29tZSBmb3JtYXRzLCB0aGVcbiAqIGRlZmF1bHQgcHJvamVjdGlvbiAodXN1YWxseSBFUFNHOjQzMjYpIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgdGhlXG4gKiBkYXRhUHJvamVjdGlvbiBjb25zdHJ1Y3RvciBvcHRpb24gb24gdGhlIGZvcm1hdC5cbiAqIE5vdGUgdGhhdCBpZiBhIHNvdXJjZSBjb250YWlucyBub24tZmVhdHVyZSBkYXRhLCBzdWNoIGFzIGEgR2VvSlNPTiBnZW9tZXRyeVxuICogb3IgYSBLTUwgTmV0d29ya0xpbmssIHRoZXNlIHdpbGwgYmUgaWdub3JlZC4gVXNlIGEgY3VzdG9tIGxvYWRlciB0byBsb2FkIHRoZXNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlU3BhdGlhbEluZGV4PXRydWVdXG4gKiBCeSBkZWZhdWx0LCBhbiBSVHJlZSBpcyB1c2VkIGFzIHNwYXRpYWwgaW5kZXguIFdoZW4gZmVhdHVyZXMgYXJlIHJlbW92ZWQgYW5kXG4gKiBhZGRlZCBmcmVxdWVudGx5LCBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBmZWF0dXJlcyBpcyBsb3csIHNldHRpbmcgdGhpcyB0b1xuICogYGZhbHNlYCBtYXkgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqXG4gKiBOb3RlIHRoYXRcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RmVhdHVyZXNJbkV4dGVudH0sXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldENsb3Nlc3RGZWF0dXJlVG9Db29yZGluYXRlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RXh0ZW50fSBjYW5ub3QgYmUgdXNlZCB3aGVuIGB1c2VTcGF0aWFsSW5kZXhgIGlzXG4gKiBzZXQgdG8gYGZhbHNlYCwgYW5kIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmVJbkV4dGVudH0gd2lsbCBsb29wXG4gKiB0aHJvdWdoIGFsbCBmZWF0dXJlcy5cbiAqXG4gKiBXaGVuIHNldCB0byBgZmFsc2VgLCB0aGUgZmVhdHVyZXMgd2lsbCBiZSBtYWludGFpbmVkIGluIGFuXG4gKiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb259LCB3aGljaCBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2hcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0RmVhdHVyZXNDb2xsZWN0aW9ufS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS4gRm9yIHZlY3RvciBlZGl0aW5nIGFjcm9zcyB0aGVcbiAqIC0xODDCsCBhbmQgMTgwwrAgbWVyaWRpYW5zIHRvIHdvcmsgcHJvcGVybHksIHRoaXMgc2hvdWxkIGJlIHNldCB0byBgZmFsc2VgLiBUaGVcbiAqIHJlc3VsdGluZyBnZW9tZXRyeSBjb29yZGluYXRlcyB3aWxsIHRoZW4gZXhjZWVkIHRoZSB3b3JsZCBib3VuZHMuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFByb3ZpZGVzIGEgc291cmNlIG9mIGZlYXR1cmVzIGZvciB2ZWN0b3IgbGF5ZXJzLiBWZWN0b3IgZmVhdHVyZXMgcHJvdmlkZWRcbiAqIGJ5IHRoaXMgc291cmNlIGFyZSBzdWl0YWJsZSBmb3IgZWRpdGluZy4gU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3RvclRpbGV+VmVjdG9yVGlsZX0gZm9yXG4gKiB2ZWN0b3IgZGF0YSB0aGF0IGlzIG9wdGltaXplZCBmb3IgcmVuZGVyaW5nLlxuICpcbiAqIEBmaXJlcyBvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZUV2ZW50XG4gKiBAYXBpXG4gKi9cbnZhciBWZWN0b3JTb3VyY2UgPSAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICBmdW5jdGlvbiBWZWN0b3JTb3VyY2Uob3B0X29wdGlvbnMpIHtcblxuICAgIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICBTb3VyY2UuY2FsbCh0aGlzLCB7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgcHJvamVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IFNvdXJjZVN0YXRlLlJFQURZLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlTG9hZGVyfVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVyXyA9IFVOREVGSU5FRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9mb3JtYXQvRmVhdHVyZXx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5mb3JtYXRfID0gb3B0aW9ucy5mb3JtYXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHNfID0gb3B0aW9ucy5vdmVybGFwcyA9PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5vdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3xtb2R1bGU6b2wvZmVhdHVyZWxvYWRlcn5GZWF0dXJlVXJsRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudXJsXyA9IG9wdGlvbnMudXJsO1xuXG4gICAgaWYgKG9wdGlvbnMubG9hZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9hZGVyXyA9IG9wdGlvbnMubG9hZGVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cmxfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydCh0aGlzLmZvcm1hdF8sIDcpOyAvLyBgZm9ybWF0YCBtdXN0IGJlIHNldCB3aGVuIGB1cmxgIGlzIHNldFxuICAgICAgLy8gY3JlYXRlIGEgWEhSIGZlYXR1cmUgbG9hZGVyIGZvciBcInVybFwiIGFuZCBcImZvcm1hdFwiXG4gICAgICB0aGlzLmxvYWRlcl8gPSB4aHIodGhpcy51cmxfLCAvKiogQHR5cGUge21vZHVsZTpvbC9mb3JtYXQvRmVhdHVyZX0gKi8gKHRoaXMuZm9ybWF0XykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfkxvYWRpbmdTdHJhdGVneX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cmF0ZWd5XyA9IG9wdGlvbnMuc3RyYXRlZ3kgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RyYXRlZ3kgOiBhbGxTdHJhdGVneTtcblxuICAgIHZhciB1c2VTcGF0aWFsSW5kZXggPVxuICAgICAgICBvcHRpb25zLnVzZVNwYXRpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvUkJ1c2guPG1vZHVsZTpvbC9GZWF0dXJlPn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfID0gdXNlU3BhdGlhbEluZGV4ID8gbmV3IFJCdXNoKCkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvUkJ1c2guPHtleHRlbnQ6IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fT59XG4gICAgICovXG4gICAgdGhpcy5sb2FkZWRFeHRlbnRzUnRyZWVfID0gbmV3IFJCdXNoKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9GZWF0dXJlPn1cbiAgICAgKi9cbiAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBsb29rdXAgb2YgZmVhdHVyZXMgYnkgaWQgKHRoZSByZXR1cm4gZnJvbSBmZWF0dXJlLmdldElkKCkpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL0ZlYXR1cmU+fVxuICAgICAqL1xuICAgIHRoaXMuaWRJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIGZlYXR1cmVzIHdpdGhvdXQgaWQgKGtleWVkIGJ5IGdldFVpZChmZWF0dXJlKSkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCBtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICovXG4gICAgdGhpcy51bmRlZklkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgQXJyYXkuPG1vZHVsZTpvbC9ldmVudHN+RXZlbnRzS2V5Pj59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9Db2xsZWN0aW9uLjxtb2R1bGU6b2wvRmVhdHVyZT59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gbnVsbDtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBmZWF0dXJlcztcbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlcyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgICAgZmVhdHVyZXMgPSBjb2xsZWN0aW9uLmdldEFycmF5KCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZmVhdHVyZXMpKSB7XG4gICAgICBmZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgfVxuICAgIGlmICghdXNlU3BhdGlhbEluZGV4ICYmIGNvbGxlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcyk7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuYmluZEZlYXR1cmVzQ29sbGVjdGlvbl8oY29sbGVjdGlvbik7XG4gICAgfVxuXG4gIH1cblxuICBpZiAoIFNvdXJjZSApIFZlY3RvclNvdXJjZS5fX3Byb3RvX18gPSBTb3VyY2U7XG4gIFZlY3RvclNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTb3VyY2UgJiYgU291cmNlLnByb3RvdHlwZSApO1xuICBWZWN0b3JTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmVjdG9yU291cmNlO1xuXG4gIHJldHVybiBWZWN0b3JTb3VyY2U7XG59KFNvdXJjZSkpO1xuXG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIGZlYXR1cmUgdG8gdGhlIHNvdXJjZS4gIElmIHlvdSB3YW50IHRvIGFkZCBhIGJhdGNoIG9mIGZlYXR1cmVzXG4gKiBhdCBvbmNlLCBjYWxsIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjYWRkRmVhdHVyZXMgI2FkZEZlYXR1cmVzKCl9XG4gKiBpbnN0ZWFkLiBBIGZlYXR1cmUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHNvdXJjZSBpZiBmZWF0dXJlIHdpdGhcbiAqIHRoZSBzYW1lIGlkIGlzIGFscmVhZHkgdGhlcmUuIFRoZSByZWFzb24gZm9yIHRoaXMgYmVoYXZpb3IgaXMgdG8gYXZvaWRcbiAqIGZlYXR1cmUgZHVwbGljYXRpb24gd2hlbiB1c2luZyBiYm94IG9yIHRpbGUgbG9hZGluZyBzdHJhdGVnaWVzLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlIHRvIGFkZC5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICB0aGlzLmFkZEZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogQWRkIGEgZmVhdHVyZSB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHByb3RlY3RlZFxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmFkZEZlYXR1cmVJbnRlcm5hbCA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdmFyIGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSkudG9TdHJpbmcoKTtcblxuICBpZiAoIXRoaXMuYWRkVG9JbmRleF8oZmVhdHVyZUtleSwgZmVhdHVyZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnNldHVwQ2hhbmdlRXZlbnRzXyhmZWF0dXJlS2V5LCBmZWF0dXJlKTtcblxuICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gIGlmIChnZW9tZXRyeSkge1xuICAgIHZhciBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pbnNlcnQoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgIG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSwgZmVhdHVyZSkpO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLnNldHVwQ2hhbmdlRXZlbnRzXyA9IGZ1bmN0aW9uKGZlYXR1cmVLZXksIGZlYXR1cmUpIHtcbiAgdGhpcy5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUtleV0gPSBbXG4gICAgbGlzdGVuKGZlYXR1cmUsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKSxcbiAgICBsaXN0ZW4oZmVhdHVyZSwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgdGhpcy5oYW5kbGVGZWF0dXJlQ2hhbmdlXywgdGhpcylcbiAgXTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUtleSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9GZWF0dXJlfSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGZlYXR1cmUgaXMgXCJ2YWxpZFwiLCBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBpcyBhbHNvIGFcbiAqICAgICBjYW5kaWRhdGUgZm9yIGluc2VydGlvbiBpbnRvIHRoZSBSdHJlZS5cbiAqIEBwcml2YXRlXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuYWRkVG9JbmRleF8gPSBmdW5jdGlvbihmZWF0dXJlS2V5LCBmZWF0dXJlKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIShpZC50b1N0cmluZygpIGluIHRoaXMuaWRJbmRleF8pKSB7XG4gICAgICB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldID0gZmVhdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KCEoZmVhdHVyZUtleSBpbiB0aGlzLnVuZGVmSWRJbmRleF8pLFxuICAgICAgMzApOyAvLyBUaGUgcGFzc2VkIGBmZWF0dXJlYCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgc291cmNlXG4gICAgdGhpcy51bmRlZklkSW5kZXhfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59O1xuXG5cbi8qKlxuICogQWRkIGEgYmF0Y2ggb2YgZmVhdHVyZXMgdG8gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gZmVhdHVyZXMgRmVhdHVyZXMgdG8gYWRkLlxuICogQGFwaVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogQWRkIGZlYXR1cmVzIHdpdGhvdXQgZmlyaW5nIGEgYGNoYW5nZWAgZXZlbnQuXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICogQHByb3RlY3RlZFxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmFkZEZlYXR1cmVzSW50ZXJuYWwgPSBmdW5jdGlvbihmZWF0dXJlcykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZXh0ZW50cyA9IFtdO1xuICB2YXIgbmV3RmVhdHVyZXMgPSBbXTtcbiAgdmFyIGdlb21ldHJ5RmVhdHVyZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMkMS5hZGRUb0luZGV4XyhmZWF0dXJlS2V5LCBmZWF0dXJlKSkge1xuICAgICAgbmV3RmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpJDEgPSAwLCBsZW5ndGgkMSA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSQxIDwgbGVuZ3RoJDE7IGkkMSsrKSB7XG4gICAgdmFyIGZlYXR1cmUkMSA9IG5ld0ZlYXR1cmVzW2kkMV07XG4gICAgdmFyIGZlYXR1cmVLZXkkMSA9IGdldFVpZChmZWF0dXJlJDEpLnRvU3RyaW5nKCk7XG4gICAgdGhpcyQxLnNldHVwQ2hhbmdlRXZlbnRzXyhmZWF0dXJlS2V5JDEsIGZlYXR1cmUkMSk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlJDEuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIHZhciBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGV4dGVudHMucHVzaChleHRlbnQpO1xuICAgICAgZ2VvbWV0cnlGZWF0dXJlcy5wdXNoKGZlYXR1cmUkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMkMS5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleSQxXSA9IGZlYXR1cmUkMTtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmxvYWQoZXh0ZW50cywgZ2VvbWV0cnlGZWF0dXJlcyk7XG4gIH1cblxuICBmb3IgKHZhciBpJDIgPSAwLCBsZW5ndGgkMiA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSQyIDwgbGVuZ3RoJDI7IGkkMisrKSB7XG4gICAgdGhpcyQxLmRpc3BhdGNoRXZlbnQobmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLCBuZXdGZWF0dXJlc1tpJDJdKSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvQ29sbGVjdGlvbi48bW9kdWxlOm9sL0ZlYXR1cmU+fSBjb2xsZWN0aW9uIENvbGxlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmJpbmRGZWF0dXJlc0NvbGxlY3Rpb25fID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICB2YXIgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICBsaXN0ZW4odGhpcywgVmVjdG9yRXZlbnRUeXBlLkFEREZFQVRVUkUsXG4gICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbGxlY3Rpb24ucHVzaChldnQuZmVhdHVyZSk7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgbGlzdGVuKHRoaXMsIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb2xsZWN0aW9uLnJlbW92ZShldnQuZmVhdHVyZSk7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgbGlzdGVuKGNvbGxlY3Rpb24sIENvbGxlY3Rpb25FdmVudFR5cGUuQURELFxuICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgbGlzdGVuKGNvbGxlY3Rpb24sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFtb2RpZnlpbmdDb2xsZWN0aW9uKSB7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbW92ZUZlYXR1cmUoLyoqIEB0eXBlIHttb2R1bGU6b2wvRmVhdHVyZX0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gY29sbGVjdGlvbjtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGZlYXR1cmVzIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9mYXN0IFNraXAgZGlzcGF0Y2hpbmcgb2Yge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmV9IGV2ZW50cy5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKG9wdF9mYXN0KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChvcHRfZmFzdCkge1xuICAgIGZvciAodmFyIGZlYXR1cmVJZCBpbiB0aGlzJDEuZmVhdHVyZUNoYW5nZUtleXNfKSB7XG4gICAgICB2YXIga2V5cyA9IHRoaXMkMS5mZWF0dXJlQ2hhbmdlS2V5c19bZmVhdHVyZUlkXTtcbiAgICAgIGtleXMuZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfID0ge307XG4gICAgICB0aGlzLmlkSW5kZXhfID0ge307XG4gICAgICB0aGlzLnVuZGVmSWRJbmRleF8gPSB7fTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uZm9yRWFjaCh0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbCwgdGhpcyk7XG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzJDEubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgIHRoaXMkMS5yZW1vdmVGZWF0dXJlSW50ZXJuYWwodGhpcyQxLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tpZF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmNsZWFyKCk7XG4gIH1cblxuICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8uY2xlYXIoKTtcbiAgfVxuICB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV8uY2xlYXIoKTtcbiAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICB2YXIgY2xlYXJFdmVudCA9IG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQ0xFQVIpO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoY2xlYXJFdmVudCk7XG4gIHRoaXMuY2hhbmdlZCgpO1xufTtcblxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgb24gdGhlIHNvdXJjZSwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAqIHdpdGggZWFjaCBvbmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhbnkgXCJ0cnV0aHlcIiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGxcbiAqIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gb25seSBpdGVyYXRlIHRocm91Z2ggdGhlIGZlYXR1cmUgdGhhdCBoYXZlIGEgZGVmaW5lZCBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9GZWF0dXJlKTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gKiAgICAgb24gdGhlIHNvdXJjZS4gIFJldHVybiBhIHRydXRoeSB2YWx1ZSB0byBzdG9wIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gKiBAdGVtcGxhdGUgVFxuICogQGFwaVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmZvckVhY2hGZWF0dXJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmZvckVhY2goY2FsbGJhY2spO1xuICB9XG59O1xuXG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGNvbnRhaW4gdGhlIHByb3ZpZGVkXG4gKiBjb29yZGluYXRlLCBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gKiBhIFwidHJ1dGh5XCIgdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogdmFsdWUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG1vZHVsZTpvbC9GZWF0dXJlKTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gKiAgICAgd2hvc2UgZ29lbWV0cnkgY29udGFpbnMgdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZURpcmVjdCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBleHRlbnQgPSBbY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXV07XG4gIHJldHVybiB0aGlzLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeS5pbnRlcnNlY3RzQ29vcmRpbmF0ZShjb29yZGluYXRlKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGZlYXR1cmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWRcbiAqIGV4dGVudCAobm90ZSB0aGF0IHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkgbWF5IG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVudCksXG4gKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICogdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqXG4gKiBJZiB5b3UgYXJlIGludGVyZXN0ZWQgaW4gZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyBhbiBleHRlbnQsIGNhbGxcbiAqIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAqXG4gKiBXaGVuIGB1c2VTcGF0aWFsSW5kZXhgIGlzIHNldCB0byBmYWxzZSwgdGhpcyBtZXRob2Qgd2lsbCBsb29wIHRocm91Z2ggYWxsXG4gKiBmZWF0dXJlcywgZXF1aXZhbGVudCB0byB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlICNmb3JFYWNoRmVhdHVyZSgpfS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvRmVhdHVyZSk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICogICAgIHdob3NlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRcbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUluRXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBjYWxsYmFjaykge1xuICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8pIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmZvckVhY2goY2FsbGJhY2spO1xuICB9XG59O1xuXG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQsXG4gKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICogdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqXG4gKiBJZiB5b3Ugb25seSB3YW50IHRvIHRlc3QgZm9yIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb24sIGNhbGwgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW5FeHRlbnQgI2ZvckVhY2hGZWF0dXJlSW5FeHRlbnQoKX0gbWV0aG9kIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL0ZlYXR1cmUpOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAqICAgICB3aG9zZSBnZW9tZXRyeSBpbnRlcnNlY3RzIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFRcbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5mb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKi9cbiAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gICAgICBpZiAoZ2VvbWV0cnkuaW50ZXJzZWN0c0V4dGVudChleHRlbnQpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGZlYXR1cmVzIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLiBXaWxsIGJlIGBudWxsYFxuICogdW5sZXNzIHRoZSBzb3VyY2Ugd2FzIGNvbmZpZ3VyZWQgd2l0aCBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYCwgb3JcbiAqIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufSBhcyBgZmVhdHVyZXNgLlxuICogQHJldHVybiB7bW9kdWxlOm9sL0NvbGxlY3Rpb24uPG1vZHVsZTpvbC9GZWF0dXJlPn0gVGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXNDb2xsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl87XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBmZWF0dXJlcyBvbiB0aGUgc291cmNlIGluIHJhbmRvbSBvcmRlci5cbiAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6b2wvRmVhdHVyZT59IEZlYXR1cmVzLlxuICogQGFwaVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmZWF0dXJlcztcbiAgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmdldEFycmF5KCk7XG4gIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRBbGwoKTtcbiAgICBpZiAoIWlzRW1wdHkodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKSB7XG4gICAgICBleHRlbmQoZmVhdHVyZXMsIGdldFZhbHVlcyh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gKi8gKGZlYXR1cmVzKVxuICApO1xufTtcblxuXG4vKipcbiAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTpvbC9GZWF0dXJlPn0gRmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RmVhdHVyZXNBdENvb3JkaW5hdGUgPSBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gIHZhciBmZWF0dXJlcyA9IFtdO1xuICB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlRGlyZWN0KGNvb3JkaW5hdGUsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICBmZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICB9KTtcbiAgcmV0dXJuIGZlYXR1cmVzO1xufTtcblxuXG4vKipcbiAqIEdldCBhbGwgZmVhdHVyZXMgaW4gdGhlIHByb3ZpZGVkIGV4dGVudC4gIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAqIGFsbCBmZWF0dXJlcyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIGV4dGVudCBpbiByYW5kb20gb3JkZXIgKHNvIGl0IG1heSBpbmNsdWRlXG4gKiBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGRvIG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVudCkuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL0ZlYXR1cmU+fSBGZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlc0luRXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50KSB7XG4gIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEluRXh0ZW50KGV4dGVudCk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjbG9zZXN0IGZlYXR1cmUgdG8gdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGUuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtmdW5jdGlvbihtb2R1bGU6b2wvRmVhdHVyZSk6Ym9vbGVhbj19IG9wdF9maWx0ZXIgRmVhdHVyZSBmaWx0ZXIgZnVuY3Rpb24uXG4gKiAgICAgVGhlIGZpbHRlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgb25lIGFyZ3VtZW50LCB0aGUge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlIGZlYXR1cmV9XG4gKiAgICAgYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLiBCeSBkZWZhdWx0LCBubyBmaWx0ZXJpbmcgaXMgbWFkZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9GZWF0dXJlfSBDbG9zZXN0IGZlYXR1cmUuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGUgPSBmdW5jdGlvbihjb29yZGluYXRlLCBvcHRfZmlsdGVyKSB7XG4gIC8vIEZpbmQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB1c2luZyBicmFuY2ggYW5kIGJvdW5kLiAgV2Ugc3RhcnQgc2VhcmNoaW5nIGFuXG4gIC8vIGluZmluaXRlIGV4dGVudCwgYW5kIGZpbmQgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGZpcnN0IGZlYXR1cmUgZm91bmQuICBUaGlzXG4gIC8vIGJlY29tZXMgdGhlIGNsb3Nlc3QgZmVhdHVyZS4gIFdlIHRoZW4gY29tcHV0ZSBhIHNtYWxsZXIgZXh0ZW50IHdoaWNoIGFueVxuICAvLyBjbG9zZXIgZmVhdHVyZSBtdXN0IGludGVyc2VjdC4gIFdlIGNvbnRpbnVlIHNlYXJjaGluZyB3aXRoIHRoaXMgc21hbGxlclxuICAvLyBleHRlbnQsIHRyeWluZyB0byBmaW5kIGEgY2xvc2VyIGZlYXR1cmUuICBFdmVyeSB0aW1lIHdlIGZpbmQgYSBjbG9zZXJcbiAgLy8gZmVhdHVyZSwgd2UgdXBkYXRlIHRoZSBleHRlbnQgYmVpbmcgc2VhcmNoZWQgc28gdGhhdCBhbnkgZXZlbiBjbG9zZXJcbiAgLy8gZmVhdHVyZSBtdXN0IGludGVyc2VjdCBpdC4gIFdlIGNvbnRpbnVlIHVudGlsIHdlIHJ1biBvdXQgb2YgZmVhdHVyZXMuXG4gIHZhciB4ID0gY29vcmRpbmF0ZVswXTtcbiAgdmFyIHkgPSBjb29yZGluYXRlWzFdO1xuICB2YXIgY2xvc2VzdEZlYXR1cmUgPSBudWxsO1xuICB2YXIgY2xvc2VzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgdmFyIG1pblNxdWFyZWREaXN0YW5jZSA9IEluZmluaXR5O1xuICB2YXIgZXh0ZW50ID0gWy1JbmZpbml0eSwgLUluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldO1xuICB2YXIgZmlsdGVyID0gb3B0X2ZpbHRlciA/IG9wdF9maWx0ZXIgOiBUUlVFO1xuICB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2hJbkV4dGVudChleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIGlmIChmaWx0ZXIoZmVhdHVyZSkpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICB2YXIgcHJldmlvdXNNaW5TcXVhcmVkRGlzdGFuY2UgPSBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGdlb21ldHJ5LmNsb3Nlc3RQb2ludFhZKFxuICAgICAgICAgIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IHByZXZpb3VzTWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgY2xvc2VzdEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgIC8vIFRoaXMgaXMgc25lYWt5LiAgUmVkdWNlIHRoZSBleHRlbnQgdGhhdCBpdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICAgICAgICAvLyBzZWFyY2hlZCB3aGlsZSB0aGUgUi1UcmVlIHRyYXZlcnNhbCB1c2luZyB0aGlzIHNhbWUgZXh0ZW50IG9iamVjdFxuICAgICAgICAgIC8vIGlzIHN0aWxsIGluIHByb2dyZXNzLiAgVGhpcyBpcyBzYWZlIGJlY2F1c2UgdGhlIG5ldyBleHRlbnQgaXNcbiAgICAgICAgICAvLyBzdHJpY3RseSBjb250YWluZWQgYnkgdGhlIG9sZCBleHRlbnQuXG4gICAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gTWF0aC5zcXJ0KG1pblNxdWFyZWREaXN0YW5jZSk7XG4gICAgICAgICAgZXh0ZW50WzBdID0geCAtIG1pbkRpc3RhbmNlO1xuICAgICAgICAgIGV4dGVudFsxXSA9IHkgLSBtaW5EaXN0YW5jZTtcbiAgICAgICAgICBleHRlbnRbMl0gPSB4ICsgbWluRGlzdGFuY2U7XG4gICAgICAgICAgZXh0ZW50WzNdID0geSArIG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBjbG9zZXN0RmVhdHVyZTtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZmVhdHVyZXMgY3VycmVudGx5IGluIHRoZSBzb3VyY2UuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gKiBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC4gSWYgcHJvdmlkZWQsIG5vIG5ldyBleHRlbnRcbiAqICAgICB3aWxsIGJlIGNyZWF0ZWQuIEluc3RlYWQsIHRoYXQgZXh0ZW50J3MgY29vcmRpbmF0ZXMgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24ob3B0X2V4dGVudCkge1xuICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRFeHRlbnQob3B0X2V4dGVudCk7XG59O1xuXG5cbi8qKlxuICogR2V0IGEgZmVhdHVyZSBieSBpdHMgaWRlbnRpZmllciAodGhlIHZhbHVlIHJldHVybmVkIGJ5IGZlYXR1cmUuZ2V0SWQoKSkuXG4gKiBOb3RlIHRoYXQgdGhlIGluZGV4IHRyZWF0cyBzdHJpbmcgYW5kIG51bWVyaWMgaWRlbnRpZmllcnMgYXMgdGhlIHNhbWUuICBTb1xuICogYHNvdXJjZS5nZXRGZWF0dXJlQnlJZCgyKWAgd2lsbCByZXR1cm4gYSBmZWF0dXJlIHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgRmVhdHVyZSBpZGVudGlmaWVyLlxuICogQHJldHVybiB7bW9kdWxlOm9sL0ZlYXR1cmV9IFRoZSBmZWF0dXJlIChvciBgbnVsbGAgaWYgbm90IGZvdW5kKS5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRGZWF0dXJlQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBmZWF0dXJlID0gdGhpcy5pZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgcmV0dXJuIGZlYXR1cmUgIT09IHVuZGVmaW5lZCA/IGZlYXR1cmUgOiBudWxsO1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgZm9ybWF0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS5cbiAqXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZm9ybWF0L0ZlYXR1cmV8dW5kZWZpbmVkfSBUaGUgZmVhdHVyZSBmb3JtYXQuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0Rm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZvcm1hdF87XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHNvdXJjZSBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmdldE92ZXJsYXBzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm92ZXJsYXBzXztcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBHZXQgdGhlIHVybCBhc3NvY2lhdGVkIHdpdGggdGhpcyBzb3VyY2UuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxGdW5jdGlvbnx1bmRlZmluZWR9IFRoZSB1cmwuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnVybF87XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXZlbnRzL0V2ZW50fSBldmVudCBFdmVudC5cbiAqIEBwcml2YXRlXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuaGFuZGxlRmVhdHVyZUNoYW5nZV8gPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgZmVhdHVyZSA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL0ZlYXR1cmV9ICovIChldmVudC50YXJnZXQpO1xuICB2YXIgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKS50b1N0cmluZygpO1xuICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gIGlmICghZ2VvbWV0cnkpIHtcbiAgICBpZiAoIShmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSkge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICBpZiAoZmVhdHVyZUtleSBpbiB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykge1xuICAgICAgZGVsZXRlIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfW2ZlYXR1cmVLZXldO1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5pbnNlcnQoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy51cGRhdGUoZXh0ZW50LCBmZWF0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzaWQgPSBpZC50b1N0cmluZygpO1xuICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMudW5kZWZJZEluZGV4Xykge1xuICAgICAgZGVsZXRlIHRoaXMudW5kZWZJZEluZGV4X1tmZWF0dXJlS2V5XTtcbiAgICAgIHRoaXMuaWRJbmRleF9bc2lkXSA9IGZlYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlkSW5kZXhfW3NpZF0gIT09IGZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSk7XG4gICAgICAgIHRoaXMuaWRJbmRleF9bc2lkXSA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghKGZlYXR1cmVLZXkgaW4gdGhpcy51bmRlZklkSW5kZXhfKSkge1xuICAgICAgdGhpcy5yZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSk7XG4gICAgICB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYW5nZWQoKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBWZWN0b3JTb3VyY2VFdmVudChcbiAgICBWZWN0b3JFdmVudFR5cGUuQ0hBTkdFRkVBVFVSRSwgZmVhdHVyZSkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZlYXR1cmUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGZlYXR1cmUuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUuaGFzRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdmFyIGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpZCBpbiB0aGlzLmlkSW5kZXhfO1xuICB9IGVsc2Uge1xuICAgIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGZlYXR1cmVLZXkgaW4gdGhpcy51bmRlZklkSW5kZXhfO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmVhdHVyZXNSdHJlZV8uaXNFbXB0eSgpICYmIGlzRW1wdHkodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUubG9hZEZlYXR1cmVzID0gZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gIHZhciBleHRlbnRzVG9Mb2FkID0gdGhpcy5zdHJhdGVneV8oZXh0ZW50LCByZXNvbHV0aW9uKTtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGksIGlpICkge1xuICAgIHZhciBleHRlbnRUb0xvYWQgPSBleHRlbnRzVG9Mb2FkW2ldO1xuICAgIHZhciBhbHJlYWR5TG9hZGVkID0gbG9hZGVkRXh0ZW50c1J0cmVlLmZvckVhY2hJbkV4dGVudChleHRlbnRUb0xvYWQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7e2V4dGVudDogbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9fSBvYmplY3QgT2JqZWN0LlxuICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gY29udGFpbnNFeHRlbnQob2JqZWN0LmV4dGVudCwgZXh0ZW50VG9Mb2FkKTtcbiAgICAgIH0pO1xuICAgIGlmICghYWxyZWFkeUxvYWRlZCkge1xuICAgICAgdGhpcyQxLmxvYWRlcl8uY2FsbCh0aGlzJDEsIGV4dGVudFRvTG9hZCwgcmVzb2x1dGlvbiwgcHJvamVjdGlvbik7XG4gICAgICBsb2FkZWRFeHRlbnRzUnRyZWUuaW5zZXJ0KGV4dGVudFRvTG9hZCwge2V4dGVudDogZXh0ZW50VG9Mb2FkLnNsaWNlKCl9KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gZXh0ZW50c1RvTG9hZC5sZW5ndGg7IGkgPCBpaTsgKytpKSBsb29wKCBpLCBpaSApO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbiBleHRlbnQgZnJvbSB0aGUgbGlzdCBvZiBsb2FkZWQgZXh0ZW50cy5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUucmVtb3ZlTG9hZGVkRXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50KSB7XG4gIHZhciBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gIHZhciBvYmo7XG4gIGxvYWRlZEV4dGVudHNSdHJlZS5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAoZXF1YWxzKG9iamVjdC5leHRlbnQsIGV4dGVudCkpIHtcbiAgICAgIG9iaiA9IG9iamVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvYmopIHtcbiAgICBsb2FkZWRFeHRlbnRzUnRyZWUucmVtb3ZlKG9iaik7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYSBzaW5nbGUgZmVhdHVyZSBmcm9tIHRoZSBzb3VyY2UuICBJZiB5b3Ugd2FudCB0byByZW1vdmUgYWxsIGZlYXR1cmVzXG4gKiBhdCBvbmNlLCB1c2UgdGhlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjY2xlYXIgI2NsZWFyKCl9IG1ldGhvZFxuICogaW5zdGVhZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZSB0byByZW1vdmUuXG4gKiBAYXBpXG4gKi9cblZlY3RvclNvdXJjZS5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdmFyIGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSkudG9TdHJpbmcoKTtcbiAgaWYgKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pIHtcbiAgICBkZWxldGUgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV07XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgIH1cbiAgfVxuICB0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKTtcbiAgdGhpcy5jaGFuZ2VkKCk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGZlYXR1cmUgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuVmVjdG9yU291cmNlLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlSW50ZXJuYWwgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gIHZhciBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpLnRvU3RyaW5nKCk7XG4gIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfW2ZlYXR1cmVLZXldLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gIGRlbGV0ZSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XTtcbiAgdmFyIGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSB0aGlzLmlkSW5kZXhfW2lkLnRvU3RyaW5nKCldO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV07XG4gIH1cbiAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBWZWN0b3JTb3VyY2VFdmVudChcbiAgICBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSwgZmVhdHVyZSkpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhIGZlYXR1cmUgZnJvbSB0aGUgaWQgaW5kZXguICBDYWxsZWQgaW50ZXJuYWxseSB3aGVuIHRoZSBmZWF0dXJlIGlkXG4gKiBtYXkgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZX0gZmVhdHVyZSBUaGUgZmVhdHVyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQgdGhlIGZlYXR1cmUgZnJvbSB0aGUgaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLnJlbW92ZUZyb21JZEluZGV4XyA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgZm9yICh2YXIgaWQgaW4gdGhpcyQxLmlkSW5kZXhfKSB7XG4gICAgaWYgKHRoaXMkMS5pZEluZGV4X1tpZF0gPT09IGZlYXR1cmUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzJDEuaWRJbmRleF9baWRdO1xuICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbW92ZWQ7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBuZXcgbG9hZGVyIG9mIHRoZSBzb3VyY2UuIFRoZSBuZXh0IGxvYWRGZWF0dXJlcyBjYWxsIHdpbGwgdXNlIHRoZVxuICogbmV3IGxvYWRlci5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2ZlYXR1cmVsb2FkZXJ+RmVhdHVyZUxvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdG8gc2V0LlxuICogQGFwaVxuICovXG5WZWN0b3JTb3VyY2UucHJvdG90eXBlLnNldExvYWRlciA9IGZ1bmN0aW9uKGxvYWRlcikge1xuICB0aGlzLmxvYWRlcl8gPSBsb2FkZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JTb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3Rvci5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1ZlY3RvckV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYSBmZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZUV2ZW50I2FkZGZlYXR1cmVcbiAgICogQGFwaVxuICAgKi9cbiAgQURERkVBVFVSRTogJ2FkZGZlYXR1cmUnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgdXBkYXRlZC5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlRXZlbnQjY2hhbmdlZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0VGRUFUVVJFOiAnY2hhbmdlZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBjbGVhciBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBzb3VyY2UuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZUV2ZW50I2NsZWFyXG4gICAqIEBhcGlcbiAgICovXG4gIENMRUFSOiAnY2xlYXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3IjY2xlYXIgc291cmNlLmNsZWFyKCl9IGZvciBleGNlcHRpb25zLlxuICAgKiBAZXZlbnQgb2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2VFdmVudCNyZW1vdmVmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIFJFTU9WRUZFQVRVUkU6ICdyZW1vdmVmZWF0dXJlJ1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yRXZlbnRUeXBlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvWFlaXG4gKi9cblxuaW1wb3J0IFRpbGVJbWFnZSBmcm9tICcuLi9zb3VyY2UvVGlsZUltYWdlLmpzJztcbmltcG9ydCB7Y3JlYXRlWFlaLCBleHRlbnRGcm9tUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXSBBdHRyaWJ1dGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvXG4gKiBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuICBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT10cnVlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTE4XSBPcHRpb25hbCBtYXggem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBPcHRpb25hbCBtaW4gem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL1RpbGV+TG9hZEZ1bmN0aW9ufSBbdGlsZUxvYWRGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gbG9hZCBhIHRpbGUgZ2l2ZW4gYSBVUkwuIFRoZSBkZWZhdWx0IGlzXG4gKiBgYGBqc1xuICogZnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAqICAgaW1hZ2VUaWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpbz0xXSBUaGUgcGl4ZWwgcmF0aW8gdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlIHNlcnZpY2UgYWR2ZXJ0aXplcyAyNTZweCBieSAyNTZweCB0aWxlcyBidXQgYWN0dWFsbHkgc2VuZHMgNTEycHhcbiAqIGJ5IDUxMnB4IGltYWdlcyAoZm9yIHJldGluYS9oaWRwaSBkZXZpY2VzKSB0aGVuIGB0aWxlUGl4ZWxSYXRpb2BcbiAqIHNob3VsZCBiZSBzZXQgdG8gYDJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZX0gW3RpbGVTaXplPVsyNTYsIDI1Nl1dIFRoZSB0aWxlIHNpemUgdXNlZCBieSB0aGUgdGlsZSBzZXJ2aWNlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0XG4gKiB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBSZXF1aXJlZCBpZiB1cmwgb3IgdXJscyBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsXG4gKiBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLFxuICogbWF5IGJlIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl0gRHVyYXRpb24gb2YgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbiBmb3IgcmVuZGVyaW5nLlxuICogVG8gZGlzYWJsZSB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLCBwYXNzIGB0cmFuc2l0aW9uOiAwYC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aWxlIGRhdGEgd2l0aCBVUkxzIGluIGEgc2V0IFhZWiBmb3JtYXQgdGhhdCBhcmVcbiAqIGRlZmluZWQgaW4gYSBVUkwgdGVtcGxhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgZm9sbG93cyB0aGUgd2lkZWx5LXVzZWRcbiAqIEdvb2dsZSBncmlkIHdoZXJlIGB4YCAwIGFuZCBgeWAgMCBhcmUgaW4gdGhlIHRvcCBsZWZ0LiBHcmlkcyBsaWtlXG4gKiBUTVMgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgYm90dG9tIGxlZnQgY2FuIGJlIHVzZWQgYnlcbiAqIHVzaW5nIHRoZSBgey15fWAgcGxhY2Vob2xkZXIgaW4gdGhlIFVSTCB0ZW1wbGF0ZSwgc28gbG9uZyBhcyB0aGVcbiAqIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgY3VzdG9tIHRpbGUgZ3JpZC4gSW4gdGhpcyBjYXNlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZUltYWdlfSBjYW4gYmUgdXNlZCB3aXRoIGEgYHRpbGVVcmxGdW5jdGlvbmBcbiAqIHN1Y2ggYXM6XG4gKlxuICogIHRpbGVVcmxGdW5jdGlvbjogZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICogICAgcmV0dXJuICdodHRwOi8vbWFwc2VydmVyLmNvbS8nICsgY29vcmRpbmF0ZVswXSArICcvJyArXG4gKiAgICAgICAgY29vcmRpbmF0ZVsxXSArICcvJyArIGNvb3JkaW5hdGVbMl0gKyAnLnBuZyc7XG4gKiAgICB9XG4gKlxuICogQGFwaVxuICovXG52YXIgWFlaID0gKGZ1bmN0aW9uIChUaWxlSW1hZ2UpIHtcbiAgZnVuY3Rpb24gWFlaKG9wdF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucHJvamVjdGlvbiA6ICdFUFNHOjM4NTcnO1xuXG4gICAgdmFyIHRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6XG4gICAgICBjcmVhdGVYWVooe1xuICAgICAgICBleHRlbnQ6IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pLFxuICAgICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20sXG4gICAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbSxcbiAgICAgICAgdGlsZVNpemU6IG9wdGlvbnMudGlsZVNpemVcbiAgICAgIH0pO1xuXG4gICAgVGlsZUltYWdlLmNhbGwodGhpcywge1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogb3B0aW9ucy5jcm9zc09yaWdpbixcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggVGlsZUltYWdlICkgWFlaLl9fcHJvdG9fXyA9IFRpbGVJbWFnZTtcbiAgWFlaLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRpbGVJbWFnZSAmJiBUaWxlSW1hZ2UucHJvdG90eXBlICk7XG4gIFhZWi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBYWVo7XG5cbiAgcmV0dXJuIFhZWjtcbn0oVGlsZUltYWdlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFhZWjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9WFlaLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExhdGl0dWRlL2xvbmdpdHVkZSBzcGhlcmljYWwgZ2VvZGVzeSBmb3JtdWxhZSB0YWtlbiBmcm9tXG4gKiBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuICogTGljZW5zZWQgdW5kZXIgQ0MtQlktMy4wLlxuICovXG5cbi8qKlxuICogQG1vZHVsZSBvbC9zcGhlcmVcbiAqL1xuaW1wb3J0IHt0b1JhZGlhbnMsIHRvRGVncmVlc30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgZ2V0TGVuZ3RofSBvciB7QGxpbmsgZ2V0QXJlYX1cbiAqIGZ1bmN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNwaGVyZU1ldHJpY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXVxuICogUHJvamVjdGlvbiBvZiB0aGUgIGdlb21ldHJ5LiAgQnkgZGVmYXVsdCwgdGhlIGdlb21ldHJ5IGlzIGFzc3VtZWQgdG8gYmUgaW5cbiAqIFdlYiBNZXJjYXRvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzPTYzNzEwMDguOF0gU3BoZXJlIHJhZGl1cy4gIEJ5IGRlZmF1bHQsIHRoZSByYWRpdXMgb2YgdGhlXG4gKiBlYXJ0aCBpcyB1c2VkIChDbGFya2UgMTg2NiBBdXRoYWxpYyBTcGhlcmUpLlxuICovXG5cblxuLyoqXG4gKiBUaGUgbWVhbiBFYXJ0aCByYWRpdXMgKDEvMyAqICgyYSArIGIpKSBmb3IgdGhlIFdHUzg0IGVsbGlwc29pZC5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VhcnRoX3JhZGl1cyNNZWFuX3JhZGl1c1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBERUZBVUxUX1JBRElVUyA9IDYzNzEwMDguODtcblxuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgb3B0X3JhZGl1cykge1xuICB2YXIgcmFkaXVzID0gb3B0X3JhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgdmFyIGxhdDEgPSB0b1JhZGlhbnMoYzFbMV0pO1xuICB2YXIgbGF0MiA9IHRvUmFkaWFucyhjMlsxXSk7XG4gIHZhciBkZWx0YUxhdEJ5MiA9IChsYXQyIC0gbGF0MSkgLyAyO1xuICB2YXIgZGVsdGFMb25CeTIgPSB0b1JhZGlhbnMoYzJbMF0gLSBjMVswXSkgLyAyO1xuICB2YXIgYSA9IE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgICBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKiBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKlxuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1bXVsYXRpdmUgZ3JlYXQgY2lyY2xlIGxlbmd0aCBvZiBsaW5lc3RyaW5nIGNvb3JkaW5hdGVzIChnZW9ncmFwaGljKS5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIExpbmVzdHJpbmcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWkgLSAxOyArK2kpIHtcbiAgICBsZW5ndGggKz0gZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgKyAxXSwgcmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgbGVuZ3RoIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZVxuICogZ3JlYXQgY2lyY2xlIGRpc3RhbmNlcyBiZXR3ZWVuIGNvb3JkaW5hdGVzLiAgRm9yIHBvbHlnb25zLCB0aGUgbGVuZ3RoIGlzXG4gKiB0aGUgc3VtIG9mIGFsbCByaW5ncy4gIEZvciBwb2ludHMsIHRoZSBsZW5ndGggaXMgemVyby4gIEZvciBtdWx0aS1wYXJ0XG4gKiBnZW9tZXRyaWVzLCB0aGUgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIGxlbmd0aCBvZiBlYWNoIHBhcnQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3BoZXJlflNwaGVyZU1ldHJpY09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zIGZvciB0aGVcbiAqIGxlbmd0aCBjYWxjdWxhdGlvbi4gIEJ5IGRlZmF1bHQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gJ0VQU0c6Mzg1NycuXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHByb3ZpZGluZyBhIGBwcm9qZWN0aW9uYCBvcHRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzcGhlcmljYWwgbGVuZ3RoIChpbiBtZXRlcnMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoKGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICB2YXIgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBwcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1NpbXBsZUdlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9TaW1wbGVHZW9tZXRyeX0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046IHtcbiAgICAgIHZhciBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSkuZ2V0R2VvbWV0cmllcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aChnZW9tZXRyaWVzW2ldLCBvcHRfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzcGhlcmljYWwgYXJlYSBmb3IgYSBsaXN0IG9mIGNvb3JkaW5hdGVzLlxuICpcbiAqIFtSZWZlcmVuY2VdKGh0dHBzOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvaGFuZGxlLzIwMTQvNDA0MDkpXG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3XG4gKlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIExpc3Qgb2YgY29vcmRpbmF0ZXMgb2YgYSBsaW5lYXJcbiAqIHJpbmcuIElmIHRoZSByaW5nIGlzIG9yaWVudGVkIGNsb2Nrd2lzZSwgdGhlIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSxcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cy5cbiAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAoaW4gc3F1YXJlIG1ldGVycykuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlcywgcmFkaXVzKSB7XG4gIHZhciBhcmVhID0gMDtcbiAgdmFyIGxlbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgdmFyIHgxID0gY29vcmRpbmF0ZXNbbGVuIC0gMV1bMF07XG4gIHZhciB5MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzFdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHgyID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgdmFyIHkyID0gY29vcmRpbmF0ZXNbaV1bMV07XG4gICAgYXJlYSArPSB0b1JhZGlhbnMoeDIgLSB4MSkgKlxuICAgICAgICAoMiArIE1hdGguc2luKHRvUmFkaWFucyh5MSkpICtcbiAgICAgICAgTWF0aC5zaW4odG9SYWRpYW5zKHkyKSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gYXJlYSAqIHJhZGl1cyAqIHJhZGl1cyAvIDIuMDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgc3BoZXJpY2FsIGFyZWEgb2YgYSBnZW9tZXRyeS4gIFRoaXMgaXMgdGhlIGFyZWEgKGluIG1ldGVycykgYXNzdW1pbmdcbiAqIHRoYXQgcG9seWdvbiBlZGdlcyBhcmUgc2VnbWVudHMgb2YgZ3JlYXQgY2lyY2xlcyBvbiBhIHNwaGVyZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9IGdlb21ldHJ5IEEgZ2VvbWV0cnkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zcGhlcmV+U3BoZXJlTWV0cmljT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gIHZhciByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgdmFyIHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0VHlwZSgpO1xuICBpZiAodHlwZSAhPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBnZW9tZXRyeSA9IGdlb21ldHJ5LmNsb25lKCkudHJhbnNmb3JtKHByb2plY3Rpb24sICdFUFNHOjQzMjYnKTtcbiAgfVxuICB2YXIgYXJlYSA9IDA7XG4gIHZhciBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVBUl9SSU5HOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL1BvbHlnb259ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGFyZWEgPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbMF0sIHJhZGl1cykpO1xuICAgICAgZm9yIChpID0gMSwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vU2ltcGxlR2VvbWV0cnl9ICovIChnZW9tZXRyeSkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzWzBdLCByYWRpdXMpKTtcbiAgICAgICAgZm9yIChqID0gMSwgamogPSBjb29yZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMoZ2V0QXJlYUludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OOiB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGFyZWEgKz0gZ2V0QXJlYShnZW9tZXRyaWVzW2ldLCBvcHRfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmVhO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgZ2l2ZW4gZGlzdGFuY2UgYW5kIGJlYXJpbmcgZnJvbSBgYzFgLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYzEgVGhlIG9yaWdpbiBwb2ludCAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIFRoZSBncmVhdC1jaXJjbGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgb3JpZ2luXG4gKiAgICAgcG9pbnQgYW5kIHRoZSB0YXJnZXQgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVhcmluZyBUaGUgYmVhcmluZyAoaW4gcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdF9yYWRpdXMpIHtcbiAgdmFyIHJhZGl1cyA9IG9wdF9yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIHZhciBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgdmFyIGxvbjEgPSB0b1JhZGlhbnMoYzFbMF0pO1xuICB2YXIgZEJ5UiA9IGRpc3RhbmNlIC8gcmFkaXVzO1xuICB2YXIgbGF0ID0gTWF0aC5hc2luKFxuICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MoZEJ5UikgK1xuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihkQnlSKSAqIE1hdGguY29zKGJlYXJpbmcpKTtcbiAgdmFyIGxvbiA9IGxvbjEgKyBNYXRoLmF0YW4yKFxuICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICBNYXRoLmNvcyhkQnlSKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0KSk7XG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbiksIHRvRGVncmVlcyhsYXQpXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BoZXJlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgTnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9wcmVjaXNpb24gUHJlY2lzaW9uIG9mIHRoZSBvdXRwdXQgc3RyaW5nIChpLmUuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZE51bWJlcihudW1iZXIsIHdpZHRoLCBvcHRfcHJlY2lzaW9uKSB7XG4gIHZhciBudW1iZXJTdHJpbmcgPSBvcHRfcHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBudW1iZXIudG9GaXhlZChvcHRfcHJlY2lzaW9uKSA6ICcnICsgbnVtYmVyO1xuICB2YXIgZGVjaW1hbCA9IG51bWJlclN0cmluZy5pbmRleE9mKCcuJyk7XG4gIGRlY2ltYWwgPSBkZWNpbWFsID09PSAtMSA/IG51bWJlclN0cmluZy5sZW5ndGggOiBkZWNpbWFsO1xuICByZXR1cm4gZGVjaW1hbCA+IHdpZHRoID8gbnVtYmVyU3RyaW5nIDogbmV3IEFycmF5KDEgKyB3aWR0aCAtIGRlY2ltYWwpLmpvaW4oJzAnKSArIG51bWJlclN0cmluZztcbn1cblxuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb21pY2hlbHNlbi9jb21wYXJlLXZlcnNpb25zL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHYxIEZpcnN0IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjIgU2Vjb25kIHZlcnNpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIHZhciBzMSA9ICgnJyArIHYxKS5zcGxpdCgnLicpO1xuICB2YXIgczIgPSAoJycgKyB2Mikuc3BsaXQoJy4nKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKTsgaSsrKSB7XG4gICAgdmFyIG4xID0gcGFyc2VJbnQoczFbaV0gfHwgJzAnLCAxMCk7XG4gICAgdmFyIG4yID0gcGFyc2VJbnQoczJbaV0gfHwgJzAnLCAxMCk7XG5cbiAgICBpZiAobjEgPiBuMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChuMiA+IG4xKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9MUlVDYWNoZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9ldmVudHMvRXZlbnRUYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5X1xuICogQHByb3BlcnR5IHtPYmplY3R9IG5ld2VyXG4gKiBAcHJvcGVydHkge09iamVjdH0gb2xkZXJcbiAqIEBwcm9wZXJ0eSB7Kn0gdmFsdWVfXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudHMgYSBMZWFzdC1SZWNlbnRseS1Vc2VkIGNhY2hlIHdoZXJlIHRoZSBrZXlzIGRvIG5vdCBjb25mbGljdCB3aXRoXG4gKiBPYmplY3QncyBwcm9wZXJ0aWVzIChlLmcuICdoYXNPd25Qcm9wZXJ0eScgaXMgbm90IGFsbG93ZWQgYXMgYSBrZXkpLiBFeHBpcmluZ1xuICogaXRlbXMgZnJvbSB0aGUgY2FjaGUgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyLlxuICpcbiAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50XG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgTFJVQ2FjaGUgPSAoZnVuY3Rpb24gKEV2ZW50VGFyZ2V0KSB7XG4gIGZ1bmN0aW9uIExSVUNhY2hlKG9wdF9oaWdoV2F0ZXJNYXJrKSB7XG5cbiAgICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRfaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkID8gb3B0X2hpZ2hXYXRlck1hcmsgOiAyMDQ4O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywgbW9kdWxlOm9sL3N0cnVjdHMvTFJVQ2FjaGV+RW50cnk+fVxuICAgICAqL1xuICAgIHRoaXMuZW50cmllc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9tb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm9sZGVzdF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fVxuICAgICAqL1xuICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG5cbiAgfVxuXG4gIGlmICggRXZlbnRUYXJnZXQgKSBMUlVDYWNoZS5fX3Byb3RvX18gPSBFdmVudFRhcmdldDtcbiAgTFJVQ2FjaGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZlbnRUYXJnZXQgJiYgRXZlbnRUYXJnZXQucHJvdG90eXBlICk7XG4gIExSVUNhY2hlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExSVUNhY2hlO1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuY2FuRXhwaXJlQ2FjaGUgPSBmdW5jdGlvbiBjYW5FeHBpcmVDYWNoZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q291bnQoKSA+IHRoaXMuaGlnaFdhdGVyTWFyaztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgICovXG4gIExSVUNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNMRUFSKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMga2V5LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmNvbnRhaW5zS2V5ID0gZnVuY3Rpb24gY29udGFpbnNLZXkgKGtleSkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXNfLmhhc093blByb3BlcnR5KGtleSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBULCBzdHJpbmcsIG1vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlKTogP30gZiBUaGUgZnVuY3Rpb25cbiAgICogICAgIHRvIGNhbGwgZm9yIGV2ZXJ5IGVudHJ5IGZyb20gdGhlIG9sZGVzdCB0byB0aGUgbmV3ZXIuIFRoaXMgZnVuY3Rpb24gdGFrZXNcbiAgICogICAgIDMgYXJndW1lbnRzICh0aGUgZW50cnkgdmFsdWUsIHRoZSBlbnRyeSBrZXkgYW5kIHRoZSBMUlVDYWNoZSBvYmplY3QpLlxuICAgKiAgICAgVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGZgLlxuICAgKiBAdGVtcGxhdGUgU1xuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChmLCBvcHRfdGhpcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgZi5jYWxsKG9wdF90aGlzLCBlbnRyeS52YWx1ZV8sIGVudHJ5LmtleV8sIHRoaXMkMSk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5ld2VyO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHJldHVybiB7VH0gVmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNfW2tleV07XG4gICAgYXNzZXJ0KGVudHJ5ICE9PSB1bmRlZmluZWQsXG4gICAgICAxNSk7IC8vIFRyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZVxuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX0gKi8gKHRoaXMub2xkZXN0Xy5uZXdlcik7XG4gICAgICB0aGlzLm9sZGVzdF8ub2xkZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyO1xuICAgICAgZW50cnkub2xkZXIubmV3ZXIgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIgPSBudWxsO1xuICAgIGVudHJ5Lm9sZGVyID0gdGhpcy5uZXdlc3RfO1xuICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIHRoaXMubmV3ZXN0XyA9IGVudHJ5O1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH07XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLCAxNSk7IC8vIFRyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZVxuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoZW50cnkub2xkZXIpO1xuICAgICAgaWYgKHRoaXMubmV3ZXN0Xykge1xuICAgICAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX0gKi8gKGVudHJ5Lm5ld2VyKTtcbiAgICAgIGlmICh0aGlzLm9sZGVzdF8pIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2tleV07XG4gICAgLS10aGlzLmNvdW50XztcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiBnZXRDb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY291bnRfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBLZXlzLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiBnZXRLZXlzICgpIHtcbiAgICB2YXIga2V5cyA9IG5ldyBBcnJheSh0aGlzLmNvdW50Xyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICBmb3IgKGVudHJ5ID0gdGhpcy5uZXdlc3RfOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5vbGRlcikge1xuICAgICAga2V5c1tpKytdID0gZW50cnkua2V5XztcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPFQ+fSBWYWx1ZXMuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gZ2V0VmFsdWVzICgpIHtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuY291bnRfKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIGZvciAoZW50cnkgPSB0aGlzLm5ld2VzdF87IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm9sZGVyKSB7XG4gICAgICB2YWx1ZXNbaSsrXSA9IGVudHJ5LnZhbHVlXztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUfSBMYXN0IHZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtMYXN0ID0gZnVuY3Rpb24gcGVla0xhc3QgKCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTGFzdCBrZXkuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucGVla0xhc3RLZXkgPSBmdW5jdGlvbiBwZWVrTGFzdEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2xkZXN0Xy5rZXlfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5IG9mIHRoZSBuZXdlc3QgaXRlbSBpbiB0aGUgY2FjaGUuICBUaHJvd3MgaWYgdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXdlc3Qga2V5LlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBlZWtGaXJzdEtleSA9IGZ1bmN0aW9uIHBlZWtGaXJzdEtleSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3ZXN0Xy5rZXlfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2VudHJ5LmtleV9dO1xuICAgIGlmIChlbnRyeS5uZXdlcikge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL0xSVUNhY2hlfkVudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgIGlmICghdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICAgIH1cbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmdldChrZXkpOyAvLyB1cGRhdGUgYG5ld2VzdF9gXG4gICAgdGhpcy5lbnRyaWVzX1trZXldLnZhbHVlXyA9IHZhbHVlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGFzc2VydCghKGtleSBpbiB0aGlzLmVudHJpZXNfKSxcbiAgICAgIDE2KTsgLy8gVHJpZWQgdG8gc2V0IGEgdmFsdWUgZm9yIGEga2V5IHRoYXQgaXMgdXNlZCBhbHJlYWR5XG4gICAgdmFyIGVudHJ5ID0gLyoqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZX5FbnRyeX0gKi8gKHtcbiAgICAgIGtleV86IGtleSxcbiAgICAgIG5ld2VyOiBudWxsLFxuICAgICAgb2xkZXI6IHRoaXMubmV3ZXN0XyxcbiAgICAgIHZhbHVlXzogdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMubmV3ZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gZW50cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV3ZXN0Xy5uZXdlciA9IGVudHJ5O1xuICAgIH1cbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICB0aGlzLmVudHJpZXNfW2tleV0gPSBlbnRyeTtcbiAgICArK3RoaXMuY291bnRfO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgTFJVQ2FjaGUucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiBzZXRTaXplIChzaXplKSB7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gc2l6ZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQcnVuZSB0aGUgY2FjaGUuXG4gICAqL1xuICBMUlVDYWNoZS5wcm90b3R5cGUucHJ1bmUgPSBmdW5jdGlvbiBwcnVuZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICB0aGlzJDEucG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMUlVDYWNoZTtcbn0oRXZlbnRUYXJnZXQpKTtcblxuZXhwb3J0IGRlZmF1bHQgTFJVQ2FjaGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxSVUNhY2hlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWVcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRFJPUCA9IEluZmluaXR5O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJpb3JpdHkgcXVldWUuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGlzIGluc3BpcmVkIGZyb20gdGhlIENsb3N1cmUgTGlicmFyeSdzIEhlYXAgY2xhc3MgYW5kXG4gKiBQeXRob24ncyBoZWFwcSBtb2R1bGUuXG4gKlxuICogU2VlIGh0dHA6Ly9jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vc3ZuL2RvY3MvY2xvc3VyZV9nb29nX3N0cnVjdHNfaGVhcC5qcy5zb3VyY2UuaHRtbFxuICogYW5kIGh0dHA6Ly9oZy5weXRob24ub3JnL2NweXRob24vZmlsZS8yLjcvTGliL2hlYXBxLnB5LlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBQcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZShwcmlvcml0eUZ1bmN0aW9uLCBrZXlGdW5jdGlvbikge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IG51bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucHJpb3JpdHlGdW5jdGlvbl8gPSBwcmlvcml0eUZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7ZnVuY3Rpb24oVCk6IHN0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMua2V5RnVuY3Rpb25fID0ga2V5RnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48VD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmVsZW1lbnRzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnByaW9yaXRpZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIGJvb2xlYW4+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5xdWV1ZWRFbGVtZW50c18gPSB7fTtcblxufTtcblxuLyoqXG4gKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciQxICgpIHtcbiAgdGhpcy5lbGVtZW50c18ubGVuZ3RoID0gMDtcbiAgdGhpcy5wcmlvcml0aWVzXy5sZW5ndGggPSAwO1xuICBjbGVhcih0aGlzLnF1ZXVlZEVsZW1lbnRzXyk7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGhpZ2hlc3QtcHJpb3JpdHkgZWxlbWVudC4gTyhsb2cgTikuXG4gKiBAcmV0dXJuIHtUfSBFbGVtZW50LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSAoKSB7XG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICB2YXIgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gIHZhciBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPT0gMSkge1xuICAgIGVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgcHJpb3JpdGllcy5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRzWzBdID0gZWxlbWVudHMucG9wKCk7XG4gICAgcHJpb3JpdGllc1swXSA9IHByaW9yaXRpZXMucG9wKCk7XG4gICAgdGhpcy5zaWZ0VXBfKDApO1xuICB9XG4gIHZhciBlbGVtZW50S2V5ID0gdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCk7XG4gIGRlbGV0ZSB0aGlzLnF1ZXVlZEVsZW1lbnRzX1tlbGVtZW50S2V5XTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5cbi8qKlxuICogRW5xdWV1ZSBhbiBlbGVtZW50LiBPKGxvZyBOKS5cbiAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUgKGVsZW1lbnQpIHtcbiAgYXNzZXJ0KCEodGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCkgaW4gdGhpcy5xdWV1ZWRFbGVtZW50c18pLFxuICAgIDMxKTsgLy8gVHJpZWQgdG8gZW5xdWV1ZSBhbiBgZWxlbWVudGAgdGhhdCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgcXVldWVcbiAgdmFyIHByaW9yaXR5ID0gdGhpcy5wcmlvcml0eUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgaWYgKHByaW9yaXR5ICE9IERST1ApIHtcbiAgICB0aGlzLmVsZW1lbnRzXy5wdXNoKGVsZW1lbnQpO1xuICAgIHRoaXMucHJpb3JpdGllc18ucHVzaChwcmlvcml0eSk7XG4gICAgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldID0gdHJ1ZTtcbiAgICB0aGlzLnNpZnREb3duXygwLCB0aGlzLmVsZW1lbnRzXy5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiBnZXRDb3VudCAoKSB7XG4gIHJldHVybiB0aGlzLmVsZW1lbnRzXy5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIGxlZnQgY2hpbGQgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQuXG4gKiBAcHJpdmF0ZVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRMZWZ0Q2hpbGRJbmRleF8gPSBmdW5jdGlvbiBnZXRMZWZ0Q2hpbGRJbmRleF8gKGluZGV4KSB7XG4gIHJldHVybiBpbmRleCAqIDIgKyAxO1xufTtcblxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSByaWdodCBjaGlsZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcmlnaHQgY2hpbGQgZm9yLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJpZ2h0IGNoaWxkLlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UmlnaHRDaGlsZEluZGV4XyA9IGZ1bmN0aW9uIGdldFJpZ2h0Q2hpbGRJbmRleF8gKGluZGV4KSB7XG4gIHJldHVybiBpbmRleCAqIDIgKyAyO1xufTtcblxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwYXJlbnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcGFyZW50LlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UGFyZW50SW5kZXhfID0gZnVuY3Rpb24gZ2V0UGFyZW50SW5kZXhfIChpbmRleCkge1xuICByZXR1cm4gKGluZGV4IC0gMSkgPj4gMTtcbn07XG5cblxuLyoqXG4gKiBNYWtlIHRoaXMgYSBoZWFwLiBPKE4pLlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaGVhcGlmeV8gPSBmdW5jdGlvbiBoZWFwaWZ5XyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGk7XG4gIGZvciAoaSA9ICh0aGlzLmVsZW1lbnRzXy5sZW5ndGggPj4gMSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRoaXMkMS5zaWZ0VXBfKGkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGtleSBxdWV1ZWQuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzS2V5UXVldWVkID0gZnVuY3Rpb24gaXNLZXlRdWV1ZWQgKGtleSkge1xuICByZXR1cm4ga2V5IGluIHRoaXMucXVldWVkRWxlbWVudHNfO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgcXVldWVkLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc1F1ZXVlZCA9IGZ1bmN0aW9uIGlzUXVldWVkIChlbGVtZW50KSB7XG4gIHJldHVybiB0aGlzLmlzS2V5UXVldWVkKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIG1vdmUgZG93bi5cbiAqIEBwcml2YXRlXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcF8gPSBmdW5jdGlvbiBzaWZ0VXBfIChpbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICB2YXIgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gIHZhciBjb3VudCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gIHZhciBwcmlvcml0eSA9IHByaW9yaXRpZXNbaW5kZXhdO1xuICB2YXIgc3RhcnRJbmRleCA9IGluZGV4O1xuXG4gIHdoaWxlIChpbmRleCA8IChjb3VudCA+PiAxKSkge1xuICAgIHZhciBsSW5kZXggPSB0aGlzJDEuZ2V0TGVmdENoaWxkSW5kZXhfKGluZGV4KTtcbiAgICB2YXIgckluZGV4ID0gdGhpcyQxLmdldFJpZ2h0Q2hpbGRJbmRleF8oaW5kZXgpO1xuXG4gICAgdmFyIHNtYWxsZXJDaGlsZEluZGV4ID0gckluZGV4IDwgY291bnQgJiZcbiAgICAgICAgcHJpb3JpdGllc1tySW5kZXhdIDwgcHJpb3JpdGllc1tsSW5kZXhdID9cbiAgICAgIHJJbmRleCA6IGxJbmRleDtcblxuICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3NtYWxsZXJDaGlsZEluZGV4XTtcbiAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgIGluZGV4ID0gc21hbGxlckNoaWxkSW5kZXg7XG4gIH1cblxuICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXR5O1xuICB0aGlzLnNpZnREb3duXyhzdGFydEluZGV4LCBpbmRleCk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSByb290LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIHVwLlxuICogQHByaXZhdGVcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd25fID0gZnVuY3Rpb24gc2lmdERvd25fIChzdGFydEluZGV4LCBpbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICB2YXIgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICB2YXIgcHJpb3JpdHkgPSBwcmlvcml0aWVzW2luZGV4XTtcblxuICB3aGlsZSAoaW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gdGhpcyQxLmdldFBhcmVudEluZGV4XyhpbmRleCk7XG4gICAgaWYgKHByaW9yaXRpZXNbcGFyZW50SW5kZXhdID4gcHJpb3JpdHkpIHtcbiAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnRzW3BhcmVudEluZGV4XTtcbiAgICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdGllc1twYXJlbnRJbmRleF07XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudDtcbiAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbn07XG5cblxuLyoqXG4gKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVwcmlvcml0aXplID0gZnVuY3Rpb24gcmVwcmlvcml0aXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcHJpb3JpdHlGdW5jdGlvbiA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl87XG4gIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICB2YXIgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBuID0gZWxlbWVudHMubGVuZ3RoO1xuICB2YXIgZWxlbWVudCwgaSwgcHJpb3JpdHk7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgcHJpb3JpdHkgPSBwcmlvcml0eUZ1bmN0aW9uKGVsZW1lbnQpO1xuICAgIGlmIChwcmlvcml0eSA9PSBEUk9QKSB7XG4gICAgICBkZWxldGUgdGhpcyQxLnF1ZXVlZEVsZW1lbnRzX1t0aGlzJDEua2V5RnVuY3Rpb25fKGVsZW1lbnQpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgICAgIGVsZW1lbnRzW2luZGV4KytdID0gZWxlbWVudDtcbiAgICB9XG4gIH1cbiAgZWxlbWVudHMubGVuZ3RoID0gaW5kZXg7XG4gIHByaW9yaXRpZXMubGVuZ3RoID0gaW5kZXg7XG4gIHRoaXMuaGVhcGlmeV8oKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdHlRdWV1ZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9SQnVzaFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgcmJ1c2ggZnJvbSAncmJ1c2gnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZXF1YWxzfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVudHJ5XG4gKiBAcHJvcGVydHkge251bWJlcn0gbWluWFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbllcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhYXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WVxuICogQHByb3BlcnR5IHtPYmplY3R9IFt2YWx1ZV1cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFdyYXBwZXIgYXJvdW5kIHRoZSBSQnVzaCBieSBWbGFkaW1pciBBZ2Fmb25raW4uXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2guXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIFJCdXNoID0gZnVuY3Rpb24gUkJ1c2gob3B0X21heEVudHJpZXMpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucmJ1c2hfID0gcmJ1c2gob3B0X21heEVudHJpZXMsIHVuZGVmaW5lZCk7XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBvYmplY3RzIGFkZGVkIHRvIHRoaXMgcmJ1c2ggd3JhcHBlclxuICAgKiBhbmQgdGhlIG9iamVjdHMgdGhhdCBhcmUgYWN0dWFsbHkgYWRkZWQgdG8gdGhlIGludGVybmFsIHJidXNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIG1vZHVsZTpvbC9zdHJ1Y3RzL1JCdXNofkVudHJ5Pn1cbiAgICovXG4gIHRoaXMuaXRlbXNfID0ge307XG5cbn07XG5cbi8qKlxuICogSW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgUkJ1c2guXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoZXh0ZW50LCB2YWx1ZSkge1xuICAvKiogQHR5cGUge21vZHVsZTpvbC9zdHJ1Y3RzL1JCdXNofkVudHJ5fSAqL1xuICB2YXIgaXRlbSA9IHtcbiAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgbWluWTogZXh0ZW50WzFdLFxuICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG5cbiAgdGhpcy5yYnVzaF8uaW5zZXJ0KGl0ZW0pO1xuICB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXSA9IGl0ZW07XG59O1xuXG5cbi8qKlxuICogQnVsay1pbnNlcnQgdmFsdWVzIGludG8gdGhlIFJCdXNoLlxuICogQHBhcmFtIHtBcnJheS48bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ+fSBleHRlbnRzIEV4dGVudHMuXG4gKiBAcGFyYW0ge0FycmF5LjxUPn0gdmFsdWVzIFZhbHVlcy5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkIChleHRlbnRzLCB2YWx1ZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaXRlbXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBleHRlbnQgPSBleHRlbnRzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL3N0cnVjdHMvUkJ1c2h+RW50cnl9ICovXG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICBtaW5YOiBleHRlbnRbMF0sXG4gICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgICBtYXhZOiBleHRlbnRbM10sXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuICAgIGl0ZW1zW2ldID0gaXRlbTtcbiAgICB0aGlzJDEuaXRlbXNfW2dldFVpZCh2YWx1ZSldID0gaXRlbTtcbiAgfVxuICB0aGlzLnJidXNoXy5sb2FkKGl0ZW1zKTtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZW1vdmVkLlxuICovXG5SQnVzaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICh2YWx1ZSkge1xuICB2YXIgdWlkID0gZ2V0VWlkKHZhbHVlKTtcblxuICAvLyBnZXQgdGhlIG9iamVjdCBpbiB3aGljaCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgd2hlbiBhZGRpbmcgdG8gdGhlXG4gIC8vIGludGVybmFsIHJidXNoLiB0aGVuIHVzZSB0aGF0IG9iamVjdCB0byBkbyB0aGUgcmVtb3ZhbC5cbiAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zX1t1aWRdO1xuICBkZWxldGUgdGhpcy5pdGVtc19bdWlkXTtcbiAgcmV0dXJuIHRoaXMucmJ1c2hfLnJlbW92ZShpdGVtKSAhPT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGV4dGVudCBvZiBhIHZhbHVlIGluIHRoZSBSQnVzaC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge1R9IHZhbHVlIFZhbHVlLlxuICovXG5SQnVzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChleHRlbnQsIHZhbHVlKSB7XG4gIHZhciBpdGVtID0gdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV07XG4gIHZhciBiYm94ID0gW2l0ZW0ubWluWCwgaXRlbS5taW5ZLCBpdGVtLm1heFgsIGl0ZW0ubWF4WV07XG4gIGlmICghZXF1YWxzKGJib3gsIGV4dGVudCkpIHtcbiAgICB0aGlzLnJlbW92ZSh2YWx1ZSk7XG4gICAgdGhpcy5pbnNlcnQoZXh0ZW50LCB2YWx1ZSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYWxsIHZhbHVlcyBpbiB0aGUgUkJ1c2guXG4gKiBAcmV0dXJuIHtBcnJheS48VD59IEFsbC5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbCAoKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMucmJ1c2hfLmFsbCgpO1xuICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIGdpdmVuIGV4dGVudC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtBcnJheS48VD59IEFsbCBpbiBleHRlbnQuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5nZXRJbkV4dGVudCA9IGZ1bmN0aW9uIGdldEluRXh0ZW50IChleHRlbnQpIHtcbiAgLyoqIEB0eXBlIHttb2R1bGU6b2wvc3RydWN0cy9SQnVzaH5FbnRyeX0gKi9cbiAgdmFyIGJib3ggPSB7XG4gICAgbWluWDogZXh0ZW50WzBdLFxuICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICBtYXhYOiBleHRlbnRbMl0sXG4gICAgbWF4WTogZXh0ZW50WzNdXG4gIH07XG4gIHZhciBpdGVtcyA9IHRoaXMucmJ1c2hfLnNlYXJjaChiYm94KTtcbiAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIENhbGxzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBlYWNoIHZhbHVlIGluIHRoZSB0cmVlLlxuICogSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dFxuICogY2hlY2tpbmcgdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHJldHVybiB7Kn0gQ2FsbGJhY2sgcmV0dXJuIHZhbHVlLlxuICogQHRlbXBsYXRlIFNcbiAqL1xuUkJ1c2gucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaF8odGhpcy5nZXRBbGwoKSwgY2FsbGJhY2ssIG9wdF90aGlzKTtcbn07XG5cblxuLyoqXG4gKiBDYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggZWFjaCB2YWx1ZSBpbiB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgVCk6ICp9IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gKiBAdGVtcGxhdGUgU1xuICovXG5SQnVzaC5wcm90b3R5cGUuZm9yRWFjaEluRXh0ZW50ID0gZnVuY3Rpb24gZm9yRWFjaEluRXh0ZW50IChleHRlbnQsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEluRXh0ZW50KGV4dGVudCksIGNhbGxiYWNrLCBvcHRfdGhpcyk7XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48VD59IHZhbHVlcyBWYWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAqIEB0ZW1wbGF0ZSBTXG4gKi9cblJCdXNoLnByb3RvdHlwZS5mb3JFYWNoXyA9IGZ1bmN0aW9uIGZvckVhY2hfICh2YWx1ZXMsIGNhbGxiYWNrLCBvcHRfdGhpcykge1xuICB2YXIgcmVzdWx0O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCB2YWx1ZXNbaV0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gSXMgZW1wdHkuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSQxICgpIHtcbiAgcmV0dXJuIGlzRW1wdHkodGhpcy5pdGVtc18pO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSBhbGwgdmFsdWVzIGZyb20gdGhlIFJCdXNoLlxuICovXG5SQnVzaC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHRoaXMucmJ1c2hfLmNsZWFyKCk7XG4gIHRoaXMuaXRlbXNfID0ge307XG59O1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqL1xuUkJ1c2gucHJvdG90eXBlLmdldEV4dGVudCA9IGZ1bmN0aW9uIGdldEV4dGVudCAob3B0X2V4dGVudCkge1xuICAvLyBGSVhNRSBhZGQgZ2V0RXh0ZW50KCkgdG8gcmJ1c2hcbiAgdmFyIGRhdGEgPSB0aGlzLnJidXNoXy5kYXRhO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUoZGF0YS5taW5YLCBkYXRhLm1pblksIGRhdGEubWF4WCwgZGF0YS5tYXhZLCBvcHRfZXh0ZW50KTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHJ1Y3RzL1JCdXNofSByYnVzaCBSLVRyZWUuXG4gKi9cblJCdXNoLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKHJidXNoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5yYnVzaF8ubG9hZChyYnVzaC5yYnVzaF8uYWxsKCkpO1xuICBmb3IgKHZhciBpIGluIHJidXNoLml0ZW1zXykge1xuICAgIHRoaXMkMS5pdGVtc19baSB8IDBdID0gcmJ1c2guaXRlbXNfW2kgfCAwXTtcbiAgfVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSQnVzaDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UkJ1c2guanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0NpcmNsZVxuICovXG5cbmltcG9ydCBSZWd1bGFyU2hhcGUgZnJvbSAnLi4vc3R5bGUvUmVndWxhclNoYXBlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL0ZpbGx9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1cyBDaXJjbGUgcmFkaXVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc25hcFRvUGl4ZWw9dHJ1ZV0gSWYgYHRydWVgIGludGVncmFsIG51bWJlcnMgb2YgcGl4ZWxzIGFyZSB1c2VkIGFzIHRoZSBYIGFuZCBZIHBpeGVsIGNvb3JkaW5hdGVcbiAqIHdoZW4gZHJhd2luZyB0aGUgY2lyY2xlIGluIHRoZSBvdXRwdXQgY2FudmFzLiBJZiBgZmFsc2VgIGZyYWN0aW9uYWwgbnVtYmVycyBtYXkgYmUgdXNlZC4gVXNpbmcgYHRydWVgIGFsbG93cyBmb3JcbiAqIFwic2hhcnBcIiByZW5kZXJpbmcgKG5vIGJsdXIpLCB3aGlsZSB1c2luZyBgZmFsc2VgIGFsbG93cyBmb3IgXCJhY2N1cmF0ZVwiIHJlbmRlcmluZy4gTm90ZSB0aGF0IGFjY3VyYWN5IGlzIGltcG9ydGFudCBpZlxuICogdGhlIGNpcmNsZSdzIHBvc2l0aW9uIGlzIGFuaW1hdGVkLiBXaXRob3V0IGl0LCB0aGUgY2lyY2xlIG1heSBqaXR0ZXIgbm90aWNlYWJseS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL1N0cm9rZX0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvQXRsYXNNYW5hZ2VyfSBbYXRsYXNNYW5hZ2VyXSBUaGUgYXRsYXMgbWFuYWdlciB0byB1c2UgZm9yIHRoaXMgY2lyY2xlLlxuICogV2hlbiB1c2luZyBXZWJHTCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYW4gYXRsYXMgbWFuYWdlciB0byBhdm9pZCB0ZXh0dXJlIHN3aXRjaGluZy4gSWYgYW4gYXRsYXMgbWFuYWdlciBpcyBnaXZlbixcbiAqIHRoZSBjaXJjbGUgaXMgYWRkZWQgdG8gYW4gYXRsYXMuIEJ5IGRlZmF1bHQgbm8gYXRsYXMgbWFuYWdlciBpcyB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgY2lyY2xlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbnZhciBDaXJjbGVTdHlsZSA9IChmdW5jdGlvbiAoUmVndWxhclNoYXBlKSB7XG4gIGZ1bmN0aW9uIENpcmNsZVN0eWxlKG9wdF9vcHRpb25zKSB7XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgUmVndWxhclNoYXBlLmNhbGwodGhpcywge1xuICAgICAgcG9pbnRzOiBJbmZpbml0eSxcbiAgICAgIGZpbGw6IG9wdGlvbnMuZmlsbCxcbiAgICAgIHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG4gICAgICBzbmFwVG9QaXhlbDogb3B0aW9ucy5zbmFwVG9QaXhlbCxcbiAgICAgIHN0cm9rZTogb3B0aW9ucy5zdHJva2UsXG4gICAgICBhdGxhc01hbmFnZXI6IG9wdGlvbnMuYXRsYXNNYW5hZ2VyXG4gICAgfSk7XG5cbiAgfVxuXG4gIGlmICggUmVndWxhclNoYXBlICkgQ2lyY2xlU3R5bGUuX19wcm90b19fID0gUmVndWxhclNoYXBlO1xuICBDaXJjbGVTdHlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSZWd1bGFyU2hhcGUgJiYgUmVndWxhclNoYXBlLnByb3RvdHlwZSApO1xuICBDaXJjbGVTdHlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVTdHlsZTtcblxuICAvKipcbiAgKiBDbG9uZXMgdGhlIHN0eWxlLiAgSWYgYW4gYXRsYXNtYW5hZ2VyIHdhcyBwcm92aWRlZCB0byB0aGUgb3JpZ2luYWwgc3R5bGUgaXQgd2lsbCBiZSB1c2VkIGluIHRoZSBjbG9uZWQgc3R5bGUsIHRvby5cbiAgKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAqIEBvdmVycmlkZVxuICAqIEBhcGlcbiAgKi9cbiAgQ2lyY2xlU3R5bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBzdHlsZSA9IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBzdHJva2U6IHRoaXMuZ2V0U3Ryb2tlKCkgPyB0aGlzLmdldFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICByYWRpdXM6IHRoaXMuZ2V0UmFkaXVzKCksXG4gICAgICBzbmFwVG9QaXhlbDogdGhpcy5nZXRTbmFwVG9QaXhlbCgpLFxuICAgICAgYXRsYXNNYW5hZ2VyOiB0aGlzLmF0bGFzTWFuYWdlcl9cbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICBzdHlsZS5zZXRTY2FsZSh0aGlzLmdldFNjYWxlKCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvKipcbiAgKiBTZXQgdGhlIGNpcmNsZSByYWRpdXMuXG4gICpcbiAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gICogQGFwaVxuICAqL1xuICBDaXJjbGVTdHlsZS5wcm90b3R5cGUuc2V0UmFkaXVzID0gZnVuY3Rpb24gc2V0UmFkaXVzIChyYWRpdXMpIHtcbiAgICB0aGlzLnJhZGl1c18gPSByYWRpdXM7XG4gICAgdGhpcy5yZW5kZXJfKHRoaXMuYXRsYXNNYW5hZ2VyXyk7XG4gIH07XG5cbiAgcmV0dXJuIENpcmNsZVN0eWxlO1xufShSZWd1bGFyU2hhcGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGVTdHlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2lyY2xlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9GaWxsXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCBmaWxsIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBAYXBpXG4gKi9cbnZhciBGaWxsID0gZnVuY3Rpb24gRmlsbChvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvY29sb3J+Q29sb3J8bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9XG4gICAqL1xuICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHN0eWxlLiBUaGUgY29sb3IgaXMgbm90IGNsb25lZCBpZiBpdCBpcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL0ZpbGx9IFRoZSBjbG9uZWQgc3R5bGUuXG4gKiBAYXBpXG4gKi9cbkZpbGwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICB2YXIgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gIHJldHVybiBuZXcgRmlsbCh7XG4gICAgY29sb3I6IChjb2xvciAmJiBjb2xvci5zbGljZSkgPyBjb2xvci5zbGljZSgpIDogY29sb3IgfHwgdW5kZWZpbmVkXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGZpbGwgY29sb3IuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29sb3J+Q29sb3J8bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IENvbG9yLlxuICogQGFwaVxuICovXG5GaWxsLnByb3RvdHlwZS5nZXRDb2xvciA9IGZ1bmN0aW9uIGdldENvbG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuY29sb3JfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbG9yLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEBhcGlcbiAqL1xuRmlsbC5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiBzZXRDb2xvciAoY29sb3IpIHtcbiAgdGhpcy5jb2xvcl8gPSBjb2xvcjtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNoZWNrc3VtLlxuICovXG5GaWxsLnByb3RvdHlwZS5nZXRDaGVja3N1bSA9IGZ1bmN0aW9uIGdldENoZWNrc3VtICgpIHtcbiAgaWYgKHRoaXMuY2hlY2tzdW1fID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbG9yXyBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm4gfHxcbiAgICAgICAgdGhpcy5jb2xvcl8gaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudFxuICAgICkge1xuICAgICAgdGhpcy5jaGVja3N1bV8gPSBnZXRVaWQodGhpcy5jb2xvcl8pLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tzdW1fID0gJ2YnICsgKHRoaXMuY29sb3JfID8gYXNTdHJpbmcodGhpcy5jb2xvcl8pIDogJy0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5jaGVja3N1bV87XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWxsO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxsLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZVxuICovXG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2luZ2xldG9uIGNsYXNzLiBBdmFpbGFibGUgdGhyb3VnaCB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25JbWFnZUNhY2hlfnNoYXJlZH0uXG4gKi9cbnZhciBJY29uSW1hZ2VDYWNoZSA9IGZ1bmN0aW9uIEljb25JbWFnZUNhY2hlKCkge1xuXG4gIC8qKlxuICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2U+fVxuICAqIEBwcml2YXRlXG4gICovXG4gIHRoaXMuY2FjaGVfID0ge307XG5cbiAgLyoqXG4gICogQHR5cGUge251bWJlcn1cbiAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLmNhY2hlU2l6ZV8gPSAwO1xuXG4gIC8qKlxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICogQHByaXZhdGVcbiAgKi9cbiAgdGhpcy5tYXhDYWNoZVNpemVfID0gMzI7XG59O1xuXG4vKipcbiogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4qL1xuSWNvbkltYWdlQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICB0aGlzLmNhY2hlXyA9IHt9O1xuICB0aGlzLmNhY2hlU2l6ZV8gPSAwO1xufTtcblxuLyoqXG4qIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5leHBpcmUgPSBmdW5jdGlvbiBleHBpcmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmNhY2hlU2l6ZV8gPiB0aGlzLm1heENhY2hlU2l6ZV8pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZV8pIHtcbiAgICAgIHZhciBpY29uSW1hZ2UgPSB0aGlzJDEuY2FjaGVfW2tleV07XG4gICAgICBpZiAoKGkrKyAmIDMpID09PSAwICYmICFpY29uSW1hZ2UuaGFzTGlzdGVuZXIoKSkge1xuICAgICAgICBkZWxldGUgdGhpcyQxLmNhY2hlX1trZXldO1xuICAgICAgICAtLXRoaXMkMS5jYWNoZVNpemVfO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIEBwYXJhbSB7c3RyaW5nfSBzcmMgU3JjLlxuKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiogQHBhcmFtIHttb2R1bGU6b2wvY29sb3J+Q29sb3J9IGNvbG9yIENvbG9yLlxuKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlfSBJY29uIGltYWdlLlxuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIHZhciBrZXkgPSBnZXRLZXkoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IpO1xuICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG59O1xuXG4vKipcbiogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4qIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuKiBAcGFyYW0ge21vZHVsZTpvbC9jb2xvcn5Db2xvcn0gY29sb3IgQ29sb3IuXG4qIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL0ljb25JbWFnZX0gaWNvbkltYWdlIEljb24gaW1hZ2UuXG4qL1xuSWNvbkltYWdlQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IsIGljb25JbWFnZSkge1xuICB2YXIga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgdGhpcy5jYWNoZV9ba2V5XSA9IGljb25JbWFnZTtcbiAgKyt0aGlzLmNhY2hlU2l6ZV87XG59O1xuXG4vKipcbiogU2V0IHRoZSBjYWNoZSBzaXplIG9mIHRoZSBpY29uIGNhY2hlLiBEZWZhdWx0IGlzIGAzMmAuIENoYW5nZSB0aGlzIHZhbHVlIHdoZW5cbiogeW91ciBtYXAgdXNlcyBtb3JlIHRoYW4gMzIgZGlmZmVyZW50IGljb24gaW1hZ2VzIGFuZCB5b3UgYXJlIG5vdCBjYWNoaW5nIGljb25cbiogc3R5bGVzIG9uIHRoZSBhcHBsaWNhdGlvbiBsZXZlbC5cbiogQHBhcmFtIHtudW1iZXJ9IG1heENhY2hlU2l6ZSBDYWNoZSBtYXggc2l6ZS5cbiogQGFwaVxuKi9cbkljb25JbWFnZUNhY2hlLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZSAobWF4Q2FjaGVTaXplKSB7XG4gIHRoaXMubWF4Q2FjaGVTaXplXyA9IG1heENhY2hlU2l6ZTtcbiAgdGhpcy5leHBpcmUoKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29sb3J+Q29sb3J9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBDYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcikge1xuICB2YXIgY29sb3JTdHJpbmcgPSBjb2xvciA/IGFzU3RyaW5nKGNvbG9yKSA6ICdudWxsJztcbiAgcmV0dXJuIGNyb3NzT3JpZ2luICsgJzonICsgc3JjICsgJzonICsgY29sb3JTdHJpbmc7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgSWNvbkltYWdlQ2FjaGU7XG5cblxuLyoqXG4gKiBUaGUge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29uSW1hZ2VDYWNoZX5JY29uSW1hZ2VDYWNoZX0gZm9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0gaW1hZ2VzLlxuICogQGFwaVxuICovXG5leHBvcnQgdmFyIHNoYXJlZCA9IG5ldyBJY29uSW1hZ2VDYWNoZSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uSW1hZ2VDYWNoZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvSW1hZ2VcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNuYXBUb1BpeGVsXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYXBpXG4gKi9cbnZhciBJbWFnZVN0eWxlID0gZnVuY3Rpb24gSW1hZ2VTdHlsZShvcHRpb25zKSB7XG5cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqL1xuICB0aGlzLm9wYWNpdHlfID0gb3B0aW9ucy5vcGFjaXR5O1xuXG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICogQHR5cGUge2Jvb2xlYW59XG4gICovXG4gIHRoaXMucm90YXRlV2l0aFZpZXdfID0gb3B0aW9ucy5yb3RhdGVXaXRoVmlldztcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICovXG4gIHRoaXMucm90YXRpb25fID0gb3B0aW9ucy5yb3RhdGlvbjtcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqIEB0eXBlIHtudW1iZXJ9XG4gICovXG4gIHRoaXMuc2NhbGVfID0gb3B0aW9ucy5zY2FsZTtcblxuICAvKipcbiAgKiBAcHJpdmF0ZVxuICAqIEB0eXBlIHtib29sZWFufVxuICAqL1xuICB0aGlzLnNuYXBUb1BpeGVsXyA9IG9wdGlvbnMuc25hcFRvUGl4ZWw7XG5cbn07XG5cbi8qKlxuKiBHZXQgdGhlIHN5bWJvbGl6ZXIgb3BhY2l0eS5cbiogQHJldHVybiB7bnVtYmVyfSBPcGFjaXR5LlxuKiBAYXBpXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkgKCkge1xuICByZXR1cm4gdGhpcy5vcGFjaXR5Xztcbn07XG5cbi8qKlxuKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3ltYm9saXplciByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiogQHJldHVybiB7Ym9vbGVhbn0gUm90YXRlIHdpdGggbWFwLlxuKiBAYXBpXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0Um90YXRlV2l0aFZpZXcgPSBmdW5jdGlvbiBnZXRSb3RhdGVXaXRoVmlldyAoKSB7XG4gIHJldHVybiB0aGlzLnJvdGF0ZVdpdGhWaWV3Xztcbn07XG5cbi8qKlxuKiBHZXQgdGhlIHN5bW9ibGl6ZXIgcm90YXRpb24uXG4qIEByZXR1cm4ge251bWJlcn0gUm90YXRpb24uXG4qIEBhcGlcbiovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFJvdGF0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xufTtcblxuLyoqXG4qIEdldCB0aGUgc3ltYm9saXplciBzY2FsZS5cbiogQHJldHVybiB7bnVtYmVyfSBTY2FsZS5cbiogQGFwaVxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICByZXR1cm4gdGhpcy5zY2FsZV87XG59O1xuXG4vKipcbiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN5bWJvbGl6ZXIgc2hvdWxkIGJlIHNuYXBwZWQgdG8gYSBwaXhlbC5cbiogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHN5bWJvbGl6ZXIgc2hvdWxkIHNuYXAgdG8gYSBwaXhlbC5cbiogQGFwaVxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldFNuYXBUb1BpeGVsID0gZnVuY3Rpb24gZ2V0U25hcFRvUGl4ZWwgKCkge1xuICByZXR1cm4gdGhpcy5zbmFwVG9QaXhlbF87XG59O1xuXG4vKipcbiogR2V0IHRoZSBhbmNob3IgcG9pbnQgaW4gcGl4ZWxzLiBUaGUgYW5jaG9yIGRldGVybWluZXMgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlXG4qIHN5bWJvbGl6ZXIuXG4qIEBhYnN0cmFjdFxuKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW5jaG9yLlxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEFuY2hvciA9IGZ1bmN0aW9uIGdldEFuY2hvciAoKSB7fTtcblxuLyoqXG4qIEdldCB0aGUgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHN5bWJvbGl6ZXIuXG4qIEBhYnN0cmFjdFxuKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gZ2V0SW1hZ2UgKHBpeGVsUmF0aW8pIHt9O1xuXG4vKipcbiogQGFic3RyYWN0XG4qIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnQuXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UgPSBmdW5jdGlvbiBnZXRIaXREZXRlY3Rpb25JbWFnZSAocGl4ZWxSYXRpbykge307XG5cbi8qKlxuKiBAYWJzdHJhY3RcbiogQHJldHVybiB7bW9kdWxlOm9sL0ltYWdlU3RhdGV9IEltYWdlIHN0YXRlLlxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldEltYWdlU3RhdGUgPSBmdW5jdGlvbiBnZXRJbWFnZVN0YXRlICgpIHt9O1xuXG4vKipcbiogQGFic3RyYWN0XG4qIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IEltYWdlIHNpemUuXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplICgpIHt9O1xuXG4vKipcbiogQGFic3RyYWN0XG4qIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFNpemUgb2YgdGhlIGhpdC1kZXRlY3Rpb24gaW1hZ2UuXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SGl0RGV0ZWN0aW9uSW1hZ2VTaXplICgpIHt9O1xuXG4vKipcbiogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4qIEBhYnN0cmFjdFxuKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gT3JpZ2luLlxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7fTtcblxuLyoqXG4qIEdldCB0aGUgc2l6ZSBvZiB0aGUgc3ltYm9saXplciAoaW4gcGl4ZWxzKS5cbiogQGFic3RyYWN0XG4qIEByZXR1cm4ge21vZHVsZTpvbC9zaXplflNpemV9IFNpemUuXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge307XG5cbi8qKlxuKiBTZXQgdGhlIG9wYWNpdHkuXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4qIEBhcGlcbiovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gc2V0T3BhY2l0eSAob3BhY2l0eSkge1xuICB0aGlzLm9wYWNpdHlfID0gb3BhY2l0eTtcbn07XG5cbi8qKlxuKiBTZXQgd2hldGhlciB0byByb3RhdGUgdGhlIHN0eWxlIHdpdGggdGhlIHZpZXcuXG4qXG4qIEBwYXJhbSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXcgUm90YXRlIHdpdGggbWFwLlxuKiBAYXBpXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUuc2V0Um90YXRlV2l0aFZpZXcgPSBmdW5jdGlvbiBzZXRSb3RhdGVXaXRoVmlldyAocm90YXRlV2l0aFZpZXcpIHtcbiAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbn07XG5cbi8qKlxuKiBTZXQgdGhlIHJvdGF0aW9uLlxuKlxuKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4qIEBhcGlcbiovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uIChyb3RhdGlvbikge1xuICB0aGlzLnJvdGF0aW9uXyA9IHJvdGF0aW9uO1xufTtcblxuLyoqXG4qIFNldCB0aGUgc2NhbGUuXG4qXG4qIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZS5cbiogQGFwaVxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHNjYWxlKSB7XG4gIHRoaXMuc2NhbGVfID0gc2NhbGU7XG59O1xuXG4vKipcbiogU2V0IHdoZXRoZXIgdG8gc25hcCB0aGUgaW1hZ2UgdG8gdGhlIGNsb3Nlc3QgcGl4ZWwuXG4qXG4qIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCB0byBwaXhlbD9cbiogQGFwaVxuKi9cbkltYWdlU3R5bGUucHJvdG90eXBlLnNldFNuYXBUb1BpeGVsID0gZnVuY3Rpb24gc2V0U25hcFRvUGl4ZWwgKHNuYXBUb1BpeGVsKSB7XG4gIHRoaXMuc25hcFRvUGl4ZWxfID0gc25hcFRvUGl4ZWw7XG59O1xuXG4vKipcbiogQGFic3RyYWN0XG4qIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgbW9kdWxlOm9sL2V2ZW50cy9FdmVudCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuKiBAcGFyYW0ge1R9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGlzdGVuZXJgLlxuKiBAcmV0dXJuIHttb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleXx1bmRlZmluZWR9IExpc3RlbmVyIGtleS5cbiogQHRlbXBsYXRlIFRcbiovXG5JbWFnZVN0eWxlLnByb3RvdHlwZS5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIGxpc3RlbkltYWdlQ2hhbmdlIChsaXN0ZW5lciwgdGhpc0FyZykge307XG5cbi8qKlxuKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiogQGFic3RyYWN0XG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKCkge307XG5cbi8qKlxuKiBAYWJzdHJhY3RcbiogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50KX0gbGlzdGVuZXIgTGlzdGVuZXIgZnVuY3Rpb24uXG4qIEBwYXJhbSB7VH0gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsaXN0ZW5lcmAuXG4qIEB0ZW1wbGF0ZSBUXG4qL1xuSW1hZ2VTdHlsZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIHVubGlzdGVuSW1hZ2VDaGFuZ2UgKGxpc3RlbmVyLCB0aGlzQXJnKSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VTdHlsZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2UuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1JlZ3VsYXJTaGFwZVxuICovXG5cbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Q0FOVkFTX0xJTkVfREFTSH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRGaWxsU3R5bGUsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRNaXRlckxpbWl0fSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4uL3N0eWxlL0ltYWdlLmpzJztcblxuXG4vKipcbiAqIFNwZWNpZnkgcmFkaXVzIGZvciByZWd1bGFyIHBvbHlnb25zLCBvciByYWRpdXMxIGFuZCByYWRpdXMyIGZvciBzdGFycy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL0ZpbGx9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBvaW50cyBOdW1iZXIgb2YgcG9pbnRzIGZvciBzdGFycyBhbmQgcmVndWxhciBwb2x5Z29ucy4gSW4gY2FzZSBvZiBhIHBvbHlnb24sIHRoZSBudW1iZXIgb2YgcG9pbnRzXG4gKiBpcyB0aGUgbnVtYmVyIG9mIHNpZGVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXNdIFJhZGl1cyBvZiBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMV0gT3V0ZXIgcmFkaXVzIG9mIGEgc3Rhci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzMl0gSW5uZXIgcmFkaXVzIG9mIGEgc3Rhci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYW5nbGU9MF0gU2hhcGUncyBhbmdsZSBpbiByYWRpYW5zLiBBIHZhbHVlIG9mIDAgd2lsbCBoYXZlIG9uZSBvZiB0aGUgc2hhcGUncyBwb2ludCBmYWNpbmcgdXAuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzbmFwVG9QaXhlbD10cnVlXSBJZiBgdHJ1ZWAgaW50ZWdyYWwgbnVtYmVycyBvZiBwaXhlbHMgYXJlIHVzZWQgYXMgdGhlIFggYW5kIFkgcGl4ZWwgY29vcmRpbmF0ZVxuICogd2hlbiBkcmF3aW5nIHRoZSBzaGFwZSBpbiB0aGUgb3V0cHV0IGNhbnZhcy4gSWYgYGZhbHNlYCBmcmFjdGlvbmFsIG51bWJlcnMgbWF5IGJlIHVzZWQuIFVzaW5nIGB0cnVlYCBhbGxvd3MgZm9yXG4gKiBcInNoYXJwXCIgcmVuZGVyaW5nIChubyBibHVyKSwgd2hpbGUgdXNpbmcgYGZhbHNlYCBhbGxvd3MgZm9yIFwiYWNjdXJhdGVcIiByZW5kZXJpbmcuIE5vdGUgdGhhdCBhY2N1cmFjeSBpcyBpbXBvcnRhbnQgaWZcbiAqIHRoZSBzaGFwZSdzIHBvc2l0aW9uIGlzIGFuaW1hdGVkLiBXaXRob3V0IGl0LCB0aGUgc2hhcGUgbWF5IGppdHRlciBub3RpY2VhYmx5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3Ryb2tlfSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFJvdGF0aW9uIGluIHJhZGlhbnMgKHBvc2l0aXZlIHJvdGF0aW9uIGNsb2Nrd2lzZSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyb3RhdGVXaXRoVmlldz1mYWxzZV0gV2hldGhlciB0byByb3RhdGUgdGhlIHNoYXBlIHdpdGggdGhlIHZpZXcuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zdHlsZS9BdGxhc01hbmFnZXJ9IFthdGxhc01hbmFnZXJdIFRoZSBhdGxhcyBtYW5hZ2VyIHRvIHVzZSBmb3IgdGhpcyBzeW1ib2wuIFdoZW5cbiAqIHVzaW5nIFdlYkdMIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhbiBhdGxhcyBtYW5hZ2VyIHRvIGF2b2lkIHRleHR1cmUgc3dpdGNoaW5nLiBJZiBhbiBhdGxhcyBtYW5hZ2VyIGlzIGdpdmVuLCB0aGVcbiAqIHN5bWJvbCBpcyBhZGRlZCB0byBhbiBhdGxhcy4gQnkgZGVmYXVsdCBubyBhdGxhcyBtYW5hZ2VyIGlzIHVzZWQuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlbmRlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9ybGlrZX5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lQ2FwXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBsaW5lRGFzaFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVEYXNoT2Zmc2V0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGluZUpvaW5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaXRlckxpbWl0XG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFNldCByZWd1bGFyIHNoYXBlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuIFRoZSByZXN1bHRpbmcgc2hhcGUgd2lsbCBiZVxuICogYSByZWd1bGFyIHBvbHlnb24gd2hlbiBgcmFkaXVzYCBpcyBwcm92aWRlZCwgb3IgYSBzdGFyIHdoZW4gYHJhZGl1czFgIGFuZFxuICogYHJhZGl1czJgIGFyZSBwcm92aWRlZC5cbiAqIEBhcGlcbiAqL1xudmFyIFJlZ3VsYXJTaGFwZSA9IChmdW5jdGlvbiAoSW1hZ2VTdHlsZSkge1xuICBmdW5jdGlvbiBSZWd1bGFyU2hhcGUob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciBzbmFwVG9QaXhlbCA9IG9wdGlvbnMuc25hcFRvUGl4ZWwgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnNuYXBUb1BpeGVsIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHZhciByb3RhdGVXaXRoVmlldyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3IDogZmFsc2U7XG5cbiAgICBJbWFnZVN0eWxlLmNhbGwodGhpcywge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlldyxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJvdGF0aW9uIDogMCxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgc25hcFRvUGl4ZWw6IHNuYXBUb1BpeGVsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrc3Vtc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jYW52YXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc3R5bGUvRmlsbH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxfID0gb3B0aW9ucy5maWxsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZpbGwgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IG9wdGlvbnMucG9pbnRzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXNfID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLnJhZGl1cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmFkaXVzIDogb3B0aW9ucy5yYWRpdXMxKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMyXyA9IG9wdGlvbnMucmFkaXVzMjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlXyA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bW9kdWxlOm9sL3N0eWxlL1N0cm9rZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9zaXplflNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9BdGxhc01hbmFnZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuYXRsYXNNYW5hZ2VyXyA9IG9wdGlvbnMuYXRsYXNNYW5hZ2VyO1xuXG4gICAgdGhpcy5yZW5kZXJfKHRoaXMuYXRsYXNNYW5hZ2VyXyk7XG5cbiAgfVxuXG4gIGlmICggSW1hZ2VTdHlsZSApIFJlZ3VsYXJTaGFwZS5fX3Byb3RvX18gPSBJbWFnZVN0eWxlO1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW1hZ2VTdHlsZSAmJiBJbWFnZVN0eWxlLnByb3RvdHlwZSApO1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVndWxhclNoYXBlO1xuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLiBJZiBhbiBhdGxhc21hbmFnZXIgd2FzIHByb3ZpZGVkIHRvIHRoZSBvcmlnaW5hbCBzdHlsZSBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNsb25lZCBzdHlsZSwgdG9vLlxuICAgKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBzdHlsZSA9IG5ldyBSZWd1bGFyU2hhcGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcG9pbnRzOiB0aGlzLmdldFBvaW50cygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgcmFkaXVzMjogdGhpcy5nZXRSYWRpdXMyKCksXG4gICAgICBhbmdsZTogdGhpcy5nZXRBbmdsZSgpLFxuICAgICAgc25hcFRvUGl4ZWw6IHRoaXMuZ2V0U25hcFRvUGl4ZWwoKSxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgYXRsYXNNYW5hZ2VyOiB0aGlzLmF0bGFzTWFuYWdlcl9cbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICBzdHlsZS5zZXRTY2FsZSh0aGlzLmdldFNjYWxlKCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRBbmNob3IgPSBmdW5jdGlvbiBnZXRBbmNob3IgKCkge1xuICAgIHJldHVybiB0aGlzLmFuY2hvcl87XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5nbGUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBTaGFwZSdzIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0QW5nbGUgPSBmdW5jdGlvbiBnZXRBbmdsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5nbGVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL0ZpbGx9IEZpbGwgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0RmlsbCA9IGZ1bmN0aW9uIGdldEZpbGwgKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZSA9IGZ1bmN0aW9uIGdldEhpdERldGVjdGlvbkltYWdlIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uIGdldEltYWdlIChwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplID0gZnVuY3Rpb24gZ2V0SW1hZ2VTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVNpemVfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5nZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgPSBmdW5jdGlvbiBnZXRIaXREZXRlY3Rpb25JbWFnZVNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldEltYWdlU3RhdGUgPSBmdW5jdGlvbiBnZXRJbWFnZVN0YXRlICgpIHtcbiAgICByZXR1cm4gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBwb2ludHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSAocHJpbWFyeSkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmFkaXVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFJhZGl1cyA9IGZ1bmN0aW9uIGdldFJhZGl1cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzZWNvbmRhcnkgcmFkaXVzIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJhZGl1czIuXG4gICAqIEBhcGlcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuZ2V0UmFkaXVzMiA9IGZ1bmN0aW9uIGdldFJhZGl1czIgKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1czJfO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiBnZXRTaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0cm9rZX0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldFN0cm9rZSA9IGZ1bmN0aW9uIGdldFN0cm9rZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUubGlzdGVuSW1hZ2VDaGFuZ2UgPSBmdW5jdGlvbiBsaXN0ZW5JbWFnZUNoYW5nZSAobGlzdGVuZXIsIHRoaXNBcmcpIHt9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZCAoKSB7fTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUudW5saXN0ZW5JbWFnZUNoYW5nZSA9IGZ1bmN0aW9uIHVubGlzdGVuSW1hZ2VDaGFuZ2UgKGxpc3RlbmVyLCB0aGlzQXJnKSB7fTtcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9BdGxhc01hbmFnZXJ8dW5kZWZpbmVkfSBhdGxhc01hbmFnZXIgQW4gYXRsYXMgbWFuYWdlci5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUucmVuZGVyXyA9IGZ1bmN0aW9uIHJlbmRlcl8gKGF0bGFzTWFuYWdlcikge1xuICAgIHZhciBpbWFnZVNpemU7XG4gICAgdmFyIGxpbmVDYXAgPSAnJztcbiAgICB2YXIgbGluZUpvaW4gPSAnJztcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IDA7XG4gICAgdmFyIGxpbmVEYXNoID0gbnVsbDtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHZhciBzdHJva2VTdHlsZTtcbiAgICB2YXIgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZV8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHJva2VTdHlsZSA9IGRlZmF1bHRTdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGUpO1xuICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZV8uZ2V0V2lkdGgoKTtcbiAgICAgIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGxpbmVEYXNoID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgaWYgKCFDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICAgIGxpbmVEYXNoID0gbnVsbDtcbiAgICAgICAgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgbGluZUpvaW4gPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUpvaW4oKTtcbiAgICAgIGlmIChsaW5lSm9pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVKb2luID0gZGVmYXVsdExpbmVKb2luO1xuICAgICAgfVxuICAgICAgbGluZUNhcCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lQ2FwKCk7XG4gICAgICBpZiAobGluZUNhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVDYXAgPSBkZWZhdWx0TGluZUNhcDtcbiAgICAgIH1cbiAgICAgIG1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZV8uZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgaWYgKG1pdGVyTGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaXRlckxpbWl0ID0gZGVmYXVsdE1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpemUgPSAyICogKHRoaXMucmFkaXVzXyArIHN0cm9rZVdpZHRoKSArIDE7XG5cbiAgICAvKiogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9SZWd1bGFyU2hhcGV+UmVuZGVyT3B0aW9uc30gKi9cbiAgICB2YXIgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdFxuICAgIH07XG5cbiAgICBpZiAoYXRsYXNNYW5hZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZCwgY3JlYXRlIGEgbmV3IGNhbnZhc1xuICAgICAgdmFyIGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoc2l6ZSwgc2l6ZSk7XG4gICAgICB0aGlzLmNhbnZhc18gPSBjb250ZXh0LmNhbnZhcztcblxuICAgICAgLy8gY2FudmFzLndpZHRoIGFuZCBoZWlnaHQgYXJlIHJvdW5kZWQgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlclxuICAgICAgc2l6ZSA9IHRoaXMuY2FudmFzXy53aWR0aDtcbiAgICAgIGltYWdlU2l6ZSA9IHNpemU7XG5cbiAgICAgIHRoaXMuZHJhd18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgMCwgMCk7XG5cbiAgICAgIHRoaXMuY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyhyZW5kZXJPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYW4gYXRsYXMgbWFuYWdlciBpcyB1c2VkLCBhZGQgdGhlIHN5bWJvbCB0byBhbiBhdGxhc1xuICAgICAgc2l6ZSA9IE1hdGgucm91bmQoc2l6ZSk7XG5cbiAgICAgIHZhciBoYXNDdXN0b21IaXREZXRlY3Rpb25JbWFnZSA9ICF0aGlzLmZpbGxfO1xuICAgICAgdmFyIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrO1xuICAgICAgaWYgKGhhc0N1c3RvbUhpdERldGVjdGlvbkltYWdlKSB7XG4gICAgICAgIC8vIHJlbmRlciB0aGUgaGl0LWRldGVjdGlvbiBpbWFnZSBpbnRvIGEgc2VwYXJhdGUgYXRsYXMgaW1hZ2VcbiAgICAgICAgcmVuZGVySGl0RGV0ZWN0aW9uQ2FsbGJhY2sgPVxuICAgICAgICAgICAgdGhpcy5kcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXy5iaW5kKHRoaXMsIHJlbmRlck9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSB0aGlzLmdldENoZWNrc3VtKCk7XG4gICAgICB2YXIgaW5mbyA9IGF0bGFzTWFuYWdlci5hZGQoXG4gICAgICAgIGlkLCBzaXplLCBzaXplLCB0aGlzLmRyYXdfLmJpbmQodGhpcywgcmVuZGVyT3B0aW9ucyksXG4gICAgICAgIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrKTtcblxuICAgICAgdGhpcy5jYW52YXNfID0gaW5mby5pbWFnZTtcbiAgICAgIHRoaXMub3JpZ2luXyA9IFtpbmZvLm9mZnNldFgsIGluZm8ub2Zmc2V0WV07XG4gICAgICBpbWFnZVNpemUgPSBpbmZvLmltYWdlLndpZHRoO1xuXG4gICAgICBpZiAoaGFzQ3VzdG9tSGl0RGV0ZWN0aW9uSW1hZ2UpIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfID0gaW5mby5oaXRJbWFnZTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID1cbiAgICAgICAgICAgIFtpbmZvLmhpdEltYWdlLndpZHRoLCBpbmZvLmhpdEltYWdlLmhlaWdodF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNhbnZhc187XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VTaXplXyA9IFtpbWFnZVNpemUsIGltYWdlU2l6ZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmNob3JfID0gW3NpemUgLyAyLCBzaXplIC8gMl07XG4gICAgdGhpcy5zaXplXyA9IFtzaXplLCBzaXplXTtcbiAgICB0aGlzLmltYWdlU2l6ZV8gPSBbaW1hZ2VTaXplLCBpbWFnZVNpemVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9SZWd1bGFyU2hhcGV+UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgVGhlIHJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgb3JpZ2luIGZvciB0aGUgc3ltYm9sICh4KS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIG9yaWdpbiBmb3IgdGhlIHN5bWJvbCAoeSkuXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmRyYXdfID0gZnVuY3Rpb24gZHJhd18gKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIHgsIHkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpLCBhbmdsZTAsIHJhZGl1c0M7XG4gICAgLy8gcmVzZXQgdHJhbnNmb3JtXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAvLyB0aGVuIG1vdmUgdG8gKHgsIHkpXG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzXztcbiAgICBpZiAocG9pbnRzID09PSBJbmZpbml0eSkge1xuICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIsXG4gICAgICAgIHRoaXMucmFkaXVzXywgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFkaXVzMiA9ICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpID8gdGhpcy5yYWRpdXMyX1xuICAgICAgICA6IHRoaXMucmFkaXVzXztcbiAgICAgIGlmIChyYWRpdXMyICE9PSB0aGlzLnJhZGl1c18pIHtcbiAgICAgICAgcG9pbnRzID0gMiAqIHBvaW50cztcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gcG9pbnRzOyBpKyspIHtcbiAgICAgICAgYW5nbGUwID0gaSAqIDIgKiBNYXRoLlBJIC8gcG9pbnRzIC0gTWF0aC5QSSAvIDIgKyB0aGlzJDEuYW5nbGVfO1xuICAgICAgICByYWRpdXNDID0gaSAlIDIgPT09IDAgPyB0aGlzJDEucmFkaXVzXyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuZmlsbF8pIHtcbiAgICAgIHZhciBjb2xvciA9IHRoaXMuZmlsbF8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICBjb2xvciA9IGRlZmF1bHRGaWxsU3R5bGU7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGFzQ29sb3JMaWtlKGNvbG9yKTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VfKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gcmVuZGVyT3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICAgIGlmIChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKSB7XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2gocmVuZGVyT3B0aW9ucy5saW5lRGFzaCk7XG4gICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSByZW5kZXJPcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgY29udGV4dC5saW5lQ2FwID0gcmVuZGVyT3B0aW9ucy5saW5lQ2FwO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IHJlbmRlck9wdGlvbnMubGluZUpvaW47XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSByZW5kZXJPcHRpb25zLm1pdGVyTGltaXQ7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9SZWd1bGFyU2hhcGV+UmVuZGVyT3B0aW9uc30gcmVuZGVyT3B0aW9ucyBSZW5kZXIgb3B0aW9ucy5cbiAgICovXG4gIFJlZ3VsYXJTaGFwZS5wcm90b3R5cGUuY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGZ1bmN0aW9uIGNyZWF0ZUhpdERldGVjdGlvbkNhbnZhc18gKHJlbmRlck9wdGlvbnMpIHtcbiAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV8gPSBbcmVuZGVyT3B0aW9ucy5zaXplLCByZW5kZXJPcHRpb25zLnNpemVdO1xuICAgIGlmICh0aGlzLmZpbGxfKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSB0aGlzLmNhbnZhc187XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmlsbCBzdHlsZSBpcyBzZXQsIGNyZWF0ZSBhbiBleHRyYSBoaXQtZGV0ZWN0aW9uIGltYWdlIHdpdGggYVxuICAgIC8vIGRlZmF1bHQgZmlsbCBzdHlsZVxuICAgIHZhciBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHJlbmRlck9wdGlvbnMuc2l6ZSwgcmVuZGVyT3B0aW9ucy5zaXplKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBjb250ZXh0LmNhbnZhcztcblxuICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgMCwgMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL1JlZ3VsYXJTaGFwZX5SZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG9yaWdpbiBmb3IgdGhlIHN5bWJvbCAoeCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHkpLlxuICAgKi9cbiAgUmVndWxhclNoYXBlLnByb3RvdHlwZS5kcmF3SGl0RGV0ZWN0aW9uQ2FudmFzXyA9IGZ1bmN0aW9uIGRyYXdIaXREZXRlY3Rpb25DYW52YXNfIChyZW5kZXJPcHRpb25zLCBjb250ZXh0LCB4LCB5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvLyByZXNldCB0cmFuc2Zvcm1cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIC8vIHRoZW4gbW92ZSB0byAoeCwgeSlcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHNfO1xuICAgIGlmIChwb2ludHMgPT09IEluZmluaXR5KSB7XG4gICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgcmVuZGVyT3B0aW9ucy5zaXplIC8gMiwgcmVuZGVyT3B0aW9ucy5zaXplIC8gMixcbiAgICAgICAgdGhpcy5yYWRpdXNfLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYWRpdXMyID0gKHRoaXMucmFkaXVzMl8gIT09IHVuZGVmaW5lZCkgPyB0aGlzLnJhZGl1czJfXG4gICAgICAgIDogdGhpcy5yYWRpdXNfO1xuICAgICAgaWYgKHJhZGl1czIgIT09IHRoaXMucmFkaXVzXykge1xuICAgICAgICBwb2ludHMgPSAyICogcG9pbnRzO1xuICAgICAgfVxuICAgICAgdmFyIGksIHJhZGl1c0MsIGFuZ2xlMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gcG9pbnRzOyBpKyspIHtcbiAgICAgICAgYW5nbGUwID0gaSAqIDIgKiBNYXRoLlBJIC8gcG9pbnRzIC0gTWF0aC5QSSAvIDIgKyB0aGlzJDEuYW5nbGVfO1xuICAgICAgICByYWRpdXNDID0gaSAlIDIgPT09IDAgPyB0aGlzJDEucmFkaXVzXyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICBpZiAodGhpcy5zdHJva2VfKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gcmVuZGVyT3B0aW9ucy5zdHJva2VTdHlsZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gcmVuZGVyT3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICAgIGlmIChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKSB7XG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2gocmVuZGVyT3B0aW9ucy5saW5lRGFzaCk7XG4gICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSByZW5kZXJPcHRpb25zLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2hlY2tzdW0uXG4gICAqL1xuICBSZWd1bGFyU2hhcGUucHJvdG90eXBlLmdldENoZWNrc3VtID0gZnVuY3Rpb24gZ2V0Q2hlY2tzdW0gKCkge1xuICAgIHZhciBzdHJva2VDaGVja3N1bSA9IHRoaXMuc3Ryb2tlXyA/XG4gICAgICB0aGlzLnN0cm9rZV8uZ2V0Q2hlY2tzdW0oKSA6ICctJztcbiAgICB2YXIgZmlsbENoZWNrc3VtID0gdGhpcy5maWxsXyA/XG4gICAgICB0aGlzLmZpbGxfLmdldENoZWNrc3VtKCkgOiAnLSc7XG5cbiAgICB2YXIgcmVjYWxjdWxhdGUgPSAhdGhpcy5jaGVja3N1bXNfIHx8XG4gICAgICAgIChzdHJva2VDaGVja3N1bSAhPSB0aGlzLmNoZWNrc3Vtc19bMV0gfHxcbiAgICAgICAgZmlsbENoZWNrc3VtICE9IHRoaXMuY2hlY2tzdW1zX1syXSB8fFxuICAgICAgICB0aGlzLnJhZGl1c18gIT0gdGhpcy5jaGVja3N1bXNfWzNdIHx8XG4gICAgICAgIHRoaXMucmFkaXVzMl8gIT0gdGhpcy5jaGVja3N1bXNfWzRdIHx8XG4gICAgICAgIHRoaXMuYW5nbGVfICE9IHRoaXMuY2hlY2tzdW1zX1s1XSB8fFxuICAgICAgICB0aGlzLnBvaW50c18gIT0gdGhpcy5jaGVja3N1bXNfWzZdKTtcblxuICAgIGlmIChyZWNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNoZWNrc3VtID0gJ3InICsgc3Ryb2tlQ2hlY2tzdW0gKyBmaWxsQ2hlY2tzdW0gK1xuICAgICAgICAgICh0aGlzLnJhZGl1c18gIT09IHVuZGVmaW5lZCA/IHRoaXMucmFkaXVzXy50b1N0cmluZygpIDogJy0nKSArXG4gICAgICAgICAgKHRoaXMucmFkaXVzMl8gIT09IHVuZGVmaW5lZCA/IHRoaXMucmFkaXVzMl8udG9TdHJpbmcoKSA6ICctJykgK1xuICAgICAgICAgICh0aGlzLmFuZ2xlXyAhPT0gdW5kZWZpbmVkID8gdGhpcy5hbmdsZV8udG9TdHJpbmcoKSA6ICctJykgK1xuICAgICAgICAgICh0aGlzLnBvaW50c18gIT09IHVuZGVmaW5lZCA/IHRoaXMucG9pbnRzXy50b1N0cmluZygpIDogJy0nKTtcbiAgICAgIHRoaXMuY2hlY2tzdW1zXyA9IFtjaGVja3N1bSwgc3Ryb2tlQ2hlY2tzdW0sIGZpbGxDaGVja3N1bSxcbiAgICAgICAgdGhpcy5yYWRpdXNfLCB0aGlzLnJhZGl1czJfLCB0aGlzLmFuZ2xlXywgdGhpcy5wb2ludHNfXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja3N1bXNfWzBdO1xuICB9O1xuXG4gIHJldHVybiBSZWd1bGFyU2hhcGU7XG59KEltYWdlU3R5bGUpKTtcblxuXG5leHBvcnQgZGVmYXVsdCBSZWd1bGFyU2hhcGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZ3VsYXJTaGFwZS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvU3Ryb2tlXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXA9J3JvdW5kJ10gTGluZSBjYXAgc3R5bGU6IGBidXR0YCwgYHJvdW5kYCwgb3IgYHNxdWFyZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVKb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj59IFtsaW5lRGFzaF0gTGluZSBkYXNoIHBhdHRlcm4uIERlZmF1bHQgaXMgYHVuZGVmaW5lZGAgKG5vIGRhc2gpLlxuICogUGxlYXNlIG5vdGUgdGhhdCBJbnRlcm5ldCBFeHBsb3JlciAxMCBhbmQgbG93ZXIgZG8gbm90IHN1cHBvcnQgdGhlIGBzZXRMaW5lRGFzaGAgbWV0aG9kIG9uXG4gKiB0aGUgYENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgYW5kIHRoZXJlZm9yZSB0aGlzIG9wdGlvbiB3aWxsIGhhdmUgbm8gdmlzdWFsIGVmZmVjdCBpbiB0aGVzZSBicm93c2Vycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZURhc2hPZmZzZXQ9MF0gTGluZSBkYXNoIG9mZnNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWl0ZXJMaW1pdD0xMF0gTWl0ZXIgbGltaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoXSBXaWR0aC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IHN0cm9rZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogTm90ZSB0aGF0IHRoZSBkZWZhdWx0cyBnaXZlbiBhcmUgdGhlIENhbnZhcyBkZWZhdWx0cywgd2hpY2ggd2lsbCBiZSB1c2VkIGlmXG4gKiBvcHRpb24gaXMgbm90IGRlZmluZWQuIFRoZSBgZ2V0YCBmdW5jdGlvbnMgcmV0dXJuIHdoYXRldmVyIHdhcyBlbnRlcmVkIGluXG4gKiB0aGUgb3B0aW9uczsgdGhleSB3aWxsIG5vdCByZXR1cm4gdGhlIGRlZmF1bHQuXG4gKiBAYXBpXG4gKi9cbnZhciBTdHJva2UgPSBmdW5jdGlvbiBTdHJva2Uob3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfVxuICAgKi9cbiAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmxpbmVDYXBfID0gb3B0aW9ucy5saW5lQ2FwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0aGlzLmxpbmVEYXNoXyA9IG9wdGlvbnMubGluZURhc2ggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGluZURhc2ggOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMubGluZURhc2hPZmZzZXRfID0gb3B0aW9ucy5saW5lRGFzaE9mZnNldDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLmxpbmVKb2luXyA9IG9wdGlvbnMubGluZUpvaW47XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5taXRlckxpbWl0XyA9IG9wdGlvbnMubWl0ZXJMaW1pdDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLndpZHRoXyA9IG9wdGlvbnMud2lkdGg7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKi9cbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgc3R5bGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvU3Ryb2tlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICB2YXIgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gIHJldHVybiBuZXcgU3Ryb2tlKHtcbiAgICBjb2xvcjogKGNvbG9yICYmIGNvbG9yLnNsaWNlKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgbGluZUNhcDogdGhpcy5nZXRMaW5lQ2FwKCksXG4gICAgbGluZURhc2g6IHRoaXMuZ2V0TGluZURhc2goKSA/IHRoaXMuZ2V0TGluZURhc2goKS5zbGljZSgpIDogdW5kZWZpbmVkLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLmdldExpbmVEYXNoT2Zmc2V0KCksXG4gICAgbGluZUpvaW46IHRoaXMuZ2V0TGluZUpvaW4oKSxcbiAgICBtaXRlckxpbWl0OiB0aGlzLmdldE1pdGVyTGltaXQoKSxcbiAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0cm9rZSBjb2xvci5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9jb2xvcn5Db2xvcnxtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gQ29sb3IuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb2xvciAoKSB7XG4gIHJldHVybiB0aGlzLmNvbG9yXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gTGluZSBjYXAuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TGluZUNhcCA9IGZ1bmN0aW9uIGdldExpbmVDYXAgKCkge1xuICByZXR1cm4gdGhpcy5saW5lQ2FwXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGRhc2ggc3R5bGUgZm9yIHRoZSBzdHJva2UuXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gTGluZSBkYXNoLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLmdldExpbmVEYXNoID0gZnVuY3Rpb24gZ2V0TGluZURhc2ggKCkge1xuICByZXR1cm4gdGhpcy5saW5lRGFzaF87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGluZSBkYXNoIG9mZnNldCBmb3IgdGhlIHN0cm9rZS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IExpbmUgZGFzaCBvZmZzZXQuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbiBnZXRMaW5lRGFzaE9mZnNldCAoKSB7XG4gIHJldHVybiB0aGlzLmxpbmVEYXNoT2Zmc2V0Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaW5lIGpvaW4gdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IExpbmUgam9pbi5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRMaW5lSm9pbiA9IGZ1bmN0aW9uIGdldExpbmVKb2luICgpIHtcbiAgcmV0dXJuIHRoaXMubGluZUpvaW5fO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG1pdGVyIGxpbWl0IGZvciB0aGUgc3Ryb2tlLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTWl0ZXIgbGltaXQuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0TWl0ZXJMaW1pdCA9IGZ1bmN0aW9uIGdldE1pdGVyTGltaXQgKCkge1xuICByZXR1cm4gdGhpcy5taXRlckxpbWl0Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHJva2Ugd2lkdGguXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBXaWR0aC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGhfO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbG9yLlxuICpcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2NvbG9yfkNvbG9yfG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uIHNldENvbG9yIChjb2xvcikge1xuICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBsaW5lIGNhcC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGxpbmVDYXAgTGluZSBjYXAuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TGluZUNhcCA9IGZ1bmN0aW9uIHNldExpbmVDYXAgKGxpbmVDYXApIHtcbiAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGxpbmUgZGFzaC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCBsb3dlciBbZG8gbm90IHN1cHBvcnRdW21kbl0gdGhlXG4gKiBgc2V0TGluZURhc2hgIG1ldGhvZCBvbiB0aGUgYENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgYW5kIHRoZXJlZm9yZSB0aGlzXG4gKiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gdmlzdWFsIGVmZmVjdCBpbiB0aGVzZSBicm93c2Vycy5cbiAqXG4gKiBbbWRuXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9zZXRMaW5lRGFzaCNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBsaW5lRGFzaCBMaW5lIGRhc2guXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TGluZURhc2ggPSBmdW5jdGlvbiBzZXRMaW5lRGFzaCAobGluZURhc2gpIHtcbiAgdGhpcy5saW5lRGFzaF8gPSBsaW5lRGFzaDtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGluZSBkYXNoIG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGxpbmVEYXNoT2Zmc2V0IExpbmUgZGFzaCBvZmZzZXQuXG4gKiBAYXBpXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuc2V0TGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbiBzZXRMaW5lRGFzaE9mZnNldCAobGluZURhc2hPZmZzZXQpIHtcbiAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBsaW5lRGFzaE9mZnNldDtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGluZSBqb2luLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGluZUpvaW4gTGluZSBqb2luLlxuICogQGFwaVxuICovXG5TdHJva2UucHJvdG90eXBlLnNldExpbmVKb2luID0gZnVuY3Rpb24gc2V0TGluZUpvaW4gKGxpbmVKb2luKSB7XG4gIHRoaXMubGluZUpvaW5fID0gbGluZUpvaW47XG4gIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pdGVyIGxpbWl0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gbWl0ZXJMaW1pdCBNaXRlciBsaW1pdC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRNaXRlckxpbWl0ID0gZnVuY3Rpb24gc2V0TWl0ZXJMaW1pdCAobWl0ZXJMaW1pdCkge1xuICB0aGlzLm1pdGVyTGltaXRfID0gbWl0ZXJMaW1pdDtcbiAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgd2lkdGguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSB3aWR0aCBXaWR0aC5cbiAqIEBhcGlcbiAqL1xuU3Ryb2tlLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uIHNldFdpZHRoICh3aWR0aCkge1xuICB0aGlzLndpZHRoXyA9IHdpZHRoO1xuICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2hlY2tzdW0uXG4gKi9cblN0cm9rZS5wcm90b3R5cGUuZ2V0Q2hlY2tzdW0gPSBmdW5jdGlvbiBnZXRDaGVja3N1bSAoKSB7XG4gIGlmICh0aGlzLmNoZWNrc3VtXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5jaGVja3N1bV8gPSAncyc7XG4gICAgaWYgKHRoaXMuY29sb3JfKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY29sb3JfID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmNoZWNrc3VtXyArPSB0aGlzLmNvbG9yXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW1fICs9IGdldFVpZCh0aGlzLmNvbG9yXykudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja3N1bV8gKz0gJy0nO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrc3VtXyArPSAnLCcgK1xuICAgICAgICAodGhpcy5saW5lQ2FwXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmxpbmVDYXBfLnRvU3RyaW5nKCkgOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMubGluZURhc2hfID9cbiAgICAgICAgICB0aGlzLmxpbmVEYXNoXy50b1N0cmluZygpIDogJy0nKSArICcsJyArXG4gICAgICAgICh0aGlzLmxpbmVEYXNoT2Zmc2V0XyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA6ICctJykgKyAnLCcgK1xuICAgICAgICAodGhpcy5saW5lSm9pbl8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGhpcy5saW5lSm9pbl8gOiAnLScpICsgJywnICtcbiAgICAgICAgKHRoaXMubWl0ZXJMaW1pdF8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGhpcy5taXRlckxpbWl0Xy50b1N0cmluZygpIDogJy0nKSArICcsJyArXG4gICAgICAgICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0aGlzLndpZHRoXy50b1N0cmluZygpIDogJy0nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNoZWNrc3VtXztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0cm9rZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Ryb2tlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHlsZVxuICovXG5cbi8qKlxuICogRmVhdHVyZSBzdHlsZXMuXG4gKlxuICogSWYgbm8gc3R5bGUgaXMgZGVmaW5lZCwgdGhlIGZvbGxvd2luZyBkZWZhdWx0IHN0eWxlIGlzIHVzZWQ6XG4gKiBgYGBqc1xuICogIGltcG9ydCB7RmlsbCwgU3Ryb2tlLCBDaXJjbGUsIFN0eWxlfSBmcm9tICdvbC9zdHlsZSc7XG4gKlxuICogIHZhciBmaWxsID0gbmV3IEZpbGwoe1xuICogICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknXG4gKiAgfSk7XG4gKiAgdmFyIHN0cm9rZSA9IG5ldyBTdHJva2Uoe1xuICogICAgY29sb3I6ICcjMzM5OUNDJyxcbiAqICAgIHdpZHRoOiAxLjI1XG4gKiAgfSk7XG4gKiAgdmFyIHN0eWxlcyA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICBmaWxsOiBmaWxsLFxuICogICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICogICAgICAgIHJhZGl1czogNVxuICogICAgICB9KSxcbiAqICAgICAgZmlsbDogZmlsbCxcbiAqICAgICAgc3Ryb2tlOiBzdHJva2VcbiAqICAgIH0pXG4gKiAgXTtcbiAqIGBgYFxuICpcbiAqIEEgc2VwYXJhdGUgZWRpdGluZyBzdHlsZSBoYXMgdGhlIGZvbGxvd2luZyBkZWZhdWx0czpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtGaWxsLCBTdHJva2UsIENpcmNsZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlJztcbiAqICBpbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJ29sL2dlb20vR2VvbWV0cnlUeXBlJztcbiAqXG4gKiAgdmFyIHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICogIHZhciBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAqICB2YXIgd2lkdGggPSAzO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgY29sb3I6IFsyNTUsIDI1NSwgMjU1LCAwLjVdXG4gKiAgICAgIH0pXG4gKiAgICB9KVxuICogIF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10gPSBbXG4gKiAgICBuZXcgU3R5bGUoe1xuICogICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICogICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGggKyAyXG4gKiAgICAgIH0pXG4gKiAgICB9KSxcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IGJsdWUsXG4gKiAgICAgICAgd2lkdGg6IHdpZHRoXG4gKiAgICAgIH0pXG4gKiAgICB9KVxuICogIF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklOR10gPVxuICogICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlKHtcbiAqICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAqICAgICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gKiAgICAgICAgICBjb2xvcjogYmx1ZVxuICogICAgICAgIH0pLFxuICogICAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gKiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyXG4gKiAgICAgICAgfSlcbiAqICAgICAgfSksXG4gKiAgICAgIHpJbmRleDogSW5maW5pdHlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTl0gPVxuICogICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dLmNvbmNhdChcbiAqICAgICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddLFxuICogICAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF1cbiAqICAgICAgKTtcbiAqIGBgYFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBDaXJjbGVTdHlsZSBmcm9tICcuLi9zdHlsZS9DaXJjbGUuanMnO1xuaW1wb3J0IEZpbGwgZnJvbSAnLi4vc3R5bGUvRmlsbC5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4uL3N0eWxlL1N0cm9rZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfSBhbmQgYSBge251bWJlcn1gXG4gKiByZXByZXNlbnRpbmcgdGhlIHZpZXcncyByZXNvbHV0aW9uLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBvciBhbiBhcnJheSBvZiB0aGVtLiBUaGlzIHdheSBlLmcuIGFcbiAqIHZlY3RvciBsYXllciBjYW4gYmUgc3R5bGVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlKSwgbnVtYmVyKTpcbiAqICAgICAobW9kdWxlOm9sL3N0eWxlL1N0eWxlfEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+KX0gU3R5bGVGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJucyBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIHN0eWxlZCBmb3IgdGhlIGZlYXR1cmUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChtb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUpKTpcbiAqICAgICAobW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfHVuZGVmaW5lZCl9IEdlb21ldHJ5RnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLiBUYWtlcyB0d28gYXJndW1lbnRzOlxuICpcbiAqIDEuIFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkgaW4gR2VvSlNPTiBub3RhdGlvbi5cbiAqIDIuIFRoZSB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlcn5TdGF0ZX0gb2YgdGhlIGxheWVyIHJlbmRlcmVyLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigobW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZXxBcnJheTxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPnxBcnJheS48QXJyYXkuPG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGU+PiksbW9kdWxlOm9sL3JlbmRlcn5TdGF0ZSl9XG4gKiBSZW5kZXJGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+R2VvbWV0cnlGdW5jdGlvbn0gW2dlb21ldHJ5XSBGZWF0dXJlIHByb3BlcnR5IG9yIGdlb21ldHJ5XG4gKiBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXIgZm9yIHRoaXMgc3R5bGUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zdHlsZS9GaWxsfSBbZmlsbF0gRmlsbCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm9sL3N0eWxlL0ltYWdlfSBbaW1hZ2VdIEltYWdlIHN0eWxlLlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+UmVuZGVyRnVuY3Rpb259IFtyZW5kZXJlcl0gQ3VzdG9tIHJlbmRlcmVyLiBXaGVuIGNvbmZpZ3VyZWQsIGBmaWxsYCwgYHN0cm9rZWAgYW5kIGBpbWFnZWAgd2lsbCBiZVxuICogaWdub3JlZCwgYW5kIHRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGVhY2ggcmVuZGVyIGZyYW1lIGZvciBlYWNoIGdlb21ldHJ5LlxuICogQHByb3BlcnR5IHttb2R1bGU6b2wvc3R5bGUvU3Ryb2tlfSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9zdHlsZS9UZXh0fSBbdGV4dF0gVGV4dCBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBaIGluZGV4LlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250YWluZXIgZm9yIHZlY3RvciBmZWF0dXJlIHJlbmRlcmluZyBzdHlsZXMuIEFueSBjaGFuZ2VzIG1hZGUgdG8gdGhlIHN0eWxlXG4gKiBvciBpdHMgY2hpbGRyZW4gdGhyb3VnaCBgc2V0KigpYCBtZXRob2RzIHdpbGwgbm90IHRha2UgZWZmZWN0IHVudGlsIHRoZVxuICogZmVhdHVyZSBvciBsYXllciB0aGF0IHVzZXMgdGhlIHN0eWxlIGlzIHJlLXJlbmRlcmVkLlxuICogQGFwaVxuICovXG52YXIgU3R5bGUgPSBmdW5jdGlvbiBTdHlsZShvcHRfb3B0aW9ucykge1xuXG4gIHZhciBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtzdHJpbmd8bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3N0eWxlL1N0eWxlfkdlb21ldHJ5RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLmdlb21ldHJ5XyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshbW9kdWxlOm9sL3N0eWxlL1N0eWxlfkdlb21ldHJ5RnVuY3Rpb259XG4gICAqL1xuICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG5cbiAgaWYgKG9wdGlvbnMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2V0R2VvbWV0cnkob3B0aW9ucy5nZW9tZXRyeSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9GaWxsfVxuICAgKi9cbiAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHttb2R1bGU6b2wvc3R5bGUvSW1hZ2V9XG4gICAgICovXG4gIHRoaXMuaW1hZ2VfID0gb3B0aW9ucy5pbWFnZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbWFnZSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICovXG4gIHRoaXMucmVuZGVyZXJfID0gb3B0aW9ucy5yZW5kZXJlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJlciA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvc3R5bGUvU3Ryb2tlfVxuICAgKi9cbiAgdGhpcy5zdHJva2VfID0gb3B0aW9ucy5zdHJva2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3Ryb2tlIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9zdHlsZS9UZXh0fVxuICAgKi9cbiAgdGhpcy50ZXh0XyA9IG9wdGlvbnMudGV4dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZXh0IDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICB0aGlzLnpJbmRleF8gPSBvcHRpb25zLnpJbmRleDtcblxufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIHN0eWxlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgaWYgKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmNsb25lKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICB9XG4gIHJldHVybiBuZXcgU3R5bGUoe1xuICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICBmaWxsOiB0aGlzLmdldEZpbGwoKSA/IHRoaXMuZ2V0RmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgaW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoKSA/IHRoaXMuZ2V0SW1hZ2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB0aGlzLmdldFRleHQoKSA/IHRoaXMuZ2V0VGV4dCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgekluZGV4OiB0aGlzLmdldFpJbmRleCgpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiB0aGF0IHdhcyBjb25maWd1cmVkIHdpdGhcbiAqIHtAbGluayAjc2V0UmVuZGVyZXJ9IG9yIHRoZSBgcmVuZGVyZXJgIGNvbnN0cnVjdG9yIG9wdGlvbi5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9TdHlsZX5SZW5kZXJGdW5jdGlvbnxudWxsfSBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uIGdldFJlbmRlcmVyICgpIHtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXJfO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uIGZvciB0aGlzIHN0eWxlLiBXaGVuIHNldCwgYGZpbGxgLCBgc3Ryb2tlYFxuICogYW5kIGBpbWFnZWAgb3B0aW9ucyBvZiB0aGUgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+UmVuZGVyRnVuY3Rpb258bnVsbH0gcmVuZGVyZXIgQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0UmVuZGVyZXIgPSBmdW5jdGlvbiBzZXRSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgdGhpcy5yZW5kZXJlcl8gPSByZW5kZXJlcjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBnZW9tZXRyeSB0byBiZSByZW5kZXJlZC5cbiAqIEByZXR1cm4ge3N0cmluZ3xtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvc3R5bGUvU3R5bGV+R2VvbWV0cnlGdW5jdGlvbn1cbiAqIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBnZW9tZXRyeSB0aGF0IHdpbGxcbiAqIGJlIHJlbmRlcmVkIHdpdGggdGhpcyBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICByZXR1cm4gdGhpcy5nZW9tZXRyeV87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSBhIGdlb21ldHJ5IGZvciByZW5kZXJpbmcuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3N0eWxlL1N0eWxlfkdlb21ldHJ5RnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlXG4gKiBhbmQgcmV0dXJucyB0aGUgZ2VvbWV0cnkgdG8gcmVuZGVyIGluc3RlYWQgb2YgdGhlIGZlYXR1cmUncyBnZW9tZXRyeS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLmdldEdlb21ldHJ5RnVuY3Rpb24gPSBmdW5jdGlvbiBnZXRHZW9tZXRyeUZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl87XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZmlsbCBzdHlsZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9GaWxsfSBGaWxsIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0RmlsbCA9IGZ1bmN0aW9uIGdldEZpbGwgKCkge1xuICByZXR1cm4gdGhpcy5maWxsXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBmaWxsIHN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvRmlsbH0gZmlsbCBGaWxsIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0RmlsbCA9IGZ1bmN0aW9uIHNldEZpbGwgKGZpbGwpIHtcbiAgdGhpcy5maWxsXyA9IGZpbGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvSW1hZ2V9IEltYWdlIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiBnZXRJbWFnZSAoKSB7XG4gIHJldHVybiB0aGlzLmltYWdlXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3N0eWxlL0ltYWdlfSBpbWFnZSBJbWFnZSBzdHlsZS5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldEltYWdlID0gZnVuY3Rpb24gc2V0SW1hZ2UgKGltYWdlKSB7XG4gIHRoaXMuaW1hZ2VfID0gaW1hZ2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL3N0eWxlL1N0cm9rZX0gU3Ryb2tlIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0U3Ryb2tlID0gZnVuY3Rpb24gZ2V0U3Ryb2tlICgpIHtcbiAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdHJva2Ugc3R5bGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9zdHlsZS9TdHJva2V9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gKiBAYXBpXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zZXRTdHJva2UgPSBmdW5jdGlvbiBzZXRTdHJva2UgKHN0cm9rZSkge1xuICB0aGlzLnN0cm9rZV8gPSBzdHJva2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGV4dCBzdHlsZS5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9zdHlsZS9UZXh0fSBUZXh0IHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQgKCkge1xuICByZXR1cm4gdGhpcy50ZXh0Xztcbn07XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0IHN0eWxlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvVGV4dH0gdGV4dCBUZXh0IHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIHNldFRleHQgKHRleHQpIHtcbiAgdGhpcy50ZXh0XyA9IHRleHQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgei1pbmRleCBmb3IgdGhlIHN0eWxlLlxuICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gWkluZGV4LlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuZ2V0WkluZGV4ID0gZnVuY3Rpb24gZ2V0WkluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuekluZGV4Xztcbn07XG5cbi8qKlxuICogU2V0IGEgZ2VvbWV0cnkgdGhhdCBpcyByZW5kZXJlZCBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl8bW9kdWxlOm9sL3N0eWxlL1N0eWxlfkdlb21ldHJ5RnVuY3Rpb259IGdlb21ldHJ5XG4gKiAgIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnkgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIGEgZ2VvbWV0cnkgdG8gcmVuZGVyXG4gKiAgIGZvciB0aGlzIHN0eWxlLlxuICogQGFwaVxuICovXG5TdHlsZS5wcm90b3R5cGUuc2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBzZXRHZW9tZXRyeSAoZ2VvbWV0cnkpIHtcbiAgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBnZW9tZXRyeTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7bW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9ICovIChmZWF0dXJlLmdldChnZW9tZXRyeSkpXG4gICAgICApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdlb21ldHJ5KSB7XG4gICAgdGhpcy5nZW9tZXRyeUZ1bmN0aW9uXyA9IGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKGdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge21vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fSAqLyAoZ2VvbWV0cnkpXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgdGhpcy5nZW9tZXRyeV8gPSBnZW9tZXRyeTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSB6LWluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gekluZGV4IFpJbmRleC5cbiAqIEBhcGlcbiAqL1xuU3R5bGUucHJvdG90eXBlLnNldFpJbmRleCA9IGZ1bmN0aW9uIHNldFpJbmRleCAoekluZGV4KSB7XG4gIHRoaXMuekluZGV4XyA9IHpJbmRleDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwcm92aWRlZCBvYmplY3QgaW50byBhIHN0eWxlIGZ1bmN0aW9uLiAgRnVuY3Rpb25zIHBhc3NlZCB0aHJvdWdoXG4gKiB1bmNoYW5nZWQuICBBcnJheXMgb2YgbW9kdWxlOm9sL3N0eWxlL1N0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWQgaW4gYVxuICogbmV3IHN0eWxlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbnxBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPnxtb2R1bGU6b2wvc3R5bGUvU3R5bGV9IG9ialxuICogICAgIEEgc3R5bGUgZnVuY3Rpb24sIGEgc2luZ2xlIHN0eWxlLCBvciBhbiBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvc3R5bGUvU3R5bGV+U3R5bGVGdW5jdGlvbn0gQSBzdHlsZSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRnVuY3Rpb24ob2JqKSB7XG4gIHZhciBzdHlsZUZ1bmN0aW9uO1xuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGVGdW5jdGlvbiA9IG9iajtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTpvbC9zdHlsZS9TdHlsZT59XG4gICAgICovXG4gICAgdmFyIHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBzdHlsZXMgPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChvYmogaW5zdGFuY2VvZiBTdHlsZSxcbiAgICAgICAgNDEpOyAvLyBFeHBlY3RlZCBhbiBgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlYCBvciBhbiBhcnJheSBvZiBgbW9kdWxlOm9sL3N0eWxlL1N0eWxlflN0eWxlYFxuICAgICAgc3R5bGVzID0gW29ial07XG4gICAgfVxuICAgIHN0eWxlRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc3R5bGVGdW5jdGlvbjtcbn1cblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPn1cbiAqL1xudmFyIGRlZmF1bHRTdHlsZXMgPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvRmVhdHVyZXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOm9sL3N0eWxlL1N0eWxlPn0gU3R5bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0U3R5bGUoZmVhdHVyZSwgcmVzb2x1dGlvbikge1xuICAvLyBXZSBkb24ndCB1c2UgYW4gaW1tZWRpYXRlbHktaW52b2tlZCBmdW5jdGlvblxuICAvLyBhbmQgYSBjbG9zdXJlIHNvIHdlIGRvbid0IGdldCBhbiBlcnJvciBhdCBzY3JpcHQgZXZhbHVhdGlvbiB0aW1lIGluXG4gIC8vIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgQ2FudmFzLiAobW9kdWxlOm9sL3N0eWxlL0NpcmNsZX5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICB2YXIgZmlsbCA9IG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJ1xuICAgIH0pO1xuICAgIHZhciBzdHJva2UgPSBuZXcgU3Ryb2tlKHtcbiAgICAgIGNvbG9yOiAnIzMzOTlDQycsXG4gICAgICB3aWR0aDogMS4yNVxuICAgIH0pO1xuICAgIGRlZmF1bHRTdHlsZXMgPSBbXG4gICAgICBuZXcgU3R5bGUoe1xuICAgICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgICAgICAgIHJhZGl1czogNVxuICAgICAgICB9KSxcbiAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0eWxlcztcbn1cblxuXG4vKipcbiAqIERlZmF1bHQgc3R5bGVzIGZvciBlZGl0aW5nIGZlYXR1cmVzLlxuICogQHJldHVybiB7T2JqZWN0Ljxtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeVR5cGUsIEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+Pn0gU3R5bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0aW5nU3R5bGUoKSB7XG4gIC8qKiBAdHlwZSB7T2JqZWN0Ljxtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeVR5cGUsIEFycmF5Ljxtb2R1bGU6b2wvc3R5bGUvU3R5bGU+Pn0gKi9cbiAgdmFyIHN0eWxlcyA9IHt9O1xuICB2YXIgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gIHZhciBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAgdmFyIHdpZHRoID0gMztcbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXSA9IFtcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV1cbiAgICAgIH0pXG4gICAgfSlcbiAgXTtcbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dO1xuXG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICBjb2xvcjogd2hpdGUsXG4gICAgICAgIHdpZHRoOiB3aWR0aCArIDJcbiAgICAgIH0pXG4gICAgfSksXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiBibHVlLFxuICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgIH0pXG4gICAgfSlcbiAgXTtcbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklOR10gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR107XG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5DSVJDTEVdID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0uY29uY2F0KFxuICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXVxuICAgICAgKTtcblxuXG4gIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBpbWFnZTogbmV3IENpcmNsZVN0eWxlKHtcbiAgICAgICAgcmFkaXVzOiB3aWR0aCAqIDIsXG4gICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAgICAgICAgICBjb2xvcjogYmx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgICBjb2xvcjogd2hpdGUsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gMlxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICB6SW5kZXg6IEluZmluaXR5XG4gICAgfSlcbiAgXTtcbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVF0gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF07XG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dLmNvbmNhdChcbiAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10sXG4gICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdXG4gICAgICApO1xuXG4gIHJldHVybiBzdHlsZXM7XG59XG5cblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGEgZmVhdHVyZSBhbmQgcmV0dXJucyBpdHMgZGVmYXVsdCBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL0ZlYXR1cmV8bW9kdWxlOm9sL3JlbmRlci9GZWF0dXJlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeXxtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmV8dW5kZWZpbmVkfSBHZW9tZXRyeSB0byByZW5kZXIuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRHZW9tZXRyeUZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgcmV0dXJuIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU3R5bGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0eWxlLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9UZXh0UGxhY2VtZW50XG4gKi9cblxuLyoqXG4gKiBUZXh0IHBsYWNlbWVudC4gT25lIG9mIGAncG9pbnQnYCwgYCdsaW5lJ2AuIERlZmF1bHQgaXMgYCdwb2ludCdgLiBOb3RlIHRoYXRcbiAqIGAnbGluZSdgIHJlcXVpcmVzIHRoZSB1bmRlcmx5aW5nIGdlb21ldHJ5IHRvIGJlIGEge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0xpbmVTdHJpbmd+TGluZVN0cmluZ30sXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vUG9seWdvbn5Qb2x5Z29ufSwge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpTGluZVN0cmluZ35NdWx0aUxpbmVTdHJpbmd9IG9yXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vTXVsdGlQb2x5Z29ufk11bHRpUG9seWdvbn0uXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5UOiAncG9pbnQnLFxuICBMSU5FOiAnbGluZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRQbGFjZW1lbnQuanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGVjb29yZFxuICovXG5cblxuLyoqXG4gKiBBbiBhcnJheSBvZiB0aHJlZSBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSB0aWxlIGluIGEgdGlsZVxuICogZ3JpZC4gVGhlIG9yZGVyIGlzIGB6YCwgYHhgLCBhbmQgYHlgLiBgemAgaXMgdGhlIHpvb20gbGV2ZWwuXG4gKiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IFRpbGVDb29yZFxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUoeiwgeCwgeSwgb3B0X3RpbGVDb29yZCkge1xuICBpZiAob3B0X3RpbGVDb29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0X3RpbGVDb29yZFswXSA9IHo7XG4gICAgb3B0X3RpbGVDb29yZFsxXSA9IHg7XG4gICAgb3B0X3RpbGVDb29yZFsyXSA9IHk7XG4gICAgcmV0dXJuIG9wdF90aWxlQ29vcmQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFt6LCB4LCB5XTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHJldHVybiB7c3RyaW5nfSBLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlaWFkoeiwgeCwgeSkge1xuICByZXR1cm4geiArICcvJyArIHggKyAnLycgKyB5O1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBrZXkgZm9yIGEgdGlsZSBjb29yZC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaGUgdGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KHRpbGVDb29yZCkge1xuICByZXR1cm4gZ2V0S2V5WlhZKHRpbGVDb29yZFswXSwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZCBnaXZlbiBhIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRpbGUgY29vcmQga2V5LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRoZSB0aWxlIGNvb3JkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIGtleS5zcGxpdCgnLycpLm1hcChOdW1iZXIpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKHRpbGVDb29yZCkge1xuICByZXR1cm4gKHRpbGVDb29yZFsxXSA8PCB0aWxlQ29vcmRbMF0pICsgdGlsZUNvb3JkWzJdO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFF1YWQga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEtleSh0aWxlQ29vcmQpIHtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF07XG4gIHZhciBkaWdpdHMgPSBuZXcgQXJyYXkoeik7XG4gIHZhciBtYXNrID0gMSA8PCAoeiAtIDEpO1xuICB2YXIgaSwgY2hhckNvZGU7XG4gIGZvciAoaSA9IDA7IGkgPCB6OyArK2kpIHtcbiAgICAvLyA0OCBpcyBjaGFyQ29kZSBmb3IgMCAtICcwJy5jaGFyQ29kZUF0KDApXG4gICAgY2hhckNvZGUgPSA0ODtcbiAgICBpZiAodGlsZUNvb3JkWzFdICYgbWFzaykge1xuICAgICAgY2hhckNvZGUgKz0gMTtcbiAgICB9XG4gICAgaWYgKHRpbGVDb29yZFsyXSAmIG1hc2spIHtcbiAgICAgIGNoYXJDb2RlICs9IDI7XG4gICAgfVxuICAgIGRpZ2l0c1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIG1hc2sgPj49IDE7XG4gIH1cbiAgcmV0dXJuIGRpZ2l0cy5qb2luKCcnKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRpbGUgY29vcmRpbmF0ZSBpcyB3aXRoaW4gZXh0ZW50IGFuZCB6b29tIGxldmVsIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aGluRXh0ZW50QW5kWih0aWxlQ29vcmQsIHRpbGVHcmlkKSB7XG4gIHZhciB6ID0gdGlsZUNvb3JkWzBdO1xuICB2YXIgeCA9IHRpbGVDb29yZFsxXTtcbiAgdmFyIHkgPSB0aWxlQ29vcmRbMl07XG5cbiAgaWYgKHRpbGVHcmlkLmdldE1pblpvb20oKSA+IHogfHwgeiA+IHRpbGVHcmlkLmdldE1heFpvb20oKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZXh0ZW50ID0gdGlsZUdyaWQuZ2V0RXh0ZW50KCk7XG4gIHZhciB0aWxlUmFuZ2U7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0RnVsbFRpbGVSYW5nZSh6KTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gIH1cbiAgaWYgKCF0aWxlUmFuZ2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZVJhbmdlLmNvbnRhaW5zWFkoeCwgeSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlsZWNvb3JkLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZFxuICovXG5pbXBvcnQge0RFRkFVTFRfTUFYX1pPT00sIERFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL3RpbGVncmlkL2NvbW1vbi5qcyc7XG5pbXBvcnQge3RvU2l6ZX0gZnJvbSAnLi9zaXplLmpzJztcbmltcG9ydCB7Y29udGFpbnNDb29yZGluYXRlLCBjcmVhdGVPclVwZGF0ZSwgZ2V0Q29ybmVyLCBnZXRIZWlnaHQsIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQgQ29ybmVyIGZyb20gJy4vZXh0ZW50L0Nvcm5lci5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi9vYmouanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgTUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgVGlsZUdyaWQgZnJvbSAnLi90aWxlZ3JpZC9UaWxlR3JpZC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IERlZmF1bHQgdGlsZSBncmlkIGZvciB0aGVcbiAqIHBhc3NlZCBwcm9qZWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHZhciB0aWxlR3JpZCA9IHByb2plY3Rpb24uZ2V0RGVmYXVsdFRpbGVHcmlkKCk7XG4gIGlmICghdGlsZUdyaWQpIHtcbiAgICB0aWxlR3JpZCA9IGNyZWF0ZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgcHJvamVjdGlvbi5zZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpO1xuICB9XG4gIHJldHVybiB0aWxlR3JpZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbikge1xuICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgdmFyIGNlbnRlciA9IHRpbGVHcmlkLmdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpO1xuICB2YXIgcHJvamVjdGlvbkV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAoIWNvbnRhaW5zQ29vcmRpbmF0ZShwcm9qZWN0aW9uRXh0ZW50LCBjZW50ZXIpKSB7XG4gICAgdmFyIHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICB2YXIgd29ybGRzQXdheSA9IE1hdGguY2VpbCgocHJvamVjdGlvbkV4dGVudFswXSAtIGNlbnRlclswXSkgLyB3b3JsZFdpZHRoKTtcbiAgICBjZW50ZXJbMF0gKz0gd29ybGRXaWR0aCAqIHdvcmxkc0F3YXk7XG4gICAgcmV0dXJuIHRpbGVHcmlkLmdldFRpbGVDb29yZEZvckNvb3JkQW5kWihjZW50ZXIsIHopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aWxlQ29vcmQ7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9tYXhab29tIE1heGltdW0gem9vbSBsZXZlbCAoZGVmYXVsdCBpc1xuICogICAgIERFRkFVTFRfTUFYX1pPT00pLlxuICogQHBhcmFtIHtudW1iZXJ8bW9kdWxlOm9sL3NpemV+U2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudC9Db3JuZXI9fSBvcHRfY29ybmVyIEV4dGVudCBjb3JuZXIgKGRlZmF1bHQgaXMgYCd0b3AtbGVmdCdgKS5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdGlsZWdyaWQvVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcikge1xuICB2YXIgY29ybmVyID0gb3B0X2Nvcm5lciAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvcm5lciA6IENvcm5lci5UT1BfTEVGVDtcblxuICB2YXIgcmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKTtcblxuICByZXR1cm4gbmV3IFRpbGVHcmlkKHtcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBvcmlnaW46IGdldENvcm5lcihleHRlbnQsIGNvcm5lciksXG4gICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zLFxuICAgIHRpbGVTaXplOiBvcHRfdGlsZVNpemVcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBYWVpPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIFRoZSBvcmlnaW4gZm9yIGFuIFhZWiB0aWxlIGdyaWQgaXMgdGhlXG4gKiB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gVGhlIHplcm8gbGV2ZWwgb2YgdGhlIGdyaWQgaXMgZGVmaW5lZCBieSB0aGUgcmVzb2x1dGlvbiBhdCB3aGljaCBvbmUgdGlsZSBmaXRzIGluIHRoZVxuICogcHJvdmlkZWQgZXh0ZW50LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBleHRlbnQgb2YgdGhlIEVQU0c6Mzg1NyBwcm9qZWN0aW9uIGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbS4gVGhlIGRlZmF1bHQgaXMgYDQyYC4gVGhpcyBkZXRlcm1pbmVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzXG4gKiBpbiB0aGUgZ3JpZCBzZXQuIEZvciBleGFtcGxlLCBhIGBtYXhab29tYCBvZiAyMSBtZWFucyB0aGVyZSBhcmUgMjIgbGV2ZWxzIGluIHRoZSBncmlkIHNldC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRpbGUgZ3JpZCB3aXRoIGEgc3RhbmRhcmQgWFlaIHRpbGluZyBzY2hlbWUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZH5YWVpPcHRpb25zPX0gb3B0X29wdGlvbnMgVGlsZSBncmlkIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSBUaWxlIGdyaWQgaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVYWVoob3B0X29wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSAvKiogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH5PcHRpb25zfSAqLyAoe30pO1xuICBhc3NpZ24ob3B0aW9ucywgb3B0X29wdGlvbnMgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X29wdGlvbnMgOiAvKiogQHR5cGUge21vZHVsZTpvbC90aWxlZ3JpZH5YWVpPcHRpb25zfSAqLyAoe30pKTtcbiAgaWYgKG9wdGlvbnMuZXh0ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmV4dGVudCA9IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuICB9XG4gIG9wdGlvbnMucmVzb2x1dGlvbnMgPSByZXNvbHV0aW9uc0Zyb21FeHRlbnQoXG4gICAgb3B0aW9ucy5leHRlbnQsIG9wdGlvbnMubWF4Wm9vbSwgb3B0aW9ucy50aWxlU2l6ZSk7XG4gIGRlbGV0ZSBvcHRpb25zLm1heFpvb207XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZChvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHJlc29sdXRpb25zIGFycmF5IGZyb20gYW4gZXh0ZW50LiAgQSB6b29tIGZhY3RvciBvZiAyIGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemU9fSBvcHRfdGlsZVNpemUgVGlsZSBzaXplIChkZWZhdWx0IHVzZXNcbiAqICAgICBERUZBVUxUX1RJTEVfU0laRSkuXG4gKiBAcmV0dXJuIHshQXJyYXkuPG51bWJlcj59IFJlc29sdXRpb25zIGFycmF5LlxuICovXG5mdW5jdGlvbiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKSB7XG4gIHZhciBtYXhab29tID0gb3B0X21heFpvb20gIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X21heFpvb20gOiBERUZBVUxUX01BWF9aT09NO1xuXG4gIHZhciBoZWlnaHQgPSBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgdmFyIHdpZHRoID0gZ2V0V2lkdGgoZXh0ZW50KTtcblxuICB2YXIgdGlsZVNpemUgPSB0b1NpemUob3B0X3RpbGVTaXplICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdF90aWxlU2l6ZSA6IERFRkFVTFRfVElMRV9TSVpFKTtcbiAgdmFyIG1heFJlc29sdXRpb24gPSBNYXRoLm1heChcbiAgICB3aWR0aCAvIHRpbGVTaXplWzBdLCBoZWlnaHQgLyB0aWxlU2l6ZVsxXSk7XG5cbiAgdmFyIGxlbmd0aCA9IG1heFpvb20gKyAxO1xuICB2YXIgcmVzb2x1dGlvbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgeiA9IDA7IHogPCBsZW5ndGg7ICsreikge1xuICAgIHJlc29sdXRpb25zW3pdID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KDIsIHopO1xuICB9XG4gIHJldHVybiByZXNvbHV0aW9ucztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2p+UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplPX0gb3B0X3RpbGVTaXplIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50L0Nvcm5lcj19IG9wdF9jb3JuZXIgRXh0ZW50IGNvcm5lciAoZGVmYXVsdCBpcyBgJ3RvcC1sZWZ0J2ApLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gVGlsZUdyaWQgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24sIG9wdF9tYXhab29tLCBvcHRfdGlsZVNpemUsIG9wdF9jb3JuZXIpIHtcbiAgdmFyIGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcik7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qflByb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW50RnJvbVByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICBwcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgdmFyIGV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gIGlmICghZXh0ZW50KSB7XG4gICAgdmFyIGhhbGYgPSAxODAgKiBNRVRFUlNfUEVSX1VOSVRbVW5pdHMuREVHUkVFU10gLyBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZSgtaGFsZiwgLWhhbGYsIGhhbGYsIGhhbGYpO1xuICB9XG4gIHJldHVybiBleHRlbnQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGVncmlkLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9UaWxlR3JpZFxuICovXG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlLCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2V9IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge2lzU29ydGVkLCBsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZ2V0VG9wTGVmdH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9XG4gKi9cbnZhciB0bXBUaWxlQ29vcmQgPSBbMCwgMCwgMF07XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV9IHNvdXJjZXMuIFdoZW4gbm8gYG9yaWdpbmAgb3JcbiAqIGBvcmlnaW5zYCBhcmUgY29uZmlndXJlZCwgdGhlIGBvcmlnaW5gIHdpbGwgYmUgc2V0IHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IFtvcmlnaW5dIFRoZSB0aWxlIGdyaWQgb3JpZ2luLCBpLmUuIHdoZXJlIHRoZSBgeGBcbiAqIGFuZCBgeWAgYXhlcyBtZWV0IChgW3osIDAsIDBdYCkuIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90XG4gKiBzcGVjaWZpZWQsIGBleHRlbnRgIG9yIGBvcmlnaW5zYCBtdXN0IGJlIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucywgaS5lLiB3aGVyZVxuICogdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheS48bnVtYmVyPn0gcmVzb2x1dGlvbnMgUmVzb2x1dGlvbnMuIFRoZSBhcnJheSBpbmRleCBvZiBlYWNoIHJlc29sdXRpb24gbmVlZHNcbiAqIHRvIG1hdGNoIHRoZSB6b29tIGxldmVsLiBUaGlzIG1lYW5zIHRoYXQgZXZlbiBpZiBhIGBtaW5ab29tYCBpcyBjb25maWd1cmVkLCB0aGUgcmVzb2x1dGlvbnNcbiAqIGFycmF5IHdpbGwgaGF2ZSBhIGxlbmd0aCBvZiBgbWF4Wm9vbSArIDFgLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL3NpemV+U2l6ZT59IFtzaXplc10gU2l6ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfSBbdGlsZVNpemVdIFRpbGUgc2l6ZS5cbiAqIERlZmF1bHQgaXMgYFsyNTYsIDI1Nl1gLlxuICogQHByb3BlcnR5IHtBcnJheS48bW9kdWxlOm9sL3NpemV+U2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc2V0dGluZyB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyB0aWxlZC1pbWFnZVxuICogc2VydmVycy5cbiAqIEBhcGlcbiAqL1xudmFyIFRpbGVHcmlkID0gZnVuY3Rpb24gVGlsZUdyaWQob3B0aW9ucykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLm1pblpvb20gPSBvcHRpb25zLm1pblpvb20gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluWm9vbSA6IDA7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG4gIGFzc2VydChpc1NvcnRlZCh0aGlzLnJlc29sdXRpb25zXywgZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYTtcbiAgfSwgdHJ1ZSksIDE3KTsgLy8gYHJlc29sdXRpb25zYCBtdXN0IGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG5cblxuICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgdmFyIHpvb21GYWN0b3I7XG4gIGlmICghb3B0aW9ucy5vcmlnaW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmICghem9vbUZhY3Rvcikge1xuICAgICAgICB6b29tRmFjdG9yID0gdGhpcyQxLnJlc29sdXRpb25zX1tpXSAvIHRoaXMkMS5yZXNvbHV0aW9uc19baSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXNvbHV0aW9uc19baV0gLyB0aGlzJDEucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgIHpvb21GYWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIHRoaXMuem9vbUZhY3Rvcl8gPSB6b29tRmFjdG9yO1xuXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMubWF4Wm9vbSA9IHRoaXMucmVzb2x1dGlvbnNfLmxlbmd0aCAtIDE7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfVxuICAgKi9cbiAgdGhpcy5vcmlnaW5fID0gb3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3JpZ2luIDogbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlPn1cbiAgICovXG4gIHRoaXMub3JpZ2luc18gPSBudWxsO1xuICBpZiAob3B0aW9ucy5vcmlnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLm9yaWdpbnNfID0gb3B0aW9ucy5vcmlnaW5zO1xuICAgIGFzc2VydCh0aGlzLm9yaWdpbnNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAyMCk7IC8vIE51bWJlciBvZiBgb3JpZ2luc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICB9XG5cbiAgdmFyIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuXG4gIGlmIChleHRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXRoaXMub3JpZ2luXyAmJiAhdGhpcy5vcmlnaW5zXykge1xuICAgIHRoaXMub3JpZ2luXyA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgfVxuXG4gIGFzc2VydChcbiAgICAoIXRoaXMub3JpZ2luXyAmJiB0aGlzLm9yaWdpbnNfKSB8fCAodGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSxcbiAgICAxOCk7IC8vIEVpdGhlciBgb3JpZ2luYCBvciBgb3JpZ2luc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemU+fVxuICAgKi9cbiAgdGhpcy50aWxlU2l6ZXNfID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMudGlsZVNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRpbGVTaXplc18gPSBvcHRpb25zLnRpbGVTaXplcztcbiAgICBhc3NlcnQodGhpcy50aWxlU2l6ZXNfLmxlbmd0aCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGgsXG4gICAgICAxOSk7IC8vIE51bWJlciBvZiBgdGlsZVNpemVzYCBhbmQgYHJlc29sdXRpb25zYCBtdXN0IGJlIGVxdWFsXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcnxtb2R1bGU6b2wvc2l6ZX5TaXplfVxuICAgKi9cbiAgdGhpcy50aWxlU2l6ZV8gPSBvcHRpb25zLnRpbGVTaXplICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudGlsZVNpemUgOlxuICAgICF0aGlzLnRpbGVTaXplc18gPyBERUZBVUxUX1RJTEVfU0laRSA6IG51bGw7XG4gIGFzc2VydChcbiAgICAoIXRoaXMudGlsZVNpemVfICYmIHRoaXMudGlsZVNpemVzXykgfHxcbiAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAyMik7IC8vIEVpdGhlciBgdGlsZVNpemVgIG9yIGB0aWxlU2l6ZXNgIG11c3QgYmUgY29uZmlndXJlZCwgbmV2ZXIgYm90aFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9XG4gICAqL1xuICB0aGlzLmV4dGVudF8gPSBleHRlbnQgIT09IHVuZGVmaW5lZCA/IGV4dGVudCA6IG51bGw7XG5cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0FycmF5Ljxtb2R1bGU6b2wvVGlsZVJhbmdlPn1cbiAgICovXG4gIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge21vZHVsZTpvbC9zaXplflNpemV9XG4gICAqL1xuICB0aGlzLnRtcFNpemVfID0gWzAsIDBdO1xuXG4gIGlmIChvcHRpb25zLnNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IG9wdGlvbnMuc2l6ZXMubWFwKGZ1bmN0aW9uKHNpemUsIHopIHtcbiAgICAgIHZhciB0aWxlUmFuZ2UgPSBuZXcgVGlsZVJhbmdlKFxuICAgICAgICBNYXRoLm1pbigwLCBzaXplWzBdKSwgTWF0aC5tYXgoc2l6ZVswXSAtIDEsIC0xKSxcbiAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVsxXSksIE1hdGgubWF4KHNpemVbMV0gLSAxLCAtMSkpO1xuICAgICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgICB9LCB0aGlzKTtcbiAgfSBlbHNlIGlmIChleHRlbnQpIHtcbiAgICB0aGlzLmNhbGN1bGF0ZVRpbGVSYW5nZXNfKGV4dGVudCk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQpfSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmZvckVhY2hUaWxlQ29vcmQgPSBmdW5jdGlvbiBmb3JFYWNoVGlsZUNvb3JkIChleHRlbnQsIHpvb20sIGNhbGxiYWNrKSB7XG4gIHZhciB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6b29tKTtcbiAgZm9yICh2YXIgaSA9IHRpbGVSYW5nZS5taW5YLCBpaSA9IHRpbGVSYW5nZS5tYXhYOyBpIDw9IGlpOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gdGlsZVJhbmdlLm1pblksIGpqID0gdGlsZVJhbmdlLm1heFk7IGogPD0gamo7ICsraikge1xuICAgICAgY2FsbGJhY2soW3pvb20sIGksIGpdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgbnVtYmVyLCBtb2R1bGU6b2wvVGlsZVJhbmdlKTogYm9vbGVhbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGNhbGxiYWNrYC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL1RpbGVSYW5nZT19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IG1vZHVsZTpvbC9UaWxlUmFuZ2Ugb2JqZWN0LlxuICogQHBhcmFtIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50IG9iamVjdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENhbGxiYWNrIHN1Y2NlZWRlZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5mb3JFYWNoVGlsZUNvb3JkUGFyZW50VGlsZVJhbmdlID0gZnVuY3Rpb24gZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZSAodGlsZUNvb3JkLCBjYWxsYmFjaywgb3B0X3RoaXMsIG9wdF90aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdGlsZVJhbmdlLCB4LCB5O1xuICB2YXIgdGlsZUNvb3JkRXh0ZW50ID0gbnVsbDtcbiAgdmFyIHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgIHggPSB0aWxlQ29vcmRbMV07XG4gICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgfSBlbHNlIHtcbiAgICB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICB9XG4gIHdoaWxlICh6ID49IHRoaXMubWluWm9vbSkge1xuICAgIGlmICh0aGlzJDEuem9vbUZhY3Rvcl8gPT09IDIpIHtcbiAgICAgIHggPSBNYXRoLmZsb29yKHggLyAyKTtcbiAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICAgIHRpbGVSYW5nZSA9IGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKHgsIHgsIHksIHksIG9wdF90aWxlUmFuZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlUmFuZ2UgPSB0aGlzJDEuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWih0aWxlQ29vcmRFeHRlbnQsIHosIG9wdF90aWxlUmFuZ2UpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2suY2FsbChvcHRfdGhpcywgeiwgdGlsZVJhbmdlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC0tejtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZCwgaWYgaXQgd2FzIGNvbmZpZ3VyZWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0RXh0ZW50ID0gZnVuY3Rpb24gZ2V0RXh0ZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50Xztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICogQHJldHVybiB7bnVtYmVyfSBNYXggem9vbS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE1heFpvb20gPSBmdW5jdGlvbiBnZXRNYXhab29tICgpIHtcbiAgcmV0dXJuIHRoaXMubWF4Wm9vbTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICogQHJldHVybiB7bnVtYmVyfSBNaW4gem9vbS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldE1pblpvb20gPSBmdW5jdGlvbiBnZXRNaW5ab29tICgpIHtcbiAgcmV0dXJuIHRoaXMubWluWm9vbTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvcmlnaW4gZm9yIHRoZSBncmlkIGF0IHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gT3JpZ2luLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICh6KSB7XG4gIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgdGhlIGdpdmVuIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24uXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbiAoeikge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc19bel07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGlzdCBvZiByZXNvbHV0aW9ucyBmb3IgdGhlIHRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBSZXNvbHV0aW9ucy5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFJlc29sdXRpb25zID0gZnVuY3Rpb24gZ2V0UmVzb2x1dGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uc187XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2U9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSBtb2R1bGU6b2wvVGlsZVJhbmdlIG9iamVjdC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZVJhbmdlfSBUaWxlIHJhbmdlLlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkQ2hpbGRUaWxlUmFuZ2UgPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZSAodGlsZUNvb3JkLCBvcHRfdGlsZVJhbmdlLCBvcHRfZXh0ZW50KSB7XG4gIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgdmFyIG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgdmFyIG1pblkgPSB0aWxlQ29vcmRbMl0gKiAyO1xuICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1pblggKyAxLCBtaW5ZLCBtaW5ZICsgMSwgb3B0X3RpbGVSYW5nZSk7XG4gICAgfVxuICAgIHZhciB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooXG4gICAgICB0aWxlQ29vcmRFeHRlbnQsIHRpbGVDb29yZFswXSArIDEsIG9wdF90aWxlUmFuZ2UpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGV4dGVudCBmb3IgYSB0aWxlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICogQHBhcmFtIHttb2R1bGU6b2wvVGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gRXh0ZW50LlxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZVJhbmdlRXh0ZW50ID0gZnVuY3Rpb24gZ2V0VGlsZVJhbmdlRXh0ZW50ICh6LCB0aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgdmFyIG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKHopO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuICB2YXIgbWluWCA9IG9yaWdpblswXSArIHRpbGVSYW5nZS5taW5YICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WCA9IG9yaWdpblswXSArICh0aWxlUmFuZ2UubWF4WCArIDEpICogdGlsZVNpemVbMF0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWluWSA9IG9yaWdpblsxXSArIHRpbGVSYW5nZS5taW5ZICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WSA9IG9yaWdpblsxXSArICh0aWxlUmFuZ2UubWF4WSArIDEpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG59O1xuXG4vKipcbiAqIEdldCBhIHRpbGUgcmFuZ2UgZm9yIHRoZSBnaXZlbiBleHRlbnQgYW5kIGludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9UaWxlUmFuZ2U9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSB0aWxlIHJhbmdlIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IFRpbGUgcmFuZ2UuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaID0gZnVuY3Rpb24gZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWiAoZXh0ZW50LCB6LCBvcHRfdGlsZVJhbmdlKSB7XG4gIHZhciB0aWxlQ29vcmQgPSB0bXBUaWxlQ29vcmQ7XG4gIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMF0sIGV4dGVudFsxXSwgeiwgZmFsc2UsIHRpbGVDb29yZCk7XG4gIHZhciBtaW5YID0gdGlsZUNvb3JkWzFdO1xuICB2YXIgbWluWSA9IHRpbGVDb29yZFsyXTtcbiAgdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKGV4dGVudFsyXSwgZXh0ZW50WzNdLCB6LCB0cnVlLCB0aWxlQ29vcmQpO1xuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgdGlsZUNvb3JkWzFdLCBtaW5ZLCB0aWxlQ29vcmRbMl0sIG9wdF90aWxlUmFuZ2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gVGlsZSBjZW50ZXIuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRDZW50ZXIgPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRDZW50ZXIgKHRpbGVDb29yZCkge1xuICB2YXIgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4odGlsZUNvb3JkWzBdKTtcbiAgdmFyIHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgdmFyIHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUodGlsZUNvb3JkWzBdKSwgdGhpcy50bXBTaXplXyk7XG4gIHJldHVybiBbXG4gICAgb3JpZ2luWzBdICsgKHRpbGVDb29yZFsxXSArIDAuNSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb24sXG4gICAgb3JpZ2luWzFdICsgKHRpbGVDb29yZFsyXSArIDAuNSkgKiB0aWxlU2l6ZVsxXSAqIHJlc29sdXRpb25cbiAgXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBleHRlbnQgb2YgYSB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IEV4dGVudC5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZEV4dGVudCA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEV4dGVudCAodGlsZUNvb3JkLCBvcHRfZXh0ZW50KSB7XG4gIHZhciBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh0aWxlQ29vcmRbMF0pLCB0aGlzLnRtcFNpemVfKTtcbiAgdmFyIG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIHZhciBtaW5ZID0gb3JpZ2luWzFdICsgdGlsZUNvb3JkWzJdICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICB2YXIgbWF4WCA9IG1pblggKyB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gIHZhciBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1pblksIG1heFgsIG1heFksIG9wdF9leHRlbnQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpbGUgY29vcmRpbmF0ZSBmb3IgdGhlIGdpdmVuIG1hcCBjb29yZGluYXRlIGFuZCByZXNvbHV0aW9uLlRoaXNcbiAqIG1ldGhvZCBjb25zaWRlcnMgdGhhdCBjb29yZGluYXRlcyB0aGF0IGludGVyc2VjdCB0aWxlIGJvdW5kYXJpZXMgc2hvdWxkIGJlXG4gKiBhc3NpZ25lZCB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBEZXN0aW5hdGlvbiBtb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZCBvYmplY3QuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRSZXNvbHV0aW9uID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRSZXNvbHV0aW9uIChjb29yZGluYXRlLCByZXNvbHV0aW9uLCBvcHRfdGlsZUNvb3JkKSB7XG4gIHJldHVybiB0aGlzLmdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oXG4gICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgcmVzb2x1dGlvbiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xufTtcblxuLyoqXG4gKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZm9yIHJlc29sdXRpb25zIHRoYXQgY29ycmVzcG9uZFxuICogdG8gYW4gaW50ZWdlciB6b29tIGxldmVsLkluc3RlYWQgY2FsbCB0aGUgYGdldFRpbGVDb29yZEZvclhZQW5kWl9gIG1ldGhvZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiAoZm9yIGEgbm9uLWludGVnZXIgem9vbSBsZXZlbCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgSW5zdGVhZCBvZiBsZXR0aW5nIGVkZ2VcbiAqICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICogICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGVtcG9yYXJ5IG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcHJpdmF0ZVxuICovXG5UaWxlR3JpZC5wcm90b3R5cGUuZ2V0VGlsZUNvb3JkRm9yWFlBbmRSZXNvbHV0aW9uXyA9IGZ1bmN0aW9uIGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8gKHgsIHksIHJlc29sdXRpb24sIHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3ksIG9wdF90aWxlQ29vcmQpIHtcbiAgdmFyIHogPSB0aGlzLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICB2YXIgc2NhbGUgPSByZXNvbHV0aW9uIC8gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICB2YXIgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gIHZhciB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICB2YXIgYWRqdXN0WCA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwLjUgOiAwO1xuICB2YXIgYWRqdXN0WSA9IHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kgPyAwIDogMC41O1xuICB2YXIgeEZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luWzBdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RYKTtcbiAgdmFyIHlGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeSAtIG9yaWdpblsxXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WSk7XG4gIHZhciB0aWxlQ29vcmRYID0gc2NhbGUgKiB4RnJvbU9yaWdpbiAvIHRpbGVTaXplWzBdO1xuICB2YXIgdGlsZUNvb3JkWSA9IHNjYWxlICogeUZyb21PcmlnaW4gLyB0aWxlU2l6ZVsxXTtcblxuICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmNlaWwodGlsZUNvb3JkWCkgLSAxO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmNlaWwodGlsZUNvb3JkWSkgLSAxO1xuICB9IGVsc2Uge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmZsb29yKHRpbGVDb29yZFgpO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkKHosIHRpbGVDb29yZFgsIHRpbGVDb29yZFksIG9wdF90aWxlQ29vcmQpO1xufTtcblxuLyoqXG4gKiBBbHRob3VnaCB0aGVyZSBpcyByZXBldGl0aW9uIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIGBnZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fYCxcbiAqIHRoZXkgc2hvdWxkIGhhdmUgc2VwYXJhdGUgaW1wbGVtZW50YXRpb25zLlRoaXMgbWV0aG9kIGlzIGZvciBpbnRlZ2VyIHpvb21cbiAqIGxldmVscy5UaGUgb3RoZXIgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgY29ycmVzcG9uZGluZ1xuICogdG8gbm9uLWludGVnZXIgem9vbSBsZXZlbHMuXG4gKiBAcGFyYW0ge251bWJlcn0geCBNYXAgeCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgTWFwIHkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICogICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gKiAgIGdvIHRvIHRoZSBsb3dlciB0aWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBUZW1wb3JhcnkgbW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQgb2JqZWN0LlxuICogQHJldHVybiB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfID0gZnVuY3Rpb24gZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyAoeCwgeSwgeiwgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSwgb3B0X3RpbGVDb29yZCkge1xuICB2YXIgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gIHZhciByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICB2YXIgdGlsZVNpemUgPSB0b1NpemUodGhpcy5nZXRUaWxlU2l6ZSh6KSwgdGhpcy50bXBTaXplXyk7XG5cbiAgdmFyIGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgdmFyIGFkanVzdFkgPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMCA6IDAuNTtcbiAgdmFyIHhGcm9tT3JpZ2luID0gTWF0aC5mbG9vcigoeCAtIG9yaWdpblswXSkgLyByZXNvbHV0aW9uICsgYWRqdXN0WCk7XG4gIHZhciB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICB2YXIgdGlsZUNvb3JkWCA9IHhGcm9tT3JpZ2luIC8gdGlsZVNpemVbMF07XG4gIHZhciB0aWxlQ29vcmRZID0geUZyb21PcmlnaW4gLyB0aWxlU2l6ZVsxXTtcblxuICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmNlaWwodGlsZUNvb3JkWCkgLSAxO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmNlaWwodGlsZUNvb3JkWSkgLSAxO1xuICB9IGVsc2Uge1xuICAgIHRpbGVDb29yZFggPSBNYXRoLmZsb29yKHRpbGVDb29yZFgpO1xuICAgIHRpbGVDb29yZFkgPSBNYXRoLmZsb29yKHRpbGVDb29yZFkpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkKHosIHRpbGVDb29yZFgsIHRpbGVDb29yZFksIG9wdF90aWxlQ29vcmQpO1xufTtcblxuLyoqXG4gKiBHZXQgYSB0aWxlIGNvb3JkaW5hdGUgZ2l2ZW4gYSBtYXAgY29vcmRpbmF0ZSBhbmQgem9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIERlc3RpbmF0aW9uIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFogPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRGb3JDb29yZEFuZFogKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhcbiAgICBjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCB6LCBmYWxzZSwgb3B0X3RpbGVDb29yZCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRpbGUgcmVzb2x1dGlvbi5cbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVDb29yZFJlc29sdXRpb24gPSBmdW5jdGlvbiBnZXRUaWxlQ29vcmRSZXNvbHV0aW9uICh0aWxlQ29vcmQpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3RpbGVDb29yZFswXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGlsZSBzaXplIGZvciBhIHpvb20gbGV2ZWwuIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGVcbiAqIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgdGhhdCB0aGUgdGlsZSBncmlkIHdhcyBjb25maWd1cmVkIHdpdGguIFRvIGFsd2F5c1xuICogZ2V0IGFuIGBtb2R1bGU6b2wvc2l6ZX5TaXplYCwgcnVuIHRoZSByZXN1bHQgdGhyb3VnaCBgbW9kdWxlOm9sL3NpemV+U2l6ZS50b1NpemUoKWAuXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHJldHVybiB7bnVtYmVyfG1vZHVsZTpvbC9zaXplflNpemV9IFRpbGUgc2l6ZS5cbiAqIEBhcGlcbiAqL1xuVGlsZUdyaWQucHJvdG90eXBlLmdldFRpbGVTaXplID0gZnVuY3Rpb24gZ2V0VGlsZVNpemUgKHopIHtcbiAgaWYgKHRoaXMudGlsZVNpemVfKSB7XG4gICAgcmV0dXJuIHRoaXMudGlsZVNpemVfO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnRpbGVTaXplc19bel07XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHogWm9vbSBsZXZlbC5cbiAqIEByZXR1cm4ge21vZHVsZTpvbC9UaWxlUmFuZ2V9IEV4dGVudCB0aWxlIHJhbmdlIGZvciB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWwuXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRGdWxsVGlsZVJhbmdlID0gZnVuY3Rpb24gZ2V0RnVsbFRpbGVSYW5nZSAoeikge1xuICBpZiAoIXRoaXMuZnVsbFRpbGVSYW5nZXNfKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFRpbGVSYW5nZXNfW3pdO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gSWYgMCwgdGhlIG5lYXJlc3QgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuXG4gKiAgIElmIDEsIHRoZSBuZWFyZXN0IGxvd2VyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBJZiAtMSwgdGhlIG5lYXJlc3RcbiAqICAgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBEZWZhdWx0IGlzIDAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFouXG4gKiBAYXBpXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5nZXRaRm9yUmVzb2x1dGlvbiA9IGZ1bmN0aW9uIGdldFpGb3JSZXNvbHV0aW9uIChyZXNvbHV0aW9uLCBvcHRfZGlyZWN0aW9uKSB7XG4gIHZhciB6ID0gbGluZWFyRmluZE5lYXJlc3QodGhpcy5yZXNvbHV0aW9uc18sIHJlc29sdXRpb24sIG9wdF9kaXJlY3Rpb24gfHwgMCk7XG4gIHJldHVybiBjbGFtcCh6LCB0aGlzLm1pblpvb20sIHRoaXMubWF4Wm9vbSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSBleHRlbnQgRXh0ZW50IGZvciB0aGlzIHRpbGUgZ3JpZC5cbiAqIEBwcml2YXRlXG4gKi9cblRpbGVHcmlkLnByb3RvdHlwZS5jYWxjdWxhdGVUaWxlUmFuZ2VzXyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbGVSYW5nZXNfIChleHRlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICB2YXIgZnVsbFRpbGVSYW5nZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgZnVsbFRpbGVSYW5nZXNbel0gPSB0aGlzJDEuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICB9XG4gIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gZnVsbFRpbGVSYW5nZXM7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVHcmlkO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaWxlR3JpZC5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWQvY29tbW9uXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gem9vbSBmb3IgZGVmYXVsdCB0aWxlIGdyaWRzLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBERUZBVUxUX01BWF9aT09NID0gNDI7XG5cbi8qKlxuICogRGVmYXVsdCB0aWxlIHNpemUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIERFRkFVTFRfVElMRV9TSVpFID0gMjU2O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGV1cmxmdW5jdGlvblxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtoYXNoIGFzIHRpbGVDb29yZEhhc2h9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVncmlkL1RpbGVHcmlkfSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHRpbGVHcmlkKSB7XG4gIHZhciB6UmVnRXggPSAvXFx7elxcfS9nO1xuICB2YXIgeFJlZ0V4ID0gL1xce3hcXH0vZztcbiAgdmFyIHlSZWdFeCA9IC9cXHt5XFx9L2c7XG4gIHZhciBkYXNoWVJlZ0V4ID0gL1xcey15XFx9L2c7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvdGlsZWNvb3JkflRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbih0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIHtcbiAgICAgIGlmICghdGlsZUNvb3JkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSh6UmVnRXgsIHRpbGVDb29yZFswXS50b1N0cmluZygpKVxuICAgICAgICAgIC5yZXBsYWNlKHhSZWdFeCwgdGlsZUNvb3JkWzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgLnJlcGxhY2UoeVJlZ0V4LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB5ID0gLXRpbGVDb29yZFsyXSAtIDE7XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoZGFzaFlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeiA9IHRpbGVDb29yZFswXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gICAgICAgICAgICBhc3NlcnQocmFuZ2UsIDU1KTsgLy8gVGhlIHsteX0gcGxhY2Vob2xkZXIgcmVxdWlyZXMgYSB0aWxlIGdyaWQgd2l0aCBleHRlbnRcbiAgICAgICAgICAgIHZhciB5ID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgKyB0aWxlQ29vcmRbMl07XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHRlbXBsYXRlcyBUZW1wbGF0ZXMuXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90aWxlZ3JpZC9UaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlcyh0ZW1wbGF0ZXMsIHRpbGVHcmlkKSB7XG4gIHZhciBsZW4gPSB0ZW1wbGF0ZXMubGVuZ3RoO1xuICB2YXIgdGlsZVVybEZ1bmN0aW9ucyA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGlsZVVybEZ1bmN0aW9uc1tpXSA9IGNyZWF0ZUZyb21UZW1wbGF0ZSh0ZW1wbGF0ZXNbaV0sIHRpbGVHcmlkKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6b2wvVGlsZX5VcmxGdW5jdGlvbj59IHRpbGVVcmxGdW5jdGlvbnMgVGlsZSBVUkwgRnVuY3Rpb25zLlxuICogQHJldHVybiB7bW9kdWxlOm9sL1RpbGV+VXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRpbGVVcmxGdW5jdGlvbnModGlsZVVybEZ1bmN0aW9ucykge1xuICBpZiAodGlsZVVybEZ1bmN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdGlsZVVybEZ1bmN0aW9uc1swXTtcbiAgfVxuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHttb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGggPSB0aWxlQ29vcmRIYXNoKHRpbGVDb29yZCk7XG4gICAgICAgIHZhciBpbmRleCA9IG1vZHVsbyhoLCB0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zW2luZGV4XSh0aWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3RpbGVjb29yZH5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAqIEBwYXJhbSB7bW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBudWxsVGlsZVVybEZ1bmN0aW9uKHRpbGVDb29yZCwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gQXJyYXkgb2YgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFVybCh1cmwpIHtcbiAgdmFyIHVybHMgPSBbXTtcbiAgdmFyIG1hdGNoID0gL1xceyhbYS16XSktKFthLXpdKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBjaGFyIHJhbmdlXG4gICAgdmFyIHN0YXJ0Q2hhckNvZGUgPSBtYXRjaFsxXS5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBzdG9wQ2hhckNvZGUgPSBtYXRjaFsyXS5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICBmb3IgKGNoYXJDb2RlID0gc3RhcnRDaGFyQ29kZTsgY2hhckNvZGUgPD0gc3RvcENoYXJDb2RlOyArK2NoYXJDb2RlKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxzO1xuICB9XG4gIG1hdGNoID0gbWF0Y2ggPSAvXFx7KFxcZCspLShcXGQrKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBudW1iZXIgcmFuZ2VcbiAgICB2YXIgc3RvcCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgZm9yICh2YXIgaSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIGkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICB1cmxzLnB1c2godXJsKTtcbiAgcmV0dXJuIHVybHM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbGV1cmxmdW5jdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdHJhbnNmb3JtXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgcmVwcmVzZW50aW5nIGFuIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvdHJhbnNmb3JtfSBmdW5jdGlvbnMuIFRoZSBhcnJheSBoYXMgNiBlbGVtZW50cy5cbiAqIEB0eXBlZGVmIHshQXJyYXkuPG51bWJlcj59IFRyYW5zZm9ybVxuICovXG5cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMuIFRoZSBmdW5jdGlvbnMgd29yayBvbiBhblxuICogYXJyYXkgb2YgNiBlbGVtZW50cy4gVGhlIGVsZW1lbnQgb3JkZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbU1ZHTWF0cml4XG4gKiBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdNYXRyaXgpIGFuZCBpc1xuICogYSBzdWJzZXQgKGVsZW1lbnRzIGEgdG8gZikgb2YgYSAzw5czIG1hdHJpeDpcbiAqIGBgYFxuICogWyBhIGMgZSBdXG4gKiBbIGIgZCBmIF1cbiAqIFsgMCAwIDEgXVxuICogYGBgXG4gKi9cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7bW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19XG4gKi9cbnZhciB0bXBfID0gbmV3IEFycmF5KDYpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFtb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gSWRlbnRpdHkgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICByZXR1cm4gWzEsIDAsIDAsIDEsIDAsIDBdO1xufVxuXG5cbi8qKlxuICogUmVzZXRzIHRoZSBnaXZlbiB0cmFuc2Zvcm0gdG8gYW4gaWRlbnRpdHkgdHJhbnNmb3JtLlxuICogQHBhcmFtIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgdW5kZXJseWluZyBtYXRyaWNlcyBvZiB0d28gdHJhbnNmb3JtcyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgaW5cbiAqIHRoZSBmaXJzdCB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtMSBUcmFuc2Zvcm0gcGFyYW1ldGVycyBvZiBtYXRyaXggMS5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0yIFRyYW5zZm9ybSBwYXJhbWV0ZXJzIG9mIG1hdHJpeCAyLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0xIG11bHRpcGxpZWQgd2l0aCB0cmFuc2Zvcm0yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICB2YXIgYTEgPSB0cmFuc2Zvcm0xWzBdO1xuICB2YXIgYjEgPSB0cmFuc2Zvcm0xWzFdO1xuICB2YXIgYzEgPSB0cmFuc2Zvcm0xWzJdO1xuICB2YXIgZDEgPSB0cmFuc2Zvcm0xWzNdO1xuICB2YXIgZTEgPSB0cmFuc2Zvcm0xWzRdO1xuICB2YXIgZjEgPSB0cmFuc2Zvcm0xWzVdO1xuICB2YXIgYTIgPSB0cmFuc2Zvcm0yWzBdO1xuICB2YXIgYjIgPSB0cmFuc2Zvcm0yWzFdO1xuICB2YXIgYzIgPSB0cmFuc2Zvcm0yWzJdO1xuICB2YXIgZDIgPSB0cmFuc2Zvcm0yWzNdO1xuICB2YXIgZTIgPSB0cmFuc2Zvcm0yWzRdO1xuICB2YXIgZjIgPSB0cmFuc2Zvcm0yWzVdO1xuXG4gIHRyYW5zZm9ybTFbMF0gPSBhMSAqIGEyICsgYzEgKiBiMjtcbiAgdHJhbnNmb3JtMVsxXSA9IGIxICogYTIgKyBkMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzJdID0gYTEgKiBjMiArIGMxICogZDI7XG4gIHRyYW5zZm9ybTFbM10gPSBiMSAqIGMyICsgZDEgKiBkMjtcbiAgdHJhbnNmb3JtMVs0XSA9IGExICogZTIgKyBjMSAqIGYyICsgZTE7XG4gIHRyYW5zZm9ybTFbNV0gPSBiMSAqIGUyICsgZDEgKiBmMiArIGYxO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNmb3JtIGNvbXBvbmVudHMgYS1mIG9uIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYSBUaGUgYSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiIFRoZSBiIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGMgVGhlIGMgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZCBUaGUgZCBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlIFRoZSBlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGYgVGhlIGYgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IE1hdHJpeCB3aXRoIHRyYW5zZm9ybSBhcHBsaWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRyYW5zZm9ybSwgYSwgYiwgYywgZCwgZSwgZikge1xuICB0cmFuc2Zvcm1bMF0gPSBhO1xuICB0cmFuc2Zvcm1bMV0gPSBiO1xuICB0cmFuc2Zvcm1bMl0gPSBjO1xuICB0cmFuc2Zvcm1bM10gPSBkO1xuICB0cmFuc2Zvcm1bNF0gPSBlO1xuICB0cmFuc2Zvcm1bNV0gPSBmO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogU2V0IHRyYW5zZm9ybSBvbiBvbmUgbWF0cml4IGZyb20gYW5vdGhlciBtYXRyaXguXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtMSBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSB0by5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0yIE1hdHJpeCB0byBzZXQgdHJhbnNmb3JtIGZyb20uXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybTEgd2l0aCB0cmFuc2Zvcm0gZnJvbSB0cmFuc2Zvcm0yIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGcm9tQXJyYXkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICB0cmFuc2Zvcm0xWzBdID0gdHJhbnNmb3JtMlswXTtcbiAgdHJhbnNmb3JtMVsxXSA9IHRyYW5zZm9ybTJbMV07XG4gIHRyYW5zZm9ybTFbMl0gPSB0cmFuc2Zvcm0yWzJdO1xuICB0cmFuc2Zvcm0xWzNdID0gdHJhbnNmb3JtMlszXTtcbiAgdHJhbnNmb3JtMVs0XSA9IHRyYW5zZm9ybTJbNF07XG4gIHRyYW5zZm9ybTFbNV0gPSB0cmFuc2Zvcm0yWzVdO1xuICByZXR1cm4gdHJhbnNmb3JtMTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIGNvb3JkaW5hdGUgd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHJldHVybmluZyB0aGVcbiAqIHJlc3VsdGluZywgdHJhbnNmb3JtZWQgY29vcmRpbmF0ZS4gVGhlIGNvb3JkaW5hdGUgd2lsbCBiZSBtb2RpZmllZCBpbi1wbGFjZS5cbiAqXG4gKiBAcGFyYW0ge21vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfG1vZHVsZTpvbC9waXhlbH5QaXhlbH0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHttb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfG1vZHVsZTpvbC9waXhlbH5QaXhlbH0gcmV0dXJuIGNvb3JkaW5hdGUgc28gdGhhdCBvcGVyYXRpb25zIGNhbiBiZVxuICogICAgIGNoYWluZWQgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseSh0cmFuc2Zvcm0sIGNvb3JkaW5hdGUpIHtcbiAgdmFyIHggPSBjb29yZGluYXRlWzBdO1xuICB2YXIgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGNvb3JkaW5hdGVbMF0gPSB0cmFuc2Zvcm1bMF0gKiB4ICsgdHJhbnNmb3JtWzJdICogeSArIHRyYW5zZm9ybVs0XTtcbiAgY29vcmRpbmF0ZVsxXSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bM10gKiB5ICsgdHJhbnNmb3JtWzVdO1xuICByZXR1cm4gY29vcmRpbmF0ZTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgcm90YXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IFRoZSByb3RhdGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZSh0cmFuc2Zvcm0sIGFuZ2xlKSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIHJldHVybiBtdWx0aXBseSh0cmFuc2Zvcm0sIHNldCh0bXBfLCBjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwKSk7XG59XG5cblxuLyoqXG4gKiBBcHBsaWVzIHNjYWxlIHRvIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0geCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjYWxlIGZhY3RvciB5LlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSBUaGUgc2NhbGVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgeCwgeSkge1xuICByZXR1cm4gbXVsdGlwbHkodHJhbnNmb3JtLCBzZXQodG1wXywgeCwgMCwgMCwgeSwgMCwgMCkpO1xufVxuXG5cbi8qKlxuICogQXBwbGllcyB0cmFuc2xhdGlvbiB0byB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZHggVHJhbnNsYXRpb24geC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUcmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSBUaGUgdHJhbnNsYXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBkeCwgZHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIDEsIDAsIDAsIDEsIGR4LCBkeSkpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB0cmFuc2Zvcm0gZ2l2ZW4gYW4gaW5pdGlhbCB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCBhbmRcbiAqIGZpbmFsIHRyYW5zbGF0aW9uIChpbiB0aGF0IG9yZGVyIG9ubHksIG5vdCBjb21tdXRhdGl2ZSkuXG4gKiBAcGFyYW0geyFtb2R1bGU6b2wvdHJhbnNmb3JtflRyYW5zZm9ybX0gdHJhbnNmb3JtIFRoZSB0cmFuc2Zvcm0gKHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MSBJbml0aWFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkxIEluaXRpYWwgdHJhbnNsYXRpb24geS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzeSBTY2FsZSBmYWN0b3IgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBSb3RhdGlvbiAoaW4gY291bnRlci1jbG9ja3dpc2UgcmFkaWFucykuXG4gKiBAcGFyYW0ge251bWJlcn0gZHgyIEZpbmFsIHRyYW5zbGF0aW9uIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZHkyIEZpbmFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IFRoZSBjb21wb3NpdGUgdHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9zZSh0cmFuc2Zvcm0sIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mikge1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB0cmFuc2Zvcm1bMF0gPSBzeCAqIGNvcztcbiAgdHJhbnNmb3JtWzFdID0gc3kgKiBzaW47XG4gIHRyYW5zZm9ybVsyXSA9IC1zeCAqIHNpbjtcbiAgdHJhbnNmb3JtWzNdID0gc3kgKiBjb3M7XG4gIHRyYW5zZm9ybVs0XSA9IGR4MiAqIHN4ICogY29zIC0gZHkyICogc3ggKiBzaW4gKyBkeDE7XG4gIHRyYW5zZm9ybVs1XSA9IGR4MiAqIHN5ICogc2luICsgZHkyICogc3kgKiBjb3MgKyBkeTE7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHJldHVybiB7IW1vZHVsZTpvbC90cmFuc2Zvcm1+VHJhbnNmb3JtfSBJbnZlcnNlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQodHJhbnNmb3JtKSB7XG4gIHZhciBkZXQgPSBkZXRlcm1pbmFudCh0cmFuc2Zvcm0pO1xuICBhc3NlcnQoZGV0ICE9PSAwLCAzMik7IC8vIFRyYW5zZm9ybWF0aW9uIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWRcblxuICB2YXIgYSA9IHRyYW5zZm9ybVswXTtcbiAgdmFyIGIgPSB0cmFuc2Zvcm1bMV07XG4gIHZhciBjID0gdHJhbnNmb3JtWzJdO1xuICB2YXIgZCA9IHRyYW5zZm9ybVszXTtcbiAgdmFyIGUgPSB0cmFuc2Zvcm1bNF07XG4gIHZhciBmID0gdHJhbnNmb3JtWzVdO1xuXG4gIHRyYW5zZm9ybVswXSA9IGQgLyBkZXQ7XG4gIHRyYW5zZm9ybVsxXSA9IC1iIC8gZGV0O1xuICB0cmFuc2Zvcm1bMl0gPSAtYyAvIGRldDtcbiAgdHJhbnNmb3JtWzNdID0gYSAvIGRldDtcbiAgdHJhbnNmb3JtWzRdID0gKGMgKiBmIC0gZCAqIGUpIC8gZGV0O1xuICB0cmFuc2Zvcm1bNV0gPSAtKGEgKiBmIC0gYiAqIGUpIC8gZGV0O1xuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXRlcm1pbmFudCBvZiB0aGUgZ2l2ZW4gbWF0cml4LlxuICogQHBhcmFtIHshbW9kdWxlOm9sL3RyYW5zZm9ybX5UcmFuc2Zvcm19IG1hdCBNYXRyaXguXG4gKiBAcmV0dXJuIHtudW1iZXJ9IERldGVybWluYW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQobWF0KSB7XG4gIHJldHVybiBtYXRbMF0gKiBtYXRbM10gLSBtYXRbMV0gKiBtYXRbMl07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCIvKipcbiAqIEBtb2R1bGUgb2wvdXRpbFxuICovXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUuZm9vID0gZnVuY3Rpb24oYSkgeyB9XG4gKlxuICogICAgIGZ1bmN0aW9uIENoaWxkQ2xhc3MoYSwgYiwgYykge1xuICogICAgICAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAqICAgICAgIFBhcmVudENsYXNzLmNhbGwodGhpcywgYSwgYik7XG4gKiAgICAgfVxuICogICAgIGluaGVyaXRzKENoaWxkQ2xhc3MsIFBhcmVudENsYXNzKTtcbiAqXG4gKiAgICAgdmFyIGNoaWxkID0gbmV3IENoaWxkQ2xhc3MoJ2EnLCAnYicsICdzZWUnKTtcbiAqICAgICBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY2hpbGRDdG9yIENoaWxkIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHBhcmVudEN0b3IgUGFyZW50IGNvbnN0cnVjdG9yLlxuICogQGZ1bmN0aW9uIG1vZHVsZTpvbC5pbmhlcml0c1xuICogQGRlcHJlY2F0ZWRcbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkQ3RvciwgcGFyZW50Q3Rvcikge1xuICBjaGlsZEN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDdG9yLnByb3RvdHlwZSk7XG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZEN0b3I7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVpZChvYmopIHtcbiAgcmV0dXJuIG9iai5vbF91aWQgfHwgKG9iai5vbF91aWQgPSArK3VpZENvdW50ZXJfKTtcbn1cblxuLyoqXG4gKiBPcGVuTGF5ZXJzIHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgdmFyIFZFUlNJT04gPSAnNS4xLjMnO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIi8qKlxuICogQG1vZHVsZSBvbC93ZWJnbFxuICovXG5cblxuLyoqXG4gKiBDb25zdGFudHMgdGFrZW4gZnJvbSBnb29nLndlYmdsXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBPTkUgPSAxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFNSQ19BTFBIQSA9IDB4MDMwMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDT0xPUl9BVFRBQ0hNRU5UMCA9IDB4OENFMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBDT0xPUl9CVUZGRVJfQklUID0gMHgwMDAwNDAwMDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBUUklBTkdMRVMgPSAweDAwMDQ7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVFJJQU5HTEVfU1RSSVAgPSAweDAwMDU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgT05FX01JTlVTX1NSQ19BTFBIQSA9IDB4MDMwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBBUlJBWV9CVUZGRVIgPSAweDg4OTI7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAweDg4OTM7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU1RSRUFNX0RSQVcgPSAweDg4RTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgU1RBVElDX0RSQVcgPSAweDg4RTQ7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRFlOQU1JQ19EUkFXID0gMHg4OEU4O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIENVTExfRkFDRSA9IDB4MEI0NDtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBCTEVORCA9IDB4MEJFMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBTVEVOQ0lMX1RFU1QgPSAweDBCOTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgREVQVEhfVEVTVCA9IDB4MEI3MTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBTQ0lTU09SX1RFU1QgPSAweDBDMTE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVU5TSUdORURfQllURSA9IDB4MTQwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBVTlNJR05FRF9TSE9SVCA9IDB4MTQwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBVTlNJR05FRF9JTlQgPSAweDE0MDU7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRkxPQVQgPSAweDE0MDY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgUkdCQSA9IDB4MTkwODtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBGUkFHTUVOVF9TSEFERVIgPSAweDhCMzA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVkVSVEVYX1NIQURFUiA9IDB4OEIzMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBMSU5LX1NUQVRVUyA9IDB4OEI4MjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBMSU5FQVIgPSAweDI2MDE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgVEVYVFVSRV9NQUdfRklMVEVSID0gMHgyODAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFX1dSQVBfUyA9IDB4MjgwMjtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFX1dSQVBfVCA9IDB4MjgwMztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IHZhciBURVhUVVJFXzJEID0gMHgwREUxO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIFRFWFRVUkUwID0gMHg4NEMwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgdmFyIENMQU1QX1RPX0VER0UgPSAweDgxMkY7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgQ09NUElMRV9TVEFUVVMgPSAweDhCODE7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRlJBTUVCVUZGRVIgPSAweDhENDA7XG5cblxuLyoqIGVuZCBvZiBnb29nLndlYmdsIGNvbnN0YW50c1xuICovXG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAqL1xudmFyIENPTlRFWFRfSURTID0gW1xuICAnZXhwZXJpbWVudGFsLXdlYmdsJyxcbiAgJ3dlYmdsJyxcbiAgJ3dlYmtpdC0zZCcsXG4gICdtb3otd2ViZ2wnXG5dO1xuXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIENhbnZhcy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2F0dHJpYnV0ZXMgQXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcywgb3B0X2F0dHJpYnV0ZXMpIHtcbiAgdmFyIGlpID0gQ09OVEVYVF9JRFMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyArK2kpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChDT05URVhUX0lEU1tpXSwgb3B0X2F0dHJpYnV0ZXMpO1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IVdlYkdMUmVuZGVyaW5nQ29udGV4dH0gKi8gKGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBhc3NcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqXG4gKiBJbmNsdWRlIGRlYnVnZ2FibGUgc2hhZGVyIHNvdXJjZXMuICBEZWZhdWx0IGlzIGB0cnVlYC4gVGhpcyBzaG91bGQgYmUgc2V0IHRvXG4gKiBgZmFsc2VgIGZvciBwcm9kdWN0aW9uIGJ1aWxkcy5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgdmFyIERFQlVHID0gdHJ1ZTtcblxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIHN1cHBvcnRlZCBXZWJHTCB0ZXh0dXJlIHNpemUgaW4gcGl4ZWxzLiBJZiBXZWJHTCBpcyBub3RcbiAqIHN1cHBvcnRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdW5kZWZpbmVkYC5cbiAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICovXG52YXIgTUFYX1RFWFRVUkVfU0laRTsgLy8gdmFsdWUgaXMgc2V0IGJlbG93XG5cblxuLyoqXG4gKiBMaXN0IG9mIHN1cHBvcnRlZCBXZWJHTCBleHRlbnNpb25zLlxuICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxuICovXG52YXIgRVhURU5TSU9OUzsgLy8gdmFsdWUgaXMgc2V0IGJlbG93XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJvdGggT3BlbkxheWVycyBhbmQgYnJvd3NlciBzdXBwb3J0IFdlYkdMLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAYXBpXG4gKi9cbnZhciBIQVMgPSBmYWxzZTtcblxuLy9UT0RPIFJlbW92ZSBzaWRlIGVmZmVjdHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnV2ViR0xSZW5kZXJpbmdDb250ZXh0JyBpbiB3aW5kb3cpIHtcbiAgdHJ5IHtcbiAgICB2YXIgY2FudmFzID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NBTlZBUycpKTtcbiAgICB2YXIgZ2wgPSBnZXRDb250ZXh0KGNhbnZhcywge2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWV9KTtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIEhBUyA9IHRydWU7XG4gICAgICBNQVhfVEVYVFVSRV9TSVpFID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSkpO1xuICAgICAgRVhURU5TSU9OUyA9IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwYXNzXG4gIH1cbn1cblxuZXhwb3J0IHtIQVMsIE1BWF9URVhUVVJFX1NJWkUsIEVYVEVOU0lPTlN9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJnbC5qcy5tYXAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwucXVpY2tzZWxlY3QgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0KGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcbiAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0IHx8IDAsIHJpZ2h0IHx8IChhcnIubGVuZ3RoIC0gMSksIGNvbXBhcmUgfHwgZGVmYXVsdENvbXBhcmUpO1xufVxuXG5mdW5jdGlvbiBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gYXJyW2tdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcChhcnIsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29tcGFyZShhcnJbcmlnaHRdLCB0KSA+IDApIHN3YXAoYXJyLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwKGFyciwgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbaV0sIHQpIDwgMCkgaSsrO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2pdLCB0KSA+IDApIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wYXJlKGFycltsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwKGFyciwgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3dhcChhcnIsIGksIGopIHtcbiAgICB2YXIgdG1wID0gYXJyW2ldO1xuICAgIGFycltpXSA9IGFycltqXTtcbiAgICBhcnJbal0gPSB0bXA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbnJldHVybiBxdWlja3NlbGVjdDtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByYnVzaDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSByYnVzaDtcblxudmFyIHF1aWNrc2VsZWN0ID0gcmVxdWlyZSgncXVpY2tzZWxlY3QnKTtcblxuZnVuY3Rpb24gcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHJidXNoKSkgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpO1xuXG4gICAgLy8gbWF4IGVudHJpZXMgaW4gYSBub2RlIGlzIDkgYnkgZGVmYXVsdDsgbWluIG5vZGUgZmlsbCBpcyA0MCUgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGlzLl9tYXhFbnRyaWVzID0gTWF0aC5tYXgoNCwgbWF4RW50cmllcyB8fCA5KTtcbiAgICB0aGlzLl9taW5FbnRyaWVzID0gTWF0aC5tYXgoMiwgTWF0aC5jZWlsKHRoaXMuX21heEVudHJpZXMgKiAwLjQpKTtcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5faW5pdEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxucmJ1c2gucHJvdG90eXBlID0ge1xuXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfSxcblxuICAgIHNlYXJjaDogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgdGhpcy5fYWxsKGNoaWxkLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb2xsaWRlczogZnVuY3Rpb24gKGJib3gpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0cyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgY29udGFpbnMoYmJveCwgY2hpbGRCQm94KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS5sZW5ndGgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBzbWFsbCB0cmVlIGludG8gdGhlIGxhcmdlIHRyZWUgYXQgYXBwcm9wcmlhdGUgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuX2luc2VydChub2RlLCB0aGlzLmRhdGEuaGVpZ2h0IC0gbm9kZS5oZWlnaHQgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtKSB0aGlzLl9pbnNlcnQoaXRlbSwgdGhpcy5kYXRhLmhlaWdodCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIChpdGVtLCBlcXVhbHNGbikge1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgYmJveCA9IHRoaXMudG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgcGF0aCA9IFtdLFxuICAgICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgaSwgcGFyZW50LCBpbmRleCwgZ29pbmdVcDtcblxuICAgICAgICAvLyBkZXB0aC1maXJzdCBpdGVyYXRpdmUgdHJlZSB0cmF2ZXJzYWxcbiAgICAgICAgd2hpbGUgKG5vZGUgfHwgcGF0aC5sZW5ndGgpIHtcblxuICAgICAgICAgICAgaWYgKCFub2RlKSB7IC8vIGdvIHVwXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhdGgucG9wKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGkgPSBpbmRleGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7IC8vIGNoZWNrIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGluZGV4ID0gZmluZEl0ZW0oaXRlbSwgbm9kZS5jaGlsZHJlbiwgZXF1YWxzRm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtIGZvdW5kLCByZW1vdmUgdGhlIGl0ZW0gYW5kIGNvbmRlbnNlIHRyZWUgdXB3YXJkc1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uZGVuc2UocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFnb2luZ1VwICYmICFub2RlLmxlYWYgJiYgY29udGFpbnMobm9kZSwgYmJveCkpIHsgLy8gZ28gZG93blxuICAgICAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQpIHsgLy8gZ28gcmlnaHRcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH0gZWxzZSBub2RlID0gbnVsbDsgLy8gbm90aGluZyBmb3VuZFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQkJveDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0sXG5cbiAgICBjb21wYXJlTWluWDogY29tcGFyZU5vZGVNaW5YLFxuICAgIGNvbXBhcmVNaW5ZOiBjb21wYXJlTm9kZU1pblksXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfSxcblxuICAgIGZyb21KU09OOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2FsbDogZnVuY3Rpb24gKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBfYnVpbGQ6IGZ1bmN0aW9uIChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBOID0gcmlnaHQgLSBsZWZ0ICsgMSxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGxlYWYgbGV2ZWw7IHJldHVybiBsZWFmXG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZShpdGVtcy5zbGljZShsZWZ0LCByaWdodCArIDEpKTtcbiAgICAgICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHRhcmdldCBoZWlnaHQgb2YgdGhlIGJ1bGstbG9hZGVkIHRyZWVcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChNYXRoLmxvZyhOKSAvIE1hdGgubG9nKE0pKTtcblxuICAgICAgICAgICAgLy8gdGFyZ2V0IG51bWJlciBvZiByb290IGVudHJpZXMgdG8gbWF4aW1pemUgc3RvcmFnZSB1dGlsaXphdGlvblxuICAgICAgICAgICAgTSA9IE1hdGguY2VpbChOIC8gTWF0aC5wb3coTSwgaGVpZ2h0IC0gMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICBub2RlLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIGl0ZW1zIGludG8gTSBtb3N0bHkgc3F1YXJlIHRpbGVzXG5cbiAgICAgICAgdmFyIE4yID0gTWF0aC5jZWlsKE4gLyBNKSxcbiAgICAgICAgICAgIE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKSxcbiAgICAgICAgICAgIGksIGosIHJpZ2h0MiwgcmlnaHQzO1xuXG4gICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBsZWZ0LCByaWdodCwgTjEsIHRoaXMuY29tcGFyZU1pblgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkgKz0gTjEpIHtcblxuICAgICAgICAgICAgcmlnaHQyID0gTWF0aC5taW4oaSArIE4xIC0gMSwgcmlnaHQpO1xuXG4gICAgICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgaSwgcmlnaHQyLCBOMiwgdGhpcy5jb21wYXJlTWluWSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVN1YnRyZWU6IGZ1bmN0aW9uIChiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIGNoaWxkLCB0YXJnZXROb2RlLCBhcmVhLCBlbmxhcmdlbWVudCwgbWluQXJlYSwgbWluRW5sYXJnZW1lbnQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBwYXRoLmxlbmd0aCAtIDEgPT09IGxldmVsKSBicmVhaztcblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbmxhcmdlbWVudCA9IGVubGFyZ2VkQXJlYShiYm94LCBjaGlsZCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZSB8fCBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9pbnNlcnQ6IGZ1bmN0aW9uIChpdGVtLCBsZXZlbCwgaXNOb2RlKSB7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgYmJveCA9IGlzTm9kZSA/IGl0ZW0gOiB0b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICBleHRlbmQobm9kZSwgYmJveCk7XG5cbiAgICAgICAgLy8gc3BsaXQgb24gbm9kZSBvdmVyZmxvdzsgcHJvcGFnYXRlIHVwd2FyZHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHdoaWxlIChsZXZlbCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0UGF0aFtsZXZlbF0uY2hpbGRyZW4ubGVuZ3RoID4gdGhpcy5fbWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NwbGl0KGluc2VydFBhdGgsIGxldmVsKTtcbiAgICAgICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgaW5zZXJ0aW9uIHBhdGhcbiAgICAgICAgdGhpcy5fYWRqdXN0UGFyZW50QkJveGVzKGJib3gsIGluc2VydFBhdGgsIGxldmVsKTtcbiAgICB9LFxuXG4gICAgLy8gc3BsaXQgb3ZlcmZsb3dlZCBub2RlIGludG8gdHdvXG4gICAgX3NwbGl0OiBmdW5jdGlvbiAoaW5zZXJ0UGF0aCwgbGV2ZWwpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IGluc2VydFBhdGhbbGV2ZWxdLFxuICAgICAgICAgICAgTSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgICAgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBzcGxpdEluZGV4ID0gdGhpcy5fY2hvb3NlU3BsaXRJbmRleChub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZS5jaGlsZHJlbi5zcGxpY2Uoc3BsaXRJbmRleCwgbm9kZS5jaGlsZHJlbi5sZW5ndGggLSBzcGxpdEluZGV4KSk7XG4gICAgICAgIG5ld05vZGUuaGVpZ2h0ID0gbm9kZS5oZWlnaHQ7XG4gICAgICAgIG5ld05vZGUubGVhZiA9IG5vZGUubGVhZjtcblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIGNhbGNCQm94KG5ld05vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICBpZiAobGV2ZWwpIGluc2VydFBhdGhbbGV2ZWwgLSAxXS5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICBlbHNlIHRoaXMuX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKTtcbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW25vZGUsIG5ld05vZGVdKTtcbiAgICAgICAgdGhpcy5kYXRhLmhlaWdodCA9IG5vZGUuaGVpZ2h0ICsgMTtcbiAgICAgICAgdGhpcy5kYXRhLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgY2FsY0JCb3godGhpcy5kYXRhLCB0aGlzLnRvQkJveCk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IGRpc3RCQm94KG5vZGUsIDAsIGksIHRoaXMudG9CQm94KTtcbiAgICAgICAgICAgIGJib3gyID0gZGlzdEJCb3gobm9kZSwgaSwgTSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgICAgICBvdmVybGFwID0gaW50ZXJzZWN0aW9uQXJlYShiYm94MSwgYmJveDIpO1xuICAgICAgICAgICAgYXJlYSA9IGJib3hBcmVhKGJib3gxKSArIGJib3hBcmVhKGJib3gyKTtcblxuICAgICAgICAgICAgLy8gY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gb3ZlcmxhcFxuICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlcmxhcCA9PT0gbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBhcmVhXG4gICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyBub2RlIGNoaWxkcmVuIGJ5IHRoZSBiZXN0IGF4aXMgZm9yIHNwbGl0XG4gICAgX2Nob29zZVNwbGl0QXhpczogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgY29tcGFyZU1pblggPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5YIDogY29tcGFyZU5vZGVNaW5YLFxuICAgICAgICAgICAgY29tcGFyZU1pblkgPSBub2RlLmxlYWYgPyB0aGlzLmNvbXBhcmVNaW5ZIDogY29tcGFyZU5vZGVNaW5ZLFxuICAgICAgICAgICAgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpLFxuICAgICAgICAgICAgeU1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblkpO1xuXG4gICAgICAgIC8vIGlmIHRvdGFsIGRpc3RyaWJ1dGlvbnMgbWFyZ2luIHZhbHVlIGlzIG1pbmltYWwgZm9yIHgsIHNvcnQgYnkgbWluWCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0J3MgYWxyZWFkeSBzb3J0ZWQgYnkgbWluWVxuICAgICAgICBpZiAoeE1hcmdpbiA8IHlNYXJnaW4pIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlTWluWCk7XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGxlZnRCQm94ID0gZGlzdEJCb3gobm9kZSwgMCwgbSwgdG9CQm94KSxcbiAgICAgICAgICAgIHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpLFxuICAgICAgICAgICAgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCksXG4gICAgICAgICAgICBpLCBjaGlsZDtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDwgTSAtIG07IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKGxlZnRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4obGVmdEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH0sXG5cbiAgICBfYWRqdXN0UGFyZW50QkJveGVzOiBmdW5jdGlvbiAoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAodmFyIGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29uZGVuc2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdEZvcm1hdDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAvLyBkYXRhIGZvcm1hdCAobWluWCwgbWluWSwgbWF4WCwgbWF4WSBhY2Nlc3NvcnMpXG5cbiAgICAgICAgLy8gdXNlcyBldmFsLXR5cGUgZnVuY3Rpb24gY29tcGlsYXRpb24gaW5zdGVhZCBvZiBqdXN0IGFjY2VwdGluZyBhIHRvQkJveCBmdW5jdGlvblxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBhbGdvcml0aG1zIGFyZSB2ZXJ5IHNlbnNpdGl2ZSB0byBzb3J0aW5nIGZ1bmN0aW9ucyBwZXJmb3JtYW5jZSxcbiAgICAgICAgLy8gc28gdGhleSBzaG91bGQgYmUgZGVhZCBzaW1wbGUgYW5kIHdpdGhvdXQgaW5uZXIgY2FsbHNcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLFxuICAgICAgICAgICAgJ3JldHVybiB7bWluWDogYScgKyBmb3JtYXRbMF0gK1xuICAgICAgICAgICAgJywgbWluWTogYScgKyBmb3JtYXRbMV0gK1xuICAgICAgICAgICAgJywgbWF4WDogYScgKyBmb3JtYXRbMl0gK1xuICAgICAgICAgICAgJywgbWF4WTogYScgKyBmb3JtYXRbM10gKyAnfTsnKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSXRlbShpdGVtLCBpdGVtcywgZXF1YWxzRm4pIHtcbiAgICBpZiAoIWVxdWFsc0ZuKSByZXR1cm4gaXRlbXMuaW5kZXhPZihpdGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVxdWFsc0ZuKGl0ZW0sIGl0ZW1zW2ldKSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gY2FsY3VsYXRlIG5vZGUncyBiYm94IGZyb20gYmJveGVzIG9mIGl0cyBjaGlsZHJlblxuZnVuY3Rpb24gY2FsY0JCb3gobm9kZSwgdG9CQm94KSB7XG4gICAgZGlzdEJCb3gobm9kZSwgMCwgbm9kZS5jaGlsZHJlbi5sZW5ndGgsIHRvQkJveCwgbm9kZSk7XG59XG5cbi8vIG1pbiBib3VuZGluZyByZWN0YW5nbGUgb2Ygbm9kZSBjaGlsZHJlbiBmcm9tIGsgdG8gcC0xXG5mdW5jdGlvbiBkaXN0QkJveChub2RlLCBrLCBwLCB0b0JCb3gsIGRlc3ROb2RlKSB7XG4gICAgaWYgKCFkZXN0Tm9kZSkgZGVzdE5vZGUgPSBjcmVhdGVOb2RlKG51bGwpO1xuICAgIGRlc3ROb2RlLm1pblggPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5taW5ZID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WCA9IC1JbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGssIGNoaWxkOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgdmFyIG1pblggPSBNYXRoLm1heChhLm1pblgsIGIubWluWCksXG4gICAgICAgIG1pblkgPSBNYXRoLm1heChhLm1pblksIGIubWluWSksXG4gICAgICAgIG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCksXG4gICAgICAgIG1heFkgPSBNYXRoLm1pbihhLm1heFksIGIubWF4WSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWF4WCAtIG1pblgpICpcbiAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF4WSAtIG1pblkpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluWCA8PSBiLm1pblggJiZcbiAgICAgICAgICAgYS5taW5ZIDw9IGIubWluWSAmJlxuICAgICAgICAgICBiLm1heFggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWF4WSA8PSBhLm1heFk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoYSwgYikge1xuICAgIHJldHVybiBiLm1pblggPD0gYS5tYXhYICYmXG4gICAgICAgICAgIGIubWluWSA8PSBhLm1heFkgJiZcbiAgICAgICAgICAgYi5tYXhYID49IGEubWluWCAmJlxuICAgICAgICAgICBiLm1heFkgPj0gYS5taW5ZO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIGxlYWY6IHRydWUsXG4gICAgICAgIG1pblg6IEluZmluaXR5LFxuICAgICAgICBtaW5ZOiBJbmZpbml0eSxcbiAgICAgICAgbWF4WDogLUluZmluaXR5LFxuICAgICAgICBtYXhZOiAtSW5maW5pdHlcbiAgICB9O1xufVxuXG4vLyBzb3J0IGFuIGFycmF5IHNvIHRoYXQgaXRlbXMgY29tZSBpbiBncm91cHMgb2YgbiB1bnNvcnRlZCBpdGVtcywgd2l0aCBncm91cHMgc29ydGVkIGJldHdlZW4gZWFjaCBvdGhlcjtcbi8vIGNvbWJpbmVzIHNlbGVjdGlvbiBhbGdvcml0aG0gd2l0aCBiaW5hcnkgZGl2aWRlICYgY29ucXVlciBhcHByb2FjaFxuXG5mdW5jdGlvbiBtdWx0aVNlbGVjdChhcnIsIGxlZnQsIHJpZ2h0LCBuLCBjb21wYXJlKSB7XG4gICAgdmFyIHN0YWNrID0gW2xlZnQsIHJpZ2h0XSxcbiAgICAgICAgbWlkO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBuKSBjb250aW51ZTtcblxuICAgICAgICBtaWQgPSBsZWZ0ICsgTWF0aC5jZWlsKChyaWdodCAtIGxlZnQpIC8gbiAvIDIpICogbjtcbiAgICAgICAgcXVpY2tzZWxlY3QoYXJyLCBtaWQsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKTtcblxuICAgICAgICBzdGFjay5wdXNoKGxlZnQsIG1pZCwgbWlkLCByaWdodCk7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQW5pbWF0aW9uQnVja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkJ1Y2tldChjb2xvclNjYWxlKSB7XG4gICAgICAgIHRoaXMuYnVja2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbG9yU2NhbGUgPSBjb2xvclNjYWxlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU2NhbGUuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Y2tldHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQW5pbWF0aW9uQnVja2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnRpY3VsZVNldCkge1xuICAgICAgICAgICAgcGFydGljdWxlU2V0LnNwbGljZSgwLCBwYXJ0aWN1bGVTZXQubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBbmltYXRpb25CdWNrZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChwLCB2KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sb3JTY2FsZS5nZXRDb2xvckluZGV4KHAuaW50ZW5zaXR5KTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmJ1Y2tldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcC54dCA9IHAueCArIHYudTtcbiAgICAgICAgcC55dCA9IHAueSArIHYudjtcbiAgICAgICAgdGhpcy5idWNrZXRzW2luZGV4XS5wdXNoKHApO1xuICAgIH07XG4gICAgQW5pbWF0aW9uQnVja2V0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNvbnRleHQyRCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmJ1Y2tldHMuZm9yRWFjaChmdW5jdGlvbiAoYnVja2V0LCBpKSB7XG4gICAgICAgICAgICBpZiAoYnVja2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0MkQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY29udGV4dDJELnN0cm9rZVN0eWxlID0gX3RoaXMuY29sb3JTY2FsZS5jb2xvckF0KGkpO1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0aWNsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0MkQubW92ZVRvKHBhcnRpY2xlLngsIHBhcnRpY2xlLnkpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0MkQubGluZVRvKHBhcnRpY2xlLnh0LCBwYXJ0aWNsZS55dCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnggPSBwYXJ0aWNsZS54dDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljbGUueSA9IHBhcnRpY2xlLnl0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQyRC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uQnVja2V0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFuaW1hdGlvbkJ1Y2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhcnRpY2xlXzEgPSByZXF1aXJlKFwiLi9wYXJ0aWNsZVwiKTtcbnZhciBDYW52YXNCb3VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYW52YXNCb3VuZCh4TWluLCB5TWluLCB4TWF4LCB5TWF4KSB7XG4gICAgICAgIHRoaXMueE1pbiA9IHhNaW47XG4gICAgICAgIHRoaXMueU1pbiA9IHlNaW47XG4gICAgICAgIHRoaXMueE1heCA9IHhNYXg7XG4gICAgICAgIHRoaXMueU1heCA9IHlNYXg7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNCb3VuZC5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhNYXggLSB0aGlzLnhNaW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNCb3VuZC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55TWF4IC0gdGhpcy55TWluO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYW52YXNCb3VuZC5wcm90b3R5cGUuZ2V0UmFuZG9tUGFydGljdWxlID0gZnVuY3Rpb24gKG1heEFnZSkge1xuICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy53aWR0aCkgKyB0aGlzLnhNaW4pO1xuICAgICAgICB2YXIgeSA9IE1hdGgucm91bmQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5oZWlnaHQpICsgdGhpcy55TWluKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwYXJ0aWNsZV8xLmRlZmF1bHQoeCwgeSwgbWF4QWdlKTtcbiAgICB9O1xuICAgIENhbnZhc0JvdW5kLnByb3RvdHlwZS5yZXNldFBhcnRpY3VsZSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB4ID0gTWF0aC5yb3VuZChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLndpZHRoKSArIHRoaXMueE1pbik7XG4gICAgICAgIHZhciB5ID0gTWF0aC5yb3VuZChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLmhlaWdodCkgKyB0aGlzLnlNaW4pO1xuICAgICAgICBwLnJlc2V0KHgsIHkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIHJldHVybiBDYW52YXNCb3VuZDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNCb3VuZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbG9yU2NhbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JTY2FsZShtaW5WYWx1ZSwgbWF4VmFsdWUsIHNjYWxlKSB7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBbXG4gICAgICAgICAgICBcInJnYigzNiwxMDQsIDE4MClcIixcbiAgICAgICAgICAgIFwicmdiKDYwLDE1NywgMTk0KVwiLFxuICAgICAgICAgICAgXCJyZ2IoMTI4LDIwNSwxOTMgKVwiLFxuICAgICAgICAgICAgXCJyZ2IoMTUxLDIxOCwxNjggKVwiLFxuICAgICAgICAgICAgXCJyZ2IoMTk4LDIzMSwxODEpXCIsXG4gICAgICAgICAgICBcInJnYigyMzgsMjQ3LDIxNylcIixcbiAgICAgICAgICAgIFwicmdiKDI1NSwyMzgsMTU5KVwiLFxuICAgICAgICAgICAgXCJyZ2IoMjUyLDIxNywxMjUpXCIsXG4gICAgICAgICAgICBcInJnYigyNTUsMTgyLDEwMClcIixcbiAgICAgICAgICAgIFwicmdiKDI1MiwxNTAsNzUpXCIsXG4gICAgICAgICAgICBcInJnYigyNTAsMTEyLDUyKVwiLFxuICAgICAgICAgICAgXCJyZ2IoMjQ1LDY0LDMyKVwiLFxuICAgICAgICAgICAgXCJyZ2IoMjM3LDQ1LDI4KVwiLFxuICAgICAgICAgICAgXCJyZ2IoMjIwLDI0LDMyKVwiLFxuICAgICAgICAgICAgXCJyZ2IoMTgwLDAsMzUpXCJcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5zZXRNaW5NYXgobWluVmFsdWUsIG1heFZhbHVlKTtcbiAgICAgICAgaWYgKChzY2FsZSBpbnN0YW5jZW9mIEFycmF5KSAmJiBzY2FsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb2xvclNjYWxlLnByb3RvdHlwZS5zZXRNaW5NYXggPSBmdW5jdGlvbiAobWluVmFsdWUsIG1heFZhbHVlKSB7XG4gICAgICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcbiAgICAgICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yU2NhbGUucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ29sb3JTY2FsZS5wcm90b3R5cGUuZ2V0Q29sb3JJbmRleCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPD0gdGhpcy5taW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID49IHRoaXMubWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zY2FsZS5sZW5ndGggKiAodmFsdWUgLSB0aGlzLm1pblZhbHVlKSAvICh0aGlzLm1heFZhbHVlIC0gdGhpcy5taW5WYWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHRoaXMuc2NhbGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCk7XG4gICAgfTtcbiAgICBDb2xvclNjYWxlLnByb3RvdHlwZS5jb2xvckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlW2luZGV4XTtcbiAgICB9O1xuICAgIENvbG9yU2NhbGUucHJvdG90eXBlLmdldENvbG9yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlW3RoaXMuZ2V0Q29sb3JJbmRleCh2YWx1ZSldO1xuICAgIH07XG4gICAgcmV0dXJuIENvbG9yU2NhbGU7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29sb3JTY2FsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlY3Rvcl8xID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xudmFyIEdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JpZChkYXRhLCDPhjAsIM67MCwgzpTPhiwgzpTOuywgaGVpZ2h0LCB3aWR0aCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLs+GMCA9IM+GMDtcbiAgICAgICAgdGhpcy7OuzAgPSDOuzA7XG4gICAgICAgIHRoaXMuzpTOuyA9IM6Uzrs7XG4gICAgICAgIHRoaXMuzpTPhiA9IM6Uz4Y7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHcmlkLnByb3RvdHlwZSwgXCJ2YWx1ZVJhbmdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMuZGF0YVswXS5pbnRlbnNpdHk7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5kYXRhWzBdLmludGVuc2l0eTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWUuaW50ZW5zaXR5KTtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlLmludGVuc2l0eSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBHZXQgdmVjdG9yIGF0IGFueSBwb2ludFxuICAgICAqIEBwYXJhbSDOuyBMb25naXR1ZGVcbiAgICAgKiBAcGFyYW0gz4YgTGF0aXR1ZGVcbiAgICAgKi9cbiAgICBHcmlkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAozrssIM+GKSB7XG4gICAgICAgIHZhciBmzrsgPSB0aGlzLmZsb29yTW9kKM67IC0gdGhpcy7OuzAsIDM2MCkgLyB0aGlzLs6Uzrs7IC8vIGNhbGN1bGF0ZSBsb25naXR1ZGUgaW5kZXggaW4gd3JhcHBlZCByYW5nZSBbMCwgMzYwKVxuICAgICAgICB2YXIgZs+GID0gKHRoaXMuz4YwIC0gz4YpIC8gdGhpcy7OlM+GOyAvLyBjYWxjdWxhdGUgbGF0aXR1ZGUgaW5kZXggaW4gZGlyZWN0aW9uICs5MCB0byAtOTBcbiAgICAgICAgdmFyIGnOuyA9IE1hdGguZmxvb3IoZs67KTsgLy8gY29sIG5cbiAgICAgICAgdmFyIGrOuyA9IGnOuyArIDE7IC8vIGNvbCBuKzFcbiAgICAgICAgaWYgKGrOuyA+PSB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICBqzrsgPSB0aGlzLs67MDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgac+GID0gTWF0aC5mbG9vcihmz4YpOyAvLyBsaW5lIG1cbiAgICAgICAgdmFyIGrPhiA9IGnPhiArIDE7IC8vIGxpbmUgbSsxXG4gICAgICAgIGlmIChqz4YgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGrPhiA9IGnPhjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgds67ID0gZs67IC0gac67OyAvLyBjb2wgdmFyaWF0aW9uIFswLi4xXVxuICAgICAgICB2YXIgds+GID0gZs+GIC0gac+GOyAvLyBsaW5lIHZhcmlhdGlvbiBbMC4uMV1cbiAgICAgICAgaWYgKGnOuyA+PSAwICYmIGnPhiA+PSAwICYmIGnOuyA8IHRoaXMud2lkdGggJiYgac+GIDwgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBnMDAgPSB0aGlzLmRhdGFbac67ICsgac+GICogdGhpcy53aWR0aF07XG4gICAgICAgICAgICB2YXIgZzEwID0gdGhpcy5kYXRhW2rOuyArIGnPhiAqIHRoaXMud2lkdGhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZShnMDApICYmIHRoaXMuaXNWYWx1ZShnMTApKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcwMSA9IHRoaXMuZGF0YVtpzrsgKyBqz4YgKiB0aGlzLndpZHRoXTtcbiAgICAgICAgICAgICAgICB2YXIgZzExID0gdGhpcy5kYXRhW2rOuyArIGrPhiAqIHRoaXMud2lkdGhdO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsdWUoZzAxKSAmJiB0aGlzLmlzVmFsdWUoZzExKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0aW9uKHbOuywgds+GLCBnMDAsIC8vbDBjMFxuICAgICAgICAgICAgICAgICAgICBnMTAsIC8vbDBjMVxuICAgICAgICAgICAgICAgICAgICBnMDEsIC8vbDFjMFxuICAgICAgICAgICAgICAgICAgICBnMTEgLy9sMWNsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yXzEuZGVmYXVsdCgwLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVycG9sYXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHggdmFyaWF0aW9uIGJldHdlZW4gZzAqIGFuZCBnMSpcbiAgICAgKiBAcGFyYW0geSB2YXJpYXRpb24gYmV0d2VlbiBnKjAgZGFucyBnKjFcbiAgICAgKiBAcGFyYW0gZzAwIHBvaW50IGF0IGNvbF8wIGFuZCBsaW5lXzBcbiAgICAgKiBAcGFyYW0gZzEwIHBvaW50IGF0IGNvbF8xIGFuZCBsaW5lXzBcbiAgICAgKiBAcGFyYW0gZzAxIHBvaW50IGF0IGNvbF8wIGFuZCBsaW5lXzFcbiAgICAgKiBAcGFyYW0gZzExIHBvaW50IGF0IGNvbF8xIGFuZCBsaW5lXzFcbiAgICAgKiBAcmV0dXJuIGludGVycG9sYXRlZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBHcmlkLnByb3RvdHlwZS5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKHgsIHksIGcwMCwgZzEwLCBnMDEsIGcxMSkge1xuICAgICAgICB2YXIgcnggPSAoMSAtIHgpO1xuICAgICAgICB2YXIgcnkgPSAoMSAtIHkpO1xuICAgICAgICB2YXIgYSA9IHJ4ICogcnksIGIgPSB4ICogcnksIGMgPSByeCAqIHksIGQgPSB4ICogeTtcbiAgICAgICAgdmFyIHUgPSBnMDAudSAqIGEgKyBnMTAudSAqIGIgKyBnMDEudSAqIGMgKyBnMTEudSAqIGQ7XG4gICAgICAgIHZhciB2ID0gZzAwLnYgKiBhICsgZzEwLnYgKiBiICsgZzAxLnYgKiBjICsgZzExLnYgKiBkO1xuICAgICAgICByZXR1cm4gbmV3IHZlY3Rvcl8xLmRlZmF1bHQodSwgdik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gbW9kdWxvXG4gICAgICogQHJldHVybnMge251bWJlcn0gcmV0dXJucyByZW1haW5kZXIgb2YgZmxvb3JlZCBkaXZpc2lvbiwgaS5lLiwgZmxvb3IoYSAvIG4pLiBVc2VmdWwgZm9yIGNvbnNpc3RlbnQgbW9kdWxvXG4gICAgICogICAgICAgICAgb2YgbmVnYXRpdmUgbnVtYmVycy4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBHcmlkLnByb3RvdHlwZS5mbG9vck1vZCA9IGZ1bmN0aW9uIChhLCBuKSB7XG4gICAgICAgIHJldHVybiBhIC0gbiAqIE1hdGguZmxvb3IoYSAvIG4pO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB4IGlzIGEgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCBudWxsIGFuZCBub3QgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIEdyaWQucHJvdG90eXBlLmlzVmFsdWUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCAhPT0gbnVsbCAmJiB4ICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICA7XG4gICAgcmV0dXJuIEdyaWQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gR3JpZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlbG9jaXR5TGF5ZXJfMSA9IHJlcXVpcmUoXCIuL3ZlbG9jaXR5TGF5ZXJcIik7XG52YXIgY2FudmFzQm91bmRfMSA9IHJlcXVpcmUoXCIuL2NhbnZhc0JvdW5kXCIpO1xudmFyIG1hcEJvdW5kXzEgPSByZXF1aXJlKFwiLi9tYXBCb3VuZFwiKTtcbnZhciB3aW5keV8xID0gcmVxdWlyZShcIi4vd2luZHlcIik7XG53aW5kb3cuVmVsb2NpdHlMYXllciA9IHZlbG9jaXR5TGF5ZXJfMS5kZWZhdWx0O1xud2luZG93LkNhbnZhc0JvdW5kID0gY2FudmFzQm91bmRfMS5kZWZhdWx0O1xud2luZG93Lk1hcEJvdW5kID0gbWFwQm91bmRfMS5kZWZhdWx0O1xud2luZG93LldpbmR5ID0gd2luZHlfMS5kZWZhdWx0O1xudmFyIHRlc3RsYXllcl8xID0gcmVxdWlyZShcIi4vdGVzdGxheWVyXCIpO1xud2luZG93LlRlc3RMYXllciA9IHRlc3RsYXllcl8xLmRlZmF1bHQ7XG52YXIgTWFwXzEgPSByZXF1aXJlKFwib2wvTWFwXCIpO1xudmFyIFZpZXdfMSA9IHJlcXVpcmUoXCJvbC9WaWV3XCIpO1xudmFyIFRpbGVfMSA9IHJlcXVpcmUoXCJvbC9sYXllci9UaWxlXCIpO1xudmFyIE9TTV8xID0gcmVxdWlyZShcIm9sL3NvdXJjZS9PU01cIik7XG52YXIgU3RhbWVuXzEgPSByZXF1aXJlKFwib2wvc291cmNlL1N0YW1lblwiKTtcbndpbmRvdy5NYXAgPSBNYXBfMS5kZWZhdWx0O1xud2luZG93LlZpZXcgPSBWaWV3XzEuZGVmYXVsdDtcbndpbmRvdy5UaWxlTGF5ZXIgPSBUaWxlXzEuZGVmYXVsdDtcbndpbmRvdy5PU00gPSBPU01fMS5kZWZhdWx0O1xud2luZG93LlN0YW1lbiA9IFN0YW1lbl8xLmRlZmF1bHQ7XG52YXIgcHJvaiA9IHJlcXVpcmUoJ29sL3Byb2onKS5kZWZhdWx0O1xud2luZG93LnByb2ogPSBwcm9qO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gbGF5ZXIobWFwQm91bmQsIGNhbnZhc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuY2FudmFzQm91bmQgPSBjYW52YXNCb3VuZDtcbiAgICAgICAgdGhpcy5tYXBCb3VuZCA9IG1hcEJvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGdlb2Nvb3JkaW5hdGUgZnJvbSBjYW52YXMgcG9pbnRcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogcmV0dXJuIFtsbmcsIGxhdF1cbiAgICAgKi9cbiAgICBsYXllci5wcm90b3R5cGUuY2FudmFzVG9NYXAgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbWFwTG9uRGVsdGEgPSB0aGlzLm1hcEJvdW5kLmVhc3QgLSB0aGlzLm1hcEJvdW5kLndlc3Q7XG4gICAgICAgIHZhciB3b3JsZE1hcFJhZGl1cyA9ICh0aGlzLmNhbnZhc0JvdW5kLndpZHRoIC8gdGhpcy5yYWQyZGVnKG1hcExvbkRlbHRhKSkgKiAzNjAgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICB2YXIgbWFwT2Zmc2V0WSA9ICh3b3JsZE1hcFJhZGl1cyAvIDIgKiBNYXRoLmxvZygoMSArIE1hdGguc2luKHRoaXMubWFwQm91bmQuc291dGgpKSAvICgxIC0gTWF0aC5zaW4odGhpcy5tYXBCb3VuZC5zb3V0aCkpKSk7XG4gICAgICAgIHZhciBlcXVhdG9yWSA9IHRoaXMuY2FudmFzQm91bmQuaGVpZ2h0ICsgbWFwT2Zmc2V0WTtcbiAgICAgICAgdmFyIGEgPSAoZXF1YXRvclkgLSB5KSAvIHdvcmxkTWFwUmFkaXVzO1xuICAgICAgICB2YXIgz4YgPSAxODAgLyBNYXRoLlBJICogKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoYSkpIC0gTWF0aC5QSSAvIDIpO1xuICAgICAgICB2YXIgzrsgPSB0aGlzLnJhZDJkZWcodGhpcy5tYXBCb3VuZC53ZXN0KSArIHggLyB0aGlzLmNhbnZhc0JvdW5kLndpZHRoICogdGhpcy5yYWQyZGVnKG1hcExvbkRlbHRhKTtcbiAgICAgICAgcmV0dXJuIFvOuywgz4ZdO1xuICAgIH07XG4gICAgO1xuICAgIGxheWVyLnByb3RvdHlwZS5tZXJjWSA9IGZ1bmN0aW9uICjPhikge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC50YW4oz4YgLyAyICsgTWF0aC5QSSAvIDQpKTtcbiAgICB9O1xuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IGEgcG9pbnQgb24gdGhlIG1hcFxuICAgICAqIEBwYXJhbSDOuyBMb25naXR1ZGVcbiAgICAgKiBAcGFyYW0gz4YgTGF0aXR1ZGVcbiAgICAgKiBAcmV0dXJuIFt4LCB5XVxuICAgICAqL1xuICAgIGxheWVyLnByb3RvdHlwZS5tYXBUb0NhbnZhcyA9IGZ1bmN0aW9uICjOuywgz4YpIHtcbiAgICAgICAgdmFyIHltaW4gPSB0aGlzLm1lcmNZKHRoaXMubWFwQm91bmQuc291dGgpO1xuICAgICAgICB2YXIgeW1heCA9IHRoaXMubWVyY1kodGhpcy5tYXBCb3VuZC5ub3J0aCk7XG4gICAgICAgIHZhciB4RmFjdG9yID0gdGhpcy5jYW52YXNCb3VuZC53aWR0aCAvICh0aGlzLm1hcEJvdW5kLmVhc3QgLSB0aGlzLm1hcEJvdW5kLndlc3QpO1xuICAgICAgICB2YXIgeUZhY3RvciA9IHRoaXMuY2FudmFzQm91bmQuaGVpZ2h0IC8gKHltYXggLSB5bWluKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLm1lcmNZKHRoaXMuZGVnMnJhZCjPhikpO1xuICAgICAgICB2YXIgeCA9ICh0aGlzLmRlZzJyYWQozrspIC0gdGhpcy5tYXBCb3VuZC53ZXN0KSAqIHhGYWN0b3I7XG4gICAgICAgIHkgPSAoeW1heCAtIHkpICogeUZhY3RvcjtcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9O1xuICAgIDtcbiAgICBsYXllci5wcm90b3R5cGUuZGVnMnJhZCA9IGZ1bmN0aW9uIChkZWcpIHtcbiAgICAgICAgcmV0dXJuIGRlZyAqIE1hdGguUEkgLyAxODA7XG4gICAgfTtcbiAgICA7XG4gICAgbGF5ZXIucHJvdG90eXBlLnJhZDJkZWcgPSBmdW5jdGlvbiAocmFkKSB7XG4gICAgICAgIHJldHVybiByYWQgKiAxODAgLyBNYXRoLlBJO1xuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIM67IExvbmdpdHVkZVxuICAgICAqIEBwYXJhbSDPhiBMYXRpdHVkZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJuIFtdXG4gICAgICovXG4gICAgbGF5ZXIucHJvdG90eXBlLmRpc3RvcnRpb24gPSBmdW5jdGlvbiAozrssIM+GLCB4LCB5KSB7XG4gICAgICAgIHZhciDPhCA9IDIgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgSCA9IE1hdGgucG93KDEwLCAtNS4yKTtcbiAgICAgICAgdmFyIGjOuyA9IM67IDwgMCA/IEggOiAtSDtcbiAgICAgICAgdmFyIGjPhiA9IM+GIDwgMCA/IEggOiAtSDtcbiAgICAgICAgdmFyIHDOuyA9IHRoaXMubWFwVG9DYW52YXMozrsgKyBozrssIM+GKTtcbiAgICAgICAgdmFyIHDPhiA9IHRoaXMubWFwVG9DYW52YXMozrssIM+GICsgaM+GKTtcbiAgICAgICAgLy8gTWVyaWRpYW4gc2NhbGUgZmFjdG9yIChzZWUgU255ZGVyLCBlcXVhdGlvbiA0LTMpLCB3aGVyZSBSID0gMS4gVGhpcyBoYW5kbGVzIGlzc3VlIHdoZXJlIGxlbmd0aCBvZiAxwrogzrtcbiAgICAgICAgLy8gY2hhbmdlcyBkZXBlbmRpbmcgb24gz4YuIFdpdGhvdXQgdGhpcywgdGhlcmUgaXMgYSBwaW5jaGluZyBlZmZlY3QgYXQgdGhlIHBvbGVzLlxuICAgICAgICB2YXIgayA9IE1hdGguY29zKM+GIC8gMzYwICogz4QpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKHDOu1swXSAtIHgpIC8gaM67IC8gayxcbiAgICAgICAgICAgIChwzrtbMV0gLSB5KSAvIGjOuyAvIGssXG4gICAgICAgICAgICAocM+GWzBdIC0geCkgLyBoz4YsXG4gICAgICAgICAgICAocM+GWzFdIC0geSkgLyBoz4ZcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBkaXN0b3J0aW9uIG9mIHRoZSB3aW5kIHZlY3RvciBjYXVzZWQgYnkgdGhlIHNoYXBlIG9mIHRoZSBwcm9qZWN0aW9uIGF0IHBvaW50ICh4LCB5KS4gVGhlIHdpbmRcbiAgICAgKiB2ZWN0b3IgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIM67XG4gICAgICogQHBhcmFtIM+GXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSBzY2FsZSBzY2FsZSBmYWN0b3JcbiAgICAgKiBAcGFyYW0gd2luZCBbdSwgdl1cbiAgICAgKiBAcmV0dXJuIFtdXG4gICAgICovXG4gICAgbGF5ZXIucHJvdG90eXBlLmRpc3RvcnQgPSBmdW5jdGlvbiAozrssIM+GLCB4LCB5LCBzY2FsZSwgd2luZCkge1xuICAgICAgICB2YXIgdSA9IHdpbmQudSAqIHNjYWxlO1xuICAgICAgICB2YXIgdiA9IHdpbmQudiAqIHNjYWxlO1xuICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdG9ydGlvbijOuywgz4YsIHgsIHkpO1xuICAgICAgICAvLyBTY2FsZSBkaXN0b3J0aW9uIHZlY3RvcnMgYnkgdSBhbmQgdiwgdGhlbiBhZGQuXG4gICAgICAgIHdpbmQudSA9IGRbMF0gKiB1ICsgZFsyXSAqIHY7XG4gICAgICAgIHdpbmQudiA9IGRbMV0gKiB1ICsgZFszXSAqIHY7XG4gICAgICAgIHJldHVybiB3aW5kO1xuICAgIH07XG4gICAgcmV0dXJuIGxheWVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGxheWVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWFwQm91bmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwQm91bmQobm9ydGgsIGVhc3QsIHNvdXRoLCB3ZXN0KSB7XG4gICAgICAgIHRoaXMubm9ydGggPSBub3J0aCAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIHRoaXMuZWFzdCA9IGVhc3QgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB0aGlzLnNvdXRoID0gc291dGggKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICB0aGlzLndlc3QgPSB3ZXN0ICogTWF0aC5QSSAvIDE4MDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcEJvdW5kLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuICg3MjAgKyB0aGlzLmVhc3QgLSB0aGlzLndlc3QpICUgMzYwO1xuICAgICAgICAgICAgcmV0dXJuICgoNzIwICsgdGhpcy5lYXN0ICogMTgwIC8gTWF0aC5QSSAtIHRoaXMud2VzdCAqIDE4MCAvIE1hdGguUEkpICUgMzYwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBCb3VuZC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gKDM2MCArIHRoaXMubm9ydGggLSB0aGlzLnNvdXRoKSAlIDE4MDtcbiAgICAgICAgICAgIHJldHVybiAoKDM2MCArIHRoaXMubm9ydGggKiAxODAgLyBNYXRoLlBJIC0gdGhpcy5zb3V0aCAqIDE4MCAvIE1hdGguUEkpICUgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNYXBCb3VuZDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBNYXBCb3VuZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhcnRpY3VsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJ0aWN1bGUoeCwgeSwgbWF4QWdlKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMuYWdlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4QWdlKTtcbiAgICAgICAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2U7XG4gICAgfVxuICAgIFBhcnRpY3VsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLmFnZSA9IDA7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGFydGljdWxlLnByb3RvdHlwZSwgXCJpc0RlYWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFnZSA+IHRoaXMubWF4QWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQYXJ0aWN1bGUucHJvdG90eXBlLmdyb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWdlKys7XG4gICAgfTtcbiAgICByZXR1cm4gUGFydGljdWxlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBhcnRpY3VsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRpbGVfMSA9IHJlcXVpcmUoXCJvbC9sYXllci9UaWxlXCIpO1xudmFyIFN0YW1lbl8xID0gcmVxdWlyZShcIm9sL3NvdXJjZS9TdGFtZW5cIik7XG52YXIgVGVzdExheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlc3RMYXllcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1Rlc3RMYXllci5jb25zdHJ1Y3RvcicpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPSBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRlc3RMYXllci5wcm90b3R5cGUuZ2V0TWFwTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1Rlc3RMYXllci5nZXRNYXBMYXllcicpO1xuICAgICAgICB0aGlzLl9sYXllciA9IHRoaXMuX2xheWVyIHx8IG5ldyBUaWxlXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBzb3VyY2U6IG5ldyBTdGFtZW5fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBsYXllcjogJ3RvbmVyJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1Rlc3RMYXllci5nZXRNYXBMYXllciByZXR1cm4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyO1xuICAgIH07XG4gICAgVGVzdExheWVyLnByb3RvdHlwZS5hZGRUb01hcCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnVmVsb2NpdHlMYXllci5hZGRUb01hcCcpO1xuICAgICAgICBtYXAuYWRkTGF5ZXIodGhpcy5nZXRNYXBMYXllcigpKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdUZXN0TGF5ZXIuYWRkVG9NYXAgcmV0dXJuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVzdExheWVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRlc3RMYXllcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFZlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZWN0b3IodSwgdikge1xuICAgICAgICB0aGlzLnUgPSB1IHx8IDA7XG4gICAgICAgIHRoaXMudiA9IHYgfHwgMDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlY3Rvci5wcm90b3R5cGUsIFwiaW50ZW5zaXR5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMudSAqIHRoaXMudSArIHRoaXMudiAqIHRoaXMudik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBWZWN0b3I7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVmVjdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd2luZHlfMSA9IHJlcXVpcmUoXCIuL3dpbmR5XCIpO1xudmFyIGNhbnZhc0JvdW5kXzEgPSByZXF1aXJlKFwiLi9jYW52YXNCb3VuZFwiKTtcbnZhciBtYXBCb3VuZF8xID0gcmVxdWlyZShcIi4vbWFwQm91bmRcIik7XG52YXIgbGF5ZXJfMSA9IHJlcXVpcmUoXCIuL2xheWVyXCIpO1xudmFyIEltYWdlXzEgPSByZXF1aXJlKFwib2wvbGF5ZXIvSW1hZ2VcIik7XG52YXIgSW1hZ2VDYW52YXNfMSA9IHJlcXVpcmUoXCJvbC9zb3VyY2UvSW1hZ2VDYW52YXNcIik7XG52YXIgcHJval8xID0gcmVxdWlyZShcIm9sL3Byb2pcIik7XG4vLyBkZWNsYXJlIGZ1bmN0aW9uIHJlcXVpcmUobmFtZTpzdHJpbmcpOmFueTtcbi8vIGNvbnN0IHByb2ogPSAoPGFueT5yZXF1aXJlKCdvbC9wcm9qJykpLmRlZmF1bHQ7XG4vLyBGaXg6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVubGF5ZXJzL29wZW5sYXllcnMvaXNzdWVzLzgwMzdcbnZhciBWZWxvY2l0eUxheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZlbG9jaXR5TGF5ZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXNFeHRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW52YXNTaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FudmFzTGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl93aW5keSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kaXNwbGF5VGltZW91dCA9IDA7XG4gICAgICAgIHRoaXMuX21vdXNlQ29udHJvbCA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1ZlbG9jaXR5TGF5ZXIuY29uc3RydWN0b3InKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBkaXNwbGF5VmFsdWVzOiB0cnVlLFxuICAgICAgICAgICAgZGlzcGxheU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eVR5cGU6ICdWZWxvY2l0eScsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdib3R0b21sZWZ0JyxcbiAgICAgICAgICAgICAgICBlbXB0eVN0cmluZzogJ05vIHZlbG9jaXR5IGRhdGEnLFxuICAgICAgICAgICAgICAgIGFuZ2xlQ29udmVudGlvbjogJ2JlYXJpbmdDQ1cnLFxuICAgICAgICAgICAgICAgIHNwZWVkVW5pdDogJ20vcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhWZWxvY2l0eTogMTAsXG4gICAgICAgICAgICBjb2xvclNjYWxlOiBudWxsLFxuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgY29uc29sZS5kZWJ1Zyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBWZWxvY2l0eUxheWVyLnByb3RvdHlwZS5fY2FudmFzRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzaXplLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1ZlbG9jaXR5TGF5ZXIuY2FudmFzRnVuY3Rpb24nKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnZXh0ZW50OiAnICsgZXh0ZW50ICsgJyB8IHJlc29sdXRpb246ICcgKyByZXNvbHV0aW9uICsgJyB8IHBpeGVsUmF0aW86ICcgKyBwaXhlbFJhdGlvICsgJyB8IHNpemU6ICcgKyBzaXplKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdGhpcy5fY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemVbMF0pO1xuICAgICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplWzFdKTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLl9jYW52YXNFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgIHRoaXMuX2NhbnZhc1NpemUgPSBzaXplO1xuICAgICAgICB0aGlzLl9yZXN0YXJ0V2luZHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgICB9O1xuICAgIFZlbG9jaXR5TGF5ZXIucHJvdG90eXBlLmdldE1hcExheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jYW52YXNMYXllciA9IHRoaXMuX2NhbnZhc0xheWVyIHx8IG5ldyBJbWFnZV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgc291cmNlOiBuZXcgSW1hZ2VDYW52YXNfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBjYW52YXNGdW5jdGlvbjogdGhpcy5fY2FudmFzRnVuY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uOiAnRVBTRzozODU3J1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNMYXllcjtcbiAgICB9O1xuICAgIFZlbG9jaXR5TGF5ZXIucHJvdG90eXBlLmFkZFRvTWFwID0gZnVuY3Rpb24gKG1hcCwgY2FudmFzKSB7XG4gICAgICAgIGlmIChjYW52YXMgPT09IHZvaWQgMCkgeyBjYW52YXMgPSBudWxsOyB9XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1ZlbG9jaXR5TGF5ZXIuYWRkVG9NYXAnKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzIHx8IHRoaXMuX2NhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5nZXRNYXBMYXllcigpKTtcbiAgICAgICAgdGhpcy5fc3RhcnRXaW5keSgpO1xuICAgIH07XG4gICAgVmVsb2NpdHlMYXllci5wcm90b3R5cGUucmVtb3ZlRnJvbU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnVmVsb2NpdHlMYXllci5yZW1vdmVGcm9tTWFwJyk7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVmVsb2NpdHlMYXllci5yZW1vdmVGcm9tTWFwOiBObyBtYXAhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveVdpbmQoKTtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2NhbnZhc0xheWVyKTtcbiAgICB9O1xuICAgIFZlbG9jaXR5TGF5ZXIucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdWZWxvY2l0eUxheWVyLnNldERhdGEnKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAodGhpcy5fd2luZHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpbmR5LnNldERhdGEoZGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzTGF5ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzTGF5ZXIuY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWZWxvY2l0eUxheWVyLnByb3RvdHlwZS5faW5pdFdpbmR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdWZWxvY2l0eUxheWVyLl9pbml0V2luZHknKTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gdGhpcy5fY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAvLyB3aW5keSBvYmplY3QsIGNvcHkgb3B0aW9uc1xuICAgICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgY2FudmFzOiB0aGlzLl9jYW52YXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3dpbmR5ID0gbmV3IHdpbmR5XzEuZGVmYXVsdChvcHRpb25zKTtcbiAgICAgICAgLy8gdGhpcy5faW5pdE1vdXNlSGFuZGxlcigpO1xuICAgIH07XG4gICAgVmVsb2NpdHlMYXllci5wcm90b3R5cGUuX2NhbnZhc0xheWVyX2NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhc0xheWVyLmNoYW5nZWQoKTtcbiAgICB9O1xuICAgIC8vIF9pbml0TW91c2VIYW5kbGVyKCkge1xuICAgIC8vICAgaWYgKCF0aGlzLl9tb3VzZUNvbnRyb2wgJiYgdGhpcy5vcHRpb25zLmRpc3BsYXlWYWx1ZXMpIHtcbiAgICAvLyAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZGlzcGxheU9wdGlvbnMgfHwge307XG4gICAgLy8gICAgIG9wdGlvbnNbJ2xlYWZsZXRWZWxvY2l0eSddID0gdGhpcztcbiAgICAvLyAgICAgdGhpcy5fbW91c2VDb250cm9sID0gTF9jb250cm9sVmVsb2NpdHkoKTtcbiAgICAvLyAgICAgdGhpcy5fbW91c2VDb250cm9sLnNldFdpbmR5KHRoaXMuX3dpbmR5KTtcbiAgICAvLyAgICAgdGhpcy5fbW91c2VDb250cm9sLnNldE9wdGlvbnModGhpcy5vcHRpb25zLmRpc3BsYXlPcHRpb25zKTtcbiAgICAvLyAgICAgdGhpcy5fbW91c2VDb250cm9sLmFkZFRvKHRoaXMuX21hcCk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIFZlbG9jaXR5TGF5ZXIucHJvdG90eXBlLl9zdGFydFdpbmR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmRlYnVnKCdWZWxvY2l0eUxheWVyLl9zdGFydFdpbmR5Jyk7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fd2luZHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRXaW5keSgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRXaW5keSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1ZlbG9jaXR5TGF5ZXIuX3N0YXJ0V2luZHk6IG5vIGRhdGEhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlUaW1lb3V0KVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Rpc3BsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fZGlzcGxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXBTaXplID0gX3RoaXMuX21hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdtYXBTaXplOiAnICsgbWFwU2l6ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdjYW52YXNTaXplOiAnICsgX3RoaXMuX2NhbnZhc1NpemUpO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IF90aGlzLl9tYXAuZ2V0VmlldygpLmNhbGN1bGF0ZUV4dGVudChfdGhpcy5fY2FudmFzU2l6ZSk7XG4gICAgICAgICAgICB2YXIgZXh0ZW50TEwgPSBwcm9qXzEudHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgJ0VQU0c6Mzg1NycsICdFUFNHOjQzMjYnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ2V4dGVudExMJyArIGV4dGVudExMKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICBfdGhpcy5fd2luZHkuc3RhcnQobmV3IGxheWVyXzEuZGVmYXVsdChuZXcgbWFwQm91bmRfMS5kZWZhdWx0KGV4dGVudExMWzNdLCAvLyBtYXh5IChub3J0aClcbiAgICAgICAgICAgIGV4dGVudExMWzJdLCAvLyBtYXh4IChlYXN0KVxuICAgICAgICAgICAgZXh0ZW50TExbMV0sIC8vIG1pbnkgKHNvdXRoKVxuICAgICAgICAgICAgZXh0ZW50TExbMF0gLy8gbWlueCAod2VzdClcbiAgICAgICAgICAgICksIG5ldyBjYW52YXNCb3VuZF8xLmRlZmF1bHQoMCwgMCwgX3RoaXMuX2NhbnZhc1NpemVbMF0sIF90aGlzLl9jYW52YXNTaXplWzFdKSkpO1xuICAgICAgICB9LCAxNTApOyAvLyBzaG93aW5nIHZlbG9jaXR5IGRlbGF5ZWQgd2hpbGUgbGF5ZXIgaXMgYmVpbmcgYWRkZWQgdG8gdGhlIG1hcFxuICAgIH07XG4gICAgVmVsb2NpdHlMYXllci5wcm90b3R5cGUuX3Jlc3RhcnRXaW5keSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy9jb25zb2xlLmRlYnVnKCdWZWxvY2l0eUxheWVyLl9yZXN0YXJ0V2luZHknKTtcbiAgICAgICAgaWYgKHRoaXMuX3dpbmR5KSB7XG4gICAgICAgICAgICB0aGlzLl93aW5keS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhcnRXaW5keSgpO1xuICAgIH07XG4gICAgVmVsb2NpdHlMYXllci5wcm90b3R5cGUuX2Rlc3Ryb3lXaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdWZWxvY2l0eUxheWVyLl9kZXN0cm95V2luZCcpO1xuICAgICAgICBpZiAodGhpcy5fZGlzcGxheVRpbWVvdXQpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGlzcGxheVRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fd2luZHkpXG4gICAgICAgICAgICB0aGlzLl93aW5keS5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0KVxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoMCwgMCwgMzAwMCwgMzAwMCk7XG4gICAgICAgIC8vIGlmICh0aGlzLl9tb3VzZUNvbnRyb2wpXG4gICAgICAgIC8vICAgdGhpcy5fbWFwLnJlbW92ZUNvbnRyb2wodGhpcy5fbW91c2VDb250cm9sKTtcbiAgICAgICAgLy8gdGhpcy5fbW91c2VDb250cm9sID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2luZHkgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fY2FudmFzTGF5ZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIFZlbG9jaXR5TGF5ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVmVsb2NpdHlMYXllcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlY3Rvcl8xID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xudmFyIGdyaWRfMSA9IHJlcXVpcmUoXCIuL2dyaWRcIik7XG52YXIgY29sb3JTY2FsZV8xID0gcmVxdWlyZShcIi4vY29sb3JTY2FsZVwiKTtcbnZhciBhbmltYXRpb25CdWNrZXRfMSA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbkJ1Y2tldFwiKTtcbnZhciBXaW5keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaW5keShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJ0aWN1bGVNdWx0aXBsaWVyID0gMSAvIDMwMDtcbiAgICAgICAgdGhpcy5hdXRvQ29sb3JSYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpY3VsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wID0gbnVsbDtcbiAgICAgICAgdGhpcy50aGVuID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBvcHRpb25zLmNhbnZhcztcbiAgICAgICAgaWYgKG9wdGlvbnMubWluVmVsb2NpdHkgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm1heFZlbG9jaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbG9yUmFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBjb2xvclNjYWxlXzEuZGVmYXVsdChvcHRpb25zLm1pblZlbG9jaXR5IHx8IDAsIG9wdGlvbnMubWF4VmVsb2NpdHkgfHwgMTAsIG9wdGlvbnMuY29sb3JTY2FsZSk7XG4gICAgICAgIHRoaXMudmVsb2NpdHlTY2FsZSA9IG9wdGlvbnMudmVsb2NpdHlTY2FsZSB8fCAwLjAxO1xuICAgICAgICB0aGlzLnBhcnRpY2xlQWdlID0gb3B0aW9ucy5wYXJ0aWNsZUFnZSB8fCA2NDtcbiAgICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIHRoaXMucGFydGljdWxlTXVsdGlwbGllciA9IG9wdGlvbnMucGFydGljbGVNdWx0aXBsaWVyIHx8IDEgLyAzMDA7XG4gICAgICAgIHRoaXMucGFydGljdWxlTGluZVdpZHRoID0gb3B0aW9ucy5saW5lV2lkdGggfHwgMTtcbiAgICAgICAgdmFyIGZyYW1lUmF0ZSA9IG9wdGlvbnMuZnJhbWVSYXRlIHx8IDE1O1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IDEwMDAgLyBmcmFtZVJhdGU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5keS5wcm90b3R5cGUsIFwicGFydGljdWxlQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWN1bGVSZWR1Y3Rpb24gPSAoKC9hbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGV8aXBhZHxpcGhvbmV8aXBvZHxvcGVyYSBtaW5pfHdlYm9zL2kpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpID8gKE1hdGgucG93KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxIC8gMykgfHwgMS42KSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmxheWVyLmNhbnZhc0JvdW5kLndpZHRoICogdGhpcy5sYXllci5jYW52YXNCb3VuZC5oZWlnaHQgKiB0aGlzLnBhcnRpY3VsZU11bHRpcGxpZXIpICogcGFydGljdWxlUmVkdWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBMb2FkIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIFdpbmR5LnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHVEYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIHZEYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIGdyaWQgPSBbXTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLmhlYWRlci5wYXJhbWV0ZXJDYXRlZ29yeSArIFwiLFwiICsgcmVjb3JkLmhlYWRlci5wYXJhbWV0ZXJOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiMSwyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIjIsMlwiOlxuICAgICAgICAgICAgICAgICAgICB1RGF0YSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjEsM1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIyLDNcIjpcbiAgICAgICAgICAgICAgICAgICAgdkRhdGEgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVEYXRhIHx8ICF2RGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGF0YSBhcmUgbm90IGNvcnJlY3QgZm9ybWF0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVEYXRhLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAodSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGdyaWQucHVzaChuZXcgdmVjdG9yXzEuZGVmYXVsdCh1LCB2RGF0YS5kYXRhW2luZGV4XSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZygndURhdGEnLCB1RGF0YSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3ZEYXRhJywgdkRhdGEpO1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgZ3JpZF8xLmRlZmF1bHQoZ3JpZCwgdURhdGEuaGVhZGVyLmxhMSwgdURhdGEuaGVhZGVyLmxvMSwgdURhdGEuaGVhZGVyLmR5LCB1RGF0YS5oZWFkZXIuZHgsIHVEYXRhLmhlYWRlci5ueSwgdURhdGEuaGVhZGVyLm54KTtcbiAgICAgICAgdGhpcy7OuzAgPSB1RGF0YS5oZWFkZXIubG8xO1xuICAgICAgICB0aGlzLs+GMCA9IHVEYXRhLmhlYWRlci5sYTE7XG4gICAgICAgIHRoaXMuzpTOuyA9IHVEYXRhLmhlYWRlci5keDtcbiAgICAgICAgdGhpcy7OlM+GID0gdURhdGEuaGVhZGVyLmR5O1xuICAgICAgICB0aGlzLm5pID0gdURhdGEuaGVhZGVyLm54O1xuICAgICAgICB0aGlzLm5qID0gdURhdGEuaGVhZGVyLm55OyAvLyBudW1iZXIgb2YgZ3JpZCBwb2ludHMgVy1FIGFuZCBOLVMgKGUuZy4sIDE0NCB4IDczKVxuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIHZhciBpc0NvbnRpbnVvdXMgPSBNYXRoLmZsb29yKHRoaXMubmkgKiB0aGlzLs6UzrspID49IDM2MDtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLm5qOyBqKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uaTsgaSsrLCBwKyspIHtcbiAgICAgICAgICAgICAgICByb3dbaV0gPSB0aGlzLmdyaWQuZGF0YVtwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igd3JhcHBlZCBncmlkcywgZHVwbGljYXRlIGZpcnN0IGNvbHVtbiBhcyBsYXN0IGNvbHVtbiB0byBzaW1wbGlmeSBpbnRlcnBvbGF0aW9uIGxvZ2ljXG4gICAgICAgICAgICAgICAgcm93LnB1c2gocm93WzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ3JpZFtqXSA9IHJvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQ29sb3JSYW5nZSkge1xuICAgICAgICAgICAgdmFyIG1pbk1heCA9IHRoaXMuZ3JpZC52YWx1ZVJhbmdlO1xuICAgICAgICAgICAgdGhpcy5jb2xvclNjYWxlLnNldE1pbk1heChtaW5NYXhbMF0sIG1pbk1heFsxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmR5LnByb3RvdHlwZS5mbG9vck1vZCA9IGZ1bmN0aW9uIChhLCBuKSB7XG4gICAgICAgIHJldHVybiBhIC0gbiAqIE1hdGguZmxvb3IoYSAvIG4pO1xuICAgIH07XG4gICAgO1xuICAgIFdpbmR5LnByb3RvdHlwZS5pc1ZhbHVlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggIT09IG51bGwgJiYgeCAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgO1xuICAgIFdpbmR5LnByb3RvdHlwZS5iaWxpbmVhckludGVycG9sYXRlVmVjdG9yID0gZnVuY3Rpb24gKHgsIHksIGcwMCwgZzEwLCBnMDEsIGcxMSkge1xuICAgICAgICB2YXIgcnggPSAoMSAtIHgpO1xuICAgICAgICB2YXIgcnkgPSAoMSAtIHkpO1xuICAgICAgICB2YXIgYSA9IHJ4ICogcnksIGIgPSB4ICogcnksIGMgPSByeCAqIHksIGQgPSB4ICogeTtcbiAgICAgICAgdmFyIHUgPSBnMDAudSAqIGEgKyBnMTAudSAqIGIgKyBnMDEudSAqIGMgKyBnMTEudSAqIGQ7XG4gICAgICAgIHZhciB2ID0gZzAwLnYgKiBhICsgZzEwLnYgKiBiICsgZzAxLnYgKiBjICsgZzExLnYgKiBkO1xuICAgICAgICByZXR1cm4gW3UsIHYsIE1hdGguc3FydCh1ICogdSArIHYgKiB2KV07XG4gICAgfTtcbiAgICA7XG4gICAgLyogR2V0IGludGVycG9sYXRlZCBncmlkIHZhbHVlIGZyb20gTG9uL0xhdCBwb3NpdGlvblxuICAgICogQHBhcmFtIM67IHtGbG9hdH0gTG9uZ2l0dWRlXG4gICAgKiBAcGFyYW0gz4Yge0Zsb2F0fSBMYXRpdHVkZVxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIFdpbmR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICjOuywgz4YpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gdGhpcy5mbG9vck1vZCjOuyAtIHRoaXMuzrswLCAzNjApIC8gdGhpcy7OlM67OyAvLyBjYWxjdWxhdGUgbG9uZ2l0dWRlIGluZGV4IGluIHdyYXBwZWQgcmFuZ2UgWzAsIDM2MClcbiAgICAgICAgdmFyIGogPSAodGhpcy7PhjAgLSDPhikgLyB0aGlzLs6Uz4Y7IC8vIGNhbGN1bGF0ZSBsYXRpdHVkZSBpbmRleCBpbiBkaXJlY3Rpb24gKzkwIHRvIC05MFxuICAgICAgICB2YXIgZmkgPSBNYXRoLmZsb29yKGkpO1xuICAgICAgICB2YXIgY2kgPSBmaSArIDE7XG4gICAgICAgIHZhciBmaiA9IE1hdGguZmxvb3Ioaik7XG4gICAgICAgIHZhciBjaiA9IGZqICsgMTtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ3JpZFtmal07IC8vRG9udCBrbm93IHdoeSBoZSBkb3NlbnQgZm91bmQgYW55IHJvdyBFUlJSUk9SXG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHZhciBnMDAgPSByb3dbZmldO1xuICAgICAgICAgICAgdmFyIGcxMCA9IHJvd1tjaV07XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbHVlKGcwMCkgJiYgdGhpcy5pc1ZhbHVlKGcxMCkgJiYgKHJvdyA9IHRoaXMuZ3JpZFtjal0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcwMSA9IHJvd1tmaV07XG4gICAgICAgICAgICAgICAgdmFyIGcxMSA9IHJvd1tjaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWx1ZShnMDEpICYmIHRoaXMuaXNWYWx1ZShnMTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBmb3VyIHBvaW50cyBmb3VuZCwgc28gaW50ZXJwb2xhdGUgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iaWxpbmVhckludGVycG9sYXRlVmVjdG9yKGkgLSBmaSwgaiAtIGZqLCBnMDAsIGcxMCwgZzAxLCBnMTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIDtcbiAgICBXaW5keS5wcm90b3R5cGUuZ2V0UGFydGljdWxlV2luZCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsbmdMYXQgPSB0aGlzLmxheWVyLmNhbnZhc1RvTWFwKHAueCwgcC55KTtcbiAgICAgICAgdmFyIHdpbmQgPSB0aGlzLmdyaWQuZ2V0KGxuZ0xhdFswXSwgbG5nTGF0WzFdKTtcbiAgICAgICAgcC5pbnRlbnNpdHkgPSB3aW5kLmludGVuc2l0eTtcbiAgICAgICAgdmFyIG1hcEFyZWEgPSB0aGlzLmxheWVyLm1hcEJvdW5kLmhlaWdodCAqIHRoaXMubGF5ZXIubWFwQm91bmQud2lkdGg7XG4gICAgICAgIHZhciB2ZWxvY2l0eVNjYWxlID0gdGhpcy52ZWxvY2l0eVNjYWxlICogTWF0aC5wb3cobWFwQXJlYSwgMC40KTtcbiAgICAgICAgdGhpcy5sYXllci5kaXN0b3J0KGxuZ0xhdFswXSwgbG5nTGF0WzFdLCBwLngsIHAueSwgdmVsb2NpdHlTY2FsZSwgd2luZCk7XG4gICAgICAgIHJldHVybiB3aW5kO1xuICAgIH07XG4gICAgV2luZHkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHRoaXMuY29udGV4dDJEID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB0aGlzLmNvbnRleHQyRC5saW5lV2lkdGggPSB0aGlzLnBhcnRpY3VsZUxpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5jb250ZXh0MkQuZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDAuOTcpXCI7XG4gICAgICAgIHRoaXMuY29udGV4dDJELmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQnVja2V0ID0gbmV3IGFuaW1hdGlvbkJ1Y2tldF8xLmRlZmF1bHQodGhpcy5jb2xvclNjYWxlKTtcbiAgICAgICAgdGhpcy5wYXJ0aWN1bGVzLnNwbGljZSgwLCB0aGlzLnBhcnRpY3VsZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcnRpY3VsZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucGFydGljdWxlcy5wdXNoKHRoaXMubGF5ZXIuY2FudmFzQm91bmQuZ2V0UmFuZG9tUGFydGljdWxlKHRoaXMucGFydGljbGVBZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW4gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5mcmFtZSgpO1xuICAgIH07XG4gICAgV2luZHkucHJvdG90eXBlLmZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZnJhbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gbm93IC0gdGhpcy50aGVuO1xuICAgICAgICBpZiAoZGVsdGEgPiB0aGlzLmZyYW1lVGltZSkge1xuICAgICAgICAgICAgdGhpcy50aGVuID0gbm93IC0gKGRlbHRhICUgdGhpcy5mcmFtZVRpbWUpO1xuICAgICAgICAgICAgdGhpcy5ldm9sdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXaW5keS5wcm90b3R5cGUuZXZvbHZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkJ1Y2tldC5jbGVhcigpO1xuICAgICAgICB0aGlzLnBhcnRpY3VsZXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcC5ncm93KCk7XG4gICAgICAgICAgICBpZiAocC5pc0RlYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXllci5jYW52YXNCb3VuZC5yZXNldFBhcnRpY3VsZShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3aW5kID0gX3RoaXMuZ2V0UGFydGljdWxlV2luZChwKTtcbiAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvbkJ1Y2tldC5hZGQocCwgd2luZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2luZHkucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dDJELmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcbiAgICAgICAgdGhpcy5jb250ZXh0MkQuZmlsbFJlY3QodGhpcy5sYXllci5jYW52YXNCb3VuZC54TWluLCB0aGlzLmxheWVyLmNhbnZhc0JvdW5kLnlNaW4sIHRoaXMubGF5ZXIuY2FudmFzQm91bmQud2lkdGgsIHRoaXMubGF5ZXIuY2FudmFzQm91bmQuaGVpZ2h0KTtcbiAgICAgICAgLy8gRmFkZSBleGlzdGluZyBwYXJ0aWNsZSB0cmFpbHMuXG4gICAgICAgIHRoaXMuY29udGV4dDJELmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwibGlnaHRlclwiO1xuICAgICAgICB0aGlzLmNvbnRleHQyRC5nbG9iYWxBbHBoYSA9IDAuOTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25CdWNrZXQuZHJhdyh0aGlzLmNvbnRleHQyRCk7XG4gICAgfTtcbiAgICBXaW5keS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJ0aWN1bGVzLnNwbGljZSgwLCB0aGlzLnBhcnRpY3VsZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uQnVja2V0KSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkJ1Y2tldC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvbkxvb3ApO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdpbmR5O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFdpbmR5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==